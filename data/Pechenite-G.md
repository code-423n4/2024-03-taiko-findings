|Number|Issue|Instances|Estimated Gas Saved|
|-|:-|:-:|:-:|
| [GAS&#x2011;1](#GAS1-++i-costs-less-gas-than-i++/i-+=-1-same-for---i-vs-i--/i--+-1) | `++i` costs less gas than `i++`/`i += 1` (same for `--i` vs `i--`/`i -+ 1`) | 13 | 105 |
| [GAS&#x2011;2](#GAS2-++i/i++-should-be-unchecked-when-it-is-not-possible-for-them-to-overflow) | `++i`/`i++` should be `unchecked` when it is not possible for them to overflow | 40 | 2,400 |
| [GAS&#x2011;3](#GAS3->=/<=-costs-less-gas-than->/<) | `>=`/`<=` costs less gas than `>`/`<` | 130 | 390 |
| [GAS&#x2011;4](#GAS4-abiencode-is-less-efficient-than-abiencodepacked) | `abi.encode()` is less efficient than `abi.encodePacked()` | 18 | - |
| [GAS&#x2011;5](#GAS5-addressthis-should-be-cached-when-used-multiple-times) | `address(this)` should be cached when used multiple times | 2 | - |
| [GAS&#x2011;6](#GAS6-alternative-solady-library-can-be-used-instead-of-openzeppelin-to-save-gas) | Alternative Solady library can be used instead of OpenZeppelin to save gas | 16 | 16,000 |
| [GAS&#x2011;7](#GAS7-assembly-let-var-only-used-on-once) | Assembly let var only used on once | 9 | - |
| [GAS&#x2011;8](#GAS8-assigning-state-variables-directly-with-named-struct-constructors-wastes-gas) | Assigning state variables directly with named struct constructors wastes gas | 16 | 448 |
| [GAS&#x2011;9](#GAS9-avoid-contract-existence-checks-by-using-low-level-calls) | Avoid contract existence checks by using low-level calls | 47 | 4,700 |
| [GAS&#x2011;10](#GAS10-avoid-unnecessary-public-variables) | Avoid unnecessary `public` variables | 44 | 968,000 |
| [GAS&#x2011;11](#GAS11-avoid-updating-storage-when-the-value-hasnt-changed) | Avoid updating storage when the value hasn't changed | 6 | 10,200 |
| [GAS&#x2011;12](#GAS12-avoid-zero-to-non-zero-storage-writes-where-possible) | Avoid zero to non-zero storage writes where possible | 27 | 596,700 |
| [GAS&#x2011;13](#GAS13-bytes-constants-are-more-efficient-than-string-constants) | Bytes constants are more efficient than string constants | 5 | 1,890 |
| [GAS&#x2011;14](#GAS14-bytesconcat-can-be-used-in-place-of-abiencodepacked) | `bytes.concat()` can be used in place of `abi.encodePacked` | 11 | - |
| [GAS&#x2011;15](#GAS15-cache-array-length-outside-of-loop) | Cache array length outside of loop | 29 | 116 |
| [GAS&#x2011;16](#GAS16-cache-contracts-when-making-multiple-external-calls) | Cache contracts when making multiple external calls | 1 | 168 |
| [GAS&#x2011;17](#GAS17-consider-activating-via-ir-for-deploying) | Consider activating `via-ir` for deploying | 0 | 250 |
| [GAS&#x2011;18](#GAS18-consider-caching-repeated-computations) | Consider caching repeated computations | 4 | 240 |
| [GAS&#x2011;19](#GAS19-consider-merging-sequential-for-loops) | Consider merging sequential for loops | 6 | - |
| [GAS&#x2011;20](#GAS20-consider-packing-small-uints-when-its-possible) | Consider packing small `uint`s when it's possible | 89 | 1,851,200 |
| [GAS&#x2011;21](#GAS21-consider-pre-calculating-the-address-of-addressthis) | Consider pre-calculating the address of `address(this)` | 40 | - |
| [GAS&#x2011;22](#GAS22-consider-reducing-redundant-checks-in-each-iteration-of-loops) | Consider reducing redundant checks in each iteration of loops. | 8 | - |
| [GAS&#x2011;23](#GAS23-consider-using-openzeppelins-enumerateset-instead-of-nested-mappings) | Consider using OpenZeppelin's `EnumerateSet` instead of nested mappings | 8 | 8,000 |
| [GAS&#x2011;24](#GAS24-consider-using-soladys-gas-optimized-lib-for-math) | Consider using Solady's gas optimized lib for Math | 77 | - |
| [GAS&#x2011;25](#GAS25-constructors-can-be-marked-payable) | Constructors can be marked `payable` | 3 | 63 |
| [GAS&#x2011;26](#GAS26-counting-down-in-for-statements-is-more-gas-efficient) | Counting down in `for` statements is more gas efficient | 47 | 752 |
| [GAS&#x2011;27](#GAS27-declare-variables-outside-of-loops) | Declare variables outside of loops | 57 | 855 |
| [GAS&#x2011;28](#GAS28-do-not-calculate-constants) | Do not calculate constants | 2 | - |
| [GAS&#x2011;29](#GAS29-do-while-is-cheaper-than-for-loops-when-the-initial-check-can-be-skipped) | `do`-`while` is cheaper than `for`-loops when the initial check can be skipped | 49 | 12,495 |
| [GAS&#x2011;30](#GAS30-dont-transfer-with-zero-amount-to-save-gas) | Don't transfer with zero amount to save gas | 11 | 220 |
| [GAS&#x2011;31](#GAS31-duplicated-require/revert-checks-should-be-refactored-to-a-modifier-or-function) | Duplicated `require()/revert()` checks should be refactored to a modifier or function | 792 | - |
| [GAS&#x2011;32](#GAS32-emitting-constants-wastes-gas) | Emitting constants wastes gas | 4 | 32 |
| [GAS&#x2011;33](#GAS33-empty-blocks-should-be-removed-or-emit-something) | Empty blocks should be removed or emit something | 5 | - |
| [GAS&#x2011;34](#GAS34-function-names-can-be-optimized) | Function names can be optimized | 38 | 4,864 |
| [GAS&#x2011;35](#GAS35-functions-guaranteed-to-revert-when-called-by-normal-users-can-be-marked-payable) | Functions guaranteed to revert when called by normal users can be marked `payable` | 41 | 861 |
| [GAS&#x2011;36](#GAS36-initializers-can-be-marked-payable) | Initializers can be marked `payable` | 24 | 504 |
| [GAS&#x2011;37](#GAS37-integer-increments-by-one-can-be-unchecked) | Integer increments by one can be unchecked | 49 | 2,940 |
| [GAS&#x2011;38](#GAS38-low-level-call-can-be-optimized-with-assembly) | Low-level `call` can be optimized with assembly | 3 | 477 |
| [GAS&#x2011;39](#GAS39-mappings-are-cheaper-to-use-than-storage-arrays) | Mappings are cheaper to use than storage arrays | 49 | 102,900 |
| [GAS&#x2011;40](#GAS40-memory-safe-annotation-missing) | Memory-safe annotation missing | 20 | - |
| [GAS&#x2011;41](#GAS41-merge-events-to-save-gas) | Merge events to save gas | 5 | 1,875 |
| [GAS&#x2011;42](#GAS42-multiple-accesses-of-the-same-mapping/array-key/index-should-be-cached) | Multiple accesses of the same mapping/array key/index should be cached | 29 | 1,218 |
| [GAS&#x2011;43](#GAS43-multiple-address/id-mappings-can-be-combined-into-a-single-mapping-of-an-address/id-to-a-struct) | Multiple `address`/ID mappings can be combined into a single `mapping` of an `address`/ID to a `struct` | 10 | 200,000 |
| [GAS&#x2011;44](#GAS44-nested-for-loops-should-be-avoided-due-to-high-gas-costs-resulting-from-o^2-time-complexity) | Nested for loops should be avoided due to high gas costs resulting from O^2 time complexity | 4 | - |
| [GAS&#x2011;45](#GAS45-nesting-if-statements-is-cheaper-than-using-&&) | Nesting `if`-statements is cheaper than using `&&` | 27 | 810 |
| [GAS&#x2011;46](#GAS46-newer-versions-of-solidity-are-more-gas-efficient) | Newer versions of solidity are more gas efficient | 81 | - |
| [GAS&#x2011;47](#GAS47-not-using-the-named-return-variables-when-a-function-returns-wastes-deployment-gas) | Not using the named return variables when a function returns, wastes deployment gas | 331 | - |
| [GAS&#x2011;48](#GAS48-optimize-deployment-size-by-fine-tuning-ipfs-hash) | Optimize Deployment Size by Fine-tuning IPFS Hash | 81 | 858,600 |
| [GAS&#x2011;49](#GAS49-optimize-ether-deposits-using-the-receive-function) | Optimize Ether deposits using the `receive()` function | 1 | 45 |
| [GAS&#x2011;50](#GAS50-pre-increments/pre-decrements-are-cheaper-than-+1/+=1-or--1/-=1) | Pre-increments/pre-decrements are cheaper than `+1`/`+=1` or `-1`/`-=1` | 17 | 187 |
| [GAS&#x2011;51](#GAS51-prefer-using-storage-instead-of-memory-for-state-variables-saves-gas) | Prefer using `storage` instead of `memory` for state variables saves gas | 6 | 12,600 |
| [GAS&#x2011;52](#GAS52-private-functions-used-once-can-be-inlined) | `private` functions used once can be inlined | 50 | 1,500 |
| [GAS&#x2011;53](#GAS53-redundant-state-variable-getters) | Redundant state variable getters | 2 | 6,000 |
| [GAS&#x2011;54](#GAS54-refactor-modifiers-to-call-a-local-function) | Refactor modifiers to call a local function | 15 | 9,000 |
| [GAS&#x2011;55](#GAS55-remove-or-replace-unused-state-variables) | Remove or replace unused state variables | 29 | 332,050 |
| [GAS&#x2011;56](#GAS56-reorder-modifiers-to-save-on-expensive-operations) | Reorder modifiers to save on expensive operations | 3 | 6,300 |
| [GAS&#x2011;57](#GAS57-require/revert-strings-longer-than-32-bytes-cost-extra-gas) | `require()`/`revert()` strings longer than 32 bytes cost extra gas | 27 | 81 |
| [GAS&#x2011;58](#GAS58-same-cast-is-done-multiple-times) | Same cast is done multiple times | 4 | - |
| [GAS&#x2011;59](#GAS59-shortcircuit-rules-can-be-be-used-to-optimize-some-gas-usage) | Shortcircuit rules can be be used to optimize some gas usage | 2 | 4,200 |
| [GAS&#x2011;60](#GAS60-simple-checks-for-zero-can-be-done-using-assembly-to-save-gas) | Simple checks for zero can be done using assembly to save gas | 175 | 1,050 |
| [GAS&#x2011;61](#GAS61-sort-solidity-operations-using-short-circuit-mode) | Sort Solidity operations using short-circuit mode | 190 | - |
| [GAS&#x2011;62](#GAS62-splitting-require-statements-that-use-&&-saves-gas) | Splitting `require()` statements that use `&&` saves gas | 4 | 12 |
| [GAS&#x2011;63](#GAS63-splitting-revert-statements-saves-gas) | Splitting `revert()` statements saves gas | 5 | 10 |
| [GAS&#x2011;64](#GAS64-stack-variable-is-only-used-once) | Stack variable is only used once | 137 | 411 |
| [GAS&#x2011;65](#GAS65-state-variable-read-in-a-loop) | State variable read in a loop | 8 | 776 |
| [GAS&#x2011;66](#GAS66-state-variables-can-be-reordered-to-fit-into-fewer-storage-slots) | State variables can be reordered to fit into fewer storage slots | 2 | 40,000 |
| [GAS&#x2011;67](#GAS67-state-variables-only-set-in-the-constructor-should-be-declared-immutable) | State variables only set in the constructor should be declared `immutable` | 2 | 4,194 |
| [GAS&#x2011;68](#GAS68-state-variables-should-be-cached-in-stack-variables-rather-than-re-reading-them-from-storage) | State variables should be cached in stack variables rather than re-reading them from storage | 60 | 6,000 |
| [GAS&#x2011;69](#GAS69-struct-can-be-reordered-to-fit-into-fewer-storage-slots) | Struct can be reordered to fit into fewer storage slots | 4 | 80,000 |
| [GAS&#x2011;70](#GAS70-structs-can-be-assigned-more-efficiently) | Structs can be assigned more efficiently | 22 | 2,860 |
| [GAS&#x2011;71](#GAS71-structs-can-be-packed-into-fewer-storage-slots-by-truncating-timestamp-bytes) | Structs can be packed into fewer storage slots by truncating timestamp bytes | 1 | 20,000 |
| [GAS&#x2011;72](#GAS72-superfluous-event-fields) | Superfluous event fields | 10 | 350 |
| [GAS&#x2011;73](#GAS73-the-result-of-a-function-call-should-be-cached-rather-than-re-calling-the-function) | The result of a function call should be cached rather than re-calling the function | 10 | 1,000 |
| [GAS&#x2011;74](#GAS74-unchecked-{}-can-be-used-on-the-division-of-two-uints-in-order-to-save-gas) | `unchecked {}` can be used on the division of two `uint`s in order to save gas | 5 | 300 |
| [GAS&#x2011;75](#GAS75-unnecessary-nonreentrant-modifier-in-certain-functions) | Unnecessary `nonReentrant` modifier in certain functions | 5 | 123,500 |
| [GAS&#x2011;76](#GAS76-update-openzeppelin-dependency-to-the-latest-version) | Update OpenZeppelin dependency to the latest version | 54 | - |
| [GAS&#x2011;77](#GAS77-update-solady-dependency-to-the-latest-version) | Update Solady dependency to the latest version | 4 | - |
| [GAS&#x2011;78](#GAS78-usage-of-uints/ints-smaller-than-32-bytes-256-bits-incurs-overhead) | Usage of `uints`/`ints` smaller than 32 bytes (256 bits) incurs overhead | 189 | 1,134 |
| [GAS&#x2011;79](#GAS79-use-arrayunsafeaccess-to-avoid-repeated-array-length-checks) | Use `Array.unsafeAccess()` to avoid repeated array length checks | 54 | 113,400 |
| [GAS&#x2011;80](#GAS80-use-assembly-for-small-keccak256-hashes-in-order-to-save-gas) | Use assembly for small `keccak256` hashes, in order to save gas | 23 | 1,840 |
| [GAS&#x2011;81](#GAS81-use-assembly-in-place-of-abidecode-to-save-gas) | Use assembly in place of `abi.decode` to save gas | 16 | 1,792 |
| [GAS&#x2011;82](#GAS82-use-assembly-scratch-space-to-build-calldata-for-external-calls) | Use assembly scratch space to build calldata for external calls | 51 | 11,220 |
| [GAS&#x2011;83](#GAS83-use-assembly-to-perform-efficient-back-to-back-calls) | Use assembly to perform efficient back-to-back calls | 2 | 600 |
| [GAS&#x2011;84](#GAS84-use-assembly-to-validate-msgsender) | Use assembly to validate `msg.sender` | 12 | 144 |
| [GAS&#x2011;85](#GAS85-use-assembly-to-write-address/contract-storage-values) | Use `assembly` to write address/contract storage values | 56 | 2,800 |
| [GAS&#x2011;86](#GAS86-use-calldata-instead-of-memory-for-function-arguments-that-do-not-get-mutated) | Use `calldata` instead of `memory` for function arguments that do not get mutated | 70 | 21,000 |
| [GAS&#x2011;87](#GAS87-use-constants-instead-of-typeuint<n>max-/-min) | Use constants instead of `type(uint<n>).max` / `.min` | 10 | 40 |
| [GAS&#x2011;88](#GAS88-use-custom-errors-rather-than-revert/require-strings-to-save-gas) | Use custom errors rather than `revert()`/`require()` strings to save gas | 66 | 1,914 |
| [GAS&#x2011;89](#GAS89-use-if-statements-instead-of-ternary-operators) | Use `if` statements instead of ternary operators | 14 | - |
| [GAS&#x2011;90](#GAS90-use-immutable-when-you-have-storage-variable-that-is-not-going-to-change) | Use immutable when you have storage variable that is not going to change | 5 | - |
| [GAS&#x2011;91](#GAS91-use-local-variables-for-emitting) | Use local variables for emitting | 7 | 700 |
| [GAS&#x2011;92](#GAS92-use-modifiers-rather-than-invoking-functions-to-perform-checks) | Use modifiers rather than invoking functions to perform checks | 4 | 160 |
| [GAS&#x2011;93](#GAS93-use-of-emit-inside-a-loop) | Use of `emit` inside a loop | 3 | 1,125 |
| [GAS&#x2011;94](#GAS94-use-revert-to-gain-maximum-gas-savings) | Use `revert()` to gain maximum gas savings | 244 | 68,954 |
| [GAS&#x2011;95](#GAS95-use-sx-=-sx-+-y-instead-of-sx-+=-y-for-structs) | Use `s.x = s.x + y` instead of `s.x += y` for structs | 6 | 600 |
| [GAS&#x2011;96](#GAS96-use-scratch-space-when-building-emitted-events-with-two-data-arguments) | Use scratch space when building emitted events with two data arguments | 24 | 912 |
| [GAS&#x2011;97](#GAS97-use-selfbalance-instead-of-addressthisbalance) | Use `selfbalance()` instead of `address(this).balance` | 6 | - |
| [GAS&#x2011;98](#GAS98-use-shift-right/left-instead-of-division/multiplication-if-possible) | Use shift right/left instead of division/multiplication if possible | 2 | 40 |
| [GAS&#x2011;99](#GAS99-use-the-inputs/results-of-assignments-rather-than-re-reading-state-variables) | Use the inputs/results of assignments rather than re-reading state variables | 10 | 970 |
| [GAS&#x2011;100](#GAS100-use-uint2561/uint2562-instead-of-true/false-to-save-gas-for-changes) | Use `uint256(1)`/`uint256(2)` instead of `true`/`false` to save gas for changes | 10 | 171,000 |
| [GAS&#x2011;101](#GAS101-using->-0-costs-more-gas-than-!=-0-when-used-on-a-uint-in-a-require-statement) | Using `> 0` costs more gas than `!= 0` when used on a `uint` in a `require()` statement | 5 | 30 |
| [GAS&#x2011;102](#GAS102-using-bools-for-storage-incurs-overhead) | Using `bool`s for storage incurs overhead | 24 | 410,400 |
| [GAS&#x2011;103](#GAS103-using-constants-instead-of-enum-can-save-gas) | Using `constant`s instead of `enum` can save gas | 9 | - |
| [GAS&#x2011;104](#GAS104-using-globals-directly-is-cheaper-than-assigning-them-to-variables) | Using globals directly is cheaper than assigning them to variables | 1 | 5 |
| [GAS&#x2011;105](#GAS105-using-msg-globals-directly-rather-than-caching-the-value-saves-gas) | Using `msg` globals directly, rather than caching the value, saves gas | 3 | - |
| [GAS&#x2011;106](#GAS106-using-private-rather-than-public-saves-gas) | Using `private` rather than `public`, saves gas | 86 | 310,116 |
| [GAS&#x2011;107](#GAS107-using-storage-instead-of-memory-for-structs/arrays-saves-gas) | Using `storage` instead of `memory` for structs/arrays saves gas | 44 | 92,400 |
| [GAS&#x2011;108](#GAS108-using-this<fn>-wastes-gas) | Using `this.<fn>()` wastes gas | 1 | 100 |
| [GAS&#x2011;109](#GAS109-using-variable-directly-is-cheaper) | Using variable directly is cheaper | 3 | - |
| [GAS&#x2011;110](#GAS110-x-+-y-is-more-efficient-than-using-+=-for-state-variables-likewise-for--=) | `x + y` is more efficient than using `+=` for state variables (likewise for `-=`) | 5 | 1,240 |


### [GAS&#x2011;2] `++i`/`i++` should be `unchecked` when it is not possible for them to overflow
The `unchecked` keyword is new in solidity version 0.8.0, so this only applies to that version or higher, which these instances are. This saves **30-40 gas [per loop](https://gist.github.com/hrkrshnn/ee8fabd532058307229d65dcd5836ddc#the-increment-in-for-loop-post-condition-can-be-made-unchecked)**


Gas saved per Instance: ~60 *(Total: ~2,400)*
<details>
<summary><i>There are 40 instances of this issue:</i></summary>

```solidity
📁 File: contracts/L1/hooks/AssignmentHook.sol

172:         for (uint256 i; i < _tierFees.length; ++i) { 
```
[172](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/hooks/AssignmentHook.sol#L172)

```solidity
📁 File: contracts/L1/libs/LibProposing.sol

244:             for (uint256 i; i < params.hookCalls.length; ++i) { 
```
[244](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProposing.sol#L244)

```solidity
📁 File: contracts/L1/provers/Guardians.sol

74:         for (uint256 i; i < guardians.length; ++i) { 

80:         for (uint256 i = 0; i < _newGuardians.length; ++i) { 
```
[74](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/provers/Guardians.sol#L74), [80](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/provers/Guardians.sol#L80)

```solidity
📁 File: contracts/automata-attestation/AutomataDcapV3Attestation.sol

80:         for (uint256 i; i < serialNumBatch.length; ++i) { 

95:         for (uint256 i; i < serialNumBatch.length; ++i) { 

191:         for (uint256 i; i < enclaveId.tcbLevels.length; ++i) { 

214:         for (uint256 i; i < tcb.tcbLevels.length; ++i) { 

240:         for (uint256 i; i < CPUSVN_LENGTH; ++i) { 

259:         for (uint256 i; i < n; ++i) { 

420:             for (uint256 i; i < 3; ++i) { 
```
[80](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/AutomataDcapV3Attestation.sol#L80), [95](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/AutomataDcapV3Attestation.sol#L95), [191](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/AutomataDcapV3Attestation.sol#L191), [214](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/AutomataDcapV3Attestation.sol#L214), [240](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/AutomataDcapV3Attestation.sol#L240), [259](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/AutomataDcapV3Attestation.sol#L259), [420](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/AutomataDcapV3Attestation.sol#L420)

```solidity
📁 File: contracts/automata-attestation/lib/PEMCertChainLib.sol

54:         for (uint256 i; i < size; ++i) { 

244:         for (uint256 i; i < split.length; ++i) { 

354:         for (uint256 i; i < SGX_TCB_CPUSVN_SIZE + 1; ++i) { 
```
[54](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/PEMCertChainLib.sol#L54), [244](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/PEMCertChainLib.sol#L244), [354](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/PEMCertChainLib.sol#L354)

```solidity
📁 File: contracts/automata-attestation/lib/QuoteV3Auth/V3Parser.sol

153:         for (uint256 i; i < encoded.length; ++i) { 

281:         for (uint256 i; i < 3; ++i) { 
```
[153](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/QuoteV3Auth/V3Parser.sol#L153), [281](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/QuoteV3Auth/V3Parser.sol#L281)

```solidity
📁 File: contracts/automata-attestation/utils/BytesUtils.sol

333:         for (uint256 i; i < len; ++i) { 
```
[333](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/BytesUtils.sol#L333)

```solidity
📁 File: contracts/automata-attestation/utils/RsaVerify.sol

140:         for (uint256 i = 2; i < 2 + paddingLen; ++i) { 

152:             for (uint256 i; i < digestAlgoWithParamLen; ++i) { 

158:             for (uint256 i; i < digestAlgoWithParamLen; ++i) { 

174:         for (uint256 i; i < _sha256.length; ++i) { 

273:         for (uint256 i = 2; i < 2 + paddingLen; ++i) { 

283:         for (uint256 i; i < sha1Prefix.length; ++i) { 

290:         for (uint256 i; i < _sha1.length; ++i) { 
```
[140](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/RsaVerify.sol#L140), [152](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/RsaVerify.sol#L152), [158](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/RsaVerify.sol#L158), [174](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/RsaVerify.sol#L174), [273](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/RsaVerify.sol#L273), [283](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/RsaVerify.sol#L283), [290](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/RsaVerify.sol#L290)

```solidity
📁 File: contracts/automata-attestation/utils/X509DateUtils.sol

48:         for (uint16 i = 1970; i < year; ++i) { 

59:         for (uint8 i = 1; i < month; ++i) { 
```
[48](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/X509DateUtils.sol#L48), [59](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/X509DateUtils.sol#L59)

```solidity
📁 File: contracts/bridge/Bridge.sol

90:         for (uint256 i; i < _msgHashes.length; ++i) { 
```
[90](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/Bridge.sol#L90)

```solidity
📁 File: contracts/signal/SignalService.sol

104:         for (uint256 i; i < hopProofs.length; ++i) { 
```
[104](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/signal/SignalService.sol#L104)

```solidity
📁 File: contracts/team/airdrop/ERC721Airdrop.sol

59:         for (uint256 i; i < tokenIds.length; ++i) { 
```
[59](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/airdrop/ERC721Airdrop.sol#L59)

```solidity
📁 File: contracts/thirdparty/optimism/rlp/RLPWriter.sol

46:             for (i = 1; i <= lenLen; i++) { 

59:         for (; i < 32; i++) { 

66:         for (uint256 j = 0; j < out_.length; j++) { 
67:             out_[j] = b[i++];
```
[46](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/rlp/RLPWriter.sol#L46), [59](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/rlp/RLPWriter.sol#L59), [66](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/rlp/RLPWriter.sol#L66-L67)

```solidity
📁 File: contracts/thirdparty/optimism/trie/MerkleTrie.sol

85:         for (uint256 i = 0; i < proof.length; i++) { 
```
[85](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/trie/MerkleTrie.sol#L85)

```solidity
📁 File: contracts/tokenvault/ERC1155Vault.sol

47:         for (uint256 i; i < _op.amounts.length; ++i) { 
```
[47](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC1155Vault.sol#L47)

```solidity
📁 File: contracts/tokenvault/ERC721Vault.sol

34:         for (uint256 i; i < _op.tokenIds.length; ++i) { 

170:             for (uint256 i; i < _tokenIds.length; ++i) { 

175:             for (uint256 i; i < _tokenIds.length; ++i) { 
```
[34](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC721Vault.sol#L34), [170](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC721Vault.sol#L170), [175](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC721Vault.sol#L175)

```solidity
📁 File: contracts/verifiers/SgxVerifier.sol

104:         for (uint256 i; i < _ids.length; ++i) { 

210:         for (uint256 i; i < _instances.length; ++i) { 
```
[104](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/verifiers/SgxVerifier.sol#L104), [210](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/verifiers/SgxVerifier.sol#L210)

</details>


---
### [GAS&#x2011;3] `>=`/`<=` costs less gas than `>`/`<`
The compiler uses opcodes `GT` and `ISZERO` for code that uses `>`, but only requires `LT` for `>=`. A similar behaviour applies for `>`, which uses opcodes `LT` and `ISZERO`, but only requires `GT` for `<=`.


Gas saved per Instance: ~3 *(Total: ~390)*
<details>
<summary><i>There are 130 instances of this issue:</i></summary>

```solidity
📁 File: contracts/L1/hooks/AssignmentHook.sol

82:             block.timestamp > assignment.expiry 

85:                 || assignment.maxBlockId != 0 && _meta.id > assignment.maxBlockId 
86:                 || assignment.maxProposedIn != 0 && block.number > assignment.maxProposedIn

125:         if (address(this).balance > 0) { 

172:         for (uint256 i; i < _tierFees.length; ++i) { 
```
[82](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/hooks/AssignmentHook.sol#L82), [85](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/hooks/AssignmentHook.sol#L85-L86), [125](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/hooks/AssignmentHook.sol#L125), [172](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/hooks/AssignmentHook.sol#L172)

```solidity
📁 File: contracts/L1/libs/LibDepositing.sol

78:         if (numPending < _config.ethDepositMinCountPerBlock) { 

86:             for (uint256 i; i < deposits_.length;) { 

93:                 uint96 _fee = deposits_[i].amount > fee ? fee : deposits_[i].amount; 

140:                 && _state.slotA.numEthDeposits - _state.slotA.nextEthDepositToProcess 
141:                     < _config.ethDepositRingBufferSize - 1;

150:         if (_amount > type(uint96).max) revert L1_INVALID_ETH_DEPOSIT(); 
```
[78](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibDepositing.sol#L78), [86](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibDepositing.sol#L86), [93](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibDepositing.sol#L93), [140](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibDepositing.sol#L140-L141), [150](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibDepositing.sol#L150)

```solidity
📁 File: contracts/L1/libs/LibProposing.sol

171:             if (uint256(params.txListByteOffset) + params.txListByteSize > MAX_BYTES_PER_BLOB) { 

195:         if (meta_.txListByteSize == 0 || meta_.txListByteSize > _config.blockMaxTxListBytes) { 

244:             for (uint256 i; i < params.hookCalls.length; ++i) { 

296:         return _state.reusableBlobs[_blobHash] + _config.blobExpiry > block.timestamp; 
```
[171](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProposing.sol#L171), [195](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProposing.sol#L195), [244](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProposing.sol#L244), [296](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProposing.sol#L296)

```solidity
📁 File: contracts/L1/libs/LibProving.sol

134:         if (_proof.tier == 0 || _proof.tier < _meta.minTier || _proof.tier < ts.tier) { 

192:             bool returnLivenessBond = blk.livenessBond > 0 && _proof.data.length == 32 

203:         if (_proof.tier > ts.tier) { 

381:             if (reward > _tier.validityBond) { 
```
[134](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProving.sol#L134), [192](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProving.sol#L192), [203](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProving.sol#L203), [381](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProving.sol#L381)

```solidity
📁 File: contracts/L1/libs/LibUtils.sol

34:         if (_blockId < b.lastVerifiedBlockId || _blockId >= b.numBlocks) { 
```
[34](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibUtils.sol#L34)

```solidity
📁 File: contracts/L1/libs/LibVerifying.sol

127:             while (blockId < b.numBlocks && numBlocksVerified < _maxBlocksToVerify) { 

152:                         uint256(ITierProvider(tierProvider).getTier(ts.tier).cooldownWindow) * 60 
153:                             + uint256(ts.timestamp).max(_state.slotB.lastUnpausedAt) > block.timestamp

212:             if (numBlocksVerified > 0) { 

238:         if (_lastVerifiedBlockId > lastSyncedBlock + _config.blockSyncThreshold) { 

251:                 || _config.blockMaxTxListBytes > 128 * 1024 // calldata up to 128K 

256:             || _config.ethDepositMaxCountPerBlock > 32 
257:                 || _config.ethDepositMaxCountPerBlock < _config.ethDepositMinCountPerBlock

260:                 || _config.ethDepositMaxAmount > type(uint96).max || _config.ethDepositGas == 0 

262:                 || _config.ethDepositMaxFee > type(uint96).max / _config.ethDepositMaxCountPerBlock 
```
[127](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibVerifying.sol#L127), [152](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibVerifying.sol#L152-L153), [212](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibVerifying.sol#L212), [238](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibVerifying.sol#L238), [251](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibVerifying.sol#L251), [256](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibVerifying.sol#L256-L257), [260](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibVerifying.sol#L260), [262](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibVerifying.sol#L262)

```solidity
📁 File: contracts/L1/provers/Guardians.sol

63:         if (_newGuardians.length < MIN_NUM_GUARDIANS || _newGuardians.length > type(uint8).max) { 

68:         if (_minGuardians < (_newGuardians.length + 1) >> 1 || _minGuardians > _newGuardians.length) 

74:         for (uint256 i; i < guardians.length; ++i) { 

80:         for (uint256 i = 0; i < _newGuardians.length; ++i) { 

133:             for (uint256 i; i < guardiansLength; ++i) { 
```
[63](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/provers/Guardians.sol#L63), [68](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/provers/Guardians.sol#L68), [74](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/provers/Guardians.sol#L74), [80](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/provers/Guardians.sol#L80), [133](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/provers/Guardians.sol#L133)

```solidity
📁 File: contracts/L2/Lib1559Math.sol

42:         if (input > LibFixedPointMath.MAX_EXP_INPUT) { 
```
[42](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/Lib1559Math.sol#L42)

```solidity
📁 File: contracts/L2/TaikoL2.sol

82:         if (block.chainid <= 1 || block.chainid > type(uint64).max) { 

145:         if (_l1BlockId > lastSyncedBlock + BLOCK_SYNC_THRESHOLD) { 

234:             for (uint256 i; i < 255 && _blockId >= i + 1; ++i) { 

262:         if (gasExcess > 0) { 

275:             if (lastSyncedBlock > 0 && _l1BlockId > lastSyncedBlock) { 

279:             if (numL1Blocks > 0) { 

281:                 excess = excess > issuance ? excess - issuance : 1; 
```
[82](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/TaikoL2.sol#L82), [145](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/TaikoL2.sol#L145), [234](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/TaikoL2.sol#L234), [262](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/TaikoL2.sol#L262), [275](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/TaikoL2.sol#L275), [279](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/TaikoL2.sol#L279), [281](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/TaikoL2.sol#L281)

```solidity
📁 File: contracts/automata-attestation/AutomataDcapV3Attestation.sol

80:         for (uint256 i; i < serialNumBatch.length; ++i) { 

95:         for (uint256 i; i < serialNumBatch.length; ++i) { 

191:         for (uint256 i; i < enclaveId.tcbLevels.length; ++i) { 

214:         for (uint256 i; i < tcb.tcbLevels.length; ++i) { 

240:         for (uint256 i; i < CPUSVN_LENGTH; ++i) { 
241:             if (pckCpuSvns[i] < tcbCpuSvns[i]) {

259:         for (uint256 i; i < n; ++i) { 

280:                 block.timestamp > certs[i].notBefore && block.timestamp < certs[i].notAfter; 

420:             for (uint256 i; i < 3; ++i) { 
```
[80](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/AutomataDcapV3Attestation.sol#L80), [95](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/AutomataDcapV3Attestation.sol#L95), [191](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/AutomataDcapV3Attestation.sol#L191), [214](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/AutomataDcapV3Attestation.sol#L214), [240](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/AutomataDcapV3Attestation.sol#L240-L241), [259](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/AutomataDcapV3Attestation.sol#L259), [280](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/AutomataDcapV3Attestation.sol#L280), [420](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/AutomataDcapV3Attestation.sol#L420)

```solidity
📁 File: contracts/automata-attestation/lib/PEMCertChainLib.sol

54:         for (uint256 i; i < size; ++i) { 

56:             if (i > 0) { 

244:         for (uint256 i; i < split.length; ++i) { 

323:                     if (extnValuePtr.ixl() < extnValueParentPtr.ixl()) { 

333:             if (tbsPtr.ixl() < tbsParentPtr.ixl()) { 

354:         for (uint256 i; i < SGX_TCB_CPUSVN_SIZE + 1; ++i) { 

358:             uint16 svnValue = svnValueBytes.length < 2 
```
[54](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/PEMCertChainLib.sol#L54), [56](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/PEMCertChainLib.sol#L56), [244](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/PEMCertChainLib.sol#L244), [323](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/PEMCertChainLib.sol#L323), [333](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/PEMCertChainLib.sol#L333), [354](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/PEMCertChainLib.sol#L354), [358](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/PEMCertChainLib.sol#L358)

```solidity
📁 File: contracts/automata-attestation/lib/QuoteV3Auth/V3Parser.sol

153:         for (uint256 i; i < encoded.length; ++i) { 

218:         if (cert.certType < 1 || cert.certType > 5) { 

281:         for (uint256 i; i < 3; ++i) { 
```
[153](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/QuoteV3Auth/V3Parser.sol#L153), [218](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/QuoteV3Auth/V3Parser.sol#L218), [281](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/QuoteV3Auth/V3Parser.sol#L281)

```solidity
📁 File: contracts/automata-attestation/utils/BytesUtils.sol

69:         if (otherlen < len) { 

80:         for (uint256 idx = 0; idx < shortest; idx += 32) { 

90:                 if (shortest > 32) { 

333:         for (uint256 i; i < len; ++i) { 
```
[69](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/BytesUtils.sol#L69), [80](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/BytesUtils.sol#L80), [90](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/BytesUtils.sol#L90), [333](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/BytesUtils.sol#L333)

```solidity
📁 File: contracts/automata-attestation/utils/RsaVerify.sol

140:         for (uint256 i = 2; i < 2 + paddingLen; ++i) { 

152:             for (uint256 i; i < digestAlgoWithParamLen; ++i) { 

158:             for (uint256 i; i < digestAlgoWithParamLen; ++i) { 

174:         for (uint256 i; i < _sha256.length; ++i) { 

273:         for (uint256 i = 2; i < 2 + paddingLen; ++i) { 

283:         for (uint256 i; i < sha1Prefix.length; ++i) { 

290:         for (uint256 i; i < _sha1.length; ++i) { 
```
[140](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/RsaVerify.sol#L140), [152](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/RsaVerify.sol#L152), [158](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/RsaVerify.sol#L158), [174](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/RsaVerify.sol#L174), [273](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/RsaVerify.sol#L273), [283](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/RsaVerify.sol#L283), [290](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/RsaVerify.sol#L290)

```solidity
📁 File: contracts/automata-attestation/utils/X509DateUtils.sol

18:             if (uint8(x509Time[0]) - 48 < 5) yrs += 2000; 

48:         for (uint16 i = 1970; i < year; ++i) { 

59:         for (uint8 i = 1; i < month; ++i) { 
```
[18](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/X509DateUtils.sol#L18), [48](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/X509DateUtils.sol#L48), [59](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/X509DateUtils.sol#L59)

```solidity
📁 File: contracts/bridge/Bridge.sol

90:         for (uint256 i; i < _msgHashes.length; ++i) { 
```
[90](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/Bridge.sol#L90)

```solidity
📁 File: contracts/common/AddressResolver.sol

59:         if (block.chainid > type(uint64).max) { 
```
[59](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/common/AddressResolver.sol#L59)

```solidity
📁 File: contracts/libs/LibMath.sol

13:         return _a > _b ? _b : _a; 

21:         return _a > _b ? _a : _b; 
```
[13](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/libs/LibMath.sol#L13), [21](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/libs/LibMath.sol#L21)

```solidity
📁 File: contracts/signal/SignalService.sol

104:         for (uint256 i; i < hopProofs.length; ++i) { 

120:             bool isFullProof = hop.accountProof.length > 0; 

247:         if (topBlockId[_chainId][_kind] < _blockId) { 
```
[104](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/signal/SignalService.sol#L104), [120](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/signal/SignalService.sol#L120), [247](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/signal/SignalService.sol#L247)

```solidity
📁 File: contracts/team/TimelockTokenPool.sol

275:             if (_cliff > 0) revert INVALID_GRANT(); 

277:             if (_cliff > 0 && _cliff <= _start) revert INVALID_GRANT(); 
```
[275](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/TimelockTokenPool.sol#L275), [277](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/TimelockTokenPool.sol#L277)

```solidity
📁 File: contracts/team/airdrop/ERC20Airdrop2.sol

40:         if (claimEnd > block.timestamp || claimEnd + withdrawalWindow < block.timestamp) { 

114:         if (block.timestamp < claimEnd) return (balance, 0); 
```
[40](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/airdrop/ERC20Airdrop2.sol#L40), [114](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/airdrop/ERC20Airdrop2.sol#L114)

```solidity
📁 File: contracts/team/airdrop/ERC721Airdrop.sol

59:         for (uint256 i; i < tokenIds.length; ++i) { 
```
[59](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/airdrop/ERC721Airdrop.sol#L59)

```solidity
📁 File: contracts/team/airdrop/MerkleClaimable.sol

35:             merkleRoot == 0x0 || claimStart == 0 || claimEnd == 0 || claimStart > block.timestamp 
36:                 || claimEnd < block.timestamp
```
[35](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/airdrop/MerkleClaimable.sol#L35-L36)

```solidity
📁 File: contracts/thirdparty/optimism/rlp/RLPReader.sol

38:             _in.length > 0, 

74:         while (offset < _in.length) { 

153:             _in.length > 0, 

173:                 _in.length > strLen, 

193:                 _in.length > lenOfStrLen, 

213:                 strLen > 55, 

218:                 _in.length > lenOfStrLen + strLen, 

229:                 _in.length > listLen, 

239:                 _in.length > lenOfListLen, 

259:                 listLen > 55, 

264:                 _in.length > lenOfListLen + listLen, 
```
[38](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/rlp/RLPReader.sol#L38), [74](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/rlp/RLPReader.sol#L74), [153](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/rlp/RLPReader.sol#L153), [173](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/rlp/RLPReader.sol#L173), [193](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/rlp/RLPReader.sol#L193), [213](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/rlp/RLPReader.sol#L213), [218](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/rlp/RLPReader.sol#L218), [229](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/rlp/RLPReader.sol#L229), [239](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/rlp/RLPReader.sol#L239), [259](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/rlp/RLPReader.sol#L259), [264](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/rlp/RLPReader.sol#L264)

```solidity
📁 File: contracts/thirdparty/optimism/rlp/RLPWriter.sol

14:         if (_in.length == 1 && uint8(_in[0]) < 128) { 

33:         if (_len < 56) { 

59:         for (; i < 32; i++) { 

66:         for (uint256 j = 0; j < out_.length; j++) { 
```
[14](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/rlp/RLPWriter.sol#L14), [33](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/rlp/RLPWriter.sol#L33), [59](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/rlp/RLPWriter.sol#L59), [66](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/rlp/RLPWriter.sol#L66)

```solidity
📁 File: contracts/thirdparty/optimism/trie/MerkleTrie.sol

77:         require(_key.length > 0, "MerkleTrie: empty key"); 

85:         for (uint256 i = 0; i < proof.length; i++) { 

120:                         value_.length > 0, 

173:                         value_.length > 0, 

208:         for (uint256 i = 0; i < length;) { 

221:         id_ = _node.length < 32 ? RLPReader.readRawBytes(_node) : RLPReader.readBytes(_node); 

243:         uint256 max = (_a.length < _b.length) ? _a.length : _b.length; 
244:         for (; shared_ < max && _a[shared_] == _b[shared_];) {
```
[77](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/trie/MerkleTrie.sol#L77), [85](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/trie/MerkleTrie.sol#L85), [120](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/trie/MerkleTrie.sol#L120), [173](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/trie/MerkleTrie.sol#L173), [208](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/trie/MerkleTrie.sol#L208), [221](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/trie/MerkleTrie.sol#L221), [243](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/trie/MerkleTrie.sol#L243-L244)

```solidity
📁 File: contracts/tokenvault/BaseNFTVault.sol

145:         if (_op.tokenIds.length > MAX_TOKEN_PER_TXN) { 
```
[145](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BaseNFTVault.sol#L145)

```solidity
📁 File: contracts/tokenvault/ERC1155Vault.sol

47:         for (uint256 i; i < _op.amounts.length; ++i) { 

251:                 for (uint256 i; i < _op.tokenIds.length; ++i) { 

269:                 for (uint256 i; i < _op.tokenIds.length; ++i) { 
```
[47](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC1155Vault.sol#L47), [251](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC1155Vault.sol#L251), [269](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC1155Vault.sol#L269)

```solidity
📁 File: contracts/tokenvault/ERC721Vault.sol

34:         for (uint256 i; i < _op.tokenIds.length; ++i) { 

170:             for (uint256 i; i < _tokenIds.length; ++i) { 

175:             for (uint256 i; i < _tokenIds.length; ++i) { 

197:                 for (uint256 i; i < _op.tokenIds.length; ++i) { 

210:                 for (uint256 i; i < _op.tokenIds.length; ++i) { 
```
[34](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC721Vault.sol#L34), [170](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC721Vault.sol#L170), [175](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC721Vault.sol#L175), [197](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC721Vault.sol#L197), [210](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC721Vault.sol#L210)

```solidity
📁 File: contracts/verifiers/SgxVerifier.sol

104:         for (uint256 i; i < _ids.length; ++i) { 

210:         for (uint256 i; i < _instances.length; ++i) { 
```
[104](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/verifiers/SgxVerifier.sol#L104), [210](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/verifiers/SgxVerifier.sol#L210)

</details>


---
### [GAS&#x2011;4] `abi.encode()` is less efficient than `abi.encodePacked()`
See for more information: https://github.com/ConnorBlockchain/Solidity-Encode-Gas-Comparison

<details>
<summary><i>There are 18 instances of this issue:</i></summary>

```solidity
📁 File: contracts/L1/hooks/AssignmentHook.sol

147:             abi.encode( 
```
[147](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/hooks/AssignmentHook.sol#L147)

```solidity
📁 File: contracts/L1/libs/LibProposing.sol

126:                 depositsHash: keccak256(abi.encode(deposits_)), 

213:             metaHash: keccak256(abi.encode(meta_)), 
```
[126](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProposing.sol#L126), [213](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProposing.sol#L213)

```solidity
📁 File: contracts/L1/libs/LibProving.sol

121:         if (blk.blockId != _meta.id || blk.metaHash != keccak256(abi.encode(_meta))) { 
```
[121](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProving.sol#L121)

```solidity
📁 File: contracts/L1/provers/GuardianProver.sol

46:         bytes32 hash = keccak256(abi.encode(_meta, _tran)); 

51:             ITaikoL1(resolve("taiko", false)).proveBlock(_meta.id, abi.encode(_meta, _tran, _proof)); 
```
[46](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/provers/GuardianProver.sol#L46), [51](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/provers/GuardianProver.sol#L51)

```solidity
📁 File: contracts/automata-attestation/AutomataDcapV3Attestation.sol

482:         retData = abi.encodePacked(sha256(abi.encode(v3quote)), tcbStatus); 
```
[482](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/AutomataDcapV3Attestation.sol#L482)

```solidity
📁 File: contracts/automata-attestation/utils/SigVerifyLib.sol

136:         bytes memory args = abi.encode(sha256(tbs), r, s, gx, gy); 
```
[136](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/SigVerifyLib.sol#L136)

```solidity
📁 File: contracts/bridge/Bridge.sol

450:         return keccak256(abi.encode("TAIKO_MESSAGE", _message)); 
```
[450](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/Bridge.sol#L450)

```solidity
📁 File: contracts/signal/SignalService.sol

186:         return keccak256(abi.encode(_chainId, _kind, _blockId)); 
```
[186](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/signal/SignalService.sol#L186)

```solidity
📁 File: contracts/team/airdrop/ERC20Airdrop.sol

60:         _verifyClaim(abi.encode(user, amount), proof); 
```
[60](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/airdrop/ERC20Airdrop.sol#L60)

```solidity
📁 File: contracts/team/airdrop/ERC20Airdrop2.sol

80:         _verifyClaim(abi.encode(user, amount), proof); 
```
[80](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/airdrop/ERC20Airdrop2.sol#L80)

```solidity
📁 File: contracts/team/airdrop/ERC721Airdrop.sol

56:         _verifyClaim(abi.encode(user, tokenIds), proof); 
```
[56](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/airdrop/ERC721Airdrop.sol#L56)

```solidity
📁 File: contracts/team/airdrop/MerkleClaimable.sol

68:         bytes32 hash = keccak256(abi.encode("CLAIM_TAIKO_AIRDROP", data)); 
```
[68](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/airdrop/MerkleClaimable.sol#L68)

```solidity
📁 File: contracts/tokenvault/ERC1155Vault.sol

281:             this.onMessageInvocation, abi.encode(ctoken_, _user, _op.to, _op.tokenIds, _op.amounts) 
```
[281](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC1155Vault.sol#L281)

```solidity
📁 File: contracts/tokenvault/ERC20Vault.sol

384:             this.onMessageInvocation, abi.encode(ctoken_, _user, _to, balanceChange_) 
```
[384](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC20Vault.sol#L384)

```solidity
📁 File: contracts/tokenvault/ERC721Vault.sol

217:             this.onMessageInvocation, abi.encode(ctoken_, _user, _op.to, _op.tokenIds) 
```
[217](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC721Vault.sol#L217)

```solidity
📁 File: contracts/verifiers/SgxVerifier.sol

183:             abi.encode( 
```
[183](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/verifiers/SgxVerifier.sol#L183)

</details>


---
### [GAS&#x2011;5] `address(this)` should be cached when used multiple times
<details>
<summary><i>There are 2 instances of this issue:</i></summary>

```solidity
📁 File: contracts/L1/libs/LibProposing.sol

/// @audit 'address(this)' used 5 times
68:     function proposeBlock( 
69:         TaikoData.State storage _state,
70:         TaikoData.Config memory _config,
71:         IAddressResolver _resolver,
72:         bytes calldata _data,
73:         bytes calldata _txList
74:     )
75:         internal
76:         returns (TaikoData.BlockMetadata memory meta_, TaikoData.EthDeposit[] memory deposits_)
77:     {
```
[68](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProposing.sol#L68-L77)

```solidity
📁 File: contracts/tokenvault/ERC20Vault.sol

/// @audit 'address(this)' used 3 times
348:     function _handleMessage( 
349:         address _user,
350:         address _token,
351:         address _to,
352:         uint256 _amount
353:     )
354:         private
355:         returns (bytes memory msgData_, CanonicalERC20 memory ctoken_, uint256 balanceChange_)
356:     {
```
[348](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC20Vault.sol#L348-L356)

</details>


---
### [GAS&#x2011;6] Alternative Solady library can be used instead of OpenZeppelin to save gas
The following OpenZeppelin imports have a [Solady](https://github.com/Vectorized/solady) equivalent, as such they can be used to save GAS as Solady modules have been specifically designed to be as GAS efficient as possible.


Gas saved per Instance: ~1,000 *(Total: ~16,000)*
<details>
<summary><i>There are 16 instances of this issue:</i></summary>

```solidity
📁 File: contracts/L1/hooks/AssignmentHook.sol

5: import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"; 
```
[5](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/hooks/AssignmentHook.sol#L5)

```solidity
📁 File: contracts/L2/TaikoL2.sol

5: import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"; 
```
[5](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/TaikoL2.sol#L5)

```solidity
📁 File: contracts/common/AddressResolver.sol

4: import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol"; 
```
[4](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/common/AddressResolver.sol#L4)

```solidity
📁 File: contracts/common/EssentialContract.sol

4: import "@openzeppelin/contracts/proxy/utils/UUPSUpgradeable.sol"; 
```
[4](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/common/EssentialContract.sol#L4)

```solidity
📁 File: contracts/libs/LibAddress.sol

5: import "@openzeppelin/contracts/utils/cryptography/ECDSA.sol"; 
```
[5](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/libs/LibAddress.sol#L5)

```solidity
📁 File: contracts/signal/SignalService.sol

4: import "@openzeppelin/contracts/utils/math/SafeCast.sol"; 
```
[4](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/signal/SignalService.sol#L4)

```solidity
📁 File: contracts/team/TimelockTokenPool.sol

4: import "@openzeppelin/contracts/utils/cryptography/ECDSA.sol"; 

6: import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"; 
```
[4](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/TimelockTokenPool.sol#L4), [6](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/TimelockTokenPool.sol#L6)

```solidity
📁 File: contracts/team/airdrop/MerkleClaimable.sol

4: import "@openzeppelin/contracts/utils/cryptography/MerkleProof.sol"; 
```
[4](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/airdrop/MerkleClaimable.sol#L4)

```solidity
📁 File: contracts/tokenvault/BridgedERC1155.sol

4: import "@openzeppelin/contracts/utils/Strings.sol"; 
```
[4](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC1155.sol#L4)

```solidity
📁 File: contracts/tokenvault/BridgedERC20.sol

5: import "@openzeppelin/contracts/utils/Strings.sol"; 
```
[5](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC20.sol#L5)

```solidity
📁 File: contracts/tokenvault/BridgedERC721.sol

5: import "@openzeppelin/contracts/utils/Strings.sol"; 
```
[5](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC721.sol#L5)

```solidity
📁 File: contracts/tokenvault/ERC20Vault.sol

6: import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"; 
```
[6](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC20Vault.sol#L6)

```solidity
📁 File: contracts/tokenvault/ERC721Vault.sol

5: import "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol"; 
```
[5](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC721Vault.sol#L5)

```solidity
📁 File: contracts/tokenvault/LibBridgedToken.sol

4: import "@openzeppelin/contracts/utils/Strings.sol"; 
```
[4](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/LibBridgedToken.sol#L4)

```solidity
📁 File: contracts/verifiers/SgxVerifier.sol

4: import "@openzeppelin/contracts/utils/cryptography/ECDSA.sol"; 
```
[4](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/verifiers/SgxVerifier.sol#L4)

</details>


---
### [GAS&#x2011;7] Assembly let var only used on once
If a variable is only once, it makes more sense to use the value the variable holds directly.

<details>
<summary><i>There are 9 instances of this issue:</i></summary>

```solidity
📁 File: contracts/automata-attestation/utils/BytesUtils.sol

267:             let mask := not(sub(exp(256, sub(32, len)), 1)) 
```
[267](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/BytesUtils.sol#L267)

```solidity
📁 File: contracts/automata-attestation/utils/SHA1.sol

33:                         let mask := not(sub(exp(256, sub(32, count)), 1)) 
```
[33](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/SHA1.sol#L33)

```solidity
📁 File: contracts/thirdparty/optimism/Bytes.sol

54:                 let end := add(mc, _length) 

124:             let bytesStart := add(_bytes, 0x20) 

127:             let nibblesStart := add(_nibbles, 0x20) 
```
[54](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/Bytes.sol#L54), [124](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/Bytes.sol#L124), [127](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/Bytes.sol#L127)

</details>


---
### [GAS&#x2011;8] Assigning state variables directly with named struct constructors wastes gas
Using named arguments for struct means that the compiler needs to organize the fields in memory before doing the assignment, which wastes gas. Set each field directly in storage (use dot-notation), or use the unnamed version of the constructor.


Gas saved per Instance: ~28 *(Total: ~448)*
<details>
<summary><i>There are 16 instances of this issue:</i></summary>

```solidity
📁 File: contracts/L1/libs/LibDepositing.sol

88:                 deposits_[i] = TaikoData.EthDeposit({ 
89:                     recipient: address(uint160(data >> 96)),
90:                     amount: uint96(data),
91:                     id: j
92:                 });
```
[88](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibDepositing.sol#L88-L92)

```solidity
📁 File: contracts/L1/libs/LibProposing.sol

121:             meta_ = TaikoData.BlockMetadata({ 
122:                 l1Hash: blockhash(block.number - 1),
123:                 difficulty: 0, // to be initialized below
124:                 blobHash: 0, // to be initialized below
125:                 extraData: params.extraData,
126:                 depositsHash: keccak256(abi.encode(deposits_)),
127:                 coinbase: params.coinbase,
128:                 id: b.numBlocks,
129:                 gasLimit: _config.blockMaxGasLimit,
130:                 timestamp: uint64(block.timestamp),
131:                 l1Height: uint64(block.number - 1),
132:                 txListByteOffset: 0, // to be initialized below
133:                 txListByteSize: 0, // to be initialized below
134:                 minTier: 0, // to be initialized below
135:                 blobUsed: _txList.length == 0,
136:                 parentMetaHash: parentMetaHash
137:             });

212:         TaikoData.Block memory blk = TaikoData.Block({ 
213:             metaHash: keccak256(abi.encode(meta_)),
214:             // Safeguard the liveness bond to ensure its preservation,
215:             // particularly in scenarios where it might be altered after the
216:             // block's proposal but before it has been proven or verified.
217:             livenessBond: _config.livenessBond,
218:             blockId: b.numBlocks,
219:             proposedAt: meta_.timestamp,
220:             proposedIn: uint64(block.number),
221:             // For a new block, the next transition ID is always 1, not 0.
222:             nextTransitionId: 1,
223:             // For unverified block, its verifiedTransitionId is always 0.
224:             verifiedTransitionId: 0,
225:             assignedProver: params.assignedProver
226:         });
```
[121](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProposing.sol#L121-L137), [212](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProposing.sol#L212-L226)

```solidity
📁 File: contracts/L1/libs/LibProving.sol

166:                 IVerifier.Context memory ctx = IVerifier.Context({ 
167:                     metaHash: blk.metaHash,
168:                     blobHash: _meta.blobHash,
169:                     // Separate msgSender to allow the prover to be any address in the future.
170:                     prover: msg.sender,
171:                     msgSender: msg.sender,
172:                     blockId: blk.blockId,
173:                     isContesting: isContesting,
174:                     blobUsed: _meta.blobUsed
175:                 });
```
[166](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProving.sol#L166-L175)

```solidity
📁 File: contracts/automata-attestation/lib/QuoteV3Auth/V3Parser.sol

54:         v3ParsedQuote = V3Struct.ParsedV3QuoteStruct({ 
55:             header: header,
56:             localEnclaveReport: localEnclaveReport,
57:             v3AuthData: authDataV3
58:         });

190:         header = V3Struct.Header({ 
191:             version: version,
192:             attestationKeyType: attestationKeyType,
193:             teeType: teeType,
194:             qeSvn: bytes2(rawHeader.substring(8, 2)),
195:             pceSvn: bytes2(rawHeader.substring(10, 2)),
196:             qeVendorId: qeVendorId,
197:             userData: bytes20(rawHeader.substring(28, 20))
198:         });
```
[54](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/QuoteV3Auth/V3Parser.sol#L54-L58), [190](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/QuoteV3Auth/V3Parser.sol#L190-L198)

```solidity
📁 File: contracts/bridge/Bridge.sol

243:                 proofReceipt[msgHash] = ProofReceipt({ 
244:                     receivedAt: receivedAt,
245:                     preferredExecutor: _message.gasLimit == 0 ? _message.destOwner : msg.sender
246:                 });
```
[243](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/Bridge.sol#L243-L246)

```solidity
📁 File: contracts/thirdparty/optimism/rlp/RLPReader.sol

47:         out_ = RLPItem({ length: _in.length, ptr: ptr }); 

84:             out_[itemCount] = RLPItem({ 
85:                 length: itemLength + itemOffset,
86:                 ptr: MemoryPointer.wrap(MemoryPointer.unwrap(_in.ptr) + offset)
87:             });
```
[47](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/rlp/RLPReader.sol#L47), [84](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/rlp/RLPReader.sol#L84-L87)

```solidity
📁 File: contracts/thirdparty/optimism/trie/MerkleTrie.sol

209:             proof_[i] = TrieNode({ encoded: _proof[i], decoded: RLPReader.readList(_proof[i]) }); 
```
[209](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/trie/MerkleTrie.sol#L209)

```solidity
📁 File: contracts/tokenvault/ERC1155Vault.sol

58:         IBridge.Message memory message = IBridge.Message({ 
59:             id: 0, // will receive a new value
60:             from: address(0), // will receive a new value
61:             srcChainId: 0, // will receive a new value
62:             destChainId: _op.destChainId,
63:             srcOwner: msg.sender,
64:             destOwner: _op.destOwner != address(0) ? _op.destOwner : msg.sender,
65:             to: resolve(_op.destChainId, name(), false),
66:             refundTo: _op.refundTo,
67:             value: msg.value - _op.fee,
68:             fee: _op.fee,
69:             gasLimit: _op.gasLimit,
70:             data: data,
71:             memo: _op.memo
72:         });

256:                 ctoken_ = CanonicalNFT({ 
257:                     chainId: uint64(block.chainid),
258:                     addr: _op.token,
259:                     symbol: "",
260:                     name: ""
261:                 });
```
[58](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC1155Vault.sol#L58-L72), [256](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC1155Vault.sol#L256-L261)

```solidity
📁 File: contracts/tokenvault/ERC20Vault.sol

221:         IBridge.Message memory message = IBridge.Message({ 
222:             id: 0, // will receive a new value
223:             from: address(0), // will receive a new value
224:             srcChainId: 0, // will receive a new value
225:             destChainId: _op.destChainId,
226:             srcOwner: msg.sender,
227:             destOwner: _op.destOwner != address(0) ? _op.destOwner : msg.sender,
228:             to: resolve(_op.destChainId, name(), false),
229:             refundTo: _op.refundTo,
230:             value: msg.value - _op.fee,
231:             fee: _op.fee,
232:             gasLimit: _op.gasLimit,
233:             data: data,
234:             memo: _op.memo
235:         });

365:             ctoken_ = CanonicalERC20({ 
366:                 chainId: uint64(block.chainid),
367:                 addr: _token,
368:                 decimals: meta.decimals(),
369:                 symbol: meta.symbol(),
370:                 name: meta.name()
371:             });
```
[221](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC20Vault.sol#L221-L235), [365](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC20Vault.sol#L365-L371)

```solidity
📁 File: contracts/tokenvault/ERC721Vault.sol

44:         IBridge.Message memory message = IBridge.Message({ 
45:             id: 0, // will receive a new value
46:             from: address(0), // will receive a new value
47:             srcChainId: 0, // will receive a new value
48:             destChainId: _op.destChainId,
49:             srcOwner: msg.sender,
50:             destOwner: _op.destOwner != address(0) ? _op.destOwner : msg.sender,
51:             to: resolve(_op.destChainId, name(), false),
52:             refundTo: _op.refundTo,
53:             value: msg.value - _op.fee,
54:             fee: _op.fee,
55:             gasLimit: _op.gasLimit,
56:             data: data,
57:             memo: _op.memo
58:         });

203:                 ctoken_ = CanonicalNFT({ 
204:                     chainId: uint64(block.chainid),
205:                     addr: _op.token,
206:                     symbol: t.symbol(),
207:                     name: t.name()
208:                 });
```
[44](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC721Vault.sol#L44-L58), [203](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC721Vault.sol#L203-L208)

</details>


---
### [GAS&#x2011;9] Avoid contract existence checks by using low-level calls
Prior to 0.8.10 the compiler inserted extra code, including `EXTCODESIZE` (**100 gas**), to check for contract existence for external function calls. In more recent solidity versions, the compiler will not insert these checks if the external call has a return value. Similar behavior can be achieved in earlier versions by using low-level calls, since low-level calls never check for contract existence


Gas saved per Instance: ~100 *(Total: ~4,700)*
<details>
<summary><i>There are 47 instances of this issue:</i></summary>

```solidity
📁 File: contracts/L1/hooks/AssignmentHook.sol

114:             IERC20(assignment.feeToken).safeTransferFrom( 

149:                 ITaikoL1(_taikoL1Address).getConfig().chainId, 
```
[114](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/hooks/AssignmentHook.sol#L114), [149](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/hooks/AssignmentHook.sol#L149)

```solidity
📁 File: contracts/L1/libs/LibProposing.sol

207:         meta_.minTier = ITierProvider(_resolver.resolve("tier_provider", false)).getMinTier( 

253:                 IHook(params.hookCalls[i].hook).onBlockProposed{ value: address(this).balance }( 
```
[207](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProposing.sol#L207), [253](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProposing.sol#L253)

```solidity
📁 File: contracts/L1/libs/LibProving.sol

141:             ITierProvider(_resolver.resolve("tier_provider", false)).getTier(_proof.tier); 

177:                 IVerifier(verifier).verifyProof(ctx, _tran, _proof); 
```
[141](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProving.sol#L141), [177](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProving.sol#L177)

```solidity
📁 File: contracts/L1/libs/LibVerifying.sol

152:                         uint256(ITierProvider(tierProvider).getTier(ts.tier).cooldownWindow) * 60 
```
[152](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibVerifying.sol#L152)

```solidity
📁 File: contracts/L1/provers/GuardianProver.sol

51:             ITaikoL1(resolve("taiko", false)).proveBlock(_meta.id, abi.encode(_meta, _tran, _proof)); 
```
[51](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/provers/GuardianProver.sol#L51)

```solidity
📁 File: contracts/L2/CrossChainOwned.sol

45:         IBridge.Context memory ctx = IBridge(msg.sender).context(); 
```
[45](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/CrossChainOwned.sol#L45)

```solidity
📁 File: contracts/L2/TaikoL2.sol

148:             ISignalService(resolve("signal_service", false)).syncChainData( 

176:             IERC20(_token).safeTransfer(_to, IERC20(_token).balanceOf(address(this))); 
```
[148](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/TaikoL2.sol#L148), [176](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/TaikoL2.sol#L176)

```solidity
📁 File: contracts/bridge/Bridge.sol

150:         ISignalService(resolve("signal_service", false)).sendSignal(msgHash_); 

174:             if (!ISignalService(signalService).isSignalSent(address(this), msgHash)) { 

199:                 IRecallableSender(_message.from).onMessageRecalled{ value: _message.value }( 

342:         return ISignalService(resolve("signal_service", false)).isSignalSent({ 

522:             ISignalService(resolve("signal_service", false)).sendSignal( 
```
[150](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/Bridge.sol#L150), [174](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/Bridge.sol#L174), [199](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/Bridge.sol#L199), [342](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/Bridge.sol#L342), [522](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/Bridge.sol#L522)

```solidity
📁 File: contracts/common/AddressResolver.sol

83:         addr_ = payable(IAddressManager(addressManager).getAddress(_chainId, _name)); 
```
[83](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/common/AddressResolver.sol#L83)

```solidity
📁 File: contracts/libs/LibAddress.sol

56:         try IERC165(_addr).supportsInterface(_interfaceId) returns (bool _result) { 

71:             return IERC1271(_addr).isValidSignature(_hash, _sig) == _EIP1271_MAGICVALUE; 
```
[56](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/libs/LibAddress.sol#L56), [71](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/libs/LibAddress.sol#L71)

```solidity
📁 File: contracts/team/TimelockTokenPool.sol

219:         IERC20(taikoToken).transferFrom(sharedVault, _to, amountToWithdraw); 
220:         IERC20(costToken).safeTransferFrom(_recipient, sharedVault, costToWithdraw);
```
[219](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/TimelockTokenPool.sol#L219-L220)

```solidity
📁 File: contracts/team/airdrop/ERC20Airdrop.sol

63:         IERC20(token).transferFrom(vault, user, amount); 

71:         IVotes(token).delegateBySig(delegatee, nonce, expiry, v, r, s); 
```
[63](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/airdrop/ERC20Airdrop.sol#L63), [71](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/airdrop/ERC20Airdrop.sol#L71)

```solidity
📁 File: contracts/team/airdrop/ERC20Airdrop2.sol

91:         IERC20(token).transferFrom(vault, user, amount); 
```
[91](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/airdrop/ERC20Airdrop2.sol#L91)

```solidity
📁 File: contracts/team/airdrop/ERC721Airdrop.sol

60:             IERC721(token).safeTransferFrom(vault, user, tokenIds[i]); 
```
[60](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/airdrop/ERC721Airdrop.sol#L60)

```solidity
📁 File: contracts/tokenvault/BaseVault.sol

53:         ctx_ = IBridge(msg.sender).context(); 

64:         ctx_ = IBridge(msg.sender).context(); 
```
[53](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BaseVault.sol#L53), [64](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BaseVault.sol#L64)

```solidity
📁 File: contracts/tokenvault/BridgedERC20Base.sol

82:             IBridgedERC20(migratingAddress).mint(_account, _amount); 
```
[82](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC20Base.sol#L82)

```solidity
📁 File: contracts/tokenvault/ERC1155Vault.sol

77:             IBridge(resolve("bridge", false)).sendMessage{ value: msg.value }(message); 

226:             IERC1155(token).safeBatchTransferFrom(address(this), to, tokenIds, amounts, ""); 

230:             BridgedERC1155(token).mintBatch(to, tokenIds, amounts); 

252:                     BridgedERC1155(_op.token).burn(_user, _op.tokenIds[i], _op.amounts[i]); 

270:                     IERC1155(_op.token).safeTransferFrom({ 
```
[77](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC1155Vault.sol#L77), [226](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC1155Vault.sol#L226), [230](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC1155Vault.sol#L230), [252](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC1155Vault.sol#L252), [270](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC1155Vault.sol#L270)

```solidity
📁 File: contracts/tokenvault/ERC20Vault.sol

164:         if (IBridgedERC20(_btokenNew).owner() != owner()) { 

184:             IBridgedERC20(btokenOld_).changeMigrationStatus(_btokenNew, false); 
185:             IBridgedERC20(_btokenNew).changeMigrationStatus(btokenOld_, true);

239:             IBridge(resolve("bridge", false)).sendMessage{ value: msg.value }(message); 

330:             IERC20(token_).safeTransfer(_to, _amount); 

333:             IBridgedERC20(token_).mint(_to, _amount); 

360:             IBridgedERC20(_token).burn(msg.sender, _amount); 
```
[164](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC20Vault.sol#L164), [184](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC20Vault.sol#L184-L185), [239](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC20Vault.sol#L239), [330](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC20Vault.sol#L330), [333](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC20Vault.sol#L333), [360](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC20Vault.sol#L360)

```solidity
📁 File: contracts/tokenvault/ERC721Vault.sol

62:             IBridge(resolve("bridge", false)).sendMessage{ value: msg.value }(message); 

171:                 IERC721(token_).safeTransferFrom(address(this), _to, _tokenIds[i]); 

176:                 BridgedERC721(token_).mint(_to, _tokenIds[i]); 

198:                     BridgedERC721(_op.token).burn(_user, _op.tokenIds[i]); 
```
[62](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC721Vault.sol#L62), [171](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC721Vault.sol#L171), [176](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC721Vault.sol#L176), [198](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC721Vault.sol#L198)

```solidity
📁 File: contracts/verifiers/SgxVerifier.sol

128:         (bool verified,) = IAttestation(automataDcapAttestation).verifyParsedQuote(_attestation); 

185:                 ITaikoL1(taikoL1).getConfig().chainId, 
```
[128](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/verifiers/SgxVerifier.sol#L128), [185](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/verifiers/SgxVerifier.sol#L185)

</details>


---
### [GAS&#x2011;10] Avoid unnecessary `public` variables
Public state variables in Solidity automatically generate getter functions, increasing contract size and potentially leading to higher deployment and interaction costs. To optimize gas usage and contract efficiency, minimize the use of public variables unless external access is necessary. Instead, use internal or private visibility combined with explicit getter functions when required. This practice not only reduces contract size but also provides better control over data access and manipulation, enhancing security and readability. Prioritize lean, efficient contracts to ensure cost-effectiveness and better performance on the blockchain.


Gas saved per Instance: ~22,000 *(Total: ~968,000)*
<details>
<summary><i>There are 44 instances of this issue:</i></summary>

```solidity
📁 File: contracts/L1/TaikoL1.sol

24:     TaikoData.State public state; 
```
[24](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/TaikoL1.sol#L24)

```solidity
📁 File: contracts/L1/provers/Guardians.sol

23:     address[] public guardians; 

27:     uint32 public version; 

30:     uint32 public minGuardians; 
```
[23](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/provers/Guardians.sol#L23), [27](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/provers/Guardians.sol#L27), [30](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/provers/Guardians.sol#L30)

```solidity
📁 File: contracts/L2/CrossChainOwned.sol

16:     uint64 public ownerChainId; 

19:     uint64 public nextTxId; 
```
[16](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/CrossChainOwned.sol#L16), [19](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/CrossChainOwned.sol#L19)

```solidity
📁 File: contracts/L2/TaikoL2.sol

43:     bytes32 public publicInputHash; 

47:     uint64 public gasExcess; 

50:     uint64 public lastSyncedBlock; 
```
[43](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/TaikoL2.sol#L43), [47](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/TaikoL2.sol#L47), [50](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/TaikoL2.sol#L50)

```solidity
📁 File: contracts/L2/TaikoL2EIP1559Configurable.sol

11:     Config public customConfig; 
```
[11](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/TaikoL2EIP1559Configurable.sol#L11)

```solidity
📁 File: contracts/automata-attestation/AutomataDcapV3Attestation.sol

25:     ISigVerifyLib public immutable sigVerifyLib; 
26:     IPEMCertChainLib public immutable pemCertLib;

50:     EnclaveIdStruct.EnclaveId public qeIdentity; 

52:     address public owner; 
```
[25](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/AutomataDcapV3Attestation.sol#L25-L26), [50](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/AutomataDcapV3Attestation.sol#L50), [52](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/AutomataDcapV3Attestation.sol#L52)

```solidity
📁 File: contracts/bridge/Bridge.sol

31:     uint128 public nextMessageId; 
```
[31](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/Bridge.sol#L31)

```solidity
📁 File: contracts/common/AddressResolver.sol

13:     address public addressManager; 
```
[13](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/common/AddressResolver.sol#L13)

```solidity
📁 File: contracts/team/TimelockTokenPool.sol

59:     address public taikoToken; 

62:     address public costToken; 

65:     address public sharedVault; 

68:     uint128 public totalAmountGranted; 

71:     uint128 public totalAmountVoided; 

74:     uint128 public totalAmountWithdrawn; 

77:     uint128 public totalCostPaid; 
```
[59](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/TimelockTokenPool.sol#L59), [62](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/TimelockTokenPool.sol#L62), [65](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/TimelockTokenPool.sol#L65), [68](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/TimelockTokenPool.sol#L68), [71](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/TimelockTokenPool.sol#L71), [74](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/TimelockTokenPool.sol#L74), [77](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/TimelockTokenPool.sol#L77)

```solidity
📁 File: contracts/team/airdrop/ERC20Airdrop.sol

13:     address public token; 

16:     address public vault; 
```
[13](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/airdrop/ERC20Airdrop.sol#L13), [16](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/airdrop/ERC20Airdrop.sol#L16)

```solidity
📁 File: contracts/team/airdrop/ERC20Airdrop2.sol

16:     address public token; 

19:     address public vault; 

28:     uint64 public withdrawalWindow; 
```
[16](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/airdrop/ERC20Airdrop2.sol#L16), [19](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/airdrop/ERC20Airdrop2.sol#L19), [28](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/airdrop/ERC20Airdrop2.sol#L28)

```solidity
📁 File: contracts/team/airdrop/ERC721Airdrop.sol

11:     address public token; 

14:     address public vault; 
```
[11](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/airdrop/ERC721Airdrop.sol#L11), [14](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/airdrop/ERC721Airdrop.sol#L14)

```solidity
📁 File: contracts/team/airdrop/MerkleClaimable.sol

15:     bytes32 public merkleRoot; 

18:     uint64 public claimStart; 

21:     uint64 public claimEnd; 
```
[15](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/airdrop/MerkleClaimable.sol#L15), [18](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/airdrop/MerkleClaimable.sol#L18), [21](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/airdrop/MerkleClaimable.sol#L21)

```solidity
📁 File: contracts/tokenvault/BridgedERC1155.sol

16:     address public srcToken; 

19:     uint256 public srcChainId; 
```
[16](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC1155.sol#L16), [19](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC1155.sol#L19)

```solidity
📁 File: contracts/tokenvault/BridgedERC20.sol

22:     address public srcToken; 

27:     uint256 public srcChainId; 

30:     address public snapshooter; 
```
[22](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC20.sol#L22), [27](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC20.sol#L27), [30](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC20.sol#L30)

```solidity
📁 File: contracts/tokenvault/BridgedERC20Base.sol

11:     address public migratingAddress; 

14:     bool public migratingInbound; 
```
[11](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC20Base.sol#L11), [14](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC20Base.sol#L14)

```solidity
📁 File: contracts/tokenvault/BridgedERC721.sol

14:     address public srcToken; 

17:     uint256 public srcChainId; 
```
[14](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC721.sol#L14), [17](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC721.sol#L17)

```solidity
📁 File: contracts/tokenvault/adapters/USDCAdapter.sol

31:     IUSDC public usdc; 
```
[31](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/adapters/USDCAdapter.sol#L31)

```solidity
📁 File: contracts/verifiers/SgxVerifier.sol

39:     uint256 public nextInstanceId; 
```
[39](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/verifiers/SgxVerifier.sol#L39)

</details>


---
### [GAS&#x2011;11] Avoid updating storage when the value hasn't changed
If the old value is equal to the new value, not re-storing the value will avoid a Gsreset (2900 gas), potentially at the expense of a Gcoldsload (2100 gas) or a Gwarmaccess (100 gas)


Gas saved per Instance: ~1,700 *(Total: ~10,200)*
<details>
<summary><i>There are 6 instances of this issue:</i></summary>

```solidity
📁 File: contracts/L2/TaikoL2EIP1559Configurable.sol

25:     function setConfigAndExcess( 
26:         Config memory _newConfig,
27:         uint64 _newGasExcess
28:     )
29:         external
30:         virtual
31:         onlyOwner
32:     {
33:         if (_newConfig.gasTargetPerL1Block == 0) revert L2_INVALID_CONFIG();
34:         if (_newConfig.basefeeAdjustmentQuotient == 0) revert L2_INVALID_CONFIG();
35: 
36:         customConfig = _newConfig;
37:         gasExcess = _newGasExcess;
38: 
39:         emit ConfigAndExcessChanged(_newConfig, _newGasExcess);
40:     }
```
[25](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/TaikoL2EIP1559Configurable.sol#L25-L40)

```solidity
📁 File: contracts/automata-attestation/AutomataDcapV3Attestation.sol

114:     function configureQeIdentityJson(EnclaveIdStruct.EnclaveId calldata qeIdentityInput) 
115:         external
116:         onlyOwner
117:     {
118:         // 250k gas
119:         qeIdentity = qeIdentityInput;
120:     }
```
[114](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/AutomataDcapV3Attestation.sol#L114-L120)

```solidity
📁 File: contracts/common/AddressResolver.sol

58:     function __AddressResolver_init(address _addressManager) internal virtual onlyInitializing { 
59:         if (block.chainid > type(uint64).max) {
60:             revert RESOLVER_UNEXPECTED_CHAINID();
61:         }
62:         addressManager = _addressManager;
63:     }
```
[58](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/common/AddressResolver.sol#L58-L63)

```solidity
📁 File: contracts/common/EssentialContract.sol

119:     function _storeReentryLock(uint8 _reentry) internal virtual { 
120:         if (block.chainid == 1) {
121:             assembly {
122:                 tstore(_REENTRY_SLOT, _reentry)
123:             }
124:         } else {
125:             __reentry = _reentry;
126:         }
127:     }
```
[119](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/common/EssentialContract.sol#L119-L127)

```solidity
📁 File: contracts/team/airdrop/MerkleClaimable.sol

90:     function _setConfig(uint64 _claimStart, uint64 _claimEnd, bytes32 _merkleRoot) private { 
91:         claimStart = _claimStart;
92:         claimEnd = _claimEnd;
93:         merkleRoot = _merkleRoot;
94:     }
```
[90](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/airdrop/MerkleClaimable.sol#L90-L94)

```solidity
📁 File: contracts/tokenvault/BridgedERC20.sol

80:     function setSnapshoter(address _snapshooter) external onlyOwner { 
81:         snapshooter = _snapshooter;
82:     }
```
[80](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC20.sol#L80-L82)

</details>


---
### [GAS&#x2011;12] Avoid zero to non-zero storage writes where possible
Changing a storage variable from zero to non-zero costs **22,100 gas** in total. (20,000 gas for a zero to non-zero write and 2,100 for a cold storage access)

Consider using non-zero architecture to avoid high gas costs for zero to non-zero storage writes.


Gas saved per Instance: ~22,100 *(Total: ~596,700)*
<details>
<summary><i>There are 27 instances of this issue:</i></summary>

```solidity
📁 File: contracts/L1/provers/Guardians.sol

94:         minGuardians = _minGuardians; 

116:             _approvals[version][_hash] |= 1 << (id - 1); 
```
[94](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/provers/Guardians.sol#L94), [116](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/provers/Guardians.sol#L116)

```solidity
📁 File: contracts/L2/CrossChainOwned.sol

73:         ownerChainId = _ownerChainId; 
```
[73](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/CrossChainOwned.sol#L73)

```solidity
📁 File: contracts/L2/TaikoL2.sol

96:         gasExcess = _gasExcess; 

140:         (basefee, gasExcess) = _calc1559BaseFee(config, _l1BlockId, _parentGasUsed); 

151:             lastSyncedBlock = _l1BlockId; 
```
[96](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/TaikoL2.sol#L96), [140](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/TaikoL2.sol#L140), [151](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/TaikoL2.sol#L151)

```solidity
📁 File: contracts/L2/TaikoL2EIP1559Configurable.sol

37:         gasExcess = _newGasExcess; 
```
[37](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/TaikoL2EIP1559Configurable.sol#L37)

```solidity
📁 File: contracts/bridge/Bridge.sol

183:             receivedAt = uint64(block.timestamp); 

240:             receivedAt = uint64(block.timestamp); 
```
[183](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/Bridge.sol#L183), [240](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/Bridge.sol#L240)

```solidity
📁 File: contracts/common/EssentialContract.sol

70:         __paused = _TRUE; 

79:         __paused = _FALSE; 

111:         __paused = _FALSE; 

125:             __reentry = _reentry; 
```
[70](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/common/EssentialContract.sol#L70), [79](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/common/EssentialContract.sol#L79), [111](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/common/EssentialContract.sol#L111), [125](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/common/EssentialContract.sol#L125)

```solidity
📁 File: contracts/signal/SignalService.sol

127:             chainId = hop.chainId; 
```
[127](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/signal/SignalService.sol#L127)

```solidity
📁 File: contracts/team/TimelockTokenPool.sol

141:         totalAmountGranted += _grant.amount; 

156:         totalAmountVoided += amountVoided; 

216:         totalAmountWithdrawn += amountToWithdraw; 
217:         totalCostPaid += costToWithdraw;
```
[141](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/TimelockTokenPool.sol#L141), [156](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/TimelockTokenPool.sol#L156), [216](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/TimelockTokenPool.sol#L216-L217)

```solidity
📁 File: contracts/team/airdrop/ERC20Airdrop2.sol

71:         withdrawalWindow = _withdrawalWindow; 
```
[71](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/airdrop/ERC20Airdrop2.sol#L71)

```solidity
📁 File: contracts/team/airdrop/MerkleClaimable.sol

91:         claimStart = _claimStart; 
92:         claimEnd = _claimEnd;
```
[91](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/airdrop/MerkleClaimable.sol#L91-L92)

```solidity
📁 File: contracts/tokenvault/BridgedERC1155.sol

57:         srcChainId = _srcChainId; 
```
[57](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC1155.sol#L57)

```solidity
📁 File: contracts/tokenvault/BridgedERC20.sol

74:         srcChainId = _srcChainId; 
75:         __srcDecimals = _decimals;
```
[74](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC20.sol#L74-L75)

```solidity
📁 File: contracts/tokenvault/BridgedERC721.sol

48:         srcChainId = _srcChainId; 
```
[48](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC721.sol#L48)

```solidity
📁 File: contracts/verifiers/SgxVerifier.sol

207:             validSince += INSTANCE_VALIDITY_DELAY; 

217:             instances[nextInstanceId] = Instance(_instances[i], validSince); 
```
[207](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/verifiers/SgxVerifier.sol#L207), [217](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/verifiers/SgxVerifier.sol#L217)

</details>


---
### [GAS&#x2011;13] Bytes constants are more efficient than string constants
If a string can fit in 32 bytes is it better to use `bytes32` instead of `string`, as it is cheaper.


Gas saved per Instance: ~378 *(Total: ~1,890)*

<i>There are 5 instaces of this issue:</i>

```solidity
📁 File: contracts/automata-attestation/lib/PEMCertChainLib.sol

17:     string internal constant HEADER = "-----BEGIN CERTIFICATE-----"; 
18:     string internal constant FOOTER = "-----END CERTIFICATE-----";

22:     string internal constant PCK_COMMON_NAME = "Intel SGX PCK Certificate"; 
23:     string internal constant PLATFORM_ISSUER_NAME = "Intel SGX PCK Platform CA";
24:     string internal constant PROCESSOR_ISSUER_NAME = "Intel SGX PCK Processor CA";
```
[17](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/PEMCertChainLib.sol#L17-L18), [22](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/PEMCertChainLib.sol#L22-L24)


---
### [GAS&#x2011;14] `bytes.concat()` can be used in place of `abi.encodePacked`
Given concatenation is not going to be used for hashing `bytes.concat` is the preferred method to use as its more gas efficient

<details>
<summary><i>There are 11 instances of this issue:</i></summary>

```solidity
📁 File: contracts/automata-attestation/AutomataDcapV3Attestation.sol

315:             abi.encodePacked(authDataV3.ecdsaAttestationKey, authDataV3.qeAuthData.data); 
```
[315](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/AutomataDcapV3Attestation.sol#L315)

```solidity
📁 File: contracts/automata-attestation/lib/PEMCertChainLib.sol

181:             cert.signature = abi.encodePacked(sigX, sigY); 
```
[181](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/PEMCertChainLib.sol#L181)

```solidity
📁 File: contracts/automata-attestation/lib/QuoteV3Auth/V3Parser.sol

119:         bytes memory headerBytes = abi.encodePacked( 
120:             header.version,
121:             header.attestationKeyType,
122:             header.teeType,
123:             header.qeSvn,
124:             header.pceSvn,
125:             header.qeVendorId,
126:             header.userData
127:         );

129:         signedQuoteData = abi.encodePacked(headerBytes, V3Parser.packQEReport(localEnclaveReport)); 
```
[119](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/QuoteV3Auth/V3Parser.sol#L119-L127), [129](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/QuoteV3Auth/V3Parser.sol#L129)

```solidity
📁 File: contracts/thirdparty/optimism/rlp/RLPWriter.sol

17:             out_ = abi.encodePacked(_writeLength(_in.length, 128), _in); 
```
[17](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/rlp/RLPWriter.sol#L17)

```solidity
📁 File: contracts/thirdparty/optimism/trie/MerkleTrie.sol

81:         bytes memory currentNodeID = abi.encodePacked(_root); 

94:                     Bytes.equal(abi.encodePacked(keccak256(currentNode.encoded)), currentNodeID), 

100:                     Bytes.equal(abi.encodePacked(keccak256(currentNode.encoded)), currentNodeID), 
```
[81](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/trie/MerkleTrie.sol#L81), [94](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/trie/MerkleTrie.sol#L94), [100](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/trie/MerkleTrie.sol#L100)

```solidity
📁 File: contracts/thirdparty/optimism/trie/SecureMerkleTrie.sol

55:         hash_ = abi.encodePacked(keccak256(_key)); 
```
[55](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/trie/SecureMerkleTrie.sol#L55)

```solidity
📁 File: contracts/tokenvault/BridgedERC721.sol

109:             abi.encodePacked( 
110:                 LibBridgedToken.buildURI(srcToken, srcChainId), Strings.toString(_tokenId)
111:             )
```
[109](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC721.sol#L109-L111)

```solidity
📁 File: contracts/tokenvault/LibBridgedToken.sol

54:             abi.encodePacked( 
55:                 "ethereum:",
56:                 Strings.toHexString(uint160(_srcToken), 20),
57:                 "@",
58:                 Strings.toString(_srcChainId),
59:                 "/tokenURI?uint256="
60:             )
```
[54](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/LibBridgedToken.sol#L54-L60)

</details>


---
### [GAS&#x2011;15] Cache array length outside of loop
If not cached, the solidity compiler will always read the length of the array during each iteration. That is, if it is a storage array, this is an extra sload operation (100 additional extra gas for each iteration except for the first) and if it is a memory array, this is an extra mload operation (3 additional gas for each iteration except for the first).


Gas saved per Instance: ~4 *(Total: ~116)*
<details>
<summary><i>There are 29 instances of this issue:</i></summary>

```solidity
📁 File: contracts/L1/hooks/AssignmentHook.sol

172:         for (uint256 i; i < _tierFees.length; ++i) { 
```
[172](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/hooks/AssignmentHook.sol#L172)

```solidity
📁 File: contracts/L1/libs/LibDepositing.sol

86:             for (uint256 i; i < deposits_.length;) { 
```
[86](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibDepositing.sol#L86)

```solidity
📁 File: contracts/L1/libs/LibProposing.sol

244:             for (uint256 i; i < params.hookCalls.length; ++i) { 
```
[244](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProposing.sol#L244)

```solidity
📁 File: contracts/L1/provers/Guardians.sol

74:         for (uint256 i; i < guardians.length; ++i) { 

80:         for (uint256 i = 0; i < _newGuardians.length; ++i) { 
```
[74](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/provers/Guardians.sol#L74), [80](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/provers/Guardians.sol#L80)

```solidity
📁 File: contracts/automata-attestation/AutomataDcapV3Attestation.sol

80:         for (uint256 i; i < serialNumBatch.length; ++i) { 

95:         for (uint256 i; i < serialNumBatch.length; ++i) { 

191:         for (uint256 i; i < enclaveId.tcbLevels.length; ++i) { 

214:         for (uint256 i; i < tcb.tcbLevels.length; ++i) { 
```
[80](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/AutomataDcapV3Attestation.sol#L80), [95](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/AutomataDcapV3Attestation.sol#L95), [191](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/AutomataDcapV3Attestation.sol#L191), [214](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/AutomataDcapV3Attestation.sol#L214)

```solidity
📁 File: contracts/automata-attestation/lib/PEMCertChainLib.sol

244:         for (uint256 i; i < split.length; ++i) { 
```
[244](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/PEMCertChainLib.sol#L244)

```solidity
📁 File: contracts/automata-attestation/lib/QuoteV3Auth/V3Parser.sol

153:         for (uint256 i; i < encoded.length; ++i) { 
```
[153](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/QuoteV3Auth/V3Parser.sol#L153)

```solidity
📁 File: contracts/automata-attestation/utils/RsaVerify.sol

174:         for (uint256 i; i < _sha256.length; ++i) { 

283:         for (uint256 i; i < sha1Prefix.length; ++i) { 

290:         for (uint256 i; i < _sha1.length; ++i) { 
```
[174](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/RsaVerify.sol#L174), [283](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/RsaVerify.sol#L283), [290](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/RsaVerify.sol#L290)

```solidity
📁 File: contracts/bridge/Bridge.sol

90:         for (uint256 i; i < _msgHashes.length; ++i) { 
```
[90](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/Bridge.sol#L90)

```solidity
📁 File: contracts/signal/SignalService.sol

104:         for (uint256 i; i < hopProofs.length; ++i) { 
```
[104](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/signal/SignalService.sol#L104)

```solidity
📁 File: contracts/team/airdrop/ERC721Airdrop.sol

59:         for (uint256 i; i < tokenIds.length; ++i) { 
```
[59](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/airdrop/ERC721Airdrop.sol#L59)

```solidity
📁 File: contracts/thirdparty/optimism/rlp/RLPWriter.sol

66:         for (uint256 j = 0; j < out_.length; j++) { 
```
[66](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/rlp/RLPWriter.sol#L66)

```solidity
📁 File: contracts/thirdparty/optimism/trie/MerkleTrie.sol

85:         for (uint256 i = 0; i < proof.length; i++) { 
```
[85](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/trie/MerkleTrie.sol#L85)

```solidity
📁 File: contracts/tokenvault/ERC1155Vault.sol

47:         for (uint256 i; i < _op.amounts.length; ++i) { 

251:                 for (uint256 i; i < _op.tokenIds.length; ++i) { 

269:                 for (uint256 i; i < _op.tokenIds.length; ++i) { 
```
[47](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC1155Vault.sol#L47), [251](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC1155Vault.sol#L251), [269](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC1155Vault.sol#L269)

```solidity
📁 File: contracts/tokenvault/ERC721Vault.sol

34:         for (uint256 i; i < _op.tokenIds.length; ++i) { 

170:             for (uint256 i; i < _tokenIds.length; ++i) { 

175:             for (uint256 i; i < _tokenIds.length; ++i) { 

197:                 for (uint256 i; i < _op.tokenIds.length; ++i) { 

210:                 for (uint256 i; i < _op.tokenIds.length; ++i) { 
```
[34](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC721Vault.sol#L34), [170](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC721Vault.sol#L170), [175](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC721Vault.sol#L175), [197](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC721Vault.sol#L197), [210](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC721Vault.sol#L210)

```solidity
📁 File: contracts/verifiers/SgxVerifier.sol

104:         for (uint256 i; i < _ids.length; ++i) { 

210:         for (uint256 i; i < _instances.length; ++i) { 
```
[104](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/verifiers/SgxVerifier.sol#L104), [210](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/verifiers/SgxVerifier.sol#L210)

</details>


---
### [GAS&#x2011;16] Cache contracts when making multiple external calls
When function makes multiple calls to the same external contract, it is more gas-efficient to use a local copy of the contract. This is because the EVM will cache the contract in memory, and subsequent calls will be cheaper. It's especially true for contracts that are large and/or have many functions.


Gas saved per Instance: ~168 

<i>There is one instance of this issue:</i>

```solidity
📁 File: contracts/tokenvault/adapters/USDCAdapter.sol

/// @audit 2 calls to 'usdc' contract
/// @audit lines: 48, 49
47:     function _burnToken(address _from, uint256 _amount) internal override { 
```
[47](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/adapters/USDCAdapter.sol#L47)


---
### [GAS&#x2011;17] Consider activating `via-ir` for deploying
The IR-based code generator was introduced with an aim to not only allow code generation to be more transparent and auditable but also to enable more powerful optimization passes that span across functions.You can enable it on the command line using `--via-ir` or with the option `{"viaIR": true}`.This will take longer to compile, but you can just simple test it before deploying and if you got a better benchmark then you can add --via-ir to your deploy commandMore on: https://docs.soliditylang.org/en/v0.8.17/ir-breaking-changes.html


---
### [GAS&#x2011;18] Consider caching repeated computations
The result of repeated computations can be cached to avoid calculating it multiple times and wasting gas.


Gas saved per Instance: ~60 *(Total: ~240)*
<details>
<summary><i>There are 4 instances of this issue:</i></summary>

```solidity
📁 File: contracts/automata-attestation/utils/Asn1Decode.sol

/// @audit ix+2 is seen 5 times
/// @audit ixFirstContentByte+length-1 is seen 2 times
187:     function _readNodeLength(bytes memory der, uint256 ix) private pure returns (uint256) { 
```
[187](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/Asn1Decode.sol#L187)

```solidity
📁 File: contracts/thirdparty/solmate/LibFixedPointMath.sol

/// @audit (q*x)>>96 is seen 5 times
/// @audit q*x is seen 5 times
13:     function exp(int256 x) internal pure returns (int256 r) { 
```
[13](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/solmate/LibFixedPointMath.sol#L13)

</details>


---
### [GAS&#x2011;19] Consider merging sequential for loops
Merging multiple `for` loops within a function in Solidity can enhance efficiency and reduce gas costs, especially when they share a common iterating variable or perform related operations. By minimizing redundant iterations over the same data set, execution becomes more cost-effective. However, while merging can optimize gas usage and simplify logic, it may also increase code complexity. Therefore, careful balance between optimization and maintainability is essential, along with thorough testing to ensure the refactored code behaves as expected.

<details>
<summary><i>There are 6 instances of this issue:</i></summary>

```solidity
📁 File: contracts/tokenvault/ERC1155Vault.sol

/// @audit consider merging with loops from line: 269
251:                 for (uint256 i; i < _op.tokenIds.length; ++i) { 

/// @audit consider merging with loops from line: 251
269:                 for (uint256 i; i < _op.tokenIds.length; ++i) { 
```
[251](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC1155Vault.sol#L251), [269](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC1155Vault.sol#L269)

```solidity
📁 File: contracts/tokenvault/ERC721Vault.sol

/// @audit consider merging with loops from line: 175
170:             for (uint256 i; i < _tokenIds.length; ++i) { 

/// @audit consider merging with loops from line: 170
175:             for (uint256 i; i < _tokenIds.length; ++i) { 

/// @audit consider merging with loops from line: 210
197:                 for (uint256 i; i < _op.tokenIds.length; ++i) { 

/// @audit consider merging with loops from line: 197
210:                 for (uint256 i; i < _op.tokenIds.length; ++i) { 
```
[170](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC721Vault.sol#L170), [175](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC721Vault.sol#L175), [197](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC721Vault.sol#L197), [210](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC721Vault.sol#L210)

</details>


---
### [GAS&#x2011;20] Consider packing small `uint`s when it's possible
Packing uint variables into the same storage slot can help in reducing gas costs. This is particularly useful when storing or reading multiple smaller uints (e.g., uint80) in a single transaction. Consider using bit manipulation to pack these variables.

If you pack two uint variables into a single uint storage slot, you'd perform only one `SLOAD` operation (800 gas) instead of two (1,600 gas) when you read them. This saves **800 gas** for each read operation involving the two variables.

Similarly, when you need to update both variables, a single `SSTORE` operation would cost you 20,000 gas instead of 40,000 gas, saving you another **20,000 gas**.

Example:
```solidity
uint160 packedVariables;

function packVariables(uint80 x, uint80 y) external {
    packedVariables = uint160(x) << 80 | uint160(y);
}
```


Gas saved per Instance: ~20,800 *(Total: ~1,851,200)*
<details>
<summary><i>There are 89 instances of this issue:</i></summary>

```solidity
📁 File: contracts/L1/TaikoData.sol

15:         uint64 chainId; 

20:         uint64 blockMaxProposals; 

22:         uint64 blockRingBufferSize; 

24:         uint64 maxBlocksToVerifyPerProposal; 

26:         uint32 blockMaxGasLimit; 

28:         uint24 blockMaxTxListBytes; 

30:         uint24 blobExpiry; 

39:         uint96 livenessBond; 

46:         uint64 ethDepositMinCountPerBlock; 

48:         uint64 ethDepositMaxCountPerBlock; 

50:         uint96 ethDepositMinAmount; 

52:         uint96 ethDepositMaxAmount; 

59:         uint8 blockSyncThreshold; 

64:         uint16 tier; 
65:         uint128 fee;

69:         uint16 tier; 

83:         uint24 txListByteOffset; 
84:         uint24 txListByteSize;

101:         uint64 id; 
102:         uint32 gasLimit;
103:         uint64 timestamp; // slot 7
104:         uint64 l1Height;
105:         uint24 txListByteOffset;
106:         uint24 txListByteSize;
107:         uint16 minTier;

127:         uint96 validityBond; 

129:         uint96 contestBond; 
130:         uint64 timestamp; // slot 6 (90 bits)
131:         uint16 tier;
132:         uint8 contestations;

140:         uint96 livenessBond; 
141:         uint64 blockId; // slot 3
142:         uint64 proposedAt; // timestamp
143:         uint64 proposedIn; // L1 block number
144:         uint32 nextTransitionId;
145:         uint32 verifiedTransitionId;

152:         uint96 amount; 
153:         uint64 id;

162:         uint64 genesisHeight; 
163:         uint64 genesisTimestamp;
164:         uint64 numEthDeposits;
165:         uint64 nextEthDepositToProcess;

169:         uint64 numBlocks; 
170:         uint64 lastVerifiedBlockId;

172:         uint8 __reserved1; 
173:         uint16 __reserved2;
174:         uint32 __reserved3;
175:         uint64 lastUnpausedAt;
```
[15](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/TaikoData.sol#L15), [20](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/TaikoData.sol#L20), [22](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/TaikoData.sol#L22), [24](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/TaikoData.sol#L24), [26](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/TaikoData.sol#L26), [28](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/TaikoData.sol#L28), [30](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/TaikoData.sol#L30), [39](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/TaikoData.sol#L39), [46](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/TaikoData.sol#L46), [48](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/TaikoData.sol#L48), [50](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/TaikoData.sol#L50), [52](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/TaikoData.sol#L52), [59](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/TaikoData.sol#L59), [64](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/TaikoData.sol#L64-L65), [69](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/TaikoData.sol#L69), [83](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/TaikoData.sol#L83-L84), [101](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/TaikoData.sol#L101-L107), [127](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/TaikoData.sol#L127), [129](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/TaikoData.sol#L129-L132), [140](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/TaikoData.sol#L140-L145), [152](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/TaikoData.sol#L152-L153), [162](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/TaikoData.sol#L162-L165), [169](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/TaikoData.sol#L169-L170), [172](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/TaikoData.sol#L172-L175)

```solidity
📁 File: contracts/L1/hooks/AssignmentHook.sol

20:         uint64 expiry; 
21:         uint64 maxBlockId;
22:         uint64 maxProposedIn;
```
[20](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/hooks/AssignmentHook.sol#L20-L22)

```solidity
📁 File: contracts/L1/provers/Guardians.sol

27:     uint32 public version; 

30:     uint32 public minGuardians; 
```
[27](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/provers/Guardians.sol#L27), [30](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/provers/Guardians.sol#L30)

```solidity
📁 File: contracts/L2/CrossChainOwned.sol

16:     uint64 public ownerChainId; 

19:     uint64 public nextTxId; 
```
[16](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/CrossChainOwned.sol#L16), [19](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/CrossChainOwned.sol#L19)

```solidity
📁 File: contracts/L2/TaikoL2.sol

27:         uint32 gasTargetPerL1Block; 
28:         uint8 basefeeAdjustmentQuotient;

47:     uint64 public gasExcess; 

50:     uint64 public lastSyncedBlock; 
```
[27](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/TaikoL2.sol#L27-L28), [47](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/TaikoL2.sol#L47), [50](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/TaikoL2.sol#L50)

```solidity
📁 File: contracts/automata-attestation/lib/EnclaveIdStruct.sol

10:         uint16 isvprodid; 

23:         uint16 isvsvn; 
```
[10](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/EnclaveIdStruct.sol#L10), [23](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/EnclaveIdStruct.sol#L23)

```solidity
📁 File: contracts/automata-attestation/lib/QuoteV3Auth/V3Struct.sol

26:         uint16 isvProdId; 
27:         uint16 isvSvn;

34:         uint16 parsedDataSize; 

39:         uint16 certType; 

43:         uint32 certDataSize; 
```
[26](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/QuoteV3Auth/V3Struct.sol#L26-L27), [34](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/QuoteV3Auth/V3Struct.sol#L34), [39](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/QuoteV3Auth/V3Struct.sol#L39), [43](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/QuoteV3Auth/V3Struct.sol#L43)

```solidity
📁 File: contracts/common/EssentialContract.sol

21:     uint8 private __reentry; 

23:     uint8 private __paused; 
```
[21](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/common/EssentialContract.sol#L21), [23](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/common/EssentialContract.sol#L23)

```solidity
📁 File: contracts/team/TimelockTokenPool.sol

29:         uint128 amount; 

31:         uint128 costPerToken; 

34:         uint64 grantStart; 

37:         uint64 grantCliff; 

40:         uint32 grantPeriod; 

43:         uint64 unlockStart; 

46:         uint64 unlockCliff; 

49:         uint32 unlockPeriod; 

53:         uint128 amountWithdrawn; 
54:         uint128 costPaid;

68:     uint128 public totalAmountGranted; 

71:     uint128 public totalAmountVoided; 

74:     uint128 public totalAmountWithdrawn; 

77:     uint128 public totalCostPaid; 
```
[29](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/TimelockTokenPool.sol#L29), [31](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/TimelockTokenPool.sol#L31), [34](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/TimelockTokenPool.sol#L34), [37](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/TimelockTokenPool.sol#L37), [40](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/TimelockTokenPool.sol#L40), [43](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/TimelockTokenPool.sol#L43), [46](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/TimelockTokenPool.sol#L46), [49](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/TimelockTokenPool.sol#L49), [53](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/TimelockTokenPool.sol#L53-L54), [68](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/TimelockTokenPool.sol#L68), [71](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/TimelockTokenPool.sol#L71), [74](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/TimelockTokenPool.sol#L74), [77](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/TimelockTokenPool.sol#L77)

```solidity
📁 File: contracts/team/airdrop/MerkleClaimable.sol

18:     uint64 public claimStart; 

21:     uint64 public claimEnd; 
```
[18](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/airdrop/MerkleClaimable.sol#L18), [21](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/airdrop/MerkleClaimable.sol#L21)

```solidity
📁 File: contracts/tokenvault/BaseNFTVault.sol

13:         uint64 chainId; 

25:         uint64 destChainId; 
```
[13](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BaseNFTVault.sol#L13), [25](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BaseNFTVault.sol#L25)

```solidity
📁 File: contracts/tokenvault/ERC20Vault.sol

24:         uint64 chainId; 

26:         uint8 decimals; 

33:         uint64 destChainId; 
```
[24](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC20Vault.sol#L24), [26](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC20Vault.sol#L26), [33](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC20Vault.sol#L33)

</details>


---
### [GAS&#x2011;21] Consider pre-calculating the address of `address(this)`
It can be more gas-efficient to use a hardcoded address instead of the `address(this)` expression, especially if you need to use the same address multiple times in your contract.

The reason for this, is that using `address(this)` requires an additional `EXTCODESIZE` operation to retrieve the contract’s address from its bytecode, which can increase the gas cost of your contract. By pre-calculating and using a hardcoded address, you can avoid this additional operation and reduce the overall gas cost of your contract.

<details>
<summary><i>There are 40 instances of this issue:</i></summary>

```solidity
📁 File: contracts/L1/TaikoToken.sol

61:         if (_to == address(this)) revert TKO_INVALID_ADDR(); 

79:         if (_to == address(this)) revert TKO_INVALID_ADDR(); 
```
[61](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/TaikoToken.sol#L61), [79](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/TaikoToken.sol#L79)

```solidity
📁 File: contracts/L1/hooks/AssignmentHook.sol

125:         if (address(this).balance > 0) { 
126:             taikoL1Address.sendEther(address(this).balance);

151:                 address(this), 
```
[125](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/hooks/AssignmentHook.sol#L125-L126), [151](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/hooks/AssignmentHook.sol#L151)

```solidity
📁 File: contracts/L1/libs/LibProposing.sol

238:             uint256 tkoBalance = tko.balanceOf(address(this)); 

253:                 IHook(params.hookCalls[i].hook).onBlockProposed{ value: address(this).balance }( 

260:             if (address(this).balance != 0) { 
261:                 msg.sender.sendEther(address(this).balance);

268:             if (tko.balanceOf(address(this)) != tkoBalance + _config.livenessBond) { 
```
[238](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProposing.sol#L238), [253](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProposing.sol#L253), [260](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProposing.sol#L260-L261), [268](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProposing.sol#L268)

```solidity
📁 File: contracts/L1/libs/LibProving.sol

242:                 tko.transferFrom(msg.sender, address(this), tier.contestBond); 

384:                 _tko.transferFrom(msg.sender, address(this), _tier.validityBond - reward); 
```
[242](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProving.sol#L242), [384](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProving.sol#L384)

```solidity
📁 File: contracts/L2/CrossChainOwned.sol

50:         (bool success,) = address(this).call(txdata); 
```
[50](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/CrossChainOwned.sol#L50)

```solidity
📁 File: contracts/L2/TaikoL2.sol

174:             _to.sendEther(address(this).balance); 

176:             IERC20(_token).safeTransfer(_to, IERC20(_token).balanceOf(address(this))); 
```
[174](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/TaikoL2.sol#L174), [176](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/TaikoL2.sol#L176)

```solidity
📁 File: contracts/bridge/Bridge.sol

174:             if (!ISignalService(signalService).isSignalSent(address(this), msgHash)) { 

196:                 _storeContext(msgHash, address(this), _message.srcChainId); 

270:                 _message.to == address(0) || _message.to == address(this) 

343:             _app: address(this), 

486:         assert(_message.from != address(this)); 
```
[174](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/Bridge.sol#L174), [196](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/Bridge.sol#L196), [270](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/Bridge.sol#L270), [343](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/Bridge.sol#L343), [486](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/Bridge.sol#L486)

```solidity
📁 File: contracts/signal/SignalService.sol

112:                 signalService = address(this); 

131:         if (value == 0 || value != _loadSignalValue(address(this), signal)) { 

149:         return _loadSignalValue(address(this), signal) == _chainData; 

171:             chainData_ = _loadSignalValue(address(this), signal); 

245:         _sendSignal(address(this), signal_, _chainData); 
```
[112](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/signal/SignalService.sol#L112), [131](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/signal/SignalService.sol#L131), [149](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/signal/SignalService.sol#L149), [171](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/signal/SignalService.sol#L171), [245](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/signal/SignalService.sol#L245)

```solidity
📁 File: contracts/tokenvault/BridgedERC1155.sol

137:         if (_to == address(this)) revert BTOKEN_CANNOT_RECEIVE(); 
```
[137](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC1155.sol#L137)

```solidity
📁 File: contracts/tokenvault/BridgedERC20.sol

147:         if (_to == address(this)) revert BTOKEN_CANNOT_RECEIVE(); 
```
[147](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC20.sol#L147)

```solidity
📁 File: contracts/tokenvault/BridgedERC721.sol

125:         if (_to == address(this)) revert BTOKEN_CANNOT_RECEIVE(); 
```
[125](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC721.sol#L125)

```solidity
📁 File: contracts/tokenvault/ERC1155Vault.sol

108:         if (to == address(0) || to == address(this)) revert VAULT_INVALID_TO(); 

226:             IERC1155(token).safeBatchTransferFrom(address(this), to, tokenIds, amounts, ""); 

272:                         to: address(this), 
```
[108](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC1155Vault.sol#L108), [226](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC1155Vault.sol#L226), [272](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC1155Vault.sol#L272)

```solidity
📁 File: contracts/tokenvault/ERC20Vault.sol

267:         if (to == address(0) || to == address(this)) revert VAULT_INVALID_TO(); 

378:             uint256 _balance = t.balanceOf(address(this)); 
379:             t.safeTransferFrom({ from: msg.sender, to: address(this), value: _amount });
380:             balanceChange_ = t.balanceOf(address(this)) - _balance;
```
[267](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC20Vault.sol#L267), [378](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC20Vault.sol#L378-L380)

```solidity
📁 File: contracts/tokenvault/ERC721Vault.sol

91:         if (to == address(0) || to == address(this)) revert VAULT_INVALID_TO(); 

171:                 IERC721(token_).safeTransferFrom(address(this), _to, _tokenIds[i]); 

211:                     t.safeTransferFrom(_user, address(this), _op.tokenIds[i]); 
```
[91](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC721Vault.sol#L91), [171](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC721Vault.sol#L171), [211](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC721Vault.sol#L211)

```solidity
📁 File: contracts/tokenvault/adapters/USDCAdapter.sol

48:         usdc.transferFrom(_from, address(this), _amount); 
```
[48](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/adapters/USDCAdapter.sol#L48)

```solidity
📁 File: contracts/verifiers/SgxVerifier.sol

186:                 address(this), 
```
[186](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/verifiers/SgxVerifier.sol#L186)

</details>


---
### [GAS&#x2011;22] Consider reducing redundant checks in each iteration of loops.
Having to perform the same check on every iteration of the loop is gas consuming, redundant and unnecessary since the check is not dependent on the loop iteration.

<details>
<summary><i>There are 8 instances of this issue:</i></summary>

```solidity
📁 File: contracts/L1/libs/LibVerifying.sol

127:             while (blockId < b.numBlocks && numBlocksVerified < _maxBlocksToVerify) { 
128:                 slot = blockId % _config.blockRingBufferSize;
129: 
130:                 blk = _state.blocks[slot];
131:                 if (blk.blockId != blockId) revert L1_BLOCK_MISMATCH();
132: 
133:                 tid = LibUtils.getTransitionId(_state, blk, slot, blockHash);
134:                 // When `tid` is 0, it indicates that there is no proven
135:                 // transition with its parentHash equal to the blockHash of the
136:                 // most recently verified block.
137:                 if (tid == 0) break;
138: 
139:                 // A transition with the correct `parentHash` has been located.
140:                 TaikoData.TransitionState storage ts = _state.transitions[slot][tid];
141: 
142:                 // It's not possible to verify this block if either the
143:                 // transition is contested and awaiting higher-tier proof or if
144:                 // the transition is still within its cooldown period.
/// @audit Check can be moved outside of loop
145:                 if (ts.contester != address(0)) {
146:                     break;
147:                 } else {
148:                     if (tierProvider == address(0)) {
149:                         tierProvider = _resolver.resolve("tier_provider", false);
150:                     }
/// @audit Check can be moved outside of loop
151:                     if (
152:                         uint256(ITierProvider(tierProvider).getTier(ts.tier).cooldownWindow) * 60
153:                             + uint256(ts.timestamp).max(_state.slotB.lastUnpausedAt) > block.timestamp
154:                     ) {
155:                         // If cooldownWindow is 0, the block can theoretically
156:                         // be proved and verified within the same L1 block.
157:                         break;
158:                     }
159:                 }
160: 
161:                 // Mark this block as verified
162:                 blk.verifiedTransitionId = tid;
163: 
164:                 // Update variables
165:                 blockHash = ts.blockHash;
166:                 stateRoot = ts.stateRoot;
167: 
168:                 // We consistently return the liveness bond and the validity
169:                 // bond to the actual prover of the transition utilized for
170:                 // block verification. If the actual prover happens to be the
171:                 // block's assigned prover, he will receive both deposits,
172:                 // ultimately earning the proving fee paid during block
173:                 // proposal. In contrast, if the actual prover is different from
174:                 // the block's assigned prover, the liveness bond serves as a
175:                 // reward to the actual prover, while the assigned prover
176:                 // forfeits his liveness bond due to failure to fulfill their
177:                 // commitment.
178:                 uint256 bondToReturn = uint256(ts.validityBond) + blk.livenessBond;
179: 
180:                 // Nevertheless, it's possible for the actual prover to be the
181:                 // same individual or entity as the block's assigned prover.
182:                 // Consequently, we have chosen to grant the actual prover only
183:                 // half of the liveness bond as a reward.
184:                 if (ts.prover != blk.assignedProver) {
185:                     bondToReturn -= blk.livenessBond >> 1;
186:                 }
187: 
188:                 IERC20 tko = IERC20(_resolver.resolve("taiko_token", false));
189:                 tko.transfer(ts.prover, bondToReturn);
190: 
191:                 // Note: We exclusively address the bonds linked to the
192:                 // transition used for verification. While there may exist
193:                 // other transitions for this block, we disregard them entirely.
194:                 // The bonds for these other transitions are burned either when
195:                 // the transitions are generated or proven. In such cases, both
196:                 // the provers and contesters of those transitions forfeit their bonds.
197: 
198:                 emit BlockVerified({
199:                     blockId: blockId,
200:                     assignedProver: blk.assignedProver,
201:                     prover: ts.prover,
202:                     blockHash: blockHash,
203:                     stateRoot: stateRoot,
204:                     tier: ts.tier,
205:                     contestations: ts.contestations
206:                 });
207: 
208:                 ++blockId;
209:                 ++numBlocksVerified;
210:             }
```
[127](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibVerifying.sol#L127-L210)

```solidity
📁 File: contracts/automata-attestation/lib/PEMCertChainLib.sol

286:         while (tbsPtr != 0) { 
287:             uint256 internalPtr = der.firstChildOf(tbsPtr);
/// @audit Check can be moved outside of loop
288:             if (der[internalPtr.ixs()] != 0x06) {
289:                 return (false, pcesvn, cpusvns, fmspcBytes, pceidBytes);
290:             }
291: 
292:             if (BytesUtils.compareBytes(der.bytesAt(internalPtr), SGX_EXTENSION_OID)) {
293:                 // 1.2.840.113741.1.13.1
294:                 internalPtr = der.nextSiblingOf(internalPtr);
295:                 uint256 extnValueParentPtr = der.rootOfOctetStringAt(internalPtr);
296:                 uint256 extnValuePtr = der.firstChildOf(extnValueParentPtr);
297: 
298:                 // Copy flags to memory to avoid stack too deep
299:                 PCKTCBFlags memory flags;
300: 
301:                 while (!(flags.fmspcFound && flags.pceidFound && flags.tcbFound)) {
302:                     uint256 extnValueOidPtr = der.firstChildOf(extnValuePtr);
/// @audit Check can be moved outside of loop
/// @audit Check can be moved outside of loop
303:                     if (der[extnValueOidPtr.ixs()] != 0x06) {
304:                         return (false, pcesvn, cpusvns, fmspcBytes, pceidBytes);
305:                     }
306:                     if (BytesUtils.compareBytes(der.bytesAt(extnValueOidPtr), TCB_OID)) {
307:                         // 1.2.840.113741.1.13.1.2
308:                         (flags.tcbFound, pcesvn, cpusvns) = _findTcb(der, extnValueOidPtr);
309:                     }
310:                     if (BytesUtils.compareBytes(der.bytesAt(extnValueOidPtr), PCEID_OID)) {
311:                         // 1.2.840.113741.1.13.1.3
312:                         uint256 pceidPtr = der.nextSiblingOf(extnValueOidPtr);
313:                         pceidBytes = der.bytesAt(pceidPtr);
314:                         flags.pceidFound = true;
315:                     }
316:                     if (BytesUtils.compareBytes(der.bytesAt(extnValueOidPtr), FMSPC_OID)) {
317:                         // 1.2.840.113741.1.13.1.4
318:                         uint256 fmspcPtr = der.nextSiblingOf(extnValueOidPtr);
319:                         fmspcBytes = der.bytesAt(fmspcPtr);
320:                         flags.fmspcFound = true;
321:                     }
322: 
/// @audit Check can be moved outside of loop
/// @audit Check can be moved outside of loop
323:                     if (extnValuePtr.ixl() < extnValueParentPtr.ixl()) {
324:                         extnValuePtr = der.nextSiblingOf(extnValuePtr);
325:                     } else {
326:                         break;
327:                     }
328:                 }
329:                 success = flags.fmspcFound && flags.pceidFound && flags.tcbFound;
330:                 break;
331:             }
332: 
/// @audit Check can be moved outside of loop
333:             if (tbsPtr.ixl() < tbsParentPtr.ixl()) {
334:                 tbsPtr = der.nextSiblingOf(tbsPtr);
335:             } else {
336:                 tbsPtr = 0; // exit
337:             }
338:         }
```
[286](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/PEMCertChainLib.sol#L286-L338)

</details>


---
### [GAS&#x2011;23] Consider using OpenZeppelin's `EnumerateSet` instead of nested mappings
Nested mappings and multi-dimensional arrays in Solidity operate through a process of double hashing, wherein the original storage slot and the first key are concatenated and hashed, and then this hash is again concatenated with the second key and hashed. This process can be quite gas expensive due to the double-hashing operation and subsequent storage operation (sstore).

OpenZeppelin's `EnumerableSet` provides a potential solution to this problem. It creates a data structure that combines the benefits of set operations with the ability to enumerate stored elements, which is not natively available in Solidity. EnumerableSet handles the element uniqueness internally and can therefore provide a more gas-efficient and collision-resistant alternative to nested mappings or multi-dimensional arrays in certain scenarios.


Gas saved per Instance: ~1,000 *(Total: ~8,000)*
<details>
<summary><i>There are 8 instances of this issue:</i></summary>

```solidity
📁 File: contracts/L1/TaikoData.sol

183:         mapping(uint64 blockId => mapping(bytes32 parentHash => uint32 transitionId)) transitionIds; 

185:         mapping( 
186:             uint64 blockId_mod_blockRingBufferSize
187:                 => mapping(uint32 transitionId => TransitionState ts)
188:             ) transitions;
```
[183](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/TaikoData.sol#L183), [185](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/TaikoData.sol#L185-L188)

```solidity
📁 File: contracts/L1/provers/Guardians.sol

19:     mapping(uint32 version => mapping(bytes32 hash => uint256 approvalBits)) internal _approvals; 
```
[19](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/provers/Guardians.sol#L19)

```solidity
📁 File: contracts/automata-attestation/AutomataDcapV3Attestation.sol

47:     mapping(uint256 idx => mapping(bytes serialNum => bool revoked)) private _serialNumIsRevoked; 
```
[47](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/AutomataDcapV3Attestation.sol#L47)

```solidity
📁 File: contracts/common/AddressManager.sol

12:     mapping(uint256 chainId => mapping(bytes32 name => address addr)) private __addresses; 
```
[12](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/common/AddressManager.sol#L12)

```solidity
📁 File: contracts/signal/SignalService.sol

17:     mapping(uint64 chainId => mapping(bytes32 kind => uint64 blockId)) public topBlockId; 
```
[17](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/signal/SignalService.sol#L17)

```solidity
📁 File: contracts/tokenvault/BaseNFTVault.sol

59:     mapping(uint256 chainId => mapping(address ctoken => address btoken)) public canonicalToBridged; 
```
[59](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BaseNFTVault.sol#L59)

```solidity
📁 File: contracts/tokenvault/ERC20Vault.sol

49:     mapping(uint256 chainId => mapping(address ctoken => address btoken)) public canonicalToBridged; 
```
[49](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC20Vault.sol#L49)

</details>


---
### [GAS&#x2011;24] Consider using Solady's gas optimized lib for Math
Utilizing gas-optimized math functions from libraries like [Solady](https://github.com/Vectorized/solady/blob/main/src/utils/FixedPointMathLib.sol) can lead to more efficient smart contracts.
This is particularly beneficial in contracts where these operations are frequently used.

<details>
<summary><i>There are 77 instances of this issue:</i></summary>

```solidity
📁 File: contracts/L1/libs/LibDepositing.sol

151:         return (uint256(uint160(_addr)) << 96) | _amount; 
```
[151](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibDepositing.sol#L151)

```solidity
📁 File: contracts/L1/libs/LibProposing.sol

98:         if (b.numBlocks >= b.lastVerifiedBlockId + _config.blockMaxProposals + 1) { 

103:             _state.blocks[(b.numBlocks - 1) % _config.blockRingBufferSize].metaHash; 
```
[98](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProposing.sol#L98), [103](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProposing.sol#L103)

```solidity
📁 File: contracts/L1/libs/LibProving.sol

414:         bool inProvingWindow = uint256(_ts.timestamp).max(_state.slotB.lastUnpausedAt) 
415:             + _tier.provingWindow * 60 >= block.timestamp;
```
[414](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProving.sol#L414-L415)

```solidity
📁 File: contracts/L1/libs/LibVerifying.sol

152:                         uint256(ITierProvider(tierProvider).getTier(ts.tier).cooldownWindow) * 60 
153:                             + uint256(ts.timestamp).max(_state.slotB.lastUnpausedAt) > block.timestamp
```
[152](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibVerifying.sol#L152-L153)

```solidity
📁 File: contracts/L1/provers/Guardians.sol

68:         if (_minGuardians < (_newGuardians.length + 1) >> 1 || _minGuardians > _newGuardians.length) 

116:             _approvals[version][_hash] |= 1 << (id - 1); 
```
[68](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/provers/Guardians.sol#L68), [116](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/provers/Guardians.sol#L116)

```solidity
📁 File: contracts/L2/Lib1559Math.sol

28:         return _ethQty(_gasExcess, _adjustmentFactor) / LibFixedPointMath.SCALING_FACTOR 
29:             / _adjustmentFactor;

41:         uint256 input = _gasExcess * LibFixedPointMath.SCALING_FACTOR / _adjustmentFactor; 
```
[28](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/Lib1559Math.sol#L28-L29), [41](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/Lib1559Math.sol#L41)

```solidity
📁 File: contracts/L2/TaikoL2.sol

213:         config_.gasTargetPerL1Block = 15 * 1e6 * 4; 

235:                 uint256 j = _blockId - i - 1; 
```
[213](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/TaikoL2.sol#L213), [235](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/TaikoL2.sol#L235)

```solidity
📁 File: contracts/automata-attestation/lib/QuoteV3Auth/V3Parser.sol

106:         uint32 totalQuoteSize = 48 // header 
107:             + 384 // local QE report
108:             + 64 // ecdsa256BitSignature
109:             + 64 // ecdsaAttestationKey
110:             + 384 // QE report
111:             + 64 // qeReportSignature
112:             + 2 // sizeof(v3Quote.v3AuthData.qeAuthData.parsedDataSize)
113:             + v3Quote.v3AuthData.qeAuthData.parsedDataSize + 2 // sizeof(v3Quote.v3AuthData.certification.certType)
114:             + 4 // sizeof(v3Quote.v3AuthData.certification.certDataSize)
115:             + v3Quote.v3AuthData.certification.certDataSize;

158:             uint256 acc = lowerDigit * (16 ** (2 * i)); 
159:             acc += upperDigit * (16 ** ((2 * i) + 1));

249:         uint16 isvProdIdPackBE = (enclaveReport.isvProdId >> 8) | (enclaveReport.isvProdId << 8); 
250:         uint16 isvSvnPackBE = (enclaveReport.isvSvn >> 8) | (enclaveReport.isvSvn << 8);
```
[106](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/QuoteV3Auth/V3Parser.sol#L106-L115), [158](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/QuoteV3Auth/V3Parser.sol#L158-L159), [249](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/QuoteV3Auth/V3Parser.sol#L249-L250)

```solidity
📁 File: contracts/automata-attestation/utils/Asn1Decode.sol

112:         return der.substring(ptr.ixf(), ptr.ixl() + 1 - ptr.ixf()); 

122:         return der.substring(ptr.ixs(), ptr.ixl() + 1 - ptr.ixs()); 

132:         return der.readBytesN(ptr.ixf(), ptr.ixl() + 1 - ptr.ixf()); 

144:         uint256 len = ptr.ixl() + 1 - ptr.ixf(); 
145:         return uint256(der.readBytesN(ptr.ixf(), len) >> (32 - len) * 8);

157:         uint256 valueLength = ptr.ixl() + 1 - ptr.ixf(); 

166:         return der.keccak(ptr.ixf(), ptr.ixl() + 1 - ptr.ixf()); 

170:         return der.keccak(ptr.ixs(), ptr.ixl() + 1 - ptr.ixs()); 

183:         uint256 valueLength = ptr.ixl() + 1 - ptr.ixf(); 

191:         if ((der[ix + 1] & 0x80) == 0) { 

194:             ixLastContentByte = uint80(ixFirstContentByte + length - 1); 

196:             uint8 lengthbytesLength = uint8(der[ix + 1] & 0x7F); 

203:                     der.readBytesN(ix + 2, lengthbytesLength) >> (32 - lengthbytesLength) * 8 

206:             ixFirstContentByte = uint80(ix + 2 + lengthbytesLength); 
207:             ixLastContentByte = uint80(ixFirstContentByte + length - 1);
```
[112](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/Asn1Decode.sol#L112), [122](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/Asn1Decode.sol#L122), [132](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/Asn1Decode.sol#L132), [144](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/Asn1Decode.sol#L144-L145), [157](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/Asn1Decode.sol#L157), [166](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/Asn1Decode.sol#L166), [170](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/Asn1Decode.sol#L170), [183](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/Asn1Decode.sol#L183), [191](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/Asn1Decode.sol#L191), [194](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/Asn1Decode.sol#L194), [196](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/Asn1Decode.sol#L196), [203](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/Asn1Decode.sol#L203), [206](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/Asn1Decode.sol#L206-L207)

```solidity
📁 File: contracts/automata-attestation/utils/BytesUtils.sol

93:                     mask = ~(2 ** (8 * (32 - shortest + idx)) - 1); 

95:                 uint256 diff = (a & mask) - (b & mask); 

341:             ret = (ret << 5) | decoded; 

347:             ret = (ret << 5) | decoded; 

350:             ret = (ret << 3) | (decoded >> 2); 

354:             ret = (ret << 1) | (decoded >> 4); 

358:             ret = (ret << 4) | (decoded >> 1); 

362:             ret = (ret << 2) | (decoded >> 3); 

368:         return bytes32(ret << (256 - bitlen)); 
```
[93](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/BytesUtils.sol#L93), [95](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/BytesUtils.sol#L95), [341](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/BytesUtils.sol#L341), [347](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/BytesUtils.sol#L347), [350](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/BytesUtils.sol#L350), [354](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/BytesUtils.sol#L354), [358](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/BytesUtils.sol#L358), [362](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/BytesUtils.sol#L362), [368](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/BytesUtils.sol#L368)

```solidity
📁 File: contracts/automata-attestation/utils/RsaVerify.sol

135:         uint256 paddingLen = decipherlen - 5 - digestAlgoWithParamLen - 32; 

153:                 if (decipher[3 + paddingLen + i] != bytes1(sha256ExplicitNullParam[i])) { 

159:                 if (decipher[3 + paddingLen + i] != bytes1(sha256ImplicitNullParam[i])) { 

168:             decipher[3 + paddingLen + digestAlgoWithParamLen] != 0x04 
169:                 || decipher[4 + paddingLen + digestAlgoWithParamLen] != 0x20

175:             if (decipher[5 + paddingLen + digestAlgoWithParamLen + i] != _sha256[i]) { 

268:         uint256 paddingLen = decipherlen - 3 - sha1Prefix.length - 20; 

284:             if (decipher[3 + paddingLen + i] != bytes1(sha1Prefix[i])) { 

291:             if (decipher[3 + paddingLen + sha1Prefix.length + i] != _sha1[i]) { 
```
[135](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/RsaVerify.sol#L135), [153](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/RsaVerify.sol#L153), [159](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/RsaVerify.sol#L159), [168](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/RsaVerify.sol#L168-L169), [175](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/RsaVerify.sol#L175), [268](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/RsaVerify.sol#L268), [284](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/RsaVerify.sol#L284), [291](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/RsaVerify.sol#L291)

```solidity
📁 File: contracts/automata-attestation/utils/X509DateUtils.sol

21:             yrs += (uint8(x509Time[0]) - 48) * 1000 + (uint8(x509Time[1]) - 48) * 100; 

24:         yrs += (uint8(x509Time[offset + 0]) - 48) * 10 + uint8(x509Time[offset + 1]) - 48; 
25:         mnths = (uint8(x509Time[offset + 2]) - 48) * 10 + uint8(x509Time[offset + 3]) - 48;
26:         dys += (uint8(x509Time[offset + 4]) - 48) * 10 + uint8(x509Time[offset + 5]) - 48;
27:         hrs += (uint8(x509Time[offset + 6]) - 48) * 10 + uint8(x509Time[offset + 7]) - 48;
28:         mins += (uint8(x509Time[offset + 8]) - 48) * 10 + uint8(x509Time[offset + 9]) - 48;
29:         secs += (uint8(x509Time[offset + 10]) - 48) * 10 + uint8(x509Time[offset + 11]) - 48;

60:             timestamp += uint256(monthDays[i - 1]) * 86_400; // Days in seconds 

63:         timestamp += uint256(day - 1) * 86_400; // Days in seconds 
```
[21](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/X509DateUtils.sol#L21), [24](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/X509DateUtils.sol#L24-L29), [60](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/X509DateUtils.sol#L60), [63](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/X509DateUtils.sol#L63)

```solidity
📁 File: contracts/team/TimelockTokenPool.sol

198:         costToWithdraw = _amountUnlocked * r.grant.costPerToken - r.costPaid; 

264:         return _amount * uint64(block.timestamp - _start) / _period; 
```
[198](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/TimelockTokenPool.sol#L198), [264](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/TimelockTokenPool.sol#L264)

```solidity
📁 File: contracts/team/airdrop/ERC20Airdrop2.sol

117:         uint256 timeBasedAllowance = balance 
118:             * (block.timestamp.min(claimEnd + withdrawalWindow) - claimEnd) / withdrawalWindow;
```
[117](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/airdrop/ERC20Airdrop2.sol#L117-L118)

```solidity
📁 File: contracts/thirdparty/optimism/rlp/RLPWriter.sol

45:             out_[0] = bytes1(uint8(lenLen) + uint8(_offset) + 55); 

47:                 out_[i] = bytes1(uint8((_len / (256 ** (lenLen - i))) % 256)); 
```
[45](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/rlp/RLPWriter.sol#L45), [47](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/rlp/RLPWriter.sol#L47)

```solidity
📁 File: contracts/thirdparty/optimism/trie/MerkleTrie.sol

142:                 uint8 offset = 2 - (prefix % 2); 
```
[142](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/trie/MerkleTrie.sol#L142)

```solidity
📁 File: contracts/thirdparty/solmate/LibFixedPointMath.sol

33:             x = (x << 78) / 5 ** 18; 

39:             int256 k = ((x << 96) / 54_916_777_467_707_473_351_141_471_128 + 2 ** 95) >> 96; 
40:             x = x - k * 54_916_777_467_707_473_351_141_471_128;

46:             y = ((y * x) >> 96) + 57_155_421_227_552_351_082_224_309_758_442; 
47:             int256 p = y + x - 94_201_549_194_550_492_254_356_042_504_812;
48:             p = ((p * y) >> 96) + 28_719_021_644_029_726_153_956_944_680_412_240;
49:             p = p * x + (4_385_272_521_454_847_904_659_076_985_693_276 << 96);

54:             q = ((q * x) >> 96) + 50_020_603_652_535_783_019_961_831_881_945; 
55:             q = ((q * x) >> 96) - 533_845_033_583_426_703_283_633_433_725_380;
56:             q = ((q * x) >> 96) + 3_604_857_256_930_695_427_073_651_918_091_429;
57:             q = ((q * x) >> 96) - 14_423_608_567_350_463_180_887_372_962_807_573;
58:             q = ((q * x) >> 96) + 26_449_188_498_355_588_339_934_803_723_976_023;

77:                 (uint256(r) * 3_822_833_074_963_236_453_042_738_258_902_158_003_155_416_615_667) 
78:                     >> uint256(195 - k)
```
[33](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/solmate/LibFixedPointMath.sol#L33), [39](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/solmate/LibFixedPointMath.sol#L39-L40), [46](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/solmate/LibFixedPointMath.sol#L46-L49), [54](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/solmate/LibFixedPointMath.sol#L54-L58), [77](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/solmate/LibFixedPointMath.sol#L77-L78)

</details>


---
### [GAS&#x2011;25] Constructors can be marked `payable`
Payable functions cost less gas to execute, since the compiler does not have to add extra checks to ensure that a payment wasn't provided. A constructor can safely be marked as payable, since only the deployer would be able to pass funds, and the project itself would not pass any funds.


Gas saved per Instance: ~21 *(Total: ~63)*
<details>
<summary><i>There are 3 instances of this issue:</i></summary>

```solidity
📁 File: contracts/automata-attestation/AutomataDcapV3Attestation.sol

54:     constructor(address sigVerifyLibAddr, address pemCertLibAddr) { 
```
[54](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/AutomataDcapV3Attestation.sol#L54)

```solidity
📁 File: contracts/automata-attestation/utils/SigVerifyLib.sol

20:     constructor(address es256Verifier) { 
```
[20](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/SigVerifyLib.sol#L20)

```solidity
📁 File: contracts/common/EssentialContract.sol

64:     constructor() { 
```
[64](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/common/EssentialContract.sol#L64)

</details>


---
### [GAS&#x2011;26] Counting down in `for` statements is more gas efficient
Counting down is more gas efficient than counting up because neither we are making zero variable to non-zero variable and also we will get gas refund in the last transaction when making non-zero to zero variable. [More info](https://solodit.xyz/issues/g-02-counting-down-in-for-statements-is-more-gas-efficient-code4rena-pooltogether-pooltogether-git)


Gas saved per Instance: ~16 *(Total: ~752)*
<details>
<summary><i>There are 47 instances of this issue:</i></summary>

```solidity
📁 File: contracts/L1/hooks/AssignmentHook.sol

172:         for (uint256 i; i < _tierFees.length; ++i) { 
```
[172](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/hooks/AssignmentHook.sol#L172)

```solidity
📁 File: contracts/L1/libs/LibDepositing.sol

/// @audit increments @ line 103
86:             for (uint256 i; i < deposits_.length;) { 
87:                 uint256 data = _state.ethDeposits[j % _config.ethDepositRingBufferSize];
88:                 deposits_[i] = TaikoData.EthDeposit({
89:                     recipient: address(uint160(data >> 96)),
90:                     amount: uint96(data),
91:                     id: j
92:                 });
93:                 uint96 _fee = deposits_[i].amount > fee ? fee : deposits_[i].amount;
94: 
95:                 // Unchecked is safe:
96:                 // - _fee cannot be bigger than deposits_[i].amount
97:                 // - all values are in the same range (uint96) except loop
98:                 // counter, which obviously cannot be bigger than uint95
99:                 // otherwise the function would be gassing out.
100:                 unchecked {
101:                     deposits_[i].amount -= _fee;
102:                     totalFee += _fee;
103:                     ++i;
104:                     ++j;
105:                 }
106:             }
```
[86](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibDepositing.sol#L86-L106)

```solidity
📁 File: contracts/L1/libs/LibProposing.sol

244:             for (uint256 i; i < params.hookCalls.length; ++i) { 
```
[244](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProposing.sol#L244)

```solidity
📁 File: contracts/L1/provers/Guardians.sol

74:         for (uint256 i; i < guardians.length; ++i) { 

80:         for (uint256 i = 0; i < _newGuardians.length; ++i) { 

133:             for (uint256 i; i < guardiansLength; ++i) { 
```
[74](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/provers/Guardians.sol#L74), [80](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/provers/Guardians.sol#L80), [133](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/provers/Guardians.sol#L133)

```solidity
📁 File: contracts/L2/TaikoL2.sol

234:             for (uint256 i; i < 255 && _blockId >= i + 1; ++i) { 
```
[234](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/TaikoL2.sol#L234)

```solidity
📁 File: contracts/automata-attestation/AutomataDcapV3Attestation.sol

80:         for (uint256 i; i < serialNumBatch.length; ++i) { 

95:         for (uint256 i; i < serialNumBatch.length; ++i) { 

191:         for (uint256 i; i < enclaveId.tcbLevels.length; ++i) { 

214:         for (uint256 i; i < tcb.tcbLevels.length; ++i) { 

240:         for (uint256 i; i < CPUSVN_LENGTH; ++i) { 

259:         for (uint256 i; i < n; ++i) { 

420:             for (uint256 i; i < 3; ++i) { 
```
[80](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/AutomataDcapV3Attestation.sol#L80), [95](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/AutomataDcapV3Attestation.sol#L95), [191](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/AutomataDcapV3Attestation.sol#L191), [214](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/AutomataDcapV3Attestation.sol#L214), [240](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/AutomataDcapV3Attestation.sol#L240), [259](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/AutomataDcapV3Attestation.sol#L259), [420](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/AutomataDcapV3Attestation.sol#L420)

```solidity
📁 File: contracts/automata-attestation/lib/PEMCertChainLib.sol

54:         for (uint256 i; i < size; ++i) { 

244:         for (uint256 i; i < split.length; ++i) { 

354:         for (uint256 i; i < SGX_TCB_CPUSVN_SIZE + 1; ++i) { 
```
[54](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/PEMCertChainLib.sol#L54), [244](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/PEMCertChainLib.sol#L244), [354](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/PEMCertChainLib.sol#L354)

```solidity
📁 File: contracts/automata-attestation/lib/QuoteV3Auth/V3Parser.sol

153:         for (uint256 i; i < encoded.length; ++i) { 

281:         for (uint256 i; i < 3; ++i) { 
```
[153](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/QuoteV3Auth/V3Parser.sol#L153), [281](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/QuoteV3Auth/V3Parser.sol#L281)

```solidity
📁 File: contracts/automata-attestation/utils/BytesUtils.sol

333:         for (uint256 i; i < len; ++i) { 
```
[333](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/BytesUtils.sol#L333)

```solidity
📁 File: contracts/automata-attestation/utils/RsaVerify.sol

140:         for (uint256 i = 2; i < 2 + paddingLen; ++i) { 

152:             for (uint256 i; i < digestAlgoWithParamLen; ++i) { 

158:             for (uint256 i; i < digestAlgoWithParamLen; ++i) { 

174:         for (uint256 i; i < _sha256.length; ++i) { 

273:         for (uint256 i = 2; i < 2 + paddingLen; ++i) { 

283:         for (uint256 i; i < sha1Prefix.length; ++i) { 

290:         for (uint256 i; i < _sha1.length; ++i) { 
```
[140](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/RsaVerify.sol#L140), [152](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/RsaVerify.sol#L152), [158](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/RsaVerify.sol#L158), [174](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/RsaVerify.sol#L174), [273](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/RsaVerify.sol#L273), [283](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/RsaVerify.sol#L283), [290](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/RsaVerify.sol#L290)

```solidity
📁 File: contracts/automata-attestation/utils/X509DateUtils.sol

48:         for (uint16 i = 1970; i < year; ++i) { 

59:         for (uint8 i = 1; i < month; ++i) { 
```
[48](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/X509DateUtils.sol#L48), [59](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/X509DateUtils.sol#L59)

```solidity
📁 File: contracts/bridge/Bridge.sol

90:         for (uint256 i; i < _msgHashes.length; ++i) { 
```
[90](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/Bridge.sol#L90)

```solidity
📁 File: contracts/signal/SignalService.sol

104:         for (uint256 i; i < hopProofs.length; ++i) { 
```
[104](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/signal/SignalService.sol#L104)

```solidity
📁 File: contracts/team/airdrop/ERC721Airdrop.sol

59:         for (uint256 i; i < tokenIds.length; ++i) { 
```
[59](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/airdrop/ERC721Airdrop.sol#L59)

```solidity
📁 File: contracts/thirdparty/optimism/rlp/RLPWriter.sol

46:             for (i = 1; i <= lenLen; i++) { 

59:         for (; i < 32; i++) { 

66:         for (uint256 j = 0; j < out_.length; j++) { 
```
[46](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/rlp/RLPWriter.sol#L46), [59](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/rlp/RLPWriter.sol#L59), [66](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/rlp/RLPWriter.sol#L66)

```solidity
📁 File: contracts/thirdparty/optimism/trie/MerkleTrie.sol

85:         for (uint256 i = 0; i < proof.length; i++) { 

/// @audit increments @ line 211
208:         for (uint256 i = 0; i < length;) { 
209:             proof_[i] = TrieNode({ encoded: _proof[i], decoded: RLPReader.readList(_proof[i]) });
210:             unchecked {
211:                 ++i;
212:             }
213:         }
```
[85](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/trie/MerkleTrie.sol#L85), [208](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/trie/MerkleTrie.sol#L208-L213)

```solidity
📁 File: contracts/tokenvault/ERC1155Vault.sol

47:         for (uint256 i; i < _op.amounts.length; ++i) { 

251:                 for (uint256 i; i < _op.tokenIds.length; ++i) { 

269:                 for (uint256 i; i < _op.tokenIds.length; ++i) { 
```
[47](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC1155Vault.sol#L47), [251](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC1155Vault.sol#L251), [269](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC1155Vault.sol#L269)

```solidity
📁 File: contracts/tokenvault/ERC721Vault.sol

34:         for (uint256 i; i < _op.tokenIds.length; ++i) { 

170:             for (uint256 i; i < _tokenIds.length; ++i) { 

175:             for (uint256 i; i < _tokenIds.length; ++i) { 

197:                 for (uint256 i; i < _op.tokenIds.length; ++i) { 

210:                 for (uint256 i; i < _op.tokenIds.length; ++i) { 
```
[34](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC721Vault.sol#L34), [170](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC721Vault.sol#L170), [175](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC721Vault.sol#L175), [197](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC721Vault.sol#L197), [210](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC721Vault.sol#L210)

```solidity
📁 File: contracts/verifiers/SgxVerifier.sol

104:         for (uint256 i; i < _ids.length; ++i) { 

210:         for (uint256 i; i < _instances.length; ++i) { 
```
[104](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/verifiers/SgxVerifier.sol#L104), [210](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/verifiers/SgxVerifier.sol#L210)

</details>


---
### [GAS&#x2011;27] Declare variables outside of loops
Variables should be declared outside of loops, and get overriden with each iteration of loop, By doing so we save gas cost for memory variable declaration in each iteration.


Gas saved per Instance: ~15 *(Total: ~855)*
<details>
<summary><i>There are 57 instances of this issue:</i></summary>

```solidity
📁 File: contracts/L1/libs/LibDepositing.sol

/// @audit loop from line 86 to line 106
87:                 uint256 data = _state.ethDeposits[j % _config.ethDepositRingBufferSize]; 

/// @audit loop from line 86 to line 106
93:                 uint96 _fee = deposits_[i].amount > fee ? fee : deposits_[i].amount; 
```
[87](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibDepositing.sol#L87), [93](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibDepositing.sol#L93)

```solidity
📁 File: contracts/L1/libs/LibVerifying.sol

/// @audit loop from line 127 to line 210
140:                 TaikoData.TransitionState storage ts = _state.transitions[slot][tid]; 

/// @audit loop from line 127 to line 210
178:                 uint256 bondToReturn = uint256(ts.validityBond) + blk.livenessBond; 

/// @audit loop from line 127 to line 210
188:                 IERC20 tko = IERC20(_resolver.resolve("taiko_token", false)); 
```
[140](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibVerifying.sol#L140), [178](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibVerifying.sol#L178), [188](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibVerifying.sol#L188)

```solidity
📁 File: contracts/L1/provers/Guardians.sol

/// @audit loop from line 80 to line 89
81:             address guardian = _newGuardians[i]; 
```
[81](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/provers/Guardians.sol#L81)

```solidity
📁 File: contracts/L2/TaikoL2.sol

/// @audit loop from line 234 to line 237
235:                 uint256 j = _blockId - i - 1; 
```
[235](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/TaikoL2.sol#L235)

```solidity
📁 File: contracts/automata-attestation/AutomataDcapV3Attestation.sol

/// @audit loop from line 191 to line 198
192:             EnclaveIdStruct.TcbLevel memory tcb = enclaveId.tcbLevels[i]; 

/// @audit loop from line 214 to line 225
215:             TCBInfoStruct.TCBLevelObj memory current = tcb.tcbLevels[i]; 
/// @audit loop from line 214 to line 225
216:             bool pceSvnIsHigherOrGreater = pck.sgxExtension.pcesvn >= current.pcesvn;
/// @audit loop from line 214 to line 225
217:             bool cpuSvnsAreHigherOrGreater = _isCpuSvnHigherOrGreater(

/// @audit loop from line 214 to line 225
222:                 bool tcbIsRevoked = status == TCBInfoStruct.TCBStatus.TCB_REVOKED; 

/// @audit loop from line 259 to line 298
260:             IPEMCertChainLib.ECSha256Certificate memory issuer; 

/// @audit loop from line 259 to line 298
292:             bytes32 issuerPubKeyHash = keccak256(issuer.pubKey); 

/// @audit loop from line 420 to line 430
421:                 bool isPckCert = i == 0; // additional parsing for PCKCert 
/// @audit loop from line 420 to line 430
422:                 bool certDecodedSuccessfully;
```
[192](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/AutomataDcapV3Attestation.sol#L192), [215](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/AutomataDcapV3Attestation.sol#L215-L217), [222](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/AutomataDcapV3Attestation.sol#L222), [260](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/AutomataDcapV3Attestation.sol#L260), [292](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/AutomataDcapV3Attestation.sol#L292), [421](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/AutomataDcapV3Attestation.sol#L421-L422)

```solidity
📁 File: contracts/automata-attestation/lib/PEMCertChainLib.sol

/// @audit loop from line 54 to line 69
55:             string memory input; 

/// @audit loop from line 54 to line 69
61:             uint256 increment; 

/// @audit loop from line 286 to line 338
287:             uint256 internalPtr = der.firstChildOf(tbsPtr); 

/// @audit loop from line 286 to line 338
295:                 uint256 extnValueParentPtr = der.rootOfOctetStringAt(internalPtr); 
/// @audit loop from line 286 to line 338
296:                 uint256 extnValuePtr = der.firstChildOf(extnValueParentPtr);

/// @audit loop from line 286 to line 338
299:                 PCKTCBFlags memory flags; 

/// @audit loop from line 286 to line 338
/// @audit loop from line 301 to line 328
302:                     uint256 extnValueOidPtr = der.firstChildOf(extnValuePtr); 

/// @audit loop from line 286 to line 338
/// @audit loop from line 301 to line 328
312:                         uint256 pceidPtr = der.nextSiblingOf(extnValueOidPtr); 

/// @audit loop from line 286 to line 338
/// @audit loop from line 301 to line 328
318:                         uint256 fmspcPtr = der.nextSiblingOf(extnValueOidPtr); 

/// @audit loop from line 354 to line 372
355:             uint256 svnPtr = der.firstChildOf(svnParentPtr); // OID 
/// @audit loop from line 354 to line 372
356:             uint256 svnValuePtr = der.nextSiblingOf(svnPtr); // value
/// @audit loop from line 354 to line 372
357:             bytes memory svnValueBytes = der.bytesAt(svnValuePtr);
/// @audit loop from line 354 to line 372
358:             uint16 svnValue = svnValueBytes.length < 2

/// @audit loop from line 354 to line 372
366:                 uint256 cpusvn = uint256(svnValue); 
```
[55](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/PEMCertChainLib.sol#L55), [61](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/PEMCertChainLib.sol#L61), [287](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/PEMCertChainLib.sol#L287), [295](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/PEMCertChainLib.sol#L295-L296), [299](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/PEMCertChainLib.sol#L299), [302](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/PEMCertChainLib.sol#L302), [312](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/PEMCertChainLib.sol#L312), [318](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/PEMCertChainLib.sol#L318), [355](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/PEMCertChainLib.sol#L355-L358), [366](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/PEMCertChainLib.sol#L366)

```solidity
📁 File: contracts/automata-attestation/lib/QuoteV3Auth/V3Parser.sol

/// @audit loop from line 153 to line 162
154:             uint256 digits = uint256(uint8(bytes1(encoded[i]))); 
/// @audit loop from line 153 to line 162
155:             uint256 upperDigit = digits / 16;
/// @audit loop from line 153 to line 162
156:             uint256 lowerDigit = digits % 16;

/// @audit loop from line 153 to line 162
158:             uint256 acc = lowerDigit * (16 ** (2 * i)); 
```
[154](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/QuoteV3Auth/V3Parser.sol#L154-L156), [158](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/QuoteV3Auth/V3Parser.sol#L158)

```solidity
📁 File: contracts/automata-attestation/utils/BytesUtils.sol

/// @audit loop from line 80 to line 102
81:             uint256 a; 
/// @audit loop from line 80 to line 102
82:             uint256 b;

/// @audit loop from line 80 to line 102
89:                 uint256 mask; 

/// @audit loop from line 80 to line 102
95:                 uint256 diff = (a & mask) - (b & mask); 

/// @audit loop from line 333 to line 342
334:             bytes1 char = self[off + i]; 
```
[81](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/BytesUtils.sol#L81-L82), [89](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/BytesUtils.sol#L89), [95](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/BytesUtils.sol#L95), [334](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/BytesUtils.sol#L334)

```solidity
📁 File: contracts/bridge/Bridge.sol

/// @audit loop from line 90 to line 94
91:             bytes32 msgHash = _msgHashes[i]; 
```
[91](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/Bridge.sol#L91)

```solidity
📁 File: contracts/signal/SignalService.sol

/// @audit loop from line 104 to line 129
107:             bytes32 signalRoot = _verifyHopProof(chainId, app, signal, value, hop, signalService); 
/// @audit loop from line 104 to line 129
108:             bool isLastHop = i == hopProofs.length - 1;

/// @audit loop from line 104 to line 129
120:             bool isFullProof = hop.accountProof.length > 0; 

/// @audit loop from line 104 to line 129
124:             bytes32 kind = isFullProof ? LibSignals.STATE_ROOT : LibSignals.SIGNAL_ROOT; 
```
[107](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/signal/SignalService.sol#L107-L108), [120](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/signal/SignalService.sol#L120), [124](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/signal/SignalService.sol#L124)

```solidity
📁 File: contracts/thirdparty/optimism/trie/MerkleTrie.sol

/// @audit loop from line 85 to line 196
86:             TrieNode memory currentNode = proof[i]; 

/// @audit loop from line 85 to line 196
134:                     uint8 branchKey = uint8(key[currentKeyIndex]); 
/// @audit loop from line 85 to line 196
135:                     RLPReader.RLPItem memory nextNode = currentNode.decoded[branchKey];

/// @audit loop from line 85 to line 196
140:                 bytes memory path = _getNodePath(currentNode); 
/// @audit loop from line 85 to line 196
141:                 uint8 prefix = uint8(path[0]);
/// @audit loop from line 85 to line 196
142:                 uint8 offset = 2 - (prefix % 2);
/// @audit loop from line 85 to line 196
143:                 bytes memory pathRemainder = Bytes.slice(path, offset);
/// @audit loop from line 85 to line 196
144:                 bytes memory keyRemainder = Bytes.slice(key, currentKeyIndex);
/// @audit loop from line 85 to line 196
145:                 uint256 sharedNibbleLength = _getSharedNibbleLength(pathRemainder, keyRemainder);
```
[86](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/trie/MerkleTrie.sol#L86), [134](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/trie/MerkleTrie.sol#L134-L135), [140](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/trie/MerkleTrie.sol#L140-L145)

```solidity
📁 File: contracts/verifiers/SgxVerifier.sol

/// @audit loop from line 104 to line 112
105:             uint256 idx = _ids[i]; 
```
[105](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/verifiers/SgxVerifier.sol#L105)

</details>


---
### [GAS&#x2011;28] Do not calculate constants
Due to how constant variables are implemented (replacements at compile-time), an expression assigned to a constant variable is recomputed each time that the variable is used, which wastes some gas.

<details>
<summary><i>There are 2 instances of this issue:</i></summary>

```solidity
📁 File: contracts/L1/libs/LibProposing.sol

21:     uint256 public constant MAX_BYTES_PER_BLOB = 4096 * 32; 
```
[21](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProposing.sol#L21)

```solidity
📁 File: contracts/thirdparty/optimism/trie/MerkleTrie.sol

24:     uint256 internal constant BRANCH_NODE_LENGTH = TREE_RADIX + 1; 
```
[24](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/trie/MerkleTrie.sol#L24)

</details>


---
### [GAS&#x2011;29] `do`-`while` is cheaper than `for`-loops when the initial check can be skipped
Using `do-while` loops instead of `for` loops can be more gas-efficient.
Even if you add an `if` condition to account for the case where the loop doesn't execute at all, a `do-while` loop can still be cheaper in terms of gas.


Gas saved per Instance: ~255 *(Total: ~12,495)*
<details>
<summary><i>There are 49 instances of this issue:</i></summary>

```solidity
📁 File: contracts/L1/hooks/AssignmentHook.sol

172:         for (uint256 i; i < _tierFees.length; ++i) { 
```
[172](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/hooks/AssignmentHook.sol#L172)

```solidity
📁 File: contracts/L1/libs/LibDepositing.sol

86:             for (uint256 i; i < deposits_.length;) { 
```
[86](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibDepositing.sol#L86)

```solidity
📁 File: contracts/L1/libs/LibProposing.sol

244:             for (uint256 i; i < params.hookCalls.length; ++i) { 
```
[244](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProposing.sol#L244)

```solidity
📁 File: contracts/L1/provers/Guardians.sol

74:         for (uint256 i; i < guardians.length; ++i) { 

80:         for (uint256 i = 0; i < _newGuardians.length; ++i) { 

133:             for (uint256 i; i < guardiansLength; ++i) { 
```
[74](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/provers/Guardians.sol#L74), [80](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/provers/Guardians.sol#L80), [133](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/provers/Guardians.sol#L133)

```solidity
📁 File: contracts/L2/TaikoL2.sol

234:             for (uint256 i; i < 255 && _blockId >= i + 1; ++i) { 
```
[234](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/TaikoL2.sol#L234)

```solidity
📁 File: contracts/automata-attestation/AutomataDcapV3Attestation.sol

80:         for (uint256 i; i < serialNumBatch.length; ++i) { 

95:         for (uint256 i; i < serialNumBatch.length; ++i) { 

191:         for (uint256 i; i < enclaveId.tcbLevels.length; ++i) { 

214:         for (uint256 i; i < tcb.tcbLevels.length; ++i) { 

240:         for (uint256 i; i < CPUSVN_LENGTH; ++i) { 

259:         for (uint256 i; i < n; ++i) { 

420:             for (uint256 i; i < 3; ++i) { 
```
[80](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/AutomataDcapV3Attestation.sol#L80), [95](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/AutomataDcapV3Attestation.sol#L95), [191](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/AutomataDcapV3Attestation.sol#L191), [214](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/AutomataDcapV3Attestation.sol#L214), [240](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/AutomataDcapV3Attestation.sol#L240), [259](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/AutomataDcapV3Attestation.sol#L259), [420](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/AutomataDcapV3Attestation.sol#L420)

```solidity
📁 File: contracts/automata-attestation/lib/PEMCertChainLib.sol

54:         for (uint256 i; i < size; ++i) { 

244:         for (uint256 i; i < split.length; ++i) { 

354:         for (uint256 i; i < SGX_TCB_CPUSVN_SIZE + 1; ++i) { 
```
[54](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/PEMCertChainLib.sol#L54), [244](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/PEMCertChainLib.sol#L244), [354](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/PEMCertChainLib.sol#L354)

```solidity
📁 File: contracts/automata-attestation/lib/QuoteV3Auth/V3Parser.sol

153:         for (uint256 i; i < encoded.length; ++i) { 

281:         for (uint256 i; i < 3; ++i) { 
```
[153](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/QuoteV3Auth/V3Parser.sol#L153), [281](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/QuoteV3Auth/V3Parser.sol#L281)

```solidity
📁 File: contracts/automata-attestation/utils/BytesUtils.sol

80:         for (uint256 idx = 0; idx < shortest; idx += 32) { 

333:         for (uint256 i; i < len; ++i) { 
```
[80](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/BytesUtils.sol#L80), [333](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/BytesUtils.sol#L333)

```solidity
📁 File: contracts/automata-attestation/utils/RsaVerify.sol

140:         for (uint256 i = 2; i < 2 + paddingLen; ++i) { 

152:             for (uint256 i; i < digestAlgoWithParamLen; ++i) { 

158:             for (uint256 i; i < digestAlgoWithParamLen; ++i) { 

174:         for (uint256 i; i < _sha256.length; ++i) { 

273:         for (uint256 i = 2; i < 2 + paddingLen; ++i) { 

283:         for (uint256 i; i < sha1Prefix.length; ++i) { 

290:         for (uint256 i; i < _sha1.length; ++i) { 
```
[140](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/RsaVerify.sol#L140), [152](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/RsaVerify.sol#L152), [158](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/RsaVerify.sol#L158), [174](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/RsaVerify.sol#L174), [273](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/RsaVerify.sol#L273), [283](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/RsaVerify.sol#L283), [290](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/RsaVerify.sol#L290)

```solidity
📁 File: contracts/automata-attestation/utils/X509DateUtils.sol

48:         for (uint16 i = 1970; i < year; ++i) { 

59:         for (uint8 i = 1; i < month; ++i) { 
```
[48](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/X509DateUtils.sol#L48), [59](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/X509DateUtils.sol#L59)

```solidity
📁 File: contracts/bridge/Bridge.sol

90:         for (uint256 i; i < _msgHashes.length; ++i) { 
```
[90](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/Bridge.sol#L90)

```solidity
📁 File: contracts/signal/SignalService.sol

104:         for (uint256 i; i < hopProofs.length; ++i) { 
```
[104](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/signal/SignalService.sol#L104)

```solidity
📁 File: contracts/team/airdrop/ERC721Airdrop.sol

59:         for (uint256 i; i < tokenIds.length; ++i) { 
```
[59](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/airdrop/ERC721Airdrop.sol#L59)

```solidity
📁 File: contracts/thirdparty/optimism/rlp/RLPWriter.sol

46:             for (i = 1; i <= lenLen; i++) { 

59:         for (; i < 32; i++) { 

66:         for (uint256 j = 0; j < out_.length; j++) { 
```
[46](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/rlp/RLPWriter.sol#L46), [59](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/rlp/RLPWriter.sol#L59), [66](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/rlp/RLPWriter.sol#L66)

```solidity
📁 File: contracts/thirdparty/optimism/trie/MerkleTrie.sol

85:         for (uint256 i = 0; i < proof.length; i++) { 

208:         for (uint256 i = 0; i < length;) { 

244:         for (; shared_ < max && _a[shared_] == _b[shared_];) { 
```
[85](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/trie/MerkleTrie.sol#L85), [208](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/trie/MerkleTrie.sol#L208), [244](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/trie/MerkleTrie.sol#L244)

```solidity
📁 File: contracts/tokenvault/ERC1155Vault.sol

47:         for (uint256 i; i < _op.amounts.length; ++i) { 

251:                 for (uint256 i; i < _op.tokenIds.length; ++i) { 

269:                 for (uint256 i; i < _op.tokenIds.length; ++i) { 
```
[47](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC1155Vault.sol#L47), [251](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC1155Vault.sol#L251), [269](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC1155Vault.sol#L269)

```solidity
📁 File: contracts/tokenvault/ERC721Vault.sol

34:         for (uint256 i; i < _op.tokenIds.length; ++i) { 

170:             for (uint256 i; i < _tokenIds.length; ++i) { 

175:             for (uint256 i; i < _tokenIds.length; ++i) { 

197:                 for (uint256 i; i < _op.tokenIds.length; ++i) { 

210:                 for (uint256 i; i < _op.tokenIds.length; ++i) { 
```
[34](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC721Vault.sol#L34), [170](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC721Vault.sol#L170), [175](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC721Vault.sol#L175), [197](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC721Vault.sol#L197), [210](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC721Vault.sol#L210)

```solidity
📁 File: contracts/verifiers/SgxVerifier.sol

104:         for (uint256 i; i < _ids.length; ++i) { 

210:         for (uint256 i; i < _instances.length; ++i) { 
```
[104](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/verifiers/SgxVerifier.sol#L104), [210](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/verifiers/SgxVerifier.sol#L210)

</details>


---
### [GAS&#x2011;30] Don't transfer with zero amount to save gas
In Solidity, unnecessary operations can waste gas. For example, a transfer function without a zero amount check uses gas even if called with a zero amount, since the contract state remains unchanged. Implementing a zero amount check avoids these unnecessary function calls, saving gas and improving efficiency.


Gas saved per Instance: ~20 *(Total: ~220)*
<details>
<summary><i>There are 11 instances of this issue:</i></summary>

```solidity
📁 File: contracts/L1/TaikoToken.sol

/// @audit check for zero amount on the '_amount' variable
62:         return super.transfer(_to, _amount); 

/// @audit check for zero amount on the '_amount' variable
80:         return super.transferFrom(_from, _to, _amount); 
```
[62](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/TaikoToken.sol#L62), [80](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/TaikoToken.sol#L80)

```solidity
📁 File: contracts/L1/hooks/AssignmentHook.sol

/// @audit check for zero amount on the 'proverFee' variable
114:             IERC20(assignment.feeToken).safeTransferFrom( 
115:                 _meta.coinbase, _blk.assignedProver, proverFee
116:             );
```
[114](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/hooks/AssignmentHook.sol#L114-L116)

```solidity
📁 File: contracts/L1/libs/LibVerifying.sol

/// @audit check for zero amount on the 'bondToReturn' variable
189:                 tko.transfer(ts.prover, bondToReturn); 
```
[189](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibVerifying.sol#L189)

```solidity
📁 File: contracts/team/TimelockTokenPool.sol

/// @audit check for zero amount on the 'amountToWithdraw' variable
219:         IERC20(taikoToken).transferFrom(sharedVault, _to, amountToWithdraw); 
/// @audit check for zero amount on the 'costToWithdraw' variable
220:         IERC20(costToken).safeTransferFrom(_recipient, sharedVault, costToWithdraw);
```
[219](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/TimelockTokenPool.sol#L219-L220)

```solidity
📁 File: contracts/team/airdrop/ERC20Airdrop.sol

/// @audit check for zero amount on the 'amount' variable
63:         IERC20(token).transferFrom(vault, user, amount); 
```
[63](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/airdrop/ERC20Airdrop.sol#L63)

```solidity
📁 File: contracts/team/airdrop/ERC20Airdrop2.sol

/// @audit check for zero amount on the 'amount' variable
91:         IERC20(token).transferFrom(vault, user, amount); 
```
[91](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/airdrop/ERC20Airdrop2.sol#L91)

```solidity
📁 File: contracts/tokenvault/ERC20Vault.sol

/// @audit check for zero amount on the '_amount' variable
330:             IERC20(token_).safeTransfer(_to, _amount); 

/// @audit check for zero amount on the '_amount' variable
379:             t.safeTransferFrom({ from: msg.sender, to: address(this), value: _amount }); 
```
[330](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC20Vault.sol#L330), [379](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC20Vault.sol#L379)

```solidity
📁 File: contracts/tokenvault/adapters/USDCAdapter.sol

/// @audit check for zero amount on the '_amount' variable
48:         usdc.transferFrom(_from, address(this), _amount); 
```
[48](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/adapters/USDCAdapter.sol#L48)

</details>


---
### [GAS&#x2011;31] Duplicated `require()/revert()` checks should be refactored to a modifier or function
Saves deployment costs

<details>
<summary><i>There are 792 instances of this issue:</i></summary>

```solidity
📁 File: contracts/automata-attestation/lib/QuoteV3Auth/V3Parser.sol

77:         require( 

82:         require( 

87:         require( 

91:         require( 

94:         require( 

100:         require( 
```
[77](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/QuoteV3Auth/V3Parser.sol#L77), [82](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/QuoteV3Auth/V3Parser.sol#L82), [87](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/QuoteV3Auth/V3Parser.sol#L87), [91](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/QuoteV3Auth/V3Parser.sol#L91), [94](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/QuoteV3Auth/V3Parser.sol#L94), [100](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/QuoteV3Auth/V3Parser.sol#L100)

```solidity
📁 File: contracts/automata-attestation/utils/Asn1Decode.sol

142:         require(der[ptr.ixs()] == 0x02, "Not type INTEGER"); 
143:         require(der[ptr.ixf()] & 0x80 == 0, "Not positive");

155:         require(der[ptr.ixs()] == 0x02, "Not type INTEGER"); 
156:         require(der[ptr.ixf()] & 0x80 == 0, "Not positive");
```
[142](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/Asn1Decode.sol#L142-L143), [155](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/Asn1Decode.sol#L155-L156)

```solidity
📁 File: contracts/automata-attestation/utils/SigVerifyLib.sol

50:             revert("Unsupported algorithm"); 

75:             revert("Unsupported algorithm"); 
```
[50](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/SigVerifyLib.sol#L50), [75](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/SigVerifyLib.sol#L75)

```solidity
📁 File: contracts/thirdparty/optimism/rlp/RLPReader.sol

37:         require( 

56:         require( 

61:         require( 

112:         require( 

117:         require( 

152:         require( 

172:             require( 

182:             require( 

192:             require( 

202:             require( 

212:             require( 

217:             require( 

228:             require( 

238:             require( 

248:             require( 

258:             require( 

263:             require( 
```
[37](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/rlp/RLPReader.sol#L37), [56](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/rlp/RLPReader.sol#L56), [61](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/rlp/RLPReader.sol#L61), [112](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/rlp/RLPReader.sol#L112), [117](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/rlp/RLPReader.sol#L117), [152](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/rlp/RLPReader.sol#L152), [172](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/rlp/RLPReader.sol#L172), [182](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/rlp/RLPReader.sol#L182), [192](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/rlp/RLPReader.sol#L192), [202](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/rlp/RLPReader.sol#L202), [212](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/rlp/RLPReader.sol#L212), [217](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/rlp/RLPReader.sol#L217), [228](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/rlp/RLPReader.sol#L228), [238](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/rlp/RLPReader.sol#L238), [248](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/rlp/RLPReader.sol#L248), [258](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/rlp/RLPReader.sol#L258), [263](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/rlp/RLPReader.sol#L263)

```solidity
📁 File: contracts/thirdparty/optimism/trie/MerkleTrie.sol

93:                 require( 

99:                 require( 

105:                 require( 

119:                     require( 

125:                     require( 

150:                 require( 

162:                     require( 

172:                     require( 

178:                     require( 
```
[93](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/trie/MerkleTrie.sol#L93), [99](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/trie/MerkleTrie.sol#L99), [105](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/trie/MerkleTrie.sol#L105), [119](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/trie/MerkleTrie.sol#L119), [125](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/trie/MerkleTrie.sol#L125), [150](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/trie/MerkleTrie.sol#L150), [162](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/trie/MerkleTrie.sol#L162), [172](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/trie/MerkleTrie.sol#L172), [178](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/trie/MerkleTrie.sol#L178)

</details>


---
### [GAS&#x2011;32] Emitting constants wastes gas
Every event parameter costs `Glogdata` (**8 gas**) per byte. You can avoid this extra cost, in cases where you're emitting a constant, by creating a second version of the event, which doesn't have the parameter (and have users look to the contract's variables for its value instead), and using the new event in the cases shown below.


Gas saved per Instance: ~8 *(Total: ~32)*
<details>
<summary><i>There are 4 instances of this issue:</i></summary>

```solidity
📁 File: contracts/L1/libs/LibProving.sol

/// @audit 0
230:                 emit TransitionProved({ 
231:                     blockId: blk.blockId,
232:                     tran: _tran,
233:                     prover: msg.sender,
234:                     validityBond: 0,
235:                     tier: _proof.tier
236:                 });
```
[230](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProving.sol#L230-L236)

```solidity
📁 File: contracts/L1/libs/LibVerifying.sol

/// @audit 0, 0, 0, 0
73:         emit BlockVerified({ 
74:             blockId: 0,
75:             assignedProver: address(0),
76:             prover: address(0),
77:             blockHash: _genesisBlockHash,
78:             stateRoot: 0,
79:             tier: 0,
80:             contestations: 0
81:         });
```
[73](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibVerifying.sol#L73-L81)

```solidity
📁 File: contracts/bridge/Bridge.sol

/// @audit true
210:             emit MessageReceived(msgHash, _message, true); 

/// @audit false
303:             emit MessageReceived(msgHash, _message, false); 
```
[210](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/Bridge.sol#L210), [303](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/Bridge.sol#L303)

</details>


---
### [GAS&#x2011;33] Empty blocks should be removed or emit something
Some functions don't have a body: consider commenting why, or add some logic. Otherwise, refactor the code and remove these functions.

<details>
<summary><i>There are 5 instances of this issue:</i></summary>

```solidity
📁 File: contracts/L1/TaikoL1.sol

220:     function _authorizePause(address) 
221:         internal
222:         view
223:         virtual
224:         override
225:         onlyFromOwnerOrNamed("chain_pauser")
226:     { }
```
[220](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/TaikoL1.sol#L220-L226)

```solidity
📁 File: contracts/bridge/Bridge.sol

70:     receive() external payable { } 

461:     function _authorizePause(address) 
462:         internal
463:         view
464:         virtual
465:         override
466:         onlyFromOwnerOrNamed("bridge_pauser")
467:     { }
```
[70](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/Bridge.sol#L70), [461](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/Bridge.sol#L461-L467)

```solidity
📁 File: contracts/common/EssentialContract.sol

114:     function _authorizeUpgrade(address) internal virtual override onlyOwner { } 

116:     function _authorizePause(address) internal virtual onlyOwner { } 
```
[114](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/common/EssentialContract.sol#L114), [116](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/common/EssentialContract.sol#L116)

</details>


---
### [GAS&#x2011;34] Function names can be optimized
Function that are `public`/`external` and `public` state variable names can be optimized to save gas.

Method IDs that have two leading zero bytes can save **128 gas** each during deployment, and renaming functions to have lower method IDs will save **22 gas** per call, per sorted position shifted. [Reference](https://blog.emn178.cc/en/post/solidity-gas-optimization-function-name/)


Gas saved per Instance: ~128 *(Total: ~4,864)*
<details>
<summary><i>There are 38 instances of this issue:</i></summary>

```solidity
📁 File: contracts/L1/ITaikoL1.sol

/// @audit optimized order: proposeBlock(), getConfig(), verifyBlocks(), proveBlock()
8: interface ITaikoL1 { 
```
[8](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/ITaikoL1.sol#L8)

```solidity
📁 File: contracts/L1/TaikoL1.sol

/// @audit optimized order: pauseProving(), getTransition(), proposeBlock(), getStateVariables(), canDepositEthToL2(), getConfig(), isBlobReusable(), verifyBlocks(), getBlock(), unpause(), init(), proveBlock(), depositEtherToL2(), _authorizePause()
22: contract TaikoL1 is EssentialContract, ITaikoL1, TaikoEvents, TaikoErrors { 
```
[22](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/TaikoL1.sol#L22)

```solidity
📁 File: contracts/L1/TaikoToken.sol

/// @audit optimized order: init(), transfer(), burn(), snapshot(), transferFrom(), _beforeTokenTransfer(), _afterTokenTransfer(), _mint(), _burn()
15: contract TaikoToken is EssentialContract, ERC20SnapshotUpgradeable, ERC20VotesUpgradeable { 
```
[15](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/TaikoToken.sol#L15)

```solidity
📁 File: contracts/L1/gov/TaikoGovernor.sol

/// @audit optimized order: propose(), proposalThreshold(), propose(), state(), votingDelay(), init(), votingPeriod(), supportsInterface(), _execute(), _cancel(), _executor()
16: contract TaikoGovernor is 
```
[16](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/gov/TaikoGovernor.sol#L16)

```solidity
📁 File: contracts/L1/gov/TaikoTimelockController.sol

/// @audit optimized order: getMinDelay(), init()
9: contract TaikoTimelockController is EssentialContract, TimelockControllerUpgradeable { 
```
[9](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/gov/TaikoTimelockController.sol#L9)

```solidity
📁 File: contracts/L1/hooks/AssignmentHook.sol

/// @audit optimized order: init(), hashAssignment(), onBlockProposed(), _getProverFee()
14: contract AssignmentHook is EssentialContract, IHook { 
```
[14](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/hooks/AssignmentHook.sol#L14)

```solidity
📁 File: contracts/L1/libs/LibUtils.sol

/// @audit optimized order: getBlock(), getTransition(), getTransitionId()
9: library LibUtils { 
```
[9](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibUtils.sol#L9)

```solidity
📁 File: contracts/L1/provers/Guardians.sol

/// @audit optimized order: setGuardians(), numGuardians(), isApproved(), approve(), deleteApproval(), isApproved()
9: abstract contract Guardians is EssentialContract { 
```
[9](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/provers/Guardians.sol#L9)

```solidity
📁 File: contracts/L1/tiers/DevnetTierProvider.sol

/// @audit optimized order: getTierIds(), getMinTier(), getTier(), init()
10: contract DevnetTierProvider is EssentialContract, ITierProvider { 
```
[10](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/tiers/DevnetTierProvider.sol#L10)

```solidity
📁 File: contracts/L1/tiers/ITierProvider.sol

/// @audit optimized order: getTierIds(), getMinTier(), getTier()
7: interface ITierProvider { 
```
[7](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/tiers/ITierProvider.sol#L7)

```solidity
📁 File: contracts/L1/tiers/MainnetTierProvider.sol

/// @audit optimized order: getTierIds(), getMinTier(), getTier(), init()
10: contract MainnetTierProvider is EssentialContract, ITierProvider { 
```
[10](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/tiers/MainnetTierProvider.sol#L10)

```solidity
📁 File: contracts/L1/tiers/TestnetTierProvider.sol

/// @audit optimized order: getTierIds(), getMinTier(), getTier(), init()
10: contract TestnetTierProvider is EssentialContract, ITierProvider { 
```
[10](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/tiers/TestnetTierProvider.sol#L10)

```solidity
📁 File: contracts/L2/TaikoL2.sol

/// @audit optimized order: withdraw(), anchor(), getConfig(), getBasefee(), init(), skipFeeCheck(), getBlockHash(), _calcPublicInputHash(), _calc1559BaseFee()
21: contract TaikoL2 is CrossChainOwned { 
```
[21](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/TaikoL2.sol#L21)

```solidity
📁 File: contracts/L2/TaikoL2EIP1559Configurable.sol

/// @audit optimized order: getConfig(), setConfigAndExcess()
9: contract TaikoL2EIP1559Configurable is TaikoL2 { 
```
[9](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/TaikoL2EIP1559Configurable.sol#L9)

```solidity
📁 File: contracts/automata-attestation/AutomataDcapV3Attestation.sol

/// @audit optimized order: setMrSigner(), toggleLocalReportCheck(), verifyAttestation(), addRevokedCertSerialNum(), configureTcbInfoJson(), setMrEnclave(), removeRevokedCertSerialNum(), configureQeIdentityJson(), _attestationTcbIsValid(), _verify(), _verifyQEReportWithIdentity(), _checkTcbLevels(), _isCpuSvnHigherOrGreater(), _verifyCertChain(), _enclaveReportSigVerification(), verifyParsedQuote(), _verifyParsedQuote()
22: contract AutomataDcapV3Attestation is IAttestation { 
```
[22](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/AutomataDcapV3Attestation.sol#L22)

```solidity
📁 File: contracts/automata-attestation/interfaces/ISigVerifyLib.sol

/// @audit optimized order: verifyES256Signature(), verifyAttStmtSignature(), verifyRS256Signature(), verifyCertificateSignature(), verifyRS1Signature()
6: interface ISigVerifyLib { 
```
[6](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/interfaces/ISigVerifyLib.sol#L6)

```solidity
📁 File: contracts/automata-attestation/lib/PEMCertChainLib.sol

/// @audit optimized order: decodeCert(), splitCertificateChain(), _removeHeadersAndFooters(), _trimBytes(), _findPckTcbInfo(), _findTcb()
12: contract PEMCertChainLib is IPEMCertChainLib { 
```
[12](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/PEMCertChainLib.sol#L12)

```solidity
📁 File: contracts/automata-attestation/lib/interfaces/IPEMCertChainLib.sol

/// @audit optimized order: decodeCert(), splitCertificateChain()
6: interface IPEMCertChainLib { 
```
[6](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/interfaces/IPEMCertChainLib.sol#L6)

```solidity
📁 File: contracts/automata-attestation/utils/SigVerifyLib.sol

/// @audit optimized order: verifyES256Signature(), verifyAttStmtSignature(), verifyRS256Signature(), verifyCertificateSignature(), verifyRS1Signature()
15: contract SigVerifyLib is ISigVerifyLib { 
```
[15](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/SigVerifyLib.sol#L15)

```solidity
📁 File: contracts/bridge/Bridge.sol

/// @audit optimized order: init(), recallMessage(), signalForFailedMessage(), context(), retryMessage(), isMessageSent(), isDestChainEnabled(), getInvocationDelays(), sendMessage(), proveMessageReceived(), banAddress(), suspendMessages(), proveMessageFailed(), hashMessage(), processMessage(), _authorizePause(), _invokeMessageCall(), _updateMessageStatus(), _resetContext(), _storeContext(), _loadContext(), _proveSignalReceived()
16: contract Bridge is EssentialContract, IBridge { 
```
[16](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/Bridge.sol#L16)

```solidity
📁 File: contracts/bridge/IBridge.sol

/// @audit optimized order: recallMessage(), context(), retryMessage(), isMessageSent(), sendMessage(), hashMessage(), processMessage()
8: interface IBridge { 
```
[8](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/IBridge.sol#L8)

```solidity
📁 File: contracts/common/AddressManager.sol

/// @audit optimized order: setAddress(), getAddress(), init(), _authorizePause()
10: contract AddressManager is EssentialContract, IAddressManager { 
```
[10](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/common/AddressManager.sol#L10)

```solidity
📁 File: contracts/common/EssentialContract.sol

/// @audit optimized order: pause(), paused(), unpause(), __Essential_init(), __Essential_init(), _authorizeUpgrade(), _authorizePause(), _storeReentryLock(), _loadReentryLock(), _inNonReentrant()
10: abstract contract EssentialContract is UUPSUpgradeable, Ownable2StepUpgradeable, AddressResolver { 
```
[10](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/common/EssentialContract.sol#L10)

```solidity
📁 File: contracts/signal/ISignalService.sol

/// @audit optimized order: getSyncedChainData(), signalForChainData(), proveSignalReceived(), sendSignal(), syncChainData(), isChainDataSynced(), isSignalSent()
12: interface ISignalService { 
```
[12](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/signal/ISignalService.sol#L12)

```solidity
📁 File: contracts/signal/SignalService.sol

/// @audit optimized order: init(), getSyncedChainData(), signalForChainData(), getSignalSlot(), proveSignalReceived(), sendSignal(), syncChainData(), isChainDataSynced(), isSignalSent(), authorize(), _verifyHopProof(), _authorizePause(), _syncChainData(), _sendSignal(), _cacheChainData(), _loadSignalValue()
14: contract SignalService is EssentialContract, ISignalService { 
```
[14](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/signal/SignalService.sol#L14)

```solidity
📁 File: contracts/team/TimelockTokenPool.sol

/// @audit optimized order: getMyGrantSummary(), void(), getMyGrant(), withdraw(), grant(), withdraw(), init(), _withdraw(), _voidGrant(), _getAmountOwned(), _getAmountUnlocked(), _calcAmount(), _validateGrant(), _validateCliff()
25: contract TimelockTokenPool is EssentialContract { 
```
[25](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/TimelockTokenPool.sol#L25)

```solidity
📁 File: contracts/team/airdrop/ERC20Airdrop2.sol

/// @audit optimized order: getBalance(), init(), withdraw(), claim()
12: contract ERC20Airdrop2 is MerkleClaimable { 
```
[12](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/airdrop/ERC20Airdrop2.sol#L12)

```solidity
📁 File: contracts/tokenvault/BaseVault.sol

/// @audit optimized order: init(), name(), supportsInterface(), checkProcessMessageContext(), checkRecallMessageContext()
12: abstract contract BaseVault is 
```
[12](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BaseVault.sol#L12)

```solidity
📁 File: contracts/tokenvault/BridgedERC1155.sol

/// @audit optimized order: burn(), init(), mintBatch(), symbol(), mint(), name(), _beforeTokenTransfer()
14: contract BridgedERC1155 is EssentialContract, IERC1155MetadataURIUpgradeable, ERC1155Upgradeable { 
```
[14](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC1155.sol#L14)

```solidity
📁 File: contracts/tokenvault/BridgedERC20.sol

/// @audit optimized order: init(), snapshot(), symbol(), decimals(), setSnapshoter(), canonical(), name(), _mintToken(), _burnToken(), _beforeTokenTransfer(), _afterTokenTransfer(), _mint(), _burn()
15: contract BridgedERC20 is 
```
[15](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC20.sol#L15)

```solidity
📁 File: contracts/tokenvault/BridgedERC20Base.sol

/// @audit optimized order: changeMigrationStatus(), burn(), owner(), mint(), _mintToken(), _burnToken(), _isMigratingOut()
9: abstract contract BridgedERC20Base is EssentialContract, IBridgedERC20 { 
```
[9](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC20Base.sol#L9)

```solidity
📁 File: contracts/tokenvault/BridgedERC721.sol

/// @audit optimized order: init(), tokenURI(), burn(), symbol(), source(), mint(), name(), _beforeTokenTransfer()
12: contract BridgedERC721 is EssentialContract, ERC721Upgradeable { 
```
[12](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC721.sol#L12)

```solidity
📁 File: contracts/tokenvault/ERC1155Vault.sol

/// @audit optimized order: symbol(), name()
16: interface IERC1155NameAndSymbol { 

/// @audit optimized order: onERC1155Received(), onERC1155BatchReceived(), onMessageInvocation(), onMessageRecalled(), sendToken(), name(), supportsInterface(), _transferTokens(), _handleMessage(), _getOrDeployBridgedToken(), _deployBridgedToken()
29: contract ERC1155Vault is BaseNFTVault, ERC1155ReceiverUpgradeable { 
```
[16](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC1155Vault.sol#L16), [29](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC1155Vault.sol#L29)

```solidity
📁 File: contracts/tokenvault/ERC20Vault.sol

/// @audit optimized order: sendToken(), onMessageInvocation(), onMessageRecalled(), changeBridgedToken(), name(), _transferTokens(), _handleMessage(), _getOrDeployBridgedToken(), _deployBridgedToken()
18: contract ERC20Vault is BaseVault { 
```
[18](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC20Vault.sol#L18)

```solidity
📁 File: contracts/tokenvault/ERC721Vault.sol

/// @audit optimized order: onMessageInvocation(), onMessageRecalled(), onERC721Received(), sendToken(), name(), _transferTokens(), _handleMessage(), _getOrDeployBridgedToken(), _deployBridgedToken()
16: contract ERC721Vault is BaseNFTVault, IERC721Receiver { 
```
[16](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC721Vault.sol#L16)

```solidity
📁 File: contracts/tokenvault/IBridgedERC20.sol

/// @audit optimized order: changeMigrationStatus(), burn(), owner(), mint()
10: interface IBridgedERC20 { 
```
[10](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/IBridgedERC20.sol#L10)

```solidity
📁 File: contracts/verifiers/SgxVerifier.sol

/// @audit optimized order: init(), registerInstance(), deleteInstances(), verifyProof(), addInstances(), getSignedHash(), _addInstances(), _replaceInstance(), _isInstanceValid()
19: contract SgxVerifier is EssentialContract, IVerifier { 
```
[19](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/verifiers/SgxVerifier.sol#L19)

</details>


---
### [GAS&#x2011;35] Functions guaranteed to revert when called by normal users can be marked `payable`
If a function modifier such as `onlyOwner` is used, the function will revert if a normal user tries to pay the function. Marking the function as `payable` will lower the gas cost for legitimate callers because the compiler will not include checks for whether a payment was provided.


Gas saved per Instance: ~21 *(Total: ~861)*
<details>
<summary><i>There are 41 instances of this issue:</i></summary>

```solidity
📁 File: contracts/L1/TaikoL1.sol

220:     function _authorizePause(address) 
221:         internal
222:         view
223:         virtual
224:         override
225:         onlyFromOwnerOrNamed("chain_pauser")
226:     { }
```
[220](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/TaikoL1.sol#L220-L226)

```solidity
📁 File: contracts/L1/TaikoToken.sol

47:     function burn(address _from, uint256 _amount) public onlyOwner { 

52:     function snapshot() public onlyFromOwnerOrNamed("snapshooter") { 
```
[47](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/TaikoToken.sol#L47), [52](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/TaikoToken.sol#L52)

```solidity
📁 File: contracts/L1/provers/Guardians.sol

53:     function setGuardians( 
54:         address[] memory _newGuardians,
55:         uint8 _minGuardians
56:     )
57:         external
58:         onlyOwner
59:         nonReentrant
60:     {
```
[53](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/provers/Guardians.sol#L53-L60)

```solidity
📁 File: contracts/L2/CrossChainOwned.sol

60:     function __CrossChainOwned_init( 
61:         address _owner,
62:         address _addressManager,
63:         uint64 _ownerChainId
64:     )
65:         internal
66:         virtual
67:         onlyInitializing
68:     {
```
[60](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/CrossChainOwned.sol#L60-L68)

```solidity
📁 File: contracts/L2/TaikoL2.sol

163:     function withdraw( 
164:         address _token,
165:         address _to
166:     )
167:         external
168:         onlyFromOwnerOrNamed("withdrawer")
169:         nonReentrant
170:         whenNotPaused
171:     {
```
[163](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/TaikoL2.sol#L163-L171)

```solidity
📁 File: contracts/L2/TaikoL2EIP1559Configurable.sol

25:     function setConfigAndExcess( 
26:         Config memory _newConfig,
27:         uint64 _newGasExcess
28:     )
29:         external
30:         virtual
31:         onlyOwner
32:     {
```
[25](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/TaikoL2EIP1559Configurable.sol#L25-L32)

```solidity
📁 File: contracts/automata-attestation/AutomataDcapV3Attestation.sol

65:     function setMrSigner(bytes32 _mrSigner, bool _trusted) external onlyOwner { 

69:     function setMrEnclave(bytes32 _mrEnclave, bool _trusted) external onlyOwner { 

73:     function addRevokedCertSerialNum( 
74:         uint256 index,
75:         bytes[] calldata serialNumBatch
76:     )
77:         external
78:         onlyOwner
79:     {

88:     function removeRevokedCertSerialNum( 
89:         uint256 index,
90:         bytes[] calldata serialNumBatch
91:     )
92:         external
93:         onlyOwner
94:     {

103:     function configureTcbInfoJson( 
104:         string calldata fmspc,
105:         TCBInfoStruct.TCBInfo calldata tcbInfoInput
106:     )
107:         public
108:         onlyOwner
109:     {

114:     function configureQeIdentityJson(EnclaveIdStruct.EnclaveId calldata qeIdentityInput) 
115:         external
116:         onlyOwner
117:     {

122:     function toggleLocalReportCheck() external onlyOwner { 
```
[65](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/AutomataDcapV3Attestation.sol#L65), [69](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/AutomataDcapV3Attestation.sol#L69), [73](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/AutomataDcapV3Attestation.sol#L73-L79), [88](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/AutomataDcapV3Attestation.sol#L88-L94), [103](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/AutomataDcapV3Attestation.sol#L103-L109), [114](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/AutomataDcapV3Attestation.sol#L114-L117), [122](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/AutomataDcapV3Attestation.sol#L122)

```solidity
📁 File: contracts/bridge/Bridge.sol

82:     function suspendMessages( 
83:         bytes32[] calldata _msgHashes,
84:         bool _suspend
85:     )
86:         external
87:         onlyFromOwnerOrNamed("bridge_watchdog")
88:     {

101:     function banAddress( 
102:         address _addr,
103:         bool _ban
104:     )
105:         external
106:         onlyFromOwnerOrNamed("bridge_watchdog")
107:         nonReentrant
108:     {

461:     function _authorizePause(address) 
462:         internal
463:         view
464:         virtual
465:         override
466:         onlyFromOwnerOrNamed("bridge_pauser")
467:     { }
```
[82](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/Bridge.sol#L82-L88), [101](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/Bridge.sol#L101-L108), [461](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/Bridge.sol#L461-L467)

```solidity
📁 File: contracts/common/AddressManager.sol

38:     function setAddress( 
39:         uint64 _chainId,
40:         bytes32 _name,
41:         address _newAddress
42:     )
43:         external
44:         virtual
45:         onlyOwner
46:     {
```
[38](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/common/AddressManager.sol#L38-L46)

```solidity
📁 File: contracts/common/AddressResolver.sol

58:     function __AddressResolver_init(address _addressManager) internal virtual onlyInitializing { 
```
[58](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/common/AddressResolver.sol#L58)

```solidity
📁 File: contracts/common/EssentialContract.sol

95:     function __Essential_init( 
96:         address _owner,
97:         address _addressManager
98:     )
99:         internal
100:         virtual
101:         onlyInitializing
102:     {

114:     function _authorizeUpgrade(address) internal virtual override onlyOwner { } 

116:     function _authorizePause(address) internal virtual onlyOwner { } 
```
[95](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/common/EssentialContract.sol#L95-L102), [114](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/common/EssentialContract.sol#L114), [116](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/common/EssentialContract.sol#L116)

```solidity
📁 File: contracts/signal/SignalService.sol

56:     function authorize(address _addr, bool _authorize) external onlyOwner { 
```
[56](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/signal/SignalService.sol#L56)

```solidity
📁 File: contracts/team/TimelockTokenPool.sol

135:     function grant(address _recipient, Grant memory _grant) external onlyOwner { 

150:     function void(address _recipient) external onlyOwner { 
```
[135](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/TimelockTokenPool.sol#L135), [150](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/TimelockTokenPool.sol#L150)

```solidity
📁 File: contracts/team/airdrop/MerkleClaimable.sol

45:     function setConfig( 
46:         uint64 _claimStart,
47:         uint64 _claimEnd,
48:         bytes32 _merkleRoot
49:     )
50:         external
51:         onlyOwner
52:     {

56:     function __MerkleClaimable_init( 
57:         uint64 _claimStart,
58:         uint64 _claimEnd,
59:         bytes32 _merkleRoot
60:     )
61:         internal
62:         onlyInitializing
63:     {
```
[45](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/airdrop/MerkleClaimable.sol#L45-L52), [56](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/airdrop/MerkleClaimable.sol#L56-L63)

```solidity
📁 File: contracts/tokenvault/BaseVault.sol

47:     function checkProcessMessageContext() 
48:         internal
49:         view
50:         onlyFromBridge
51:         returns (IBridge.Context memory ctx_)
52:     {

58:     function checkRecallMessageContext() 
59:         internal
60:         view
61:         onlyFromBridge
62:         returns (IBridge.Context memory ctx_)
63:     {
```
[47](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BaseVault.sol#L47-L52), [58](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BaseVault.sol#L58-L63)

```solidity
📁 File: contracts/tokenvault/BridgedERC1155.sol

66:     function mint( 
67:         address _to,
68:         uint256 _tokenId,
69:         uint256 _amount
70:     )
71:         public
72:         nonReentrant
73:         whenNotPaused
74:         onlyFromNamed("erc1155_vault")
75:     {

83:     function mintBatch( 
84:         address _to,
85:         uint256[] memory _tokenIds,
86:         uint256[] memory _amounts
87:     )
88:         public
89:         nonReentrant
90:         whenNotPaused
91:         onlyFromNamed("erc1155_vault")
92:     {

100:     function burn( 
101:         address _account,
102:         uint256 _tokenId,
103:         uint256 _amount
104:     )
105:         public
106:         nonReentrant
107:         whenNotPaused
108:         onlyFromNamed("erc1155_vault")
109:     {
```
[66](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC1155.sol#L66-L75), [83](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC1155.sol#L83-L92), [100](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC1155.sol#L100-L109)

```solidity
📁 File: contracts/tokenvault/BridgedERC20.sol

80:     function setSnapshoter(address _snapshooter) external onlyOwner { 

85:     function snapshot() external onlyOwnerOrSnapshooter { 
```
[80](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC20.sol#L80), [85](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC20.sol#L85)

```solidity
📁 File: contracts/tokenvault/BridgedERC20Base.sol

36:     function changeMigrationStatus( 
37:         address _migratingAddress,
38:         bool _migratingInbound
39:     )
40:         external
41:         nonReentrant
42:         whenNotPaused
43:         onlyFromOwnerOrNamed("erc20_vault")
44:     {
```
[36](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC20Base.sol#L36-L44)

```solidity
📁 File: contracts/tokenvault/BridgedERC721.sol

54:     function mint( 
55:         address _account,
56:         uint256 _tokenId
57:     )
58:         public
59:         nonReentrant
60:         whenNotPaused
61:         onlyFromNamed("erc721_vault")
62:     {

69:     function burn( 
70:         address _account,
71:         uint256 _tokenId
72:     )
73:         public
74:         nonReentrant
75:         whenNotPaused
76:         onlyFromNamed("erc721_vault")
77:     {
```
[54](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC721.sol#L54-L62), [69](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC721.sol#L69-L77)

```solidity
📁 File: contracts/tokenvault/ERC20Vault.sol

148:     function changeBridgedToken( 
149:         CanonicalERC20 calldata _ctoken,
150:         address _btokenNew
151:     )
152:         external
153:         nonReentrant
154:         whenNotPaused
155:         onlyOwner
156:         returns (address btokenOld_)
157:     {
```
[148](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC20Vault.sol#L148-L157)

```solidity
📁 File: contracts/verifiers/SgxVerifier.sol

90:     function addInstances(address[] calldata _instances) 
91:         external
92:         onlyOwner
93:         returns (uint256[] memory)
94:     {

100:     function deleteInstances(uint256[] calldata _ids) 
101:         external
102:         onlyFromOwnerOrNamed("rollup_watchdog")
103:     {

139:     function verifyProof( 
140:         Context calldata _ctx,
141:         TaikoData.Transition calldata _tran,
142:         TaikoData.TierProof calldata _proof
143:     )
144:         external
145:         onlyFromNamed("taiko")
146:     {
```
[90](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/verifiers/SgxVerifier.sol#L90-L94), [100](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/verifiers/SgxVerifier.sol#L100-L103), [139](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/verifiers/SgxVerifier.sol#L139-L146)

</details>


---
### [GAS&#x2011;36] Initializers can be marked `payable`

Gas saved per Instance: ~21 *(Total: ~504)*
<details>
<summary><i>There are 24 instances of this issue:</i></summary>

```solidity
📁 File: contracts/L1/TaikoL1.sol

42:     function init( 
43:         address _owner,
44:         address _addressManager,
45:         bytes32 _genesisBlockHash
46:     )
47:         external
48:         initializer
49:     {
```
[42](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/TaikoL1.sol#L42-L49)

```solidity
📁 File: contracts/L1/TaikoToken.sol

25:     function init( 
26:         address _owner,
27:         string calldata _name,
28:         string calldata _symbol,
29:         address _recipient
30:     )
31:         public
32:         initializer
33:     {
```
[25](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/TaikoToken.sol#L25-L33)

```solidity
📁 File: contracts/L1/gov/TaikoGovernor.sol

31:     function init( 
32:         address _owner,
33:         IVotesUpgradeable _token,
34:         TimelockControllerUpgradeable _timelock
35:     )
36:         external
37:         initializer
38:     {
```
[31](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/gov/TaikoGovernor.sol#L31-L38)

```solidity
📁 File: contracts/L1/gov/TaikoTimelockController.sol

15:     function init(address _owner, uint256 _minDelay) external initializer { 
```
[15](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/gov/TaikoTimelockController.sol#L15)

```solidity
📁 File: contracts/L1/hooks/AssignmentHook.sol

57:     function init(address _owner, address _addressManager) external initializer { 
```
[57](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/hooks/AssignmentHook.sol#L57)

```solidity
📁 File: contracts/L1/provers/GuardianProver.sol

25:     function init(address _owner, address _addressManager) external initializer { 
```
[25](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/provers/GuardianProver.sol#L25)

```solidity
📁 File: contracts/L1/tiers/DevnetTierProvider.sol

15:     function init(address _owner) external initializer { 
```
[15](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/tiers/DevnetTierProvider.sol#L15)

```solidity
📁 File: contracts/L1/tiers/MainnetTierProvider.sol

15:     function init(address _owner) external initializer { 
```
[15](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/tiers/MainnetTierProvider.sol#L15)

```solidity
📁 File: contracts/L1/tiers/TestnetTierProvider.sol

15:     function init(address _owner) external initializer { 
```
[15](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/tiers/TestnetTierProvider.sol#L15)

```solidity
📁 File: contracts/L2/TaikoL2.sol

71:     function init( 
72:         address _owner,
73:         address _addressManager,
74:         uint64 _l1ChainId,
75:         uint64 _gasExcess
76:     )
77:         external
78:         initializer
79:     {
```
[71](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/TaikoL2.sol#L71-L79)

```solidity
📁 File: contracts/bridge/Bridge.sol

75:     function init(address _owner, address _addressManager) external initializer { 
```
[75](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/Bridge.sol#L75)

```solidity
📁 File: contracts/common/AddressManager.sol

30:     function init(address _owner) external initializer { 
```
[30](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/common/AddressManager.sol#L30)

```solidity
📁 File: contracts/signal/SignalService.sol

48:     function init(address _owner, address _addressManager) external initializer { 
```
[48](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/signal/SignalService.sol#L48)

```solidity
📁 File: contracts/team/TimelockTokenPool.sol

111:     function init( 
112:         address _owner,
113:         address _taikoToken,
114:         address _costToken,
115:         address _sharedVault
116:     )
117:         external
118:         initializer
119:     {
```
[111](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/TimelockTokenPool.sol#L111-L119)

```solidity
📁 File: contracts/team/airdrop/ERC20Airdrop.sol

27:     function init( 
28:         address _owner,
29:         uint64 _claimStart,
30:         uint64 _claimEnd,
31:         bytes32 _merkleRoot,
32:         address _token,
33:         address _vault
34:     )
35:         external
36:         initializer
37:     {
```
[27](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/airdrop/ERC20Airdrop.sol#L27-L37)

```solidity
📁 File: contracts/team/airdrop/ERC20Airdrop2.sol

54:     function init( 
55:         address _owner,
56:         uint64 _claimStart,
57:         uint64 _claimEnd,
58:         bytes32 _merkleRoot,
59:         address _token,
60:         address _vault,
61:         uint64 _withdrawalWindow
62:     )
63:         external
64:         initializer
65:     {
```
[54](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/airdrop/ERC20Airdrop2.sol#L54-L65)

```solidity
📁 File: contracts/team/airdrop/ERC721Airdrop.sol

25:     function init( 
26:         address _owner,
27:         uint64 _claimStart,
28:         uint64 _claimEnd,
29:         bytes32 _merkleRoot,
30:         address _token,
31:         address _vault
32:     )
33:         external
34:         initializer
35:     {
```
[25](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/airdrop/ERC721Airdrop.sol#L25-L35)

```solidity
📁 File: contracts/tokenvault/BaseVault.sol

32:     function init(address _owner, address _addressManager) external initializer { 
```
[32](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BaseVault.sol#L32)

```solidity
📁 File: contracts/tokenvault/BridgedERC1155.sol

38:     function init( 
39:         address _owner,
40:         address _addressManager,
41:         address _srcToken,
42:         uint256 _srcChainId,
43:         string memory _symbol,
44:         string memory _name
45:     )
46:         external
47:         initializer
48:     {
```
[38](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC1155.sol#L38-L48)

```solidity
📁 File: contracts/tokenvault/BridgedERC20.sol

52:     function init( 
53:         address _owner,
54:         address _addressManager,
55:         address _srcToken,
56:         uint256 _srcChainId,
57:         uint8 _decimals,
58:         string memory _symbol,
59:         string memory _name
60:     )
61:         external
62:         initializer
63:     {
```
[52](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC20.sol#L52-L63)

```solidity
📁 File: contracts/tokenvault/BridgedERC721.sol

31:     function init( 
32:         address _owner,
33:         address _addressManager,
34:         address _srcToken,
35:         uint256 _srcChainId,
36:         string memory _symbol,
37:         string memory _name
38:     )
39:         external
40:         initializer
41:     {
```
[31](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC721.sol#L31-L41)

```solidity
📁 File: contracts/tokenvault/adapters/USDCAdapter.sol

38:     function init(address _owner, address _addressManager, IUSDC _usdc) external initializer { 
```
[38](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/adapters/USDCAdapter.sol#L38)

```solidity
📁 File: contracts/verifiers/GuardianVerifier.sol

18:     function init(address _owner, address _addressManager) external initializer { 
```
[18](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/verifiers/GuardianVerifier.sol#L18)

```solidity
📁 File: contracts/verifiers/SgxVerifier.sol

83:     function init(address _owner, address _addressManager) external initializer { 
```
[83](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/verifiers/SgxVerifier.sol#L83)

</details>


---
### [GAS&#x2011;37] Integer increments by one can be unchecked
Using unchecked increments in Solidity can save on gas fees by bypassing built-in overflow checks, thus optimizing gas usage, but requires careful assessment of potential risks and edge cases to avoid unintended consequences.


Gas saved per Instance: ~60 *(Total: ~2,940)*
<details>
<summary><i>There are 49 instances of this issue:</i></summary>

```solidity
📁 File: contracts/L1/hooks/AssignmentHook.sol

172:         for (uint256 i; i < _tierFees.length; ++i) { 
```
[172](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/hooks/AssignmentHook.sol#L172)

```solidity
📁 File: contracts/L1/libs/LibProposing.sol

244:             for (uint256 i; i < params.hookCalls.length; ++i) { 
```
[244](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProposing.sol#L244)

```solidity
📁 File: contracts/L1/libs/LibProving.sol

252:                 ts.contestations += 1; 

377:             _ts.contestations += 1; 
```
[252](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProving.sol#L252), [377](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProving.sol#L377)

```solidity
📁 File: contracts/L1/provers/Guardians.sol

74:         for (uint256 i; i < guardians.length; ++i) { 

80:         for (uint256 i = 0; i < _newGuardians.length; ++i) { 

92:         ++version; 
```
[74](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/provers/Guardians.sol#L74), [80](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/provers/Guardians.sol#L80), [92](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/provers/Guardians.sol#L92)

```solidity
📁 File: contracts/L2/CrossChainOwned.sol

53:         emit TransactionExecuted(nextTxId++, bytes4(txdata)); 
```
[53](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/CrossChainOwned.sol#L53)

```solidity
📁 File: contracts/automata-attestation/AutomataDcapV3Attestation.sol

80:         for (uint256 i; i < serialNumBatch.length; ++i) { 

95:         for (uint256 i; i < serialNumBatch.length; ++i) { 

191:         for (uint256 i; i < enclaveId.tcbLevels.length; ++i) { 

214:         for (uint256 i; i < tcb.tcbLevels.length; ++i) { 

240:         for (uint256 i; i < CPUSVN_LENGTH; ++i) { 

259:         for (uint256 i; i < n; ++i) { 

420:             for (uint256 i; i < 3; ++i) { 
```
[80](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/AutomataDcapV3Attestation.sol#L80), [95](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/AutomataDcapV3Attestation.sol#L95), [191](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/AutomataDcapV3Attestation.sol#L191), [214](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/AutomataDcapV3Attestation.sol#L214), [240](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/AutomataDcapV3Attestation.sol#L240), [259](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/AutomataDcapV3Attestation.sol#L259), [420](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/AutomataDcapV3Attestation.sol#L420)

```solidity
📁 File: contracts/automata-attestation/lib/PEMCertChainLib.sol

54:         for (uint256 i; i < size; ++i) { 

244:         for (uint256 i; i < split.length; ++i) { 

354:         for (uint256 i; i < SGX_TCB_CPUSVN_SIZE + 1; ++i) { 
```
[54](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/PEMCertChainLib.sol#L54), [244](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/PEMCertChainLib.sol#L244), [354](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/PEMCertChainLib.sol#L354)

```solidity
📁 File: contracts/automata-attestation/lib/QuoteV3Auth/V3Parser.sol

153:         for (uint256 i; i < encoded.length; ++i) { 

281:         for (uint256 i; i < 3; ++i) { 
```
[153](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/QuoteV3Auth/V3Parser.sol#L153), [281](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/QuoteV3Auth/V3Parser.sol#L281)

```solidity
📁 File: contracts/automata-attestation/utils/BytesUtils.sol

333:         for (uint256 i; i < len; ++i) { 
```
[333](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/BytesUtils.sol#L333)

```solidity
📁 File: contracts/automata-attestation/utils/RsaVerify.sol

140:         for (uint256 i = 2; i < 2 + paddingLen; ++i) { 

152:             for (uint256 i; i < digestAlgoWithParamLen; ++i) { 

158:             for (uint256 i; i < digestAlgoWithParamLen; ++i) { 

174:         for (uint256 i; i < _sha256.length; ++i) { 

273:         for (uint256 i = 2; i < 2 + paddingLen; ++i) { 

283:         for (uint256 i; i < sha1Prefix.length; ++i) { 

290:         for (uint256 i; i < _sha1.length; ++i) { 
```
[140](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/RsaVerify.sol#L140), [152](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/RsaVerify.sol#L152), [158](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/RsaVerify.sol#L158), [174](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/RsaVerify.sol#L174), [273](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/RsaVerify.sol#L273), [283](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/RsaVerify.sol#L283), [290](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/RsaVerify.sol#L290)

```solidity
📁 File: contracts/automata-attestation/utils/X509DateUtils.sol

48:         for (uint16 i = 1970; i < year; ++i) { 

59:         for (uint8 i = 1; i < month; ++i) { 
```
[48](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/X509DateUtils.sol#L48), [59](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/X509DateUtils.sol#L59)

```solidity
📁 File: contracts/bridge/Bridge.sol

90:         for (uint256 i; i < _msgHashes.length; ++i) { 

144:         message_.id = nextMessageId++; 
```
[90](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/Bridge.sol#L90), [144](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/Bridge.sol#L144)

```solidity
📁 File: contracts/signal/SignalService.sol

104:         for (uint256 i; i < hopProofs.length; ++i) { 
```
[104](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/signal/SignalService.sol#L104)

```solidity
📁 File: contracts/team/airdrop/ERC721Airdrop.sol

59:         for (uint256 i; i < tokenIds.length; ++i) { 
```
[59](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/airdrop/ERC721Airdrop.sol#L59)

```solidity
📁 File: contracts/thirdparty/optimism/rlp/RLPReader.sol

89:             itemCount += 1; 
```
[89](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/rlp/RLPReader.sol#L89)

```solidity
📁 File: contracts/thirdparty/optimism/rlp/RLPWriter.sol

40:                 lenLen++; 

46:             for (i = 1; i <= lenLen; i++) { 

59:         for (; i < 32; i++) { 

66:         for (uint256 j = 0; j < out_.length; j++) { 
67:             out_[j] = b[i++];
```
[40](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/rlp/RLPWriter.sol#L40), [46](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/rlp/RLPWriter.sol#L46), [59](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/rlp/RLPWriter.sol#L59), [66](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/rlp/RLPWriter.sol#L66-L67)

```solidity
📁 File: contracts/thirdparty/optimism/trie/MerkleTrie.sol

85:         for (uint256 i = 0; i < proof.length; i++) { 

137:                     currentKeyIndex += 1; 
```
[85](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/trie/MerkleTrie.sol#L85), [137](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/trie/MerkleTrie.sol#L137)

```solidity
📁 File: contracts/tokenvault/ERC1155Vault.sol

47:         for (uint256 i; i < _op.amounts.length; ++i) { 
```
[47](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC1155Vault.sol#L47)

```solidity
📁 File: contracts/tokenvault/ERC721Vault.sol

34:         for (uint256 i; i < _op.tokenIds.length; ++i) { 

170:             for (uint256 i; i < _tokenIds.length; ++i) { 

175:             for (uint256 i; i < _tokenIds.length; ++i) { 
```
[34](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC721Vault.sol#L34), [170](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC721Vault.sol#L170), [175](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC721Vault.sol#L175)

```solidity
📁 File: contracts/verifiers/SgxVerifier.sol

104:         for (uint256 i; i < _ids.length; ++i) { 

210:         for (uint256 i; i < _instances.length; ++i) { 

222:             nextInstanceId++; 
```
[104](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/verifiers/SgxVerifier.sol#L104), [210](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/verifiers/SgxVerifier.sol#L210), [222](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/verifiers/SgxVerifier.sol#L222)

</details>


---
### [GAS&#x2011;38] Low-level `call` can be optimized with assembly
`returnData` is copied to memory even if the variable is not utilized: the proper way to handle this is through a low level assembly call and save **159** [gas](https://gist.github.com/IllIllI000/0e18a40f3afb0b83f9a347b10ee89ad2).

```solidity
 // before (bool success,) = payable(receiver).call{gas: gas, value: value}("");
//after bool success; assembly { success := call(gas, receiver, value, 0, 0, 0, 0) }
```



Gas saved per Instance: ~159 *(Total: ~477)*
<details>
<summary><i>There are 3 instances of this issue:</i></summary>

```solidity
📁 File: contracts/L2/CrossChainOwned.sol

50:         (bool success,) = address(this).call(txdata); 
```
[50](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/CrossChainOwned.sol#L50)

```solidity
📁 File: contracts/automata-attestation/utils/SigVerifyLib.sol

137:         (bool success, bytes memory ret) = ES256VERIFIER.staticcall(args); 
```
[137](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/SigVerifyLib.sol#L137)

```solidity
📁 File: contracts/bridge/Bridge.sol

591:         (success_,) = _signalService.staticcall(data); 
```
[591](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/Bridge.sol#L591)

</details>


---
### [GAS&#x2011;39] Mappings are cheaper to use than storage arrays
When using storage arrays, solidity adds an internal lookup of the array's length (a Gcoldsload **2100 gas**) to ensure you don't read past the array's end. You can avoid this lookup by using a `mapping` and storing the number of entries in a separate storage variable. In cases where you have sentinel values (e.g. 'zero' means invalid), you can avoid length checks


Gas saved per Instance: ~2,100 *(Total: ~102,900)*
<details>
<summary><i>There are 49 instances of this issue:</i></summary>

```solidity
📁 File: contracts/L1/TaikoData.sol

87:         HookCall[] hookCalls; 

195:         uint256[43] __gap; 
```
[87](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/TaikoData.sol#L87), [195](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/TaikoData.sol#L195)

```solidity
📁 File: contracts/L1/TaikoL1.sol

26:     uint256[50] private __gap; 
```
[26](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/TaikoL1.sol#L26)

```solidity
📁 File: contracts/L1/TaikoToken.sol

16:     uint256[50] private __gap; 
```
[16](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/TaikoToken.sol#L16)

```solidity
📁 File: contracts/L1/gov/TaikoGovernor.sol

23:     uint256[50] private __gap; 
```
[23](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/gov/TaikoGovernor.sol#L23)

```solidity
📁 File: contracts/L1/gov/TaikoTimelockController.sol

10:     uint256[50] private __gap; 
```
[10](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/gov/TaikoTimelockController.sol#L10)

```solidity
📁 File: contracts/L1/hooks/AssignmentHook.sol

25:         TaikoData.TierFee[] tierFees; 

40:     uint256[50] private __gap; 
```
[25](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/hooks/AssignmentHook.sol#L25), [40](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/hooks/AssignmentHook.sol#L40)

```solidity
📁 File: contracts/L1/provers/GuardianProver.sol

11:     uint256[50] private __gap; 
```
[11](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/provers/GuardianProver.sol#L11)

```solidity
📁 File: contracts/L1/provers/Guardians.sol

23:     address[] public guardians; 

32:     uint256[46] private __gap; 
```
[23](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/provers/Guardians.sol#L23), [32](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/provers/Guardians.sol#L32)

```solidity
📁 File: contracts/L1/tiers/DevnetTierProvider.sol

11:     uint256[50] private __gap; 
```
[11](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/tiers/DevnetTierProvider.sol#L11)

```solidity
📁 File: contracts/L1/tiers/MainnetTierProvider.sol

11:     uint256[50] private __gap; 
```
[11](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/tiers/MainnetTierProvider.sol#L11)

```solidity
📁 File: contracts/L1/tiers/TestnetTierProvider.sol

11:     uint256[50] private __gap; 
```
[11](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/tiers/TestnetTierProvider.sol#L11)

```solidity
📁 File: contracts/L2/CrossChainOwned.sol

21:     uint256[49] private __gap; 
```
[21](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/CrossChainOwned.sol#L21)

```solidity
📁 File: contracts/L2/TaikoL2.sol

52:     uint256[47] private __gap; 
```
[52](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/TaikoL2.sol#L52)

```solidity
📁 File: contracts/L2/TaikoL2EIP1559Configurable.sol

13:     uint256[49] private __gap; 
```
[13](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/TaikoL2EIP1559Configurable.sol#L13)

```solidity
📁 File: contracts/automata-attestation/lib/EnclaveIdStruct.sol

14:         TcbLevel[] tcbLevels; 
```
[14](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/EnclaveIdStruct.sol#L14)

```solidity
📁 File: contracts/automata-attestation/lib/QuoteV3Auth/V3Struct.sol

44:         bytes[3] decodedCertDataArray; // base64 decoded cert bytes array 
```
[44](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/QuoteV3Auth/V3Struct.sol#L44)

```solidity
📁 File: contracts/automata-attestation/lib/TCBInfoStruct.sol

10:         TCBLevelObj[] tcbLevels; 

15:         uint8[] sgxTcbCompSvnArr; 
```
[10](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/TCBInfoStruct.sol#L10), [15](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/TCBInfoStruct.sol#L15)

```solidity
📁 File: contracts/automata-attestation/lib/interfaces/IPEMCertChainLib.sol

28:         uint256[] sgxTcbCompSvnArr; 
```
[28](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/interfaces/IPEMCertChainLib.sol#L28)

```solidity
📁 File: contracts/bridge/Bridge.sol

48:     uint256[43] private __gap; 
```
[48](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/Bridge.sol#L48)

```solidity
📁 File: contracts/common/AddressManager.sol

14:     uint256[49] private __gap; 
```
[14](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/common/AddressManager.sol#L14)

```solidity
📁 File: contracts/common/AddressResolver.sol

14:     uint256[49] private __gap; 
```
[14](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/common/AddressResolver.sol#L14)

```solidity
📁 File: contracts/common/EssentialContract.sol

25:     uint256[49] private __gap; 
```
[25](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/common/EssentialContract.sol#L25)

```solidity
📁 File: contracts/signal/ISignalService.sol

25:         bytes[] accountProof; 
26:         bytes[] storageProof;
```
[25](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/signal/ISignalService.sol#L25-L26)

```solidity
📁 File: contracts/signal/SignalService.sol

23:     uint256[48] private __gap; 
```
[23](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/signal/SignalService.sol#L23)

```solidity
📁 File: contracts/team/TimelockTokenPool.sol

82:     uint128[44] private __gap; 
```
[82](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/TimelockTokenPool.sol#L82)

```solidity
📁 File: contracts/team/airdrop/ERC20Airdrop.sol

18:     uint256[48] private __gap; 
```
[18](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/airdrop/ERC20Airdrop.sol#L18)

```solidity
📁 File: contracts/team/airdrop/ERC20Airdrop2.sol

30:     uint256[45] private __gap; 
```
[30](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/airdrop/ERC20Airdrop2.sol#L30)

```solidity
📁 File: contracts/team/airdrop/ERC721Airdrop.sol

16:     uint256[48] private __gap; 
```
[16](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/airdrop/ERC721Airdrop.sol#L16)

```solidity
📁 File: contracts/team/airdrop/MerkleClaimable.sol

23:     uint256[47] private __gap; 
```
[23](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/airdrop/MerkleClaimable.sol#L23)

```solidity
📁 File: contracts/thirdparty/optimism/trie/MerkleTrie.sol

17:         RLPReader.RLPItem[] decoded; 
```
[17](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/trie/MerkleTrie.sol#L17)

```solidity
📁 File: contracts/tokenvault/BaseNFTVault.sol

33:         uint256[] tokenIds; 

35:         uint256[] amounts; 

61:     uint256[48] private __gap; 
```
[33](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BaseNFTVault.sol#L33), [35](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BaseNFTVault.sol#L35), [61](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BaseNFTVault.sol#L61)

```solidity
📁 File: contracts/tokenvault/BaseVault.sol

18:     uint256[50] private __gap; 
```
[18](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BaseVault.sol#L18)

```solidity
📁 File: contracts/tokenvault/BridgedERC1155.sol

27:     uint256[46] private __gap; 
```
[27](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC1155.sol#L27)

```solidity
📁 File: contracts/tokenvault/BridgedERC20.sol

32:     uint256[47] private __gap; 
```
[32](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC20.sol#L32)

```solidity
📁 File: contracts/tokenvault/BridgedERC20Base.sol

16:     uint256[49] private __gap; 
```
[16](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC20Base.sol#L16)

```solidity
📁 File: contracts/tokenvault/BridgedERC721.sol

19:     uint256[48] private __gap; 
```
[19](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC721.sol#L19)

```solidity
📁 File: contracts/tokenvault/ERC1155Vault.sol

32:     uint256[50] private __gap; 
```
[32](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC1155Vault.sol#L32)

```solidity
📁 File: contracts/tokenvault/ERC20Vault.sol

54:     uint256[47] private __gap; 
```
[54](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC20Vault.sol#L54)

```solidity
📁 File: contracts/tokenvault/ERC721Vault.sol

19:     uint256[50] private __gap; 
```
[19](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC721Vault.sol#L19)

```solidity
📁 File: contracts/tokenvault/adapters/USDCAdapter.sol

32:     uint256[49] private __gap; 
```
[32](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/adapters/USDCAdapter.sol#L32)

```solidity
📁 File: contracts/verifiers/GuardianVerifier.sol

11:     uint256[50] private __gap; 
```
[11](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/verifiers/GuardianVerifier.sol#L11)

```solidity
📁 File: contracts/verifiers/SgxVerifier.sol

57:     uint256[47] private __gap; 
```
[57](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/verifiers/SgxVerifier.sol#L57)

</details>


---
### [GAS&#x2011;40] Memory-safe annotation missing
Use `assembly ("memory-safe") { ... }` for the assembly blocks below since they dont't read or modify memory, and therefore are [memory-safe](https://docs.soliditylang.org/en/latest/assembly.html#memory-safety). This will help the optimizer to create more optimal gas-efficient code. Use the comment variant if prior to Solidity version 0.8.13

<details>
<summary><i>There are 20 instances of this issue:</i></summary>

```solidity
📁 File: contracts/automata-attestation/utils/SHA1.sol

22:             switch lt(sub(totallen, len), 9) 
23:             case 1 { totallen := add(totallen, 64) }

31:                     count := sub(count, off) 
32:                     if lt(count, 32) {
33:                         let mask := not(sub(exp(256, sub(32, count)), 1))
34:                         result := and(result, mask)
35:                     }

38:  
39:             for { let i := 0 } lt(i, totallen) { i := add(i, 64) } {

44:                 switch lt(sub(len, i), 64) 
45:                 case 1 { mstore8(add(scratch, sub(len, i)), 0x80) }

51:                 // Expand the 16 32-bit words into 80 
52:                 for { let j := 64 } lt(j, 128) { j := add(j, 12) } {

70:                 } 
71:                 for { let j := 128 } lt(j, 320) { j := add(j, 24) } {

93:                 let k := 0 
94:                 for { let j := 0 } lt(j, 80) { j := add(j, 1) } {
95:                     switch div(j, 20)
96:                     case 0 {
97:                         // f = d xor (b and (c xor d))
98:                         f := xor(div(x, 0x100000000000000000000), div(x, 0x10000000000))
99:                         f := and(div(x, 0x1000000000000000000000000000000), f)
100:                         f := xor(div(x, 0x10000000000), f)
101:                         k := 0x5A827999
102:                     }
103:                     case 1 {
104:                         // f = b xor c xor d
105:                         f :=
106:                             xor(
107:                                 div(x, 0x1000000000000000000000000000000),
108:                                 div(x, 0x100000000000000000000)
109:                             )
110:                         f := xor(div(x, 0x10000000000), f)
111:                         k := 0x6ED9EBA1
112:                     }
113:                     case 2 {
114:                         // f = (b and c) or (d and (b or c))
115:                         f :=
116:                             or(
117:                                 div(x, 0x1000000000000000000000000000000),
118:                                 div(x, 0x100000000000000000000)
119:                             )
120:                         f := and(div(x, 0x10000000000), f)
121:                         f :=
122:                             or(
123:                                 and(
124:                                     div(x, 0x1000000000000000000000000000000),
125:                                     div(x, 0x100000000000000000000)
126:                                 ),
127:                                 f
128:                             )
129:                         k := 0x8F1BBCDC
130:                     }
131:                     case 3 {
132:                         // f = b xor c xor d
133:                         f :=
134:                             xor(
135:                                 div(x, 0x1000000000000000000000000000000),
136:                                 div(x, 0x100000000000000000000)
137:                             )
138:                         f := xor(div(x, 0x10000000000), f)
139:                         k := 0xCA62C1D6
140:                     }
```
[22](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/SHA1.sol#L22-L23), [31](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/SHA1.sol#L31-L35), [38](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/SHA1.sol#L38-L39), [44](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/SHA1.sol#L44-L45), [51](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/SHA1.sol#L51-L52), [70](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/SHA1.sol#L70-L71), [93](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/SHA1.sol#L93-L140)

```solidity
📁 File: contracts/thirdparty/optimism/Bytes.sol

59:                     let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start) 
60:                 } lt(mc, end) {
61:                     mc := add(mc, 0x20)
62:                     cc := add(cc, 0x20)
63:                 } { mstore(mc, mload(cc)) }

129:             // Loop through each byte in the input array 
130:             for { let i := 0x00 } lt(i, bytesLength) { i := add(i, 0x01) } {
```
[59](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/Bytes.sol#L59-L63), [129](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/Bytes.sol#L129-L130)

```solidity
📁 File: contracts/thirdparty/optimism/rlp/RLPReader.sol

297:             let i := 0 
298:             for { } lt(i, _length) { i := add(i, 32) } { mstore(add(dest, i), mload(add(src, i))) }
```
[297](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/rlp/RLPReader.sol#L297-L298)

</details>


---
### [GAS&#x2011;41] Merge events to save gas
Consolidating multiple event emissions into a single event in Solidity saves gas by reducing the cost per topic. This is crucial in functions emitting multiple related events. However, it's important to balance gas optimization with event data clarity for off-chain consumers.


Gas saved per Instance: ~375 *(Total: ~1,875)*
<details>
<summary><i>There are 5 instances of this issue:</i></summary>

```solidity
📁 File: contracts/L1/libs/LibProposing.sol

/// @audit 'BlockProposed', 'BlobCached'
68:     function proposeBlock( 
69:         TaikoData.State storage _state,
70:         TaikoData.Config memory _config,
71:         IAddressResolver _resolver,
72:         bytes calldata _data,
73:         bytes calldata _txList
74:     )
75:         internal
76:         returns (TaikoData.BlockMetadata memory meta_, TaikoData.EthDeposit[] memory deposits_)
77:     {
```
[68](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProposing.sol#L68-L77)

```solidity
📁 File: contracts/L1/libs/LibProving.sol

/// @audit 'TransitionProved', 'TransitionContested', 'TransitionProved'
/// @audit 'TransitionContested', 'TransitionProved'
91:     function proveBlock( 
92:         TaikoData.State storage _state,
93:         TaikoData.Config memory _config,
94:         IAddressResolver _resolver,
95:         TaikoData.BlockMetadata memory _meta,
96:         TaikoData.Transition memory _tran,
97:         TaikoData.TierProof memory _proof
98:     )
99:         internal
100:         returns (uint8 maxBlocksToVerify_)
101:     {
```
[91](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProving.sol#L91-L101)

```solidity
📁 File: contracts/bridge/Bridge.sol

/// @audit 'MessageRecalled', 'MessageReceived'
155:     function recallMessage( 
156:         Message calldata _message,
157:         bytes calldata _proof
158:     )
159:         external
160:         nonReentrant
161:         whenNotPaused
162:         sameChain(_message.srcChainId)
163:     {

/// @audit 'MessageExecuted', 'MessageReceived'
217:     function processMessage( 
218:         Message calldata _message,
219:         bytes calldata _proof
220:     )
221:         external
222:         nonReentrant
223:         whenNotPaused
224:         sameChain(_message.destChainId)
225:     {
```
[155](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/Bridge.sol#L155-L163), [217](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/Bridge.sol#L217-L225)

</details>


---
### [GAS&#x2011;42] Multiple accesses of the same mapping/array key/index should be cached
The instances below point to the second+ access of a value inside a mapping/array key/index, within a function. Caching a mapping's value in a local storage or calldata variable when the value is accessed [multiple times](https://gist.github.com/IllIllI000/ec23a57daa30a8f8ca8b9681c8ccefb0), saves ~42 gas per access due to not having to recalculate the key's keccak256 hash (Gkeccak256 - 30 gas) and that calculation's associated stack operations. Caching an array's struct avoids recalculating the array offsets into memory/calldata


Gas saved per Instance: ~42 *(Total: ~1,218)*
<details>
<summary><i>There are 29 instances of this issue:</i></summary>

```solidity
📁 File: contracts/L1/libs/LibProving.sol

/// @audit _state.transitions[slot][tid_] is also accessed on line 299
/// @audit _state.transitions[slot] is also accessed on line 299
345:             ts_ = _state.transitions[slot][tid_]; 
```
[345](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProving.sol#L345)

```solidity
📁 File: contracts/L1/libs/LibVerifying.sol

/// @audit _state.blocks[slot] is also accessed on line 104
130:                 blk = _state.blocks[slot]; 

/// @audit _state.transitions[slot][tid] is also accessed on line 115
/// @audit _state.transitions[slot] is also accessed on line 115
140:                 TaikoData.TransitionState storage ts = _state.transitions[slot][tid]; 
```
[130](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibVerifying.sol#L130), [140](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibVerifying.sol#L140)

```solidity
📁 File: contracts/L1/provers/Guardians.sol

/// @audit guardianIds[guardian] is also accessed on line 84
88:             guardianIds[guardian] = guardians.length; 

/// @audit _approvals[version][_hash] is also accessed on line 116
/// @audit _approvals[version] is also accessed on line 116
119:         uint256 _approval = _approvals[version][_hash]; 
```
[88](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/provers/Guardians.sol#L88), [119](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/provers/Guardians.sol#L119)

```solidity
📁 File: contracts/automata-attestation/AutomataDcapV3Attestation.sol

/// @audit _serialNumIsRevoked[index] is also accessed on line 81
84:             _serialNumIsRevoked[index][serialNumBatch[i]] = true; 

/// @audit parsedQuoteCerts[0] is also accessed on line 435
/// @audit parsedQuoteCerts[0] is also accessed on line 442
/// @audit parsedQuoteCerts[0] is also accessed on line 454
472:                 parsedQuoteCerts[0].pubKey, 
```
[84](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/AutomataDcapV3Attestation.sol#L84), [472](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/AutomataDcapV3Attestation.sol#L472)

```solidity
📁 File: contracts/automata-attestation/utils/X509DateUtils.sol

/// @audit x509Time[0] is also accessed on line 18
21:             yrs += (uint8(x509Time[0]) - 48) * 1000 + (uint8(x509Time[1]) - 48) * 100; 
```
[21](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/X509DateUtils.sol#L21)

```solidity
📁 File: contracts/bridge/Bridge.sol

/// @audit addressBanned[_addr] is also accessed on line 109
110:         addressBanned[_addr] = _ban; 

/// @audit proofReceipt[msgHash] is also accessed on line 168
184:             proofReceipt[msgHash].receivedAt = receivedAt; 

/// @audit messageStatus[msgHash] is also accessed on line 166
191:             messageStatus[msgHash] = Status.RECALLED; 

/// @audit proofReceipt[msgHash] is also accessed on line 230
/// @audit proofReceipt[msgHash] is also accessed on line 243
250:         if (invocationDelay != 0 && msg.sender != proofReceipt[msgHash].preferredExecutor) { 

/// @audit messageStatus[_msgHash] is also accessed on line 516
518:         messageStatus[_msgHash] = _status; 
```
[110](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/Bridge.sol#L110), [184](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/Bridge.sol#L184), [191](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/Bridge.sol#L191), [250](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/Bridge.sol#L250), [518](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/Bridge.sol#L518)

```solidity
📁 File: contracts/common/AddressManager.sol

/// @audit __addresses[_chainId][_name] is also accessed on line 47
/// @audit __addresses[_chainId] is also accessed on line 47
49:         __addresses[_chainId][_name] = _newAddress; 
```
[49](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/common/AddressManager.sol#L49)

```solidity
📁 File: contracts/signal/SignalService.sol

/// @audit isAuthorized[_addr] is also accessed on line 57
58:         isAuthorized[_addr] = _authorize; 

/// @audit topBlockId[_chainId][_kind] is also accessed on line 247
/// @audit topBlockId[_chainId] is also accessed on line 247
248:             topBlockId[_chainId][_kind] = _blockId; 
```
[58](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/signal/SignalService.sol#L58), [248](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/signal/SignalService.sol#L248)

```solidity
📁 File: contracts/team/TimelockTokenPool.sol

/// @audit recipients[_recipient] is also accessed on line 137
142:         recipients[_recipient].grant = _grant; 
```
[142](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/TimelockTokenPool.sol#L142)

```solidity
📁 File: contracts/team/airdrop/MerkleClaimable.sol

/// @audit isClaimed[hash] is also accessed on line 70
73:         isClaimed[hash] = true; 
```
[73](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/airdrop/MerkleClaimable.sol#L73)

```solidity
📁 File: contracts/thirdparty/optimism/rlp/RLPWriter.sol

/// @audit out_[0] is also accessed on line 35
45:             out_[0] = bytes1(uint8(lenLen) + uint8(_offset) + 55); 
```
[45](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/rlp/RLPWriter.sol#L45)

```solidity
📁 File: contracts/thirdparty/optimism/trie/MerkleTrie.sol

/// @audit currentNode.decoded[1] is also accessed on line 171
188:                     currentNodeID = _getNodeID(currentNode.decoded[1]); 
```
[188](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/trie/MerkleTrie.sol#L188)

```solidity
📁 File: contracts/tokenvault/ERC20Vault.sol

/// @audit bridgedToCanonical[_btokenNew] is also accessed on line 158
188:         bridgedToCanonical[_btokenNew] = _ctoken; 

/// @audit bridgedToCanonical[_token] is also accessed on line 358
359:             ctoken_ = bridgedToCanonical[_token]; 
```
[188](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC20Vault.sol#L188), [359](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC20Vault.sol#L359)

```solidity
📁 File: contracts/verifiers/SgxVerifier.sol

/// @audit instances[idx] is also accessed on line 107
109:             emit InstanceDeleted(idx, instances[idx].addr); 

/// @audit instances[id] is also accessed on line 235
/// @audit instances[id] is also accessed on line 236
237:             && block.timestamp <= instances[id].validSince + INSTANCE_EXPIRY; 
```
[109](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/verifiers/SgxVerifier.sol#L109), [237](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/verifiers/SgxVerifier.sol#L237)

</details>


---
### [GAS&#x2011;43] Multiple `address`/ID mappings can be combined into a single `mapping` of an `address`/ID to a `struct`
Saves a storage slot for the mapping. Depending on the circumstances and sizes of types, can avoid a Gsset (**20000 gas**) per mapping combined. Reads and subsequent writes can also be cheaper when a function requires both values and they both fit in the same storage slot. Finally, if both fields are accessed in the same function, can save **~42 gas per access** due to [not having to recalculate the key's keccak256 hash](https://gist.github.com/IllIllI000/ec23a57daa30a8f8ca8b9681c8ccefb0) (Gkeccak256 - **30 gas**) and that calculation's associated stack operations.


Gas saved per Instance: ~20,000 *(Total: ~200,000)*
<details>
<summary><i>There are 10 instances of this issue:</i></summary>

```solidity
📁 File: contracts/L1/TaikoData.sol

183:         mapping(uint64 blockId => mapping(bytes32 parentHash => uint32 transitionId)) transitionIds; 

190:         mapping(uint256 depositId_mod_ethDepositRingBufferSize => uint256 depositAmount) ethDeposits; 
```
[183](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/TaikoData.sol#L183), [190](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/TaikoData.sol#L190)

```solidity
📁 File: contracts/L1/provers/Guardians.sol

16:     mapping(address guardian => uint256 id) public guardianIds; 

19:     mapping(uint32 version => mapping(bytes32 hash => uint256 approvalBits)) internal _approvals; 
```
[16](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/provers/Guardians.sol#L16), [19](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/provers/Guardians.sol#L19)

```solidity
📁 File: contracts/team/airdrop/ERC20Airdrop2.sol

22:     mapping(address addr => uint256 amountClaimed) public claimedAmount; 

25:     mapping(address addr => uint256 amountWithdrawn) public withdrawnAmount; 
```
[22](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/airdrop/ERC20Airdrop2.sol#L22), [25](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/airdrop/ERC20Airdrop2.sol#L25)

```solidity
📁 File: contracts/tokenvault/BaseNFTVault.sol

59:     mapping(uint256 chainId => mapping(address ctoken => address btoken)) public canonicalToBridged; 
```
[59](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BaseNFTVault.sol#L59)

```solidity
📁 File: contracts/tokenvault/ERC20Vault.sol

49:     mapping(uint256 chainId => mapping(address ctoken => address btoken)) public canonicalToBridged; 
```
[49](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC20Vault.sol#L49)

</details>


---
### [GAS&#x2011;44] Nested for loops should be avoided due to high gas costs resulting from O^2 time complexity
In Solidity, avoiding nested loops is crucial due to their high gas costs, especially for large datasets. Nested loops can lead to quadratic time complexity, significantly increasing gas costs. Users pay for gas, so minimizing gas usage is vital. To optimize efficiency, limit loop usage, reduce iteration ranges, and minimize computations. Alternative patterns like map/filter/reduce are often cheaper in terms of gas usage.

<details>
<summary><i>There are 4 instances of this issue:</i></summary>

```solidity
📁 File: contracts/automata-attestation/AutomataDcapV3Attestation.sol

/// @audit _isCpuSvnHigherOrGreater() has loop inside @ line 217
214:         for (uint256 i; i < tcb.tcbLevels.length; ++i) { 
```
[214](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/AutomataDcapV3Attestation.sol#L214)

```solidity
📁 File: contracts/automata-attestation/lib/PEMCertChainLib.sol

/// @audit _removeHeadersAndFooters() has loop inside @ line 62
54:         for (uint256 i; i < size; ++i) { 

/// @audit _findTcb() has loop inside @ line 308
/// @audit loop @ line: 301
286:         while (tbsPtr != 0) { 
```
[54](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/PEMCertChainLib.sol#L54), [286](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/PEMCertChainLib.sol#L286)

```solidity
📁 File: contracts/thirdparty/optimism/trie/MerkleTrie.sol

/// @audit _getSharedNibbleLength() has loop inside @ line 145
85:         for (uint256 i = 0; i < proof.length; i++) { 
```
[85](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/trie/MerkleTrie.sol#L85)

</details>


---
### [GAS&#x2011;45] Nesting `if`-statements is cheaper than using `&&`
Using a double if statement instead of logical AND (&&) can provide similar short-circuiting behavior whereas double if is slightly more efficient.


Gas saved per Instance: ~30 *(Total: ~810)*
<details>
<summary><i>There are 27 instances of this issue:</i></summary>

```solidity
📁 File: contracts/L1/hooks/AssignmentHook.sol

120:         if (input.tip != 0 && block.coinbase != address(0)) { 
```
[120](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/hooks/AssignmentHook.sol#L120)

```solidity
📁 File: contracts/L1/libs/LibProposing.sol

108:         if (params.parentMetaHash != 0 && parentMetaHash != params.parentMetaHash) { 

164:                 if (_config.blobReuseEnabled && params.cacheBlobForReuse) { 

310:             if (proposerOne != address(0) && msg.sender != proposerOne) { 
```
[108](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProposing.sol#L108), [164](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProposing.sol#L164), [310](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProposing.sol#L310)

```solidity
📁 File: contracts/L1/libs/LibProving.sol

419:         if (_tid == 1 && _ts.tier == 0 && inProvingWindow) { 
```
[419](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProving.sol#L419)

```solidity
📁 File: contracts/L2/TaikoL2.sol

141:         if (!skipFeeCheck() && block.basefee != basefee) { 

275:             if (lastSyncedBlock > 0 && _l1BlockId > lastSyncedBlock) { 
```
[141](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/TaikoL2.sol#L141), [275](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/TaikoL2.sol#L275)

```solidity
📁 File: contracts/automata-attestation/AutomataDcapV3Attestation.sol

220:             if (pceSvnIsHigherOrGreater && cpuSvnsAreHigherOrGreater) { 
```
[220](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/AutomataDcapV3Attestation.sol#L220)

```solidity
📁 File: contracts/automata-attestation/lib/QuoteV3Auth/V3Parser.sol

77:         require( 

82:         require( 

94:         require( 
```
[77](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/QuoteV3Auth/V3Parser.sol#L77), [82](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/QuoteV3Auth/V3Parser.sol#L82), [94](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/QuoteV3Auth/V3Parser.sol#L94)

```solidity
📁 File: contracts/automata-attestation/utils/BytesUtils.sol

335:             require(char >= 0x30 && char <= 0x7A, "invalid char"); 
```
[335](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/BytesUtils.sol#L335)

```solidity
📁 File: contracts/bridge/Bridge.sol

250:         if (invocationDelay != 0 && msg.sender != proofReceipt[msgHash].preferredExecutor) { 

260:             if (_message.gasLimit == 0 && msg.sender != _message.destOwner) { 

439:         } else if (block.chainid >= 32_300 && block.chainid <= 32_400) { 

490:         if ( 
491:             _message.data.length >= 4 // msg can be empty
492:                 && bytes4(_message.data) != IMessageInvocable.onMessageInvocation.selector
493:                 && _message.to.isContract()
```
[250](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/Bridge.sol#L250), [260](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/Bridge.sol#L260), [439](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/Bridge.sol#L439), [490](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/Bridge.sol#L490-L493)

```solidity
📁 File: contracts/common/AddressResolver.sol

85:         if (!_allowZeroAddress && addr_ == address(0)) { 
```
[85](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/common/AddressResolver.sol#L85)

```solidity
📁 File: contracts/common/EssentialContract.sol

42:         if (msg.sender != owner() && msg.sender != resolve(_name, true)) revert RESOLVER_DENIED(); 
```
[42](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/common/EssentialContract.sol#L42)

```solidity
📁 File: contracts/signal/SignalService.sol

285:         if (cacheStateRoot && _isFullProof && !_isLastHop) { 

293:         if (cacheSignalRoot && (_isFullProof || !_isLastHop)) { 
```
[285](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/signal/SignalService.sol#L285), [293](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/signal/SignalService.sol#L293)

```solidity
📁 File: contracts/team/TimelockTokenPool.sol

277:             if (_cliff > 0 && _cliff <= _start) revert INVALID_GRANT(); 
```
[277](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/TimelockTokenPool.sol#L277)

```solidity
📁 File: contracts/thirdparty/optimism/rlp/RLPWriter.sol

14:         if (_in.length == 1 && uint8(_in[0]) < 128) { 
```
[14](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/rlp/RLPWriter.sol#L14)

```solidity
📁 File: contracts/tokenvault/BridgedERC20.sol

38:         if (msg.sender != owner() && msg.sender != snapshooter) { 
```
[38](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC20.sol#L38)

```solidity
📁 File: contracts/tokenvault/BridgedERC20Base.sol

45:         if (_migratingAddress == migratingAddress && _migratingInbound == migratingInbound) { 
```
[45](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC20Base.sol#L45)

</details>


---
### [GAS&#x2011;46] Newer versions of solidity are more gas efficient
The solidity language continues to pursue more efficient gas optimization schemes. Adopting a [newer version of solidity](https://github.com/ethereum/solc-js/tags) can be more gas efficient.

<details>
<summary><i>There are 81 instances of this issue:</i></summary>

```solidity
📁 File: contracts/L1/ITaikoL1.sol

2: pragma solidity ^0.8.0; 
```
[2](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/ITaikoL1.sol#L2)

```solidity
📁 File: contracts/L1/TaikoData.sol

2: pragma solidity ^0.8.0; 
```
[2](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/TaikoData.sol#L2)

```solidity
📁 File: contracts/L1/TaikoErrors.sol

2: pragma solidity ^0.8.0; 
```
[2](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/TaikoErrors.sol#L2)

```solidity
📁 File: contracts/L1/TaikoEvents.sol

2: pragma solidity ^0.8.0; 
```
[2](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/TaikoEvents.sol#L2)

```solidity
📁 File: contracts/L1/TaikoL1.sol

2: pragma solidity ^0.8.0; 
```
[2](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/TaikoL1.sol#L2)

```solidity
📁 File: contracts/L1/TaikoToken.sol

2: pragma solidity ^0.8.0; 
```
[2](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/TaikoToken.sol#L2)

```solidity
📁 File: contracts/L1/gov/TaikoGovernor.sol

2: pragma solidity ^0.8.0; 
```
[2](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/gov/TaikoGovernor.sol#L2)

```solidity
📁 File: contracts/L1/gov/TaikoTimelockController.sol

2: pragma solidity ^0.8.0; 
```
[2](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/gov/TaikoTimelockController.sol#L2)

```solidity
📁 File: contracts/L1/hooks/AssignmentHook.sol

2: pragma solidity ^0.8.0; 
```
[2](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/hooks/AssignmentHook.sol#L2)

```solidity
📁 File: contracts/L1/hooks/IHook.sol

2: pragma solidity ^0.8.0; 
```
[2](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/hooks/IHook.sol#L2)

```solidity
📁 File: contracts/L1/libs/LibDepositing.sol

2: pragma solidity ^0.8.0; 
```
[2](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibDepositing.sol#L2)

```solidity
📁 File: contracts/L1/libs/LibProposing.sol

2: pragma solidity ^0.8.0; 
```
[2](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProposing.sol#L2)

```solidity
📁 File: contracts/L1/libs/LibProving.sol

2: pragma solidity ^0.8.0; 
```
[2](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProving.sol#L2)

```solidity
📁 File: contracts/L1/libs/LibUtils.sol

2: pragma solidity ^0.8.0; 
```
[2](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibUtils.sol#L2)

```solidity
📁 File: contracts/L1/libs/LibVerifying.sol

2: pragma solidity ^0.8.0; 
```
[2](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibVerifying.sol#L2)

```solidity
📁 File: contracts/L1/provers/GuardianProver.sol

2: pragma solidity ^0.8.0; 
```
[2](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/provers/GuardianProver.sol#L2)

```solidity
📁 File: contracts/L1/provers/Guardians.sol

2: pragma solidity ^0.8.0; 
```
[2](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/provers/Guardians.sol#L2)

```solidity
📁 File: contracts/L1/tiers/DevnetTierProvider.sol

2: pragma solidity ^0.8.0; 
```
[2](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/tiers/DevnetTierProvider.sol#L2)

```solidity
📁 File: contracts/L1/tiers/ITierProvider.sol

2: pragma solidity ^0.8.0; 
```
[2](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/tiers/ITierProvider.sol#L2)

```solidity
📁 File: contracts/L1/tiers/MainnetTierProvider.sol

2: pragma solidity ^0.8.0; 
```
[2](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/tiers/MainnetTierProvider.sol#L2)

```solidity
📁 File: contracts/L1/tiers/TestnetTierProvider.sol

2: pragma solidity ^0.8.0; 
```
[2](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/tiers/TestnetTierProvider.sol#L2)

```solidity
📁 File: contracts/L2/CrossChainOwned.sol

2: pragma solidity ^0.8.0; 
```
[2](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/CrossChainOwned.sol#L2)

```solidity
📁 File: contracts/L2/Lib1559Math.sol

2: pragma solidity ^0.8.0; 
```
[2](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/Lib1559Math.sol#L2)

```solidity
📁 File: contracts/L2/TaikoL2.sol

2: pragma solidity ^0.8.0; 
```
[2](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/TaikoL2.sol#L2)

```solidity
📁 File: contracts/L2/TaikoL2EIP1559Configurable.sol

2: pragma solidity ^0.8.0; 
```
[2](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/TaikoL2EIP1559Configurable.sol#L2)

```solidity
📁 File: contracts/automata-attestation/AutomataDcapV3Attestation.sol

2: pragma solidity ^0.8.0; 
```
[2](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/AutomataDcapV3Attestation.sol#L2)

```solidity
📁 File: contracts/automata-attestation/interfaces/IAttestation.sol

2: pragma solidity ^0.8.0; 
```
[2](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/interfaces/IAttestation.sol#L2)

```solidity
📁 File: contracts/automata-attestation/interfaces/ISigVerifyLib.sol

2: pragma solidity ^0.8.0; 
```
[2](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/interfaces/ISigVerifyLib.sol#L2)

```solidity
📁 File: contracts/automata-attestation/lib/EnclaveIdStruct.sol

2: pragma solidity ^0.8.0; 
```
[2](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/EnclaveIdStruct.sol#L2)

```solidity
📁 File: contracts/automata-attestation/lib/PEMCertChainLib.sol

2: pragma solidity ^0.8.0; 
```
[2](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/PEMCertChainLib.sol#L2)

```solidity
📁 File: contracts/automata-attestation/lib/QuoteV3Auth/V3Parser.sol

2: pragma solidity ^0.8.0; 
```
[2](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/QuoteV3Auth/V3Parser.sol#L2)

```solidity
📁 File: contracts/automata-attestation/lib/QuoteV3Auth/V3Struct.sol

2: pragma solidity ^0.8.0; 
```
[2](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/QuoteV3Auth/V3Struct.sol#L2)

```solidity
📁 File: contracts/automata-attestation/lib/TCBInfoStruct.sol

2: pragma solidity ^0.8.0; 
```
[2](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/TCBInfoStruct.sol#L2)

```solidity
📁 File: contracts/automata-attestation/lib/interfaces/IPEMCertChainLib.sol

2: pragma solidity ^0.8.0; 
```
[2](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/interfaces/IPEMCertChainLib.sol#L2)

```solidity
📁 File: contracts/automata-attestation/utils/Asn1Decode.sol

3: pragma solidity ^0.8.0; 
```
[3](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/Asn1Decode.sol#L3)

```solidity
📁 File: contracts/automata-attestation/utils/BytesUtils.sol

2: pragma solidity ^0.8.0; 
```
[2](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/BytesUtils.sol#L2)

```solidity
📁 File: contracts/automata-attestation/utils/RsaVerify.sol

3: pragma solidity ^0.8.0; 
```
[3](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/RsaVerify.sol#L3)

```solidity
📁 File: contracts/automata-attestation/utils/SHA1.sol

3: pragma solidity ^0.8.0; 
```
[3](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/SHA1.sol#L3)

```solidity
📁 File: contracts/automata-attestation/utils/SigVerifyLib.sol

2: pragma solidity ^0.8.0; 
```
[2](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/SigVerifyLib.sol#L2)

```solidity
📁 File: contracts/automata-attestation/utils/X509DateUtils.sol

3: pragma solidity ^0.8.0; 
```
[3](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/X509DateUtils.sol#L3)

```solidity
📁 File: contracts/bridge/Bridge.sol

2: pragma solidity ^0.8.0; 
```
[2](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/Bridge.sol#L2)

```solidity
📁 File: contracts/bridge/IBridge.sol

2: pragma solidity ^0.8.0; 
```
[2](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/IBridge.sol#L2)

```solidity
📁 File: contracts/common/AddressManager.sol

2: pragma solidity ^0.8.0; 
```
[2](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/common/AddressManager.sol#L2)

```solidity
📁 File: contracts/common/AddressResolver.sol

2: pragma solidity ^0.8.0; 
```
[2](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/common/AddressResolver.sol#L2)

```solidity
📁 File: contracts/common/EssentialContract.sol

2: pragma solidity ^0.8.0; 
```
[2](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/common/EssentialContract.sol#L2)

```solidity
📁 File: contracts/common/IAddressManager.sol

2: pragma solidity ^0.8.0; 
```
[2](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/common/IAddressManager.sol#L2)

```solidity
📁 File: contracts/common/IAddressResolver.sol

2: pragma solidity ^0.8.0; 
```
[2](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/common/IAddressResolver.sol#L2)

```solidity
📁 File: contracts/libs/Lib4844.sol

2: pragma solidity ^0.8.0; 
```
[2](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/libs/Lib4844.sol#L2)

```solidity
📁 File: contracts/libs/LibAddress.sol

2: pragma solidity ^0.8.0; 
```
[2](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/libs/LibAddress.sol#L2)

```solidity
📁 File: contracts/libs/LibMath.sol

2: pragma solidity ^0.8.0; 
```
[2](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/libs/LibMath.sol#L2)

```solidity
📁 File: contracts/libs/LibTrieProof.sol

7: pragma solidity ^0.8.0; 
```
[7](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/libs/LibTrieProof.sol#L7)

```solidity
📁 File: contracts/signal/ISignalService.sol

2: pragma solidity ^0.8.0; 
```
[2](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/signal/ISignalService.sol#L2)

```solidity
📁 File: contracts/signal/LibSignals.sol

2: pragma solidity ^0.8.0; 
```
[2](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/signal/LibSignals.sol#L2)

```solidity
📁 File: contracts/signal/SignalService.sol

2: pragma solidity ^0.8.0; 
```
[2](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/signal/SignalService.sol#L2)

```solidity
📁 File: contracts/team/TimelockTokenPool.sol

2: pragma solidity ^0.8.0; 
```
[2](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/TimelockTokenPool.sol#L2)

```solidity
📁 File: contracts/team/airdrop/ERC20Airdrop.sol

2: pragma solidity ^0.8.0; 
```
[2](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/airdrop/ERC20Airdrop.sol#L2)

```solidity
📁 File: contracts/team/airdrop/ERC20Airdrop2.sol

2: pragma solidity ^0.8.0; 
```
[2](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/airdrop/ERC20Airdrop2.sol#L2)

```solidity
📁 File: contracts/team/airdrop/ERC721Airdrop.sol

2: pragma solidity ^0.8.0; 
```
[2](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/airdrop/ERC721Airdrop.sol#L2)

```solidity
📁 File: contracts/team/airdrop/MerkleClaimable.sol

2: pragma solidity ^0.8.0; 
```
[2](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/airdrop/MerkleClaimable.sol#L2)

```solidity
📁 File: contracts/thirdparty/nomad-xyz/ExcessivelySafeCall.sol

3: pragma solidity ^0.8.0; 
```
[3](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/nomad-xyz/ExcessivelySafeCall.sol#L3)

```solidity
📁 File: contracts/thirdparty/optimism/Bytes.sol

2: pragma solidity ^0.8.0; 
```
[2](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/Bytes.sol#L2)

```solidity
📁 File: contracts/thirdparty/optimism/rlp/RLPReader.sol

2: pragma solidity ^0.8.0; 
```
[2](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/rlp/RLPReader.sol#L2)

```solidity
📁 File: contracts/thirdparty/optimism/rlp/RLPWriter.sol

2: pragma solidity ^0.8.0; 
```
[2](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/rlp/RLPWriter.sol#L2)

```solidity
📁 File: contracts/thirdparty/optimism/trie/MerkleTrie.sol

2: pragma solidity ^0.8.0; 
```
[2](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/trie/MerkleTrie.sol#L2)

```solidity
📁 File: contracts/thirdparty/optimism/trie/SecureMerkleTrie.sol

2: pragma solidity ^0.8.0; 
```
[2](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/trie/SecureMerkleTrie.sol#L2)

```solidity
📁 File: contracts/thirdparty/solmate/LibFixedPointMath.sol

4: pragma solidity ^0.8.0; 
```
[4](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/solmate/LibFixedPointMath.sol#L4)

```solidity
📁 File: contracts/tokenvault/BaseNFTVault.sol

2: pragma solidity ^0.8.0; 
```
[2](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BaseNFTVault.sol#L2)

```solidity
📁 File: contracts/tokenvault/BaseVault.sol

2: pragma solidity ^0.8.0; 
```
[2](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BaseVault.sol#L2)

```solidity
📁 File: contracts/tokenvault/BridgedERC1155.sol

2: pragma solidity ^0.8.0; 
```
[2](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC1155.sol#L2)

```solidity
📁 File: contracts/tokenvault/BridgedERC20.sol

2: pragma solidity ^0.8.0; 
```
[2](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC20.sol#L2)

```solidity
📁 File: contracts/tokenvault/BridgedERC20Base.sol

2: pragma solidity ^0.8.0; 
```
[2](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC20Base.sol#L2)

```solidity
📁 File: contracts/tokenvault/BridgedERC721.sol

2: pragma solidity ^0.8.0; 
```
[2](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC721.sol#L2)

```solidity
📁 File: contracts/tokenvault/ERC1155Vault.sol

2: pragma solidity ^0.8.0; 
```
[2](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC1155Vault.sol#L2)

```solidity
📁 File: contracts/tokenvault/ERC20Vault.sol

2: pragma solidity ^0.8.0; 
```
[2](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC20Vault.sol#L2)

```solidity
📁 File: contracts/tokenvault/ERC721Vault.sol

2: pragma solidity ^0.8.0; 
```
[2](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC721Vault.sol#L2)

```solidity
📁 File: contracts/tokenvault/IBridgedERC20.sol

2: pragma solidity ^0.8.0; 
```
[2](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/IBridgedERC20.sol#L2)

```solidity
📁 File: contracts/tokenvault/LibBridgedToken.sol

2: pragma solidity ^0.8.0; 
```
[2](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/LibBridgedToken.sol#L2)

```solidity
📁 File: contracts/tokenvault/adapters/USDCAdapter.sol

2: pragma solidity ^0.8.0; 
```
[2](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/adapters/USDCAdapter.sol#L2)

```solidity
📁 File: contracts/verifiers/GuardianVerifier.sol

2: pragma solidity ^0.8.0; 
```
[2](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/verifiers/GuardianVerifier.sol#L2)

```solidity
📁 File: contracts/verifiers/IVerifier.sol

2: pragma solidity ^0.8.0; 
```
[2](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/verifiers/IVerifier.sol#L2)

```solidity
📁 File: contracts/verifiers/SgxVerifier.sol

2: pragma solidity ^0.8.0; 
```
[2](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/verifiers/SgxVerifier.sol#L2)

</details>


---
### [GAS&#x2011;47] Not using the named return variables when a function returns, wastes deployment gas
The solidity compiler outputs more efficient code when the variable is declared in the return statement. There seem to be very few exceptions to this in practice, so if you see an anonymous return, you should test it with a named return instead to determine which case is most efficient.

<details>
<summary><i>There are 331 instances of this issue:</i></summary>

```solidity
📁 File: contracts/L1/ITaikoL1.sol

14:     function proposeBlock( 
15:         bytes calldata _params,
16:         bytes calldata _txList
17:     )
18:         external
19:         payable
20:         returns (TaikoData.BlockMetadata memory meta_, TaikoData.EthDeposit[] memory deposits_);

/// @audit Parameter of type 'struct TaikoData.Config' at index '0'
35:     function getConfig() external view returns (TaikoData.Config memory); 
```
[14](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/ITaikoL1.sol#L14-L20), [35](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/ITaikoL1.sol#L35)

```solidity
📁 File: contracts/L1/TaikoL1.sol

55:     function proposeBlock( 
56:         bytes calldata _params,
57:         bytes calldata _txList
58:     )
59:         external
60:         payable
61:         nonReentrant
62:         whenNotPaused
63:         returns (TaikoData.BlockMetadata memory meta_, TaikoData.EthDeposit[] memory deposits_)
64:     {
65:         TaikoData.Config memory config = getConfig();
66: 
67:         (meta_, deposits_) = LibProposing.proposeBlock(state, config, this, _params, _txList);
68: 
69:         if (!state.slotB.provingPaused) {
70:             LibVerifying.verifyBlocks(state, config, this, config.maxBlocksToVerifyPerProposal);
71:         }
72:     }

/// @audit Parameter of type 'bool' at index '0'
132:     function canDepositEthToL2(uint256 _amount) public view returns (bool) { 

/// @audit Parameter of type 'bool' at index '0'
137:     function isBlobReusable(bytes32 _blobHash) public view returns (bool) { 

145:     function getBlock(uint64 _blockId) 
146:         public
147:         view
148:         returns (TaikoData.Block memory blk_, TaikoData.TransitionState memory ts_)
149:     {
150:         uint64 slot;
151:         (blk_, slot) = LibUtils.getBlock(state, getConfig(), _blockId);
152: 
153:         if (blk_.verifiedTransitionId != 0) {
154:             ts_ = state.transitions[slot][blk_.verifiedTransitionId];
155:         }
156:     }

162:     function getTransition( 

176:     function getStateVariables() 
177:         public
178:         view
179:         returns (TaikoData.SlotA memory a_, TaikoData.SlotB memory b_)
180:     {
181:         a_ = state.slotA;
182:         b_ = state.slotB;
183:     }

/// @audit Parameter of type 'struct TaikoData.Config' at index '0'
186:     function getConfig() public view virtual override returns (TaikoData.Config memory) { 
```
[55](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/TaikoL1.sol#L55-L72), [132](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/TaikoL1.sol#L132), [137](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/TaikoL1.sol#L137), [145](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/TaikoL1.sol#L145-L156), [162](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/TaikoL1.sol#L162), [176](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/TaikoL1.sol#L176-L183), [186](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/TaikoL1.sol#L186)

```solidity
📁 File: contracts/L1/TaikoToken.sol

/// @audit Parameter of type 'bool' at index '0'
60:     function transfer(address _to, uint256 _amount) public override returns (bool) { 

70:     function transferFrom( 
```
[60](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/TaikoToken.sol#L60), [70](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/TaikoToken.sol#L70)

```solidity
📁 File: contracts/L1/gov/TaikoGovernor.sol

48:     function propose( 

69:     function propose( 

89:     function supportsInterface(bytes4 _interfaceId) 

99:     function state(uint256 _proposalId) 

/// @audit Parameter of type 'uint256' at index '0'
111:     function votingDelay() public pure override returns (uint256) { 

/// @audit Parameter of type 'uint256' at index '0'
117:     function votingPeriod() public pure override returns (uint256) { 

/// @audit Parameter of type 'uint256' at index '0'
123:     function proposalThreshold() public pure override returns (uint256) { 

140:     function _cancel( 

153:     function _executor() 
```
[48](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/gov/TaikoGovernor.sol#L48), [69](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/gov/TaikoGovernor.sol#L69), [89](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/gov/TaikoGovernor.sol#L89), [99](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/gov/TaikoGovernor.sol#L99), [111](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/gov/TaikoGovernor.sol#L111), [117](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/gov/TaikoGovernor.sol#L117), [123](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/gov/TaikoGovernor.sol#L123), [140](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/gov/TaikoGovernor.sol#L140), [153](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/gov/TaikoGovernor.sol#L153)

```solidity
📁 File: contracts/L1/gov/TaikoTimelockController.sol

/// @audit Parameter of type 'uint256' at index '0'
24:     function getMinDelay() public view override returns (uint256) { 
```
[24](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/gov/TaikoTimelockController.sol#L24)

```solidity
📁 File: contracts/L1/hooks/AssignmentHook.sol

137:     function hashAssignment( 

164:     function _getProverFee( 
```
[137](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/hooks/AssignmentHook.sol#L137), [164](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/hooks/AssignmentHook.sol#L164)

```solidity
📁 File: contracts/L1/libs/LibDepositing.sol

67:     function processDeposits( 
68:         TaikoData.State storage _state,
69:         TaikoData.Config memory _config,
70:         address _feeRecipient
71:     )
72:         internal
73:         returns (TaikoData.EthDeposit[] memory deposits_)
74:     {
75:         // Calculate the number of pending deposits.
76:         uint256 numPending = _state.slotA.numEthDeposits - _state.slotA.nextEthDepositToProcess;
77: 
78:         if (numPending < _config.ethDepositMinCountPerBlock) {
79:             deposits_ = new TaikoData.EthDeposit[](0);
80:         } else {
81:             deposits_ =
82:                 new TaikoData.EthDeposit[](numPending.min(_config.ethDepositMaxCountPerBlock));
83:             uint96 fee = uint96(_config.ethDepositMaxFee.min(block.basefee * _config.ethDepositGas));
84:             uint64 j = _state.slotA.nextEthDepositToProcess;
85:             uint96 totalFee;
86:             for (uint256 i; i < deposits_.length;) {
87:                 uint256 data = _state.ethDeposits[j % _config.ethDepositRingBufferSize];
88:                 deposits_[i] = TaikoData.EthDeposit({
89:                     recipient: address(uint160(data >> 96)),
90:                     amount: uint96(data),
91:                     id: j
92:                 });
93:                 uint96 _fee = deposits_[i].amount > fee ? fee : deposits_[i].amount;
94: 
95:                 // Unchecked is safe:
96:                 // - _fee cannot be bigger than deposits_[i].amount
97:                 // - all values are in the same range (uint96) except loop
98:                 // counter, which obviously cannot be bigger than uint95
99:                 // otherwise the function would be gassing out.
100:                 unchecked {
101:                     deposits_[i].amount -= _fee;
102:                     totalFee += _fee;
103:                     ++i;
104:                     ++j;
105:                 }
106:             }
107:             _state.slotA.nextEthDepositToProcess = j;
108:             // This is the fee deposit
109:             _state.ethDeposits[_state.slotA.numEthDeposits % _config.ethDepositRingBufferSize] =
110:                 _encodeEthDeposit(_feeRecipient, totalFee);
111: 
112:             // Unchecked is safe:
113:             // - uint64 can store up to ~1.8 * 1e19, which can represent 584K
114:             // years if we are depositing at every second
115:             unchecked {
116:                 _state.slotA.numEthDeposits++;
117:             }
118:         }
119:     }

122:     function canDepositEthToL2( 

/// @audit Parameter of type 'uint256' at index '0'
149:     function _encodeEthDeposit(address _addr, uint256 _amount) private pure returns (uint256) { 
```
[67](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibDepositing.sol#L67-L119), [122](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibDepositing.sol#L122), [149](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibDepositing.sol#L149)

```solidity
📁 File: contracts/L1/libs/LibProposing.sol

68:     function proposeBlock( 
69:         TaikoData.State storage _state,
70:         TaikoData.Config memory _config,
71:         IAddressResolver _resolver,
72:         bytes calldata _data,
73:         bytes calldata _txList
74:     )
75:         internal
76:         returns (TaikoData.BlockMetadata memory meta_, TaikoData.EthDeposit[] memory deposits_)
77:     {
78:         TaikoData.BlockParams memory params = abi.decode(_data, (TaikoData.BlockParams));
79: 
80:         // We need a prover that will submit proofs after the block has been submitted
81:         if (params.assignedProver == address(0)) {
82:             revert L1_INVALID_PROVER();
83:         }
84: 
85:         if (params.coinbase == address(0)) {
86:             params.coinbase = msg.sender;
87:         }
88: 
89:         // Taiko, as a Based Rollup, enables permissionless block proposals.
90:         // However, if the "proposer" address is set to a non-zero value, we
91:         // ensure that only that specific address has the authority to propose
92:         // blocks.
93:         TaikoData.SlotB memory b = _state.slotB;
94:         if (!_isProposerPermitted(b, _resolver)) revert L1_UNAUTHORIZED();
95: 
96:         // It's essential to ensure that the ring buffer for proposed blocks
97:         // still has space for at least one more block.
98:         if (b.numBlocks >= b.lastVerifiedBlockId + _config.blockMaxProposals + 1) {
99:             revert L1_TOO_MANY_BLOCKS();
100:         }
101: 
102:         bytes32 parentMetaHash =
103:             _state.blocks[(b.numBlocks - 1) % _config.blockRingBufferSize].metaHash;
104: 
105:         // Check if parent block has the right meta hash
106:         // This is to allow the proposer to make sure the block builds on the expected latest chain
107:         // state
108:         if (params.parentMetaHash != 0 && parentMetaHash != params.parentMetaHash) {
109:             revert L1_UNEXPECTED_PARENT();
110:         }
111: 
112:         // Each transaction must handle a specific quantity of L1-to-L2
113:         // Ether deposits.
114:         deposits_ = LibDepositing.processDeposits(_state, _config, params.coinbase);
115: 
116:         // Initialize metadata to compute a metaHash, which forms a part of
117:         // the block data to be stored on-chain for future integrity checks.
118:         // If we choose to persist all data fields in the metadata, it will
119:         // require additional storage slots.
120:         unchecked {
121:             meta_ = TaikoData.BlockMetadata({
122:                 l1Hash: blockhash(block.number - 1),
123:                 difficulty: 0, // to be initialized below
124:                 blobHash: 0, // to be initialized below
125:                 extraData: params.extraData,
126:                 depositsHash: keccak256(abi.encode(deposits_)),
127:                 coinbase: params.coinbase,
128:                 id: b.numBlocks,
129:                 gasLimit: _config.blockMaxGasLimit,
130:                 timestamp: uint64(block.timestamp),
131:                 l1Height: uint64(block.number - 1),
132:                 txListByteOffset: 0, // to be initialized below
133:                 txListByteSize: 0, // to be initialized below
134:                 minTier: 0, // to be initialized below
135:                 blobUsed: _txList.length == 0,
136:                 parentMetaHash: parentMetaHash
137:             });
138:         }
139: 
140:         // Update certain meta fields
141:         if (meta_.blobUsed) {
142:             if (!_config.blobAllowedForDA) revert L1_BLOB_FOR_DA_DISABLED();
143: 
144:             if (params.blobHash != 0) {
145:                 if (!_config.blobReuseEnabled) revert L1_BLOB_REUSE_DISABLED();
146: 
147:                 // We try to reuse an old blob
148:                 if (!isBlobReusable(_state, _config, params.blobHash)) {
149:                     revert L1_BLOB_NOT_REUSABLE();
150:                 }
151:                 meta_.blobHash = params.blobHash;
152:             } else {
153:                 // Always use the first blob in this transaction. If the
154:                 // proposeBlock functions are called more than once in the same
155:                 // L1 transaction, these multiple L2 blocks will share the same
156:                 // blob.
157:                 meta_.blobHash = blockhash(0);
158: 
159:                 if (meta_.blobHash == 0) revert L1_BLOB_NOT_FOUND();
160: 
161:                 // Depends on the blob data price, it may not make sense to
162:                 // cache the blob which costs 20,000 (sstore) + 631 (event)
163:                 // extra gas.
164:                 if (_config.blobReuseEnabled && params.cacheBlobForReuse) {
165:                     _state.reusableBlobs[meta_.blobHash] = block.timestamp;
166:                     emit BlobCached(meta_.blobHash);
167:                 }
168:             }
169: 
170:             // Check that the txList data range is within the max size of a blob
171:             if (uint256(params.txListByteOffset) + params.txListByteSize > MAX_BYTES_PER_BLOB) {
172:                 revert L1_TXLIST_OFFSET();
173:             }
174: 
175:             meta_.txListByteOffset = params.txListByteOffset;
176:             meta_.txListByteSize = params.txListByteSize;
177:         } else {
178:             // The proposer must be an Externally Owned Account (EOA) for
179:             // calldata usage. This ensures that the transaction is not an
180:             // internal one, making calldata retrieval more straightforward for
181:             // Taiko node software.
182:             if (!LibAddress.isSenderEOA()) revert L1_PROPOSER_NOT_EOA();
183: 
184:             // The txList is the full byte array without any offset
185:             if (params.txListByteOffset != 0) {
186:                 revert L1_INVALID_PARAM();
187:             }
188: 
189:             meta_.blobHash = keccak256(_txList);
190:             meta_.txListByteOffset = 0;
191:             meta_.txListByteSize = uint24(_txList.length);
192:         }
193: 
194:         // Check that the tx length is non-zero and within the supported range
195:         if (meta_.txListByteSize == 0 || meta_.txListByteSize > _config.blockMaxTxListBytes) {
196:             revert L1_TXLIST_SIZE();
197:         }
198: 
199:         // Following the Merge, the L1 mixHash incorporates the
200:         // prevrandao value from the beacon chain. Given the possibility
201:         // of multiple Taiko blocks being proposed within a single
202:         // Ethereum block, we choose to introduce a salt to this random
203:         // number as the L2 mixHash.
204:         meta_.difficulty = keccak256(abi.encodePacked(block.prevrandao, b.numBlocks, block.number));
205: 
206:         // Use the difficulty as a random number
207:         meta_.minTier = ITierProvider(_resolver.resolve("tier_provider", false)).getMinTier(
208:             uint256(meta_.difficulty)
209:         );
210: 
211:         // Create the block that will be stored onchain
212:         TaikoData.Block memory blk = TaikoData.Block({
213:             metaHash: keccak256(abi.encode(meta_)),
214:             // Safeguard the liveness bond to ensure its preservation,
215:             // particularly in scenarios where it might be altered after the
216:             // block's proposal but before it has been proven or verified.
217:             livenessBond: _config.livenessBond,
218:             blockId: b.numBlocks,
219:             proposedAt: meta_.timestamp,
220:             proposedIn: uint64(block.number),
221:             // For a new block, the next transition ID is always 1, not 0.
222:             nextTransitionId: 1,
223:             // For unverified block, its verifiedTransitionId is always 0.
224:             verifiedTransitionId: 0,
225:             assignedProver: params.assignedProver
226:         });
227: 
228:         // Store the block in the ring buffer
229:         _state.blocks[b.numBlocks % _config.blockRingBufferSize] = blk;
230: 
231:         // Increment the counter (cursor) by 1.
232:         unchecked {
233:             ++_state.slotB.numBlocks;
234:         }
235: 
236:         {
237:             IERC20 tko = IERC20(_resolver.resolve("taiko_token", false));
238:             uint256 tkoBalance = tko.balanceOf(address(this));
239: 
240:             // Run all hooks.
241:             // Note that address(this).balance has been updated with msg.value,
242:             // prior to any code in this function has been executed.
243:             address prevHook;
244:             for (uint256 i; i < params.hookCalls.length; ++i) {
245:                 if (uint160(prevHook) >= uint160(params.hookCalls[i].hook)) {
246:                     revert L1_INVALID_HOOK();
247:                 }
248: 
249:                 // When a hook is called, all ether in this contract will be send to the hook.
250:                 // If the ether sent to the hook is not used entirely, the hook shall send the Ether
251:                 // back to this contract for the next hook to use.
252:                 // Proposers shall choose use extra hooks wisely.
253:                 IHook(params.hookCalls[i].hook).onBlockProposed{ value: address(this).balance }(
254:                     blk, meta_, params.hookCalls[i].data
255:                 );
256: 
257:                 prevHook = params.hookCalls[i].hook;
258:             }
259:             // Refund Ether
260:             if (address(this).balance != 0) {
261:                 msg.sender.sendEther(address(this).balance);
262:             }
263: 
264:             // Check that after hooks, the Taiko Token balance of this contract
265:             // have increased by the same amount as _config.livenessBond (to prevent)
266:             // multiple draining payments by a malicious proposer nesting the same
267:             // hook.
268:             if (tko.balanceOf(address(this)) != tkoBalance + _config.livenessBond) {
269:                 revert L1_LIVENESS_BOND_NOT_RECEIVED();
270:             }
271:         }
272: 
273:         emit BlockProposed({
274:             blockId: blk.blockId,
275:             assignedProver: blk.assignedProver,
276:             livenessBond: _config.livenessBond,
277:             meta: meta_,
278:             depositsProcessed: deposits_
279:         });
280:     }

287:     function isBlobReusable( 

299:     function _isProposerPermitted( 
```
[68](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProposing.sol#L68-L280), [287](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProposing.sol#L287), [299](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProposing.sol#L299)

```solidity
📁 File: contracts/L1/libs/LibProving.sol

91:     function proveBlock( 
92:         TaikoData.State storage _state,
93:         TaikoData.Config memory _config,
94:         IAddressResolver _resolver,
95:         TaikoData.BlockMetadata memory _meta,
96:         TaikoData.Transition memory _tran,
97:         TaikoData.TierProof memory _proof
98:     )
99:         internal
100:         returns (uint8 maxBlocksToVerify_)
101:     {
102:         // Make sure parentHash is not zero
103:         // To contest an existing transition, simply use any non-zero value as
104:         // the blockHash and stateRoot.
105:         if (_tran.parentHash == 0 || _tran.blockHash == 0 || _tran.stateRoot == 0) {
106:             revert L1_INVALID_TRANSITION();
107:         }
108: 
109:         // Check that the block has been proposed but has not yet been verified.
110:         TaikoData.SlotB memory b = _state.slotB;
111:         if (_meta.id <= b.lastVerifiedBlockId || _meta.id >= b.numBlocks) {
112:             revert L1_INVALID_BLOCK_ID();
113:         }
114: 
115:         uint64 slot = _meta.id % _config.blockRingBufferSize;
116:         TaikoData.Block storage blk = _state.blocks[slot];
117: 
118:         // Check the integrity of the block data. It's worth noting that in
119:         // theory, this check may be skipped, but it's included for added
120:         // caution.
121:         if (blk.blockId != _meta.id || blk.metaHash != keccak256(abi.encode(_meta))) {
122:             revert L1_BLOCK_MISMATCH();
123:         }
124: 
125:         // Each transition is uniquely identified by the parentHash, with the
126:         // blockHash and stateRoot open for later updates as higher-tier proofs
127:         // become available. In cases where a transition with the specified
128:         // parentHash does not exist, the transition ID (tid) will be set to 0.
129:         (uint32 tid, TaikoData.TransitionState storage ts) =
130:             _createTransition(_state, blk, _tran, slot);
131: 
132:         // The new proof must meet or exceed the minimum tier required by the
133:         // block or the previous proof; it cannot be on a lower tier.
134:         if (_proof.tier == 0 || _proof.tier < _meta.minTier || _proof.tier < ts.tier) {
135:             revert L1_INVALID_TIER();
136:         }
137: 
138:         // Retrieve the tier configurations. If the tier is not supported, the
139:         // subsequent action will result in a revert.
140:         ITierProvider.Tier memory tier =
141:             ITierProvider(_resolver.resolve("tier_provider", false)).getTier(_proof.tier);
142: 
143:         // Check if this prover is allowed to submit a proof for this block
144:         _checkProverPermission(_state, blk, ts, tid, tier);
145: 
146:         // We must verify the proof, and any failure in proof verification will
147:         // result in a revert.
148:         //
149:         // It's crucial to emphasize that the proof can be assessed in two
150:         // potential modes: "proving mode" and "contesting mode." However, the
151:         // precise verification logic is defined within each tier's IVerifier
152:         // contract implementation. We simply specify to the verifier contract
153:         // which mode it should utilize - if the new tier is higher than the
154:         // previous tier, we employ the proving mode; otherwise, we employ the
155:         // contesting mode (the new tier cannot be lower than the previous tier,
156:         // this has been checked above).
157:         //
158:         // It's obvious that proof verification is entirely decoupled from
159:         // Taiko's core protocol.
160:         {
161:             address verifier = _resolver.resolve(tier.verifierName, true);
162: 
163:             if (verifier != address(0)) {
164:                 bool isContesting = _proof.tier == ts.tier && tier.contestBond != 0;
165: 
166:                 IVerifier.Context memory ctx = IVerifier.Context({
167:                     metaHash: blk.metaHash,
168:                     blobHash: _meta.blobHash,
169:                     // Separate msgSender to allow the prover to be any address in the future.
170:                     prover: msg.sender,
171:                     msgSender: msg.sender,
172:                     blockId: blk.blockId,
173:                     isContesting: isContesting,
174:                     blobUsed: _meta.blobUsed
175:                 });
176: 
177:                 IVerifier(verifier).verifyProof(ctx, _tran, _proof);
178:             } else if (tier.verifierName != TIER_OP) {
179:                 // The verifier can be address-zero, signifying that there are no
180:                 // proof checks for the tier. In practice, this only applies to
181:                 // optimistic proofs.
182:                 revert L1_MISSING_VERIFIER();
183:             }
184:         }
185: 
186:         bool isTopTier = tier.contestBond == 0;
187:         IERC20 tko = IERC20(_resolver.resolve("taiko_token", false));
188: 
189:         if (isTopTier) {
190:             // A special return value from the top tier prover can signal this
191:             // contract to return all liveness bond.
192:             bool returnLivenessBond = blk.livenessBond > 0 && _proof.data.length == 32
193:                 && bytes32(_proof.data) == RETURN_LIVENESS_BOND;
194: 
195:             if (returnLivenessBond) {
196:                 tko.transfer(blk.assignedProver, blk.livenessBond);
197:                 blk.livenessBond = 0;
198:             }
199:         }
200: 
201:         bool sameTransition = _tran.blockHash == ts.blockHash && _tran.stateRoot == ts.stateRoot;
202: 
203:         if (_proof.tier > ts.tier) {
204:             // Handles the case when an incoming tier is higher than the current transition's tier.
205:             // Reverts when the incoming proof tries to prove the same transition
206:             // (L1_ALREADY_PROVED).
207:             _overrideWithHigherProof(ts, _tran, _proof, tier, tko, sameTransition);
208: 
209:             emit TransitionProved({
210:                 blockId: blk.blockId,
211:                 tran: _tran,
212:                 prover: msg.sender,
213:                 validityBond: tier.validityBond,
214:                 tier: _proof.tier
215:             });
216:         } else {
217:             // New transition and old transition on the same tier - and if this transaction tries to
218:             // prove the same, it reverts
219:             if (sameTransition) revert L1_ALREADY_PROVED();
220: 
221:             if (isTopTier) {
222:                 // The top tier prover re-proves.
223:                 assert(tier.validityBond == 0);
224:                 assert(ts.validityBond == 0 && ts.contestBond == 0 && ts.contester == address(0));
225: 
226:                 ts.prover = msg.sender;
227:                 ts.blockHash = _tran.blockHash;
228:                 ts.stateRoot = _tran.stateRoot;
229: 
230:                 emit TransitionProved({
231:                     blockId: blk.blockId,
232:                     tran: _tran,
233:                     prover: msg.sender,
234:                     validityBond: 0,
235:                     tier: _proof.tier
236:                 });
237:             } else {
238:                 // Contesting but not on the highest tier
239:                 if (ts.contester != address(0)) revert L1_ALREADY_CONTESTED();
240: 
241:                 // Burn the contest bond from the prover.
242:                 tko.transferFrom(msg.sender, address(this), tier.contestBond);
243: 
244:                 // We retain the contest bond within the transition, just in
245:                 // case this configuration is altered to a different value
246:                 // before the contest is resolved.
247:                 //
248:                 // It's worth noting that the previous value of ts.contestBond
249:                 // doesn't have any significance.
250:                 ts.contestBond = tier.contestBond;
251:                 ts.contester = msg.sender;
252:                 ts.contestations += 1;
253: 
254:                 emit TransitionContested({
255:                     blockId: blk.blockId,
256:                     tran: _tran,
257:                     contester: msg.sender,
258:                     contestBond: tier.contestBond,
259:                     tier: _proof.tier
260:                 });
261:             }
262:         }
263: 
264:         ts.timestamp = uint64(block.timestamp);
265:         return tier.maxBlocksToVerifyPerProof;
266:     }

269:     function _createTransition( 
270:         TaikoData.State storage _state,
271:         TaikoData.Block storage _blk,
272:         TaikoData.Transition memory _tran,
273:         uint64 slot
274:     )
275:         private
276:         returns (uint32 tid_, TaikoData.TransitionState storage ts_)
277:     {
278:         tid_ = LibUtils.getTransitionId(_state, _blk, slot, _tran.parentHash);
279: 
280:         if (tid_ == 0) {
281:             // In cases where a transition with the provided parentHash is not
282:             // found, we must essentially "create" one and set it to its initial
283:             // state. This initial state can be viewed as a special transition
284:             // on tier-0.
285:             //
286:             // Subsequently, we transform this tier-0 transition into a
287:             // non-zero-tier transition with a proof. This approach ensures that
288:             // the same logic is applicable for both 0-to-non-zero transition
289:             // updates and non-zero-to-non-zero transition updates.
290:             unchecked {
291:                 // Unchecked is safe:  Not realistic 2**32 different fork choice
292:                 // per block will be proven and none of them is valid
293:                 tid_ = _blk.nextTransitionId++;
294:             }
295: 
296:             // Keep in mind that state.transitions are also reusable storage
297:             // slots, so it's necessary to reinitialize all transition fields
298:             // below.
299:             ts_ = _state.transitions[slot][tid_];
300:             ts_.blockHash = 0;
301:             ts_.stateRoot = 0;
302:             ts_.validityBond = 0;
303:             ts_.contester = address(0);
304:             ts_.contestBond = 1; // to save gas
305:             ts_.timestamp = _blk.proposedAt;
306:             ts_.tier = 0;
307:             ts_.contestations = 0;
308: 
309:             if (tid_ == 1) {
310:                 // This approach serves as a cost-saving technique for the
311:                 // majority of blocks, where the first transition is expected to
312:                 // be the correct one. Writing to `tran` is more economical
313:                 // since it resides in the ring buffer, whereas writing to
314:                 // `transitionIds` is not as cost-effective.
315:                 ts_.key = _tran.parentHash;
316: 
317:                 // In the case of this first transition, the block's assigned
318:                 // prover has the privilege to re-prove it, but only when the
319:                 // assigned prover matches the previous prover. To ensure this,
320:                 // we establish the transition's prover as the block's assigned
321:                 // prover. Consequently, when we carry out a 0-to-non-zero
322:                 // transition update, the previous prover will consistently be
323:                 // the block's assigned prover.
324:                 //
325:                 // While alternative implementations are possible, introducing
326:                 // such changes would require additional if-else logic.
327:                 ts_.prover = _blk.assignedProver;
328:             } else {
329:                 // In scenarios where this transition is not the first one, we
330:                 // straightforwardly reset the transition prover to address
331:                 // zero.
332:                 ts_.prover = address(0);
333: 
334:                 // Furthermore, we index the transition for future retrieval.
335:                 // It's worth emphasizing that this mapping for indexing is not
336:                 // reusable. However, given that the majority of blocks will
337:                 // only possess one transition — the correct one — we don't need
338:                 // to be concerned about the cost in this case.
339:                 _state.transitionIds[_blk.blockId][_tran.parentHash] = tid_;
340: 
341:                 // There is no need to initialize ts.key here because it's only used when tid == 1
342:             }
343:         } else {
344:             // A transition with the provided parentHash has been located.
345:             ts_ = _state.transitions[slot][tid_];
346:         }
347:     }
```
[91](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProving.sol#L91-L266), [269](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProving.sol#L269-L347)

```solidity
📁 File: contracts/L1/libs/LibUtils.sol

23:     function getTransition( 

52:     function getBlock( 
53:         TaikoData.State storage _state,
54:         TaikoData.Config memory _config,
55:         uint64 _blockId
56:     )
57:         external
58:         view
59:         returns (TaikoData.Block storage blk_, uint64 slot_)
60:     {
61:         slot_ = _blockId % _config.blockRingBufferSize;
62:         blk_ = _state.blocks[slot_];
63:         if (blk_.blockId != _blockId) {
64:             revert L1_INVALID_BLOCK_ID();
65:         }
66:     }

70:     function getTransitionId( 
71:         TaikoData.State storage _state,
72:         TaikoData.Block storage _blk,
73:         uint64 _slot,
74:         bytes32 _parentHash
75:     )
76:         internal
77:         view
78:         returns (uint32 tid_)
79:     {
80:         if (_state.transitions[_slot][1].key == _parentHash) {
81:             tid_ = 1;
82:         } else {
83:             tid_ = _state.transitionIds[_blk.blockId][_parentHash];
84:         }
85: 
86:         if (tid_ >= _blk.nextTransitionId) revert L1_UNEXPECTED_TRANSITION_ID();
87:     }
```
[23](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibUtils.sol#L23), [52](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibUtils.sol#L52-L66), [70](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibUtils.sol#L70-L87)

```solidity
📁 File: contracts/L1/libs/LibVerifying.sol

/// @audit Parameter of type 'bool' at index '0'
245:     function _isConfigValid(TaikoData.Config memory _config) private view returns (bool) { 
```
[245](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibVerifying.sol#L245)

```solidity
📁 File: contracts/L1/provers/GuardianProver.sol

35:     function approve( 
36:         TaikoData.BlockMetadata calldata _meta,
37:         TaikoData.Transition calldata _tran,
38:         TaikoData.TierProof calldata _proof
39:     )
40:         external
41:         whenNotPaused
42:         nonReentrant
43:         returns (bool approved_)
44:     {
45:         if (_proof.tier != LibTiers.TIER_GUARDIAN) revert INVALID_PROOF();
46:         bytes32 hash = keccak256(abi.encode(_meta, _tran));
47:         approved_ = approve(_meta.id, hash);
48: 
49:         if (approved_) {
50:             deleteApproval(hash);
51:             ITaikoL1(resolve("taiko", false)).proveBlock(_meta.id, abi.encode(_meta, _tran, _proof));
52:         }
53: 
54:         emit GuardianApproval(msg.sender, _meta.id, _tran.blockHash, approved_);
55:     }
```
[35](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/provers/GuardianProver.sol#L35-L55)

```solidity
📁 File: contracts/L1/provers/Guardians.sol

/// @audit Parameter of type 'bool' at index '0'
101:     function isApproved(bytes32 _hash) public view returns (bool) { 

/// @audit Parameter of type 'uint256' at index '0'
107:     function numGuardians() public view returns (uint256) { 

111:     function approve(uint256 _operationId, bytes32 _hash) internal returns (bool approved_) { 
112:         uint256 id = guardianIds[msg.sender];
113:         if (id == 0) revert INVALID_GUARDIAN();
114: 
115:         unchecked {
116:             _approvals[version][_hash] |= 1 << (id - 1);
117:         }
118: 
119:         uint256 _approval = _approvals[version][_hash];
120:         approved_ = isApproved(_approval);
121:         emit Approved(_operationId, _approval, approved_);
122:     }

/// @audit Parameter of type 'bool' at index '0'
128:     function isApproved(uint256 _approvalBits) internal view returns (bool) { 
```
[101](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/provers/Guardians.sol#L101), [107](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/provers/Guardians.sol#L107), [111](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/provers/Guardians.sol#L111-L122), [128](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/provers/Guardians.sol#L128)

```solidity
📁 File: contracts/L1/tiers/DevnetTierProvider.sol

/// @audit Parameter of type 'struct ITierProvider.Tier' at index '0'
20:     function getTier(uint16 _tierId) public pure override returns (ITierProvider.Tier memory) { 

47:     function getTierIds() public pure override returns (uint16[] memory tiers_) { 
48:         tiers_ = new uint16[](2);
49:         tiers_[0] = LibTiers.TIER_OPTIMISTIC;
50:         tiers_[1] = LibTiers.TIER_GUARDIAN;
51:     }

/// @audit Parameter of type 'uint16' at index '0'
54:     function getMinTier(uint256) public pure override returns (uint16) { 
```
[20](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/tiers/DevnetTierProvider.sol#L20), [47](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/tiers/DevnetTierProvider.sol#L47-L51), [54](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/tiers/DevnetTierProvider.sol#L54)

```solidity
📁 File: contracts/L1/tiers/ITierProvider.sol

/// @audit Parameter of type 'struct ITierProvider.Tier' at index '0'
22:     function getTier(uint16 tierId) external view returns (Tier memory); 

/// @audit Parameter of type 'uint16[]' at index '0'
28:     function getTierIds() external view returns (uint16[] memory); 

/// @audit Parameter of type 'uint16' at index '0'
33:     function getMinTier(uint256 rand) external view returns (uint16); 
```
[22](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/tiers/ITierProvider.sol#L22), [28](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/tiers/ITierProvider.sol#L28), [33](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/tiers/ITierProvider.sol#L33)

```solidity
📁 File: contracts/L1/tiers/MainnetTierProvider.sol

/// @audit Parameter of type 'struct ITierProvider.Tier' at index '0'
20:     function getTier(uint16 _tierId) public pure override returns (ITierProvider.Tier memory) { 

58:     function getTierIds() public pure override returns (uint16[] memory tiers_) { 
59:         tiers_ = new uint16[](3);
60:         tiers_[0] = LibTiers.TIER_SGX;
61:         tiers_[1] = LibTiers.TIER_SGX_ZKVM;
62:         tiers_[2] = LibTiers.TIER_GUARDIAN;
63:     }

/// @audit Parameter of type 'uint16' at index '0'
66:     function getMinTier(uint256 _rand) public pure override returns (uint16) { 
```
[20](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/tiers/MainnetTierProvider.sol#L20), [58](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/tiers/MainnetTierProvider.sol#L58-L63), [66](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/tiers/MainnetTierProvider.sol#L66)

```solidity
📁 File: contracts/L1/tiers/TestnetTierProvider.sol

/// @audit Parameter of type 'struct ITierProvider.Tier' at index '0'
20:     function getTier(uint16 _tierId) public pure override returns (ITierProvider.Tier memory) { 

58:     function getTierIds() public pure override returns (uint16[] memory tiers_) { 
59:         tiers_ = new uint16[](3);
60:         tiers_[0] = LibTiers.TIER_OPTIMISTIC;
61:         tiers_[1] = LibTiers.TIER_SGX;
62:         tiers_[2] = LibTiers.TIER_GUARDIAN;
63:     }

/// @audit Parameter of type 'uint16' at index '0'
66:     function getMinTier(uint256 _rand) public pure override returns (uint16) { 
```
[20](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/tiers/TestnetTierProvider.sol#L20), [58](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/tiers/TestnetTierProvider.sol#L58-L63), [66](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/tiers/TestnetTierProvider.sol#L66)

```solidity
📁 File: contracts/L2/Lib1559Math.sol

16:     function basefee( 

33:     function _ethQty( 
```
[16](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/Lib1559Math.sol#L16), [33](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/Lib1559Math.sol#L33)

```solidity
📁 File: contracts/L2/TaikoL2.sol

185:     function getBasefee( 
186:         uint64 _l1BlockId,
187:         uint32 _parentGasUsed
188:     )
189:         public
190:         view
191:         returns (uint256 basefee_)
192:     {
193:         (basefee_,) = _calc1559BaseFee(getConfig(), _l1BlockId, _parentGasUsed);
194:     }

/// @audit Parameter of type 'bytes32' at index '0'
200:     function getBlockHash(uint64 _blockId) public view returns (bytes32) { 

208:     function getConfig() public view virtual returns (Config memory config_) { 
209:         // 4x Ethereum gas target, if we assume most of the time, L2 block time
210:         // is 3s, and each block is full (gasUsed is 15_000_000), then its
211:         // ~60_000_000, if the  network is congester than that, the base fee
212:         // will increase.
213:         config_.gasTargetPerL1Block = 15 * 1e6 * 4;
214:         config_.basefeeAdjustmentQuotient = 8;
215:     }

/// @audit Parameter of type 'bool' at index '0'
219:     function skipFeeCheck() public pure virtual returns (bool) { 

223:     function _calcPublicInputHash(uint256 _blockId) 
224:         private
225:         view
226:         returns (bytes32 publicInputHashOld, bytes32 publicInputHashNew)
227:     {
228:         bytes32[256] memory inputs;
229: 
230:         // Unchecked is safe because it cannot overflow.
231:         unchecked {
232:             // Put the previous 255 blockhashes (excluding the parent's) into a
233:             // ring buffer.
234:             for (uint256 i; i < 255 && _blockId >= i + 1; ++i) {
235:                 uint256 j = _blockId - i - 1;
236:                 inputs[j % 255] = blockhash(j);
237:             }
238:         }
239: 
240:         inputs[255] = bytes32(block.chainid);
241: 
242:         assembly {
243:             publicInputHashOld := keccak256(inputs, 8192 /*mul(256, 32)*/ )
244:         }
245: 
246:         inputs[_blockId % 255] = blockhash(_blockId);
247:         assembly {
248:             publicInputHashNew := keccak256(inputs, 8192 /*mul(256, 32)*/ )
249:         }
250:     }

252:     function _calc1559BaseFee( 
253:         Config memory _config,
254:         uint64 _l1BlockId,
255:         uint32 _parentGasUsed
256:     )
257:         private
258:         view
259:         returns (uint256 basefee_, uint64 gasExcess_)
260:     {
261:         // gasExcess being 0 indicate the dynamic 1559 base fee is disabled.
262:         if (gasExcess > 0) {
263:             // We always add the gas used by parent block to the gas excess
264:             // value as this has already happened
265:             uint256 excess = uint256(gasExcess) + _parentGasUsed;
266: 
267:             // Calculate how much more gas to issue to offset gas excess.
268:             // after each L1 block time, config.gasTarget more gas is issued,
269:             // the gas excess will be reduced accordingly.
270:             // Note that when lastSyncedBlock is zero, we skip this step
271:             // because that means this is the first time calculating the basefee
272:             // and the difference between the L1 height would be extremely big,
273:             // reverting the initial gas excess value back to 0.
274:             uint256 numL1Blocks;
275:             if (lastSyncedBlock > 0 && _l1BlockId > lastSyncedBlock) {
276:                 numL1Blocks = _l1BlockId - lastSyncedBlock;
277:             }
278: 
279:             if (numL1Blocks > 0) {
280:                 uint256 issuance = numL1Blocks * _config.gasTargetPerL1Block;
281:                 excess = excess > issuance ? excess - issuance : 1;
282:             }
283: 
284:             gasExcess_ = uint64(excess.min(type(uint64).max));
285: 
286:             // The base fee per gas used by this block is the spot price at the
287:             // bonding curve, regardless the actual amount of gas used by this
288:             // block, however, this block's gas used will affect the next
289:             // block's base fee.
290:             basefee_ = Lib1559Math.basefee(
291:                 gasExcess_, uint256(_config.basefeeAdjustmentQuotient) * _config.gasTargetPerL1Block
292:             );
293:         }
294: 
295:         // Always make sure basefee is nonzero, this is required by the node.
296:         if (basefee_ == 0) basefee_ = 1;
297:     }
```
[185](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/TaikoL2.sol#L185-L194), [200](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/TaikoL2.sol#L200), [208](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/TaikoL2.sol#L208-L215), [219](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/TaikoL2.sol#L219), [223](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/TaikoL2.sol#L223-L250), [252](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/TaikoL2.sol#L252-L297)

```solidity
📁 File: contracts/L2/TaikoL2EIP1559Configurable.sol

/// @audit Parameter of type 'struct TaikoL2.Config' at index '0'
43:     function getConfig() public view override returns (Config memory) { 
```
[43](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/TaikoL2EIP1559Configurable.sol#L43)

```solidity
📁 File: contracts/automata-attestation/AutomataDcapV3Attestation.sol

126:     function _attestationTcbIsValid(TCBInfoStruct.TCBStatus status) 
127:         internal
128:         pure
129:         virtual
130:         returns (bool valid)
131:     {
132:         return status == TCBInfoStruct.TCBStatus.OK
133:             || status == TCBInfoStruct.TCBStatus.TCB_SW_HARDENING_NEEDED
134:             || status == TCBInfoStruct.TCBStatus.TCB_CONFIGURATION_AND_SW_HARDENING_NEEDED
135:             || status == TCBInfoStruct.TCBStatus.TCB_OUT_OF_DATE_CONFIGURATION_NEEDED;
136:     }

/// @audit Parameter of type 'bool' at index '0'
138:     function verifyAttestation(bytes calldata data) external view override returns (bool) { 

/// @audit Parameter of type 'bool' at index '0'
/// @audit Parameter of type 'bytes' at index '1'
162:     function _verify(bytes calldata quote) private view returns (bool, bytes memory) { 

175:     function _verifyQEReportWithIdentity(V3Struct.EnclaveReport memory quoteEnclaveReport) 
176:         private
177:         view
/// @audit Parameter of type 'bool' at index '0'
178:         returns (bool, EnclaveIdStruct.EnclaveIdStatus status)
179:     {
180:         EnclaveIdStruct.EnclaveId memory enclaveId = qeIdentity;
181:         bool miscselectMatched =
182:             quoteEnclaveReport.miscSelect & enclaveId.miscselectMask == enclaveId.miscselect;
183: 
184:         bool attributesMatched =
185:             quoteEnclaveReport.attributes & enclaveId.attributesMask == enclaveId.attributes;
186:         bool mrsignerMatched = quoteEnclaveReport.mrSigner == enclaveId.mrsigner;
187: 
188:         bool isvprodidMatched = quoteEnclaveReport.isvProdId == enclaveId.isvprodid;
189: 
190:         bool tcbFound;
191:         for (uint256 i; i < enclaveId.tcbLevels.length; ++i) {
192:             EnclaveIdStruct.TcbLevel memory tcb = enclaveId.tcbLevels[i];
193:             if (tcb.tcb.isvsvn <= quoteEnclaveReport.isvSvn) {
194:                 tcbFound = true;
195:                 status = tcb.tcbStatus;
196:                 break;
197:             }
198:         }
199:         return (
200:             miscselectMatched && attributesMatched && mrsignerMatched && isvprodidMatched
201:                 && tcbFound,
202:             status
203:         );
204:     }

206:     function _checkTcbLevels( 
207:         IPEMCertChainLib.PCKCertificateField memory pck,
208:         TCBInfoStruct.TCBInfo memory tcb
209:     )
210:         private
211:         pure
/// @audit Parameter of type 'bool' at index '0'
212:         returns (bool, TCBInfoStruct.TCBStatus status)
213:     {
214:         for (uint256 i; i < tcb.tcbLevels.length; ++i) {
215:             TCBInfoStruct.TCBLevelObj memory current = tcb.tcbLevels[i];
216:             bool pceSvnIsHigherOrGreater = pck.sgxExtension.pcesvn >= current.pcesvn;
217:             bool cpuSvnsAreHigherOrGreater = _isCpuSvnHigherOrGreater(
218:                 pck.sgxExtension.sgxTcbCompSvnArr, current.sgxTcbCompSvnArr
219:             );
220:             if (pceSvnIsHigherOrGreater && cpuSvnsAreHigherOrGreater) {
221:                 status = current.status;
222:                 bool tcbIsRevoked = status == TCBInfoStruct.TCBStatus.TCB_REVOKED;
223:                 return (!tcbIsRevoked, status);
224:             }
225:         }
226:         return (true, TCBInfoStruct.TCBStatus.TCB_UNRECOGNIZED);
227:     }

229:     function _isCpuSvnHigherOrGreater( 

248:     function _verifyCertChain(IPEMCertChainLib.ECSha256Certificate[] memory certs) 

303:     function _enclaveReportSigVerification( 

355:     function verifyParsedQuote(V3Struct.ParsedV3QuoteStruct calldata v3quote) 

364:     function _verifyParsedQuote(V3Struct.ParsedV3QuoteStruct memory v3quote) 
```
[126](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/AutomataDcapV3Attestation.sol#L126-L136), [138](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/AutomataDcapV3Attestation.sol#L138), [162](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/AutomataDcapV3Attestation.sol#L162), [175](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/AutomataDcapV3Attestation.sol#L175-L204), [206](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/AutomataDcapV3Attestation.sol#L206-L227), [229](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/AutomataDcapV3Attestation.sol#L229), [248](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/AutomataDcapV3Attestation.sol#L248), [303](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/AutomataDcapV3Attestation.sol#L303), [355](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/AutomataDcapV3Attestation.sol#L355), [364](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/AutomataDcapV3Attestation.sol#L364)

```solidity
📁 File: contracts/automata-attestation/interfaces/IAttestation.sol

/// @audit Parameter of type 'bool' at index '0'
9:     function verifyAttestation(bytes calldata data) external returns (bool); 
10:     function verifyParsedQuote(V3Struct.ParsedV3QuoteStruct calldata v3quote)
11:         external
12:         returns (bool success, bytes memory retData);
```
[9](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/interfaces/IAttestation.sol#L9-L12)

```solidity
📁 File: contracts/automata-attestation/interfaces/ISigVerifyLib.sol

38:     function verifyAttStmtSignature( 

48:     function verifyCertificateSignature( 

58:     function verifyRS256Signature( 
59:         bytes memory tbs,
60:         bytes memory signature,
61:         bytes memory publicKey
62:     )
63:         external
64:         view
65:         returns (bool sigValid);

67:     function verifyRS1Signature( 
68:         bytes memory tbs,
69:         bytes memory signature,
70:         bytes memory publicKey
71:     )
72:         external
73:         view
74:         returns (bool sigValid);

76:     function verifyES256Signature( 
77:         bytes memory tbs,
78:         bytes memory signature,
79:         bytes memory publicKey
80:     )
81:         external
82:         view
83:         returns (bool sigValid);
```
[38](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/interfaces/ISigVerifyLib.sol#L38), [48](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/interfaces/ISigVerifyLib.sol#L48), [58](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/interfaces/ISigVerifyLib.sol#L58-L65), [67](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/interfaces/ISigVerifyLib.sol#L67-L74), [76](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/interfaces/ISigVerifyLib.sol#L76-L83)

```solidity
📁 File: contracts/automata-attestation/lib/PEMCertChainLib.sol

40:     function splitCertificateChain( 
41:         bytes memory pemChain,
42:         uint256 size
43:     )
44:         external
45:         pure
46:         returns (bool success, bytes[] memory certs)
47:     {
48:         certs = new bytes[](size);
49:         string memory pemChainStr = string(pemChain);
50: 
51:         uint256 index = 0;
52:         uint256 len = pemChain.length;
53: 
54:         for (uint256 i; i < size; ++i) {
55:             string memory input;
56:             if (i > 0) {
57:                 input = LibString.slice(pemChainStr, index, index + len);
58:             } else {
59:                 input = pemChainStr;
60:             }
61:             uint256 increment;
62:             (success, certs[i], increment) = _removeHeadersAndFooters(input);
63: 
64:             if (!success) {
65:                 return (false, certs);
66:             }
67: 
68:             index += increment;
69:         }
70: 
71:         success = true;
72:     }

74:     function decodeCert( 
75:         bytes memory der,
76:         bool isPckCert
77:     )
78:         external
79:         pure
80:         returns (bool success, ECSha256Certificate memory cert)
81:     {
82:         uint256 root = der.root();
83: 
84:         // Entering tbsCertificate sequence
85:         uint256 tbsParentPtr = der.firstChildOf(root);
86: 
87:         // Begin iterating through the descendants of tbsCertificate
88:         uint256 tbsPtr = der.firstChildOf(tbsParentPtr);
89: 
90:         // The Serial Number is located one element below Version
91: 
92:         // The issuer commonName value is contained in the Issuer sequence
93:         // which is 3 elements below the first element of the tbsCertificate sequence
94: 
95:         // The Validity sequence is located 4 elements below the first element of the tbsCertificate
96:         // sequence
97: 
98:         // The subject commanName value is contained in the Subject sequence
99:         // which is 5 elements below the first element of the tbsCertificate sequence
100: 
101:         // The PublicKey is located in the second element of subjectPublicKeyInfo sequence
102:         // which is 6 elements below the first element of the tbsCertificate sequence
103: 
104:         tbsPtr = der.nextSiblingOf(tbsPtr);
105: 
106:         {
107:             bytes memory serialNumBytes = der.bytesAt(tbsPtr);
108:             cert.serialNumber = serialNumBytes;
109:         }
110: 
111:         tbsPtr = der.nextSiblingOf(tbsPtr);
112:         tbsPtr = der.nextSiblingOf(tbsPtr);
113: 
114:         if (isPckCert) {
115:             uint256 issuerPtr = der.firstChildOf(tbsPtr);
116:             issuerPtr = der.firstChildOf(issuerPtr);
117:             issuerPtr = der.firstChildOf(issuerPtr);
118:             issuerPtr = der.nextSiblingOf(issuerPtr);
119:             cert.pck.issuerName = string(der.bytesAt(issuerPtr));
120:             bool issuerNameIsValid = LibString.eq(cert.pck.issuerName, PLATFORM_ISSUER_NAME)
121:                 || LibString.eq(cert.pck.issuerName, PROCESSOR_ISSUER_NAME);
122:             if (!issuerNameIsValid) {
123:                 return (false, cert);
124:             }
125:         }
126: 
127:         tbsPtr = der.nextSiblingOf(tbsPtr);
128: 
129:         {
130:             uint256 notBeforePtr = der.firstChildOf(tbsPtr);
131:             uint256 notAfterPtr = der.nextSiblingOf(notBeforePtr);
132:             bytes1 notBeforeTag = der[notBeforePtr.ixs()];
133:             bytes1 notAfterTag = der[notAfterPtr.ixs()];
134:             if (
135:                 (notBeforeTag != 0x17 && notBeforeTag == 0x18)
136:                     || (notAfterTag != 0x17 && notAfterTag != 0x18)
137:             ) {
138:                 return (false, cert);
139:             }
140:             cert.notBefore = X509DateUtils.toTimestamp(der.bytesAt(notBeforePtr));
141:             cert.notAfter = X509DateUtils.toTimestamp(der.bytesAt(notAfterPtr));
142:         }
143: 
144:         tbsPtr = der.nextSiblingOf(tbsPtr);
145: 
146:         if (isPckCert) {
147:             uint256 subjectPtr = der.firstChildOf(tbsPtr);
148:             subjectPtr = der.firstChildOf(subjectPtr);
149:             subjectPtr = der.firstChildOf(subjectPtr);
150:             subjectPtr = der.nextSiblingOf(subjectPtr);
151:             cert.pck.commonName = string(der.bytesAt(subjectPtr));
152:             if (!LibString.eq(cert.pck.commonName, PCK_COMMON_NAME)) {
153:                 return (false, cert);
154:             }
155:         }
156: 
157:         tbsPtr = der.nextSiblingOf(tbsPtr);
158: 
159:         {
160:             // Entering subjectPublicKeyInfo sequence
161:             uint256 subjectPublicKeyInfoPtr = der.firstChildOf(tbsPtr);
162:             subjectPublicKeyInfoPtr = der.nextSiblingOf(subjectPublicKeyInfoPtr);
163: 
164:             // The Signature sequence is located two sibling elements below the tbsCertificate
165:             // element
166:             uint256 sigPtr = der.nextSiblingOf(tbsParentPtr);
167:             sigPtr = der.nextSiblingOf(sigPtr);
168: 
169:             // Skip three bytes to the right
170:             // the three bytes in question: 0x034700 or 0x034800 or 0x034900
171:             sigPtr = NodePtr.getPtr(sigPtr.ixs() + 3, sigPtr.ixf() + 3, sigPtr.ixl());
172: 
173:             sigPtr = der.firstChildOf(sigPtr);
174:             bytes memory sigX = _trimBytes(der.bytesAt(sigPtr), 32);
175: 
176:             sigPtr = der.nextSiblingOf(sigPtr);
177:             bytes memory sigY = _trimBytes(der.bytesAt(sigPtr), 32);
178: 
179:             cert.tbsCertificate = der.allBytesAt(tbsParentPtr);
180:             cert.pubKey = _trimBytes(der.bytesAt(subjectPublicKeyInfoPtr), 64);
181:             cert.signature = abi.encodePacked(sigX, sigY);
182:         }
183: 
184:         if (isPckCert) {
185:             // entering Extension sequence
186:             tbsPtr = der.nextSiblingOf(tbsPtr);
187: 
188:             // check for the extension tag
189:             if (der[tbsPtr.ixs()] != 0xA3) {
190:                 return (false, cert);
191:             }
192: 
193:             tbsPtr = der.firstChildOf(tbsPtr);
194:             tbsPtr = der.firstChildOf(tbsPtr);
195: 
196:             bool sgxExtnTraversedSuccessfully;
197:             uint256 pcesvn;
198:             uint256[] memory cpuSvns;
199:             bytes memory fmspcBytes;
200:             bytes memory pceidBytes;
201:             (sgxExtnTraversedSuccessfully, pcesvn, cpuSvns, fmspcBytes, pceidBytes) =
202:                 _findPckTcbInfo(der, tbsPtr, tbsParentPtr);
203:             if (!sgxExtnTraversedSuccessfully) {
204:                 return (false, cert);
205:             }
206:             cert.pck.sgxExtension.pcesvn = pcesvn;
207:             cert.pck.sgxExtension.sgxTcbCompSvnArr = cpuSvns;
208:             cert.pck.sgxExtension.pceid = LibString.toHexStringNoPrefix(pceidBytes);
209:             cert.pck.sgxExtension.fmspc = LibString.toHexStringNoPrefix(fmspcBytes);
210:             cert.isPck = true;
211:         }
212: 
213:         success = true;
214:     }

216:     function _removeHeadersAndFooters(string memory pemData) 
217:         private
218:         pure
219:         returns (bool success, bytes memory extracted, uint256 endIndex)
220:     {
221:         // Check if the input contains the "BEGIN" and "END" headers
222:         uint256 beginPos = LibString.indexOf(pemData, HEADER);
223:         uint256 endPos = LibString.indexOf(pemData, FOOTER);
224: 
225:         bool headerFound = beginPos != LibString.NOT_FOUND;
226:         bool footerFound = endPos != LibString.NOT_FOUND;
227: 
228:         if (!headerFound || !footerFound) {
229:             return (false, extracted, endIndex);
230:         }
231: 
232:         // Extract the content between the headers
233:         uint256 contentStart = beginPos + HEADER_LENGTH;
234: 
235:         // Extract and return the content
236:         bytes memory contentBytes;
237: 
238:         // do not include newline
239:         bytes memory delimiter = hex"0a";
240:         string memory contentSlice = LibString.slice(pemData, contentStart, endPos);
241:         string[] memory split = LibString.split(contentSlice, string(delimiter));
242:         string memory contentStr;
243: 
244:         for (uint256 i; i < split.length; ++i) {
245:             contentStr = LibString.concat(contentStr, split[i]);
246:         }
247: 
248:         contentBytes = bytes(contentStr);
249:         return (true, contentBytes, endPos + FOOTER_LENGTH);
250:     }

252:     function _trimBytes( 
253:         bytes memory input,
254:         uint256 expectedLength
255:     )
256:         private
257:         pure
258:         returns (bytes memory output)
259:     {
260:         uint256 n = input.length;
261: 
262:         if (n <= expectedLength) {
263:             return input;
264:         }
265:         uint256 lengthDiff = n - expectedLength;
266:         output = input.substring(lengthDiff, expectedLength);
267:     }

269:     function _findPckTcbInfo( 
270:         bytes memory der,
271:         uint256 tbsPtr,
272:         uint256 tbsParentPtr
273:     )
274:         private
275:         pure
276:         returns (
277:             bool success,
278:             uint256 pcesvn,
279:             uint256[] memory cpusvns,
280:             bytes memory fmspcBytes,
281:             bytes memory pceidBytes
282:         )
283:     {
284:         // iterate through the elements in the Extension sequence
285:         // until we locate the SGX Extension OID
286:         while (tbsPtr != 0) {
287:             uint256 internalPtr = der.firstChildOf(tbsPtr);
288:             if (der[internalPtr.ixs()] != 0x06) {
289:                 return (false, pcesvn, cpusvns, fmspcBytes, pceidBytes);
290:             }
291: 
292:             if (BytesUtils.compareBytes(der.bytesAt(internalPtr), SGX_EXTENSION_OID)) {
293:                 // 1.2.840.113741.1.13.1
294:                 internalPtr = der.nextSiblingOf(internalPtr);
295:                 uint256 extnValueParentPtr = der.rootOfOctetStringAt(internalPtr);
296:                 uint256 extnValuePtr = der.firstChildOf(extnValueParentPtr);
297: 
298:                 // Copy flags to memory to avoid stack too deep
299:                 PCKTCBFlags memory flags;
300: 
301:                 while (!(flags.fmspcFound && flags.pceidFound && flags.tcbFound)) {
302:                     uint256 extnValueOidPtr = der.firstChildOf(extnValuePtr);
303:                     if (der[extnValueOidPtr.ixs()] != 0x06) {
304:                         return (false, pcesvn, cpusvns, fmspcBytes, pceidBytes);
305:                     }
306:                     if (BytesUtils.compareBytes(der.bytesAt(extnValueOidPtr), TCB_OID)) {
307:                         // 1.2.840.113741.1.13.1.2
308:                         (flags.tcbFound, pcesvn, cpusvns) = _findTcb(der, extnValueOidPtr);
309:                     }
310:                     if (BytesUtils.compareBytes(der.bytesAt(extnValueOidPtr), PCEID_OID)) {
311:                         // 1.2.840.113741.1.13.1.3
312:                         uint256 pceidPtr = der.nextSiblingOf(extnValueOidPtr);
313:                         pceidBytes = der.bytesAt(pceidPtr);
314:                         flags.pceidFound = true;
315:                     }
316:                     if (BytesUtils.compareBytes(der.bytesAt(extnValueOidPtr), FMSPC_OID)) {
317:                         // 1.2.840.113741.1.13.1.4
318:                         uint256 fmspcPtr = der.nextSiblingOf(extnValueOidPtr);
319:                         fmspcBytes = der.bytesAt(fmspcPtr);
320:                         flags.fmspcFound = true;
321:                     }
322: 
323:                     if (extnValuePtr.ixl() < extnValueParentPtr.ixl()) {
324:                         extnValuePtr = der.nextSiblingOf(extnValuePtr);
325:                     } else {
326:                         break;
327:                     }
328:                 }
329:                 success = flags.fmspcFound && flags.pceidFound && flags.tcbFound;
330:                 break;
331:             }
332: 
333:             if (tbsPtr.ixl() < tbsParentPtr.ixl()) {
334:                 tbsPtr = der.nextSiblingOf(tbsPtr);
335:             } else {
336:                 tbsPtr = 0; // exit
337:             }
338:         }
339:     }

341:     function _findTcb( 
342:         bytes memory der,
343:         uint256 oidPtr
344:     )
345:         private
346:         pure
347:         returns (bool success, uint256 pcesvn, uint256[] memory cpusvns)
348:     {
349:         // sibiling of tcbOid
350:         uint256 tcbPtr = der.nextSiblingOf(oidPtr);
351:         // get the first svn object in the sequence
352:         uint256 svnParentPtr = der.firstChildOf(tcbPtr);
353:         cpusvns = new uint256[](SGX_TCB_CPUSVN_SIZE);
354:         for (uint256 i; i < SGX_TCB_CPUSVN_SIZE + 1; ++i) {
355:             uint256 svnPtr = der.firstChildOf(svnParentPtr); // OID
356:             uint256 svnValuePtr = der.nextSiblingOf(svnPtr); // value
357:             bytes memory svnValueBytes = der.bytesAt(svnValuePtr);
358:             uint16 svnValue = svnValueBytes.length < 2
359:                 ? uint16(bytes2(svnValueBytes)) / 256
360:                 : uint16(bytes2(svnValueBytes));
361:             if (BytesUtils.compareBytes(der.bytesAt(svnPtr), PCESVN_OID)) {
362:                 // pcesvn is 4 bytes in size
363:                 pcesvn = uint256(svnValue);
364:             } else {
365:                 // each cpusvn is at maximum two bytes in size
366:                 uint256 cpusvn = uint256(svnValue);
367:                 cpusvns[i] = cpusvn;
368:             }
369: 
370:             // iterate to the next svn object in the sequence
371:             svnParentPtr = der.nextSiblingOf(svnParentPtr);
372:         }
373:         success = true;
374:     }
```
[40](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/PEMCertChainLib.sol#L40-L72), [74](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/PEMCertChainLib.sol#L74-L214), [216](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/PEMCertChainLib.sol#L216-L250), [252](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/PEMCertChainLib.sol#L252-L267), [269](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/PEMCertChainLib.sol#L269-L339), [341](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/PEMCertChainLib.sol#L341-L374)

```solidity
📁 File: contracts/automata-attestation/lib/QuoteV3Auth/V3Parser.sol

21:     function parseInput( 
22:         bytes memory quote,
23:         address pemCertLibAddr
24:     )
25:         internal
26:         pure
27:         returns (bool success, V3Struct.ParsedV3QuoteStruct memory v3ParsedQuote)
28:     {
29:         if (quote.length <= MINIMUM_QUOTE_LENGTH) {
30:             return (false, v3ParsedQuote);
31:         }
32: 
33:         uint256 localAuthDataSize = littleEndianDecode(quote.substring(432, 4));
34:         if (quote.length - 436 != localAuthDataSize) {
35:             return (false, v3ParsedQuote);
36:         }
37: 
38:         bytes memory rawHeader = quote.substring(0, 48);
39:         (bool headerVerifiedSuccessfully, V3Struct.Header memory header) =
40:             parseAndVerifyHeader(rawHeader);
41:         if (!headerVerifiedSuccessfully) {
42:             return (false, v3ParsedQuote);
43:         }
44: 
45:         (bool authDataVerifiedSuccessfully, V3Struct.ECDSAQuoteV3AuthData memory authDataV3) =
46:             parseAuthDataAndVerifyCertType(quote.substring(436, localAuthDataSize), pemCertLibAddr);
47:         if (!authDataVerifiedSuccessfully) {
48:             return (false, v3ParsedQuote);
49:         }
50: 
51:         bytes memory rawLocalEnclaveReport = quote.substring(48, 384);
52:         V3Struct.EnclaveReport memory localEnclaveReport = parseEnclaveReport(rawLocalEnclaveReport);
53: 
54:         v3ParsedQuote = V3Struct.ParsedV3QuoteStruct({
55:             header: header,
56:             localEnclaveReport: localEnclaveReport,
57:             v3AuthData: authDataV3
58:         });
59:         success = true;
60:     }

62:     function validateParsedInput(V3Struct.ParsedV3QuoteStruct memory v3Quote) 
63:         internal
64:         pure
65:         returns (
66:             bool success,
67:             V3Struct.Header memory header,
68:             V3Struct.EnclaveReport memory localEnclaveReport,
69:             bytes memory signedQuoteData, // concatenation of header and local enclave report bytes
70:             V3Struct.ECDSAQuoteV3AuthData memory authDataV3
71:         )
72:     {
73:         success = true;
74:         localEnclaveReport = v3Quote.localEnclaveReport;
75:         V3Struct.EnclaveReport memory pckSignedQeReport = v3Quote.v3AuthData.pckSignedQeReport;
76: 
77:         require(
78:             localEnclaveReport.reserved3.length == 96 && localEnclaveReport.reserved4.length == 60
79:                 && localEnclaveReport.reportData.length == 64,
80:             "local QE report has wrong length"
81:         );
82:         require(
83:             pckSignedQeReport.reserved3.length == 96 && pckSignedQeReport.reserved4.length == 60
84:                 && pckSignedQeReport.reportData.length == 64,
85:             "QE report has wrong length"
86:         );
87:         require(
88:             v3Quote.v3AuthData.certification.certType == 5,
89:             "certType must be 5: Concatenated PCK Cert Chain (PEM formatted)"
90:         );
91:         require(
92:             v3Quote.v3AuthData.certification.decodedCertDataArray.length == 3, "3 certs in chain"
93:         );
94:         require(
95:             v3Quote.v3AuthData.ecdsa256BitSignature.length == 64
96:                 && v3Quote.v3AuthData.ecdsaAttestationKey.length == 64
97:                 && v3Quote.v3AuthData.qeReportSignature.length == 64,
98:             "Invalid ECDSA signature format"
99:         );
100:         require(
101:             v3Quote.v3AuthData.qeAuthData.parsedDataSize
102:                 == v3Quote.v3AuthData.qeAuthData.data.length,
103:             "Invalid QEAuthData size"
104:         );
105: 
106:         uint32 totalQuoteSize = 48 // header
107:             + 384 // local QE report
108:             + 64 // ecdsa256BitSignature
109:             + 64 // ecdsaAttestationKey
110:             + 384 // QE report
111:             + 64 // qeReportSignature
112:             + 2 // sizeof(v3Quote.v3AuthData.qeAuthData.parsedDataSize)
113:             + v3Quote.v3AuthData.qeAuthData.parsedDataSize + 2 // sizeof(v3Quote.v3AuthData.certification.certType)
114:             + 4 // sizeof(v3Quote.v3AuthData.certification.certDataSize)
115:             + v3Quote.v3AuthData.certification.certDataSize;
116:         require(totalQuoteSize >= MINIMUM_QUOTE_LENGTH, "Invalid quote size");
117: 
118:         header = v3Quote.header;
119:         bytes memory headerBytes = abi.encodePacked(
120:             header.version,
121:             header.attestationKeyType,
122:             header.teeType,
123:             header.qeSvn,
124:             header.pceSvn,
125:             header.qeVendorId,
126:             header.userData
127:         );
128: 
129:         signedQuoteData = abi.encodePacked(headerBytes, V3Parser.packQEReport(localEnclaveReport));
130:         authDataV3 = v3Quote.v3AuthData;
131:     }

133:     function parseEnclaveReport(bytes memory rawEnclaveReport) 
134:         internal
135:         pure
136:         returns (V3Struct.EnclaveReport memory enclaveReport)
137:     {
138:         enclaveReport.cpuSvn = bytes16(rawEnclaveReport.substring(0, 16));
139:         enclaveReport.miscSelect = bytes4(rawEnclaveReport.substring(16, 4));
140:         enclaveReport.reserved1 = bytes28(rawEnclaveReport.substring(20, 28));
141:         enclaveReport.attributes = bytes16(rawEnclaveReport.substring(48, 16));
142:         enclaveReport.mrEnclave = bytes32(rawEnclaveReport.substring(64, 32));
143:         enclaveReport.reserved2 = bytes32(rawEnclaveReport.substring(96, 32));
144:         enclaveReport.mrSigner = bytes32(rawEnclaveReport.substring(128, 32));
145:         enclaveReport.reserved3 = rawEnclaveReport.substring(160, 96);
146:         enclaveReport.isvProdId = uint16(littleEndianDecode(rawEnclaveReport.substring(256, 2)));
147:         enclaveReport.isvSvn = uint16(littleEndianDecode(rawEnclaveReport.substring(258, 2)));
148:         enclaveReport.reserved4 = rawEnclaveReport.substring(260, 60);
149:         enclaveReport.reportData = rawEnclaveReport.substring(320, 64);
150:     }

152:     function littleEndianDecode(bytes memory encoded) private pure returns (uint256 decoded) { 
153:         for (uint256 i; i < encoded.length; ++i) {
154:             uint256 digits = uint256(uint8(bytes1(encoded[i])));
155:             uint256 upperDigit = digits / 16;
156:             uint256 lowerDigit = digits % 16;
157: 
158:             uint256 acc = lowerDigit * (16 ** (2 * i));
159:             acc += upperDigit * (16 ** ((2 * i) + 1));
160: 
161:             decoded += acc;
162:         }
163:     }

165:     function parseAndVerifyHeader(bytes memory rawHeader) 
166:         private
167:         pure
168:         returns (bool success, V3Struct.Header memory header)
169:     {
170:         bytes2 version = bytes2(rawHeader.substring(0, 2));
171:         if (version != SUPPORTED_QUOTE_VERSION) {
172:             return (false, header);
173:         }
174: 
175:         bytes2 attestationKeyType = bytes2(rawHeader.substring(2, 2));
176:         if (attestationKeyType != SUPPORTED_ATTESTATION_KEY_TYPE) {
177:             return (false, header);
178:         }
179: 
180:         bytes4 teeType = bytes4(rawHeader.substring(4, 4));
181:         if (teeType != SUPPORTED_TEE_TYPE) {
182:             return (false, header);
183:         }
184: 
185:         bytes16 qeVendorId = bytes16(rawHeader.substring(12, 16));
186:         if (qeVendorId != VALID_QE_VENDOR_ID) {
187:             return (false, header);
188:         }
189: 
190:         header = V3Struct.Header({
191:             version: version,
192:             attestationKeyType: attestationKeyType,
193:             teeType: teeType,
194:             qeSvn: bytes2(rawHeader.substring(8, 2)),
195:             pceSvn: bytes2(rawHeader.substring(10, 2)),
196:             qeVendorId: qeVendorId,
197:             userData: bytes20(rawHeader.substring(28, 20))
198:         });
199: 
200:         success = true;
201:     }

203:     function parseAuthDataAndVerifyCertType( 
204:         bytes memory rawAuthData,
205:         address pemCertLibAddr
206:     )
207:         private
208:         pure
209:         returns (bool success, V3Struct.ECDSAQuoteV3AuthData memory authDataV3)
210:     {
211:         V3Struct.QEAuthData memory qeAuthData;
212:         qeAuthData.parsedDataSize = uint16(littleEndianDecode(rawAuthData.substring(576, 2)));
213:         qeAuthData.data = rawAuthData.substring(578, qeAuthData.parsedDataSize);
214: 
215:         uint256 offset = 578 + qeAuthData.parsedDataSize;
216:         V3Struct.CertificationData memory cert;
217:         cert.certType = uint16(littleEndianDecode(rawAuthData.substring(offset, 2)));
218:         if (cert.certType < 1 || cert.certType > 5) {
219:             return (false, authDataV3);
220:         }
221:         offset += 2;
222:         cert.certDataSize = uint32(littleEndianDecode(rawAuthData.substring(offset, 4)));
223:         offset += 4;
224:         bytes memory certData = rawAuthData.substring(offset, cert.certDataSize);
225:         cert.decodedCertDataArray = parseCerificationChainBytes(certData, pemCertLibAddr);
226: 
227:         authDataV3.ecdsa256BitSignature = rawAuthData.substring(0, 64);
228:         authDataV3.ecdsaAttestationKey = rawAuthData.substring(64, 64);
229:         bytes memory rawQeReport = rawAuthData.substring(128, 384);
230:         authDataV3.pckSignedQeReport = parseEnclaveReport(rawQeReport);
231:         authDataV3.qeReportSignature = rawAuthData.substring(512, 64);
232:         authDataV3.qeAuthData = qeAuthData;
233:         authDataV3.certification = cert;
234: 
235:         success = true;
236:     }

244:     function packQEReport(V3Struct.EnclaveReport memory enclaveReport) 
245:         internal
246:         pure
247:         returns (bytes memory packedQEReport)
248:     {
249:         uint16 isvProdIdPackBE = (enclaveReport.isvProdId >> 8) | (enclaveReport.isvProdId << 8);
250:         uint16 isvSvnPackBE = (enclaveReport.isvSvn >> 8) | (enclaveReport.isvSvn << 8);
251:         packedQEReport = abi.encodePacked(
252:             enclaveReport.cpuSvn,
253:             enclaveReport.miscSelect,
254:             enclaveReport.reserved1,
255:             enclaveReport.attributes,
256:             enclaveReport.mrEnclave,
257:             enclaveReport.reserved2,
258:             enclaveReport.mrSigner,
259:             enclaveReport.reserved3,
260:             isvProdIdPackBE,
261:             isvSvnPackBE,
262:             enclaveReport.reserved4,
263:             enclaveReport.reportData
264:         );
265:     }

267:     function parseCerificationChainBytes( 
268:         bytes memory certBytes,
269:         address pemCertLibAddr
270:     )
271:         internal
272:         pure
273:         returns (bytes[3] memory certChainData)
274:     {
275:         IPEMCertChainLib pemCertLib = PEMCertChainLib(pemCertLibAddr);
276:         IPEMCertChainLib.ECSha256Certificate[] memory parsedQuoteCerts;
277:         (bool certParsedSuccessfully, bytes[] memory quoteCerts) =
278:             pemCertLib.splitCertificateChain(certBytes, 3);
279:         require(certParsedSuccessfully, "splitCertificateChain failed");
280:         parsedQuoteCerts = new IPEMCertChainLib.ECSha256Certificate[](3);
281:         for (uint256 i; i < 3; ++i) {
282:             quoteCerts[i] = Base64.decode(string(quoteCerts[i]));
283:         }
284: 
285:         certChainData = [quoteCerts[0], quoteCerts[1], quoteCerts[2]];
286:     }
```
[21](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/QuoteV3Auth/V3Parser.sol#L21-L60), [62](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/QuoteV3Auth/V3Parser.sol#L62-L131), [133](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/QuoteV3Auth/V3Parser.sol#L133-L150), [152](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/QuoteV3Auth/V3Parser.sol#L152-L163), [165](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/QuoteV3Auth/V3Parser.sol#L165-L201), [203](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/QuoteV3Auth/V3Parser.sol#L203-L236), [244](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/QuoteV3Auth/V3Parser.sol#L244-L265), [267](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/QuoteV3Auth/V3Parser.sol#L267-L286)

```solidity
📁 File: contracts/automata-attestation/lib/interfaces/IPEMCertChainLib.sol

36:     function splitCertificateChain( 
37:         bytes memory pemChain,
38:         uint256 size
39:     )
40:         external
41:         pure
42:         returns (bool success, bytes[] memory certs);

44:     function decodeCert( 
45:         bytes memory der,
46:         bool isPckCert
47:     )
48:         external
49:         pure
50:         returns (bool success, ECSha256Certificate memory cert);
```
[36](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/interfaces/IPEMCertChainLib.sol#L36-L42), [44](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/interfaces/IPEMCertChainLib.sol#L44-L50)

```solidity
📁 File: contracts/automata-attestation/utils/Asn1Decode.sol

/// @audit Parameter of type 'uint256' at index '0'
14:     function ixs(uint256 self) internal pure returns (uint256) { 

/// @audit Parameter of type 'uint256' at index '0'
19:     function ixf(uint256 self) internal pure returns (uint256) { 

/// @audit Parameter of type 'uint256' at index '0'
24:     function ixl(uint256 self) internal pure returns (uint256) { 

/// @audit Parameter of type 'uint256' at index '0'
29:     function getPtr(uint256 _ixs, uint256 _ixf, uint256 _ixl) internal pure returns (uint256) { 

/// @audit Parameter of type 'uint256' at index '0'
47:     function root(bytes memory der) internal pure returns (uint256) { 

/// @audit Parameter of type 'uint256' at index '0'
56:     function rootOfBitStringAt(bytes memory der, uint256 ptr) internal pure returns (uint256) { 

/// @audit Parameter of type 'uint256' at index '0'
66:     function rootOfOctetStringAt(bytes memory der, uint256 ptr) internal pure returns (uint256) { 

/// @audit Parameter of type 'uint256' at index '0'
77:     function nextSiblingOf(bytes memory der, uint256 ptr) internal pure returns (uint256) { 

/// @audit Parameter of type 'uint256' at index '0'
87:     function firstChildOf(bytes memory der, uint256 ptr) internal pure returns (uint256) { 

/// @audit Parameter of type 'bool' at index '0'
98:     function isChildOf(uint256 i, uint256 j) internal pure returns (bool) { 

/// @audit Parameter of type 'bytes' at index '0'
111:     function bytesAt(bytes memory der, uint256 ptr) internal pure returns (bytes memory) { 

/// @audit Parameter of type 'bytes' at index '0'
121:     function allBytesAt(bytes memory der, uint256 ptr) internal pure returns (bytes memory) { 

/// @audit Parameter of type 'bytes32' at index '0'
131:     function bytes32At(bytes memory der, uint256 ptr) internal pure returns (bytes32) { 

/// @audit Parameter of type 'uint256' at index '0'
141:     function uintAt(bytes memory der, uint256 ptr) internal pure returns (uint256) { 

/// @audit Parameter of type 'bytes' at index '0'
154:     function uintBytesAt(bytes memory der, uint256 ptr) internal pure returns (bytes memory) { 

/// @audit Parameter of type 'bytes32' at index '0'
165:     function keccakOfBytesAt(bytes memory der, uint256 ptr) internal pure returns (bytes32) { 

/// @audit Parameter of type 'bytes32' at index '0'
169:     function keccakOfAllBytesAt(bytes memory der, uint256 ptr) internal pure returns (bytes32) { 

/// @audit Parameter of type 'bytes' at index '0'
179:     function bitstringAt(bytes memory der, uint256 ptr) internal pure returns (bytes memory) { 

/// @audit Parameter of type 'uint256' at index '0'
187:     function _readNodeLength(bytes memory der, uint256 ix) private pure returns (uint256) { 
```
[14](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/Asn1Decode.sol#L14), [19](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/Asn1Decode.sol#L19), [24](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/Asn1Decode.sol#L24), [29](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/Asn1Decode.sol#L29), [47](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/Asn1Decode.sol#L47), [56](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/Asn1Decode.sol#L56), [66](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/Asn1Decode.sol#L66), [77](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/Asn1Decode.sol#L77), [87](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/Asn1Decode.sol#L87), [98](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/Asn1Decode.sol#L98), [111](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/Asn1Decode.sol#L111), [121](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/Asn1Decode.sol#L121), [131](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/Asn1Decode.sol#L131), [141](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/Asn1Decode.sol#L141), [154](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/Asn1Decode.sol#L154), [165](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/Asn1Decode.sol#L165), [169](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/Asn1Decode.sol#L169), [179](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/Asn1Decode.sol#L179), [187](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/Asn1Decode.sol#L187)

```solidity
📁 File: contracts/automata-attestation/utils/BytesUtils.sol

16:     function keccak( 
17:         bytes memory self,
18:         uint256 offset,
19:         uint256 len
20:     )
21:         internal
22:         pure
23:         returns (bytes32 ret)
24:     {
25:         require(offset + len <= self.length, "invalid offset");
26:         assembly {
27:             ret := keccak256(add(add(self, 32), offset), len)
28:         }
29:     }

/// @audit Parameter of type 'int256' at index '0'
39:     function compare(bytes memory self, bytes memory other) internal pure returns (int256) { 

56:     function compare( 

116:     function equals( 

138:     function equals( 

160:     function equals( 

/// @audit Parameter of type 'bool' at index '0'
178:     function equals(bytes memory self, bytes memory other) internal pure returns (bool) { 

188:     function readUint8(bytes memory self, uint256 idx) internal pure returns (uint8 ret) { 
189:         return uint8(self[idx]);
190:     }

198:     function readUint16(bytes memory self, uint256 idx) internal pure returns (uint16 ret) { 
199:         require(idx + 2 <= self.length, "invalid idx");
200:         assembly {
201:             ret := and(mload(add(add(self, 2), idx)), 0xFFFF)
202:         }
203:     }

211:     function readUint32(bytes memory self, uint256 idx) internal pure returns (uint32 ret) { 
212:         require(idx + 4 <= self.length, "unexpected idx");
213:         assembly {
214:             ret := and(mload(add(add(self, 4), idx)), 0xFFFFFFFF)
215:         }
216:     }

224:     function readBytes32(bytes memory self, uint256 idx) internal pure returns (bytes32 ret) { 
225:         require(idx + 32 <= self.length, "unexpected idx");
226:         assembly {
227:             ret := mload(add(add(self, 32), idx))
228:         }
229:     }

237:     function readBytes20(bytes memory self, uint256 idx) internal pure returns (bytes20 ret) { 
238:         require(idx + 20 <= self.length, "unexpected idx");
239:         assembly {
240:             ret :=
241:                 and(
242:                     mload(add(add(self, 32), idx)),
243:                     0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF000000000000000000000000
244:                 )
245:         }
246:     }

255:     function readBytesN( 
256:         bytes memory self,
257:         uint256 idx,
258:         uint256 len
259:     )
260:         internal
261:         pure
262:         returns (bytes32 ret)
263:     {
264:         require(len <= 32, "unexpected len");
265:         require(idx + len <= self.length, "unexpected idx");
266:         assembly {
267:             let mask := not(sub(exp(256, sub(32, len)), 1))
268:             ret := and(mload(add(add(self, 32), idx)), mask)
269:         }
270:     }

284:     function substring( 

320:     function base32HexDecodeWord( 

/// @audit Parameter of type 'bool' at index '0'
371:     function compareBytes(bytes memory a, bytes memory b) internal pure returns (bool) { 
```
[16](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/BytesUtils.sol#L16-L29), [39](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/BytesUtils.sol#L39), [56](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/BytesUtils.sol#L56), [116](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/BytesUtils.sol#L116), [138](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/BytesUtils.sol#L138), [160](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/BytesUtils.sol#L160), [178](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/BytesUtils.sol#L178), [188](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/BytesUtils.sol#L188-L190), [198](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/BytesUtils.sol#L198-L203), [211](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/BytesUtils.sol#L211-L216), [224](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/BytesUtils.sol#L224-L229), [237](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/BytesUtils.sol#L237-L246), [255](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/BytesUtils.sol#L255-L270), [284](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/BytesUtils.sol#L284), [320](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/BytesUtils.sol#L320), [371](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/BytesUtils.sol#L371)

```solidity
📁 File: contracts/automata-attestation/utils/RsaVerify.sol

43:     function pkcs1Sha256( 

191:     function pkcs1Sha256Raw( 

212:     function pkcs1Sha1( 

307:     function pkcs1Sha1Raw( 
```
[43](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/RsaVerify.sol#L43), [191](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/RsaVerify.sol#L191), [212](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/RsaVerify.sol#L212), [307](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/RsaVerify.sol#L307)

```solidity
📁 File: contracts/automata-attestation/utils/SHA1.sol

11:     function sha1(bytes memory data) internal pure returns (bytes20 ret) { 
12:         assembly {
13:             // Get a safe scratch location
14:             let scratch := mload(0x40)
15: 
16:             // Get the data length, and point data at the first byte
17:             let len := mload(data)
18:             data := add(data, 32)
19: 
20:             // Find the length after padding
21:             let totallen := add(and(add(len, 1), 0xFFFFFFFFFFFFFFC0), 64)
22:             switch lt(sub(totallen, len), 9)
23:             case 1 { totallen := add(totallen, 64) }
24: 
25:             let h := 0x6745230100EFCDAB890098BADCFE001032547600C3D2E1F0
26: 
27:             function readword(ptr, off, count) -> result {
28:                 result := 0
29:                 if lt(off, count) {
30:                     result := mload(add(ptr, off))
31:                     count := sub(count, off)
32:                     if lt(count, 32) {
33:                         let mask := not(sub(exp(256, sub(32, count)), 1))
34:                         result := and(result, mask)
35:                     }
36:                 }
37:             }
38: 
39:             for { let i := 0 } lt(i, totallen) { i := add(i, 64) } {
40:                 mstore(scratch, readword(data, i, len))
41:                 mstore(add(scratch, 32), readword(data, add(i, 32), len))
42: 
43:                 // If we loaded the last byte, store the terminator byte
44:                 switch lt(sub(len, i), 64)
45:                 case 1 { mstore8(add(scratch, sub(len, i)), 0x80) }
46: 
47:                 // If this is the last block, store the length
48:                 switch eq(i, sub(totallen, 64))
49:                 case 1 { mstore(add(scratch, 32), or(mload(add(scratch, 32)), mul(len, 8))) }
50: 
51:                 // Expand the 16 32-bit words into 80
52:                 for { let j := 64 } lt(j, 128) { j := add(j, 12) } {
53:                     let temp :=
54:                         xor(
55:                             xor(mload(add(scratch, sub(j, 12))), mload(add(scratch, sub(j, 32)))),
56:                             xor(mload(add(scratch, sub(j, 56))), mload(add(scratch, sub(j, 64))))
57:                         )
58:                     temp :=
59:                         or(
60:                             and(
61:                                 mul(temp, 2),
62:                                 0xFFFFFFFEFFFFFFFEFFFFFFFEFFFFFFFEFFFFFFFEFFFFFFFEFFFFFFFEFFFFFFFE
63:                             ),
64:                             and(
65:                                 div(temp, 0x80000000),
66:                                 0x0000000100000001000000010000000100000001000000010000000100000001
67:                             )
68:                         )
69:                     mstore(add(scratch, j), temp)
70:                 }
71:                 for { let j := 128 } lt(j, 320) { j := add(j, 24) } {
72:                     let temp :=
73:                         xor(
74:                             xor(mload(add(scratch, sub(j, 24))), mload(add(scratch, sub(j, 64)))),
75:                             xor(mload(add(scratch, sub(j, 112))), mload(add(scratch, sub(j, 128))))
76:                         )
77:                     temp :=
78:                         or(
79:                             and(
80:                                 mul(temp, 4),
81:                                 0xFFFFFFFCFFFFFFFCFFFFFFFCFFFFFFFCFFFFFFFCFFFFFFFCFFFFFFFCFFFFFFFC
82:                             ),
83:                             and(
84:                                 div(temp, 0x40000000),
85:                                 0x0000000300000003000000030000000300000003000000030000000300000003
86:                             )
87:                         )
88:                     mstore(add(scratch, j), temp)
89:                 }
90: 
91:                 let x := h
92:                 let f := 0
93:                 let k := 0
94:                 for { let j := 0 } lt(j, 80) { j := add(j, 1) } {
95:                     switch div(j, 20)
96:                     case 0 {
97:                         // f = d xor (b and (c xor d))
98:                         f := xor(div(x, 0x100000000000000000000), div(x, 0x10000000000))
99:                         f := and(div(x, 0x1000000000000000000000000000000), f)
100:                         f := xor(div(x, 0x10000000000), f)
101:                         k := 0x5A827999
102:                     }
103:                     case 1 {
104:                         // f = b xor c xor d
105:                         f :=
106:                             xor(
107:                                 div(x, 0x1000000000000000000000000000000),
108:                                 div(x, 0x100000000000000000000)
109:                             )
110:                         f := xor(div(x, 0x10000000000), f)
111:                         k := 0x6ED9EBA1
112:                     }
113:                     case 2 {
114:                         // f = (b and c) or (d and (b or c))
115:                         f :=
116:                             or(
117:                                 div(x, 0x1000000000000000000000000000000),
118:                                 div(x, 0x100000000000000000000)
119:                             )
120:                         f := and(div(x, 0x10000000000), f)
121:                         f :=
122:                             or(
123:                                 and(
124:                                     div(x, 0x1000000000000000000000000000000),
125:                                     div(x, 0x100000000000000000000)
126:                                 ),
127:                                 f
128:                             )
129:                         k := 0x8F1BBCDC
130:                     }
131:                     case 3 {
132:                         // f = b xor c xor d
133:                         f :=
134:                             xor(
135:                                 div(x, 0x1000000000000000000000000000000),
136:                                 div(x, 0x100000000000000000000)
137:                             )
138:                         f := xor(div(x, 0x10000000000), f)
139:                         k := 0xCA62C1D6
140:                     }
141:                     // temp = (a leftrotate 5) + f + e + k + w[i]
142:                     let temp := and(div(x, 0x80000000000000000000000000000000000000000000000), 0x1F)
143:                     temp :=
144:                         or(and(div(x, 0x800000000000000000000000000000000000000), 0xFFFFFFE0), temp)
145:                     temp := add(f, temp)
146:                     temp := add(and(x, 0xFFFFFFFF), temp)
147:                     temp := add(k, temp)
148:                     temp :=
149:                         add(
150:                             div(
151:                                 mload(add(scratch, mul(j, 4))),
152:                                 0x100000000000000000000000000000000000000000000000000000000
153:                             ),
154:                             temp
155:                         )
156:                     x :=
157:                         or(
158:                             div(x, 0x10000000000),
159:                             mul(temp, 0x10000000000000000000000000000000000000000)
160:                         )
161:                     x :=
162:                         or(
163:                             and(x, 0xFFFFFFFF00FFFFFFFF000000000000FFFFFFFF00FFFFFFFF),
164:                             mul(
165:                                 or(
166:                                     and(div(x, 0x4000000000000), 0xC0000000),
167:                                     and(div(x, 0x400000000000000000000), 0x3FFFFFFF)
168:                                 ),
169:                                 0x100000000000000000000
170:                             )
171:                         )
172:                 }
173: 
174:                 h := and(add(h, x), 0xFFFFFFFF00FFFFFFFF00FFFFFFFF00FFFFFFFF00FFFFFFFF)
175:             }
176:             ret :=
177:                 mul(
178:                     or(
179:                         or(
180:                             or(
181:                                 or(
182:                                     and(div(h, 0x100000000), 0xFFFFFFFF00000000000000000000000000000000),
183:                                     and(div(h, 0x1000000), 0xFFFFFFFF000000000000000000000000)
184:                                 ),
185:                                 and(div(h, 0x10000), 0xFFFFFFFF0000000000000000)
186:                             ),
187:                             and(div(h, 0x100), 0xFFFFFFFF00000000)
188:                         ),
189:                         and(h, 0xFFFFFFFF)
190:                     ),
191:                     0x1000000000000000000000000
192:                 )
193:         }
194:     }
```
[11](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/SHA1.sol#L11-L194)

```solidity
📁 File: contracts/automata-attestation/utils/SigVerifyLib.sol

24:     function verifyAttStmtSignature( 

54:     function verifyCertificateSignature( 

79:     function verifyRS256Signature( 
80:         bytes memory tbs,
81:         bytes memory signature,
82:         bytes memory publicKey
83:     )
84:         public
85:         view
86:         returns (bool sigValid)
87:     {
88:         // Parse public key
89:         bytes memory exponent = publicKey.substring(0, 3);
90:         bytes memory modulus = publicKey.substring(3, publicKey.length - 3);
91: 
92:         // Verify signature
93:         sigValid = RsaVerify.pkcs1Sha256Raw(tbs, signature, exponent, modulus);
94:     }

96:     function verifyRS1Signature( 
97:         bytes memory tbs,
98:         bytes memory signature,
99:         bytes memory publicKey
100:     )
101:         public
102:         view
103:         returns (bool sigValid)
104:     {
105:         // Parse public key
106:         bytes memory exponent = publicKey.substring(0, 3);
107:         bytes memory modulus = publicKey.substring(3, publicKey.length - 3);
108: 
109:         // Verify signature
110:         sigValid = RsaVerify.pkcs1Sha1Raw(tbs, signature, exponent, modulus);
111:     }

113:     function verifyES256Signature( 
114:         bytes memory tbs,
115:         bytes memory signature,
116:         bytes memory publicKey
117:     )
118:         public
119:         view
120:         returns (bool sigValid)
121:     {
122:         // Parse signature
123:         if (signature.length != 64) {
124:             return false;
125:         }
126:         uint256 r = uint256(bytes32(signature.substring(0, 32)));
127:         uint256 s = uint256(bytes32(signature.substring(32, 32)));
128:         // Parse public key
129:         if (publicKey.length != 64) {
130:             return false;
131:         }
132:         uint256 gx = uint256(bytes32(publicKey.substring(0, 32)));
133:         uint256 gy = uint256(bytes32(publicKey.substring(32, 32)));
134: 
135:         // Verify signature
136:         bytes memory args = abi.encode(sha256(tbs), r, s, gx, gy);
137:         (bool success, bytes memory ret) = ES256VERIFIER.staticcall(args);
138:         assert(success); // never reverts, always returns 0 or 1
139: 
140:         return abi.decode(ret, (uint256)) == 1;
141:     }
```
[24](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/SigVerifyLib.sol#L24), [54](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/SigVerifyLib.sol#L54), [79](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/SigVerifyLib.sol#L79-L94), [96](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/SigVerifyLib.sol#L96-L111), [113](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/SigVerifyLib.sol#L113-L141)

```solidity
📁 File: contracts/automata-attestation/utils/X509DateUtils.sol

/// @audit Parameter of type 'uint256' at index '0'
8:     function toTimestamp(bytes memory x509Time) internal pure returns (uint256) { 

34:     function toUnixTimestamp( 

/// @audit Parameter of type 'bool' at index '0'
71:     function isLeapYear(uint16 year) internal pure returns (bool) { 
```
[8](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/X509DateUtils.sol#L8), [34](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/X509DateUtils.sol#L34), [71](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/X509DateUtils.sol#L71)

```solidity
📁 File: contracts/bridge/Bridge.sol

115:     function sendMessage(Message calldata _message) 
116:         external
117:         payable
118:         override
119:         nonReentrant
120:         whenNotPaused
121:         returns (bytes32 msgHash_, Message memory message_)
122:     {
123:         // Ensure the message owner is not null.
124:         if (_message.srcOwner == address(0) || _message.destOwner == address(0)) {
125:             revert B_INVALID_USER();
126:         }
127: 
128:         // Check if the destination chain is enabled.
129:         (bool destChainEnabled,) = isDestChainEnabled(_message.destChainId);
130: 
131:         // Verify destination chain and to address.
132:         if (!destChainEnabled) revert B_INVALID_CHAINID();
133:         if (_message.destChainId == block.chainid) {
134:             revert B_INVALID_CHAINID();
135:         }
136: 
137:         // Ensure the sent value matches the expected amount.
138:         uint256 expectedAmount = _message.value + _message.fee;
139:         if (expectedAmount != msg.value) revert B_INVALID_VALUE();
140: 
141:         message_ = _message;
142: 
143:         // Configure message details and send signal to indicate message sending.
144:         message_.id = nextMessageId++;
145:         message_.from = msg.sender;
146:         message_.srcChainId = uint64(block.chainid);
147: 
148:         msgHash_ = hashMessage(message_);
149: 
150:         ISignalService(resolve("signal_service", false)).sendSignal(msgHash_);
151:         emit MessageSent(msgHash_, message_);
152:     }

/// @audit Parameter of type 'bool' at index '0'
340:     function isMessageSent(Message calldata _message) public view returns (bool) { 

352:     function proveMessageFailed( 

374:     function proveMessageReceived( 

392:     function isDestChainEnabled(uint64 _chainId) 
393:         public
394:         view
395:         returns (bool enabled_, address destBridge_)
396:     {
397:         destBridge_ = resolve(_chainId, "bridge", true);
398:         enabled_ = destBridge_ != address(0);
399:     }

403:     function context() public view returns (Context memory ctx_) { 
404:         ctx_ = _loadContext();
405:         if (ctx_.msgHash == 0 || ctx_.msgHash == bytes32(PLACEHOLDER)) {
406:             revert B_INVALID_CONTEXT();
407:         }
408:     }

417:     function getInvocationDelays() 
418:         public
419:         view
420:         virtual
421:         returns (uint256 invocationDelay_, uint256 invocationExtraDelay_)
422:     {
423:         if (
424:             block.chainid == 1 // Ethereum mainnet
425:         ) {
426:             // For Taiko mainnet
427:             // 384 seconds = 6.4 minutes = one ethereum epoch
428:             return (1 hours, 384 seconds);
429:         } else if (
430:             block.chainid == 2 // Ropsten
431:                 || block.chainid == 4 // Rinkeby
432:                 || block.chainid == 5 // Goerli
433:                 || block.chainid == 42 // Kovan
434:                 || block.chainid == 17_000 // Holesky
435:                 || block.chainid == 11_155_111 // Sepolia
436:         ) {
437:             // For all Taiko public testnets
438:             return (30 minutes, 384 seconds);
439:         } else if (block.chainid >= 32_300 && block.chainid <= 32_400) {
440:             // For all Taiko internal devnets
441:             return (5 minutes, 384 seconds);
442:         } else {
443:             // This is a Taiko L2 chain where no deleys are applied.
444:             return (0, 0);
445:         }
446:     }

/// @audit Parameter of type 'bytes32' at index '0'
449:     function hashMessage(Message memory _message) public pure returns (bytes32) { 

/// @audit Parameter of type 'bytes32' at index '0'
456:     function signalForFailedMessage(bytes32 _msgHash) public pure returns (bytes32) { 

477:     function _invokeMessageCall( 
478:         Message calldata _message,
479:         bytes32 _msgHash,
480:         uint256 _gasLimit
481:     )
482:         private
483:         returns (bool success_)
484:     {
485:         if (_gasLimit == 0) revert B_INVALID_GAS_LIMIT();
486:         assert(_message.from != address(this));
487: 
488:         _storeContext(_msgHash, _message.from, _message.srcChainId);
489: 
490:         if (
491:             _message.data.length >= 4 // msg can be empty
492:                 && bytes4(_message.data) != IMessageInvocable.onMessageInvocation.selector
493:                 && _message.to.isContract()
494:         ) {
495:             success_ = false;
496:         } else {
497:             (success_,) = ExcessivelySafeCall.excessivelySafeCall(
498:                 _message.to,
499:                 _gasLimit,
500:                 _message.value,
501:                 64, // return max 64 bytes
502:                 _message.data
503:             );
504:         }
505: 
506:         // Must reset the context after the message call
507:         _resetContext();
508:     }

/// @audit Parameter of type 'struct IBridge.Context' at index '0'
555:     function _loadContext() private view returns (Context memory) { 

577:     function _proveSignalReceived( 
578:         address _signalService,
579:         bytes32 _signal,
580:         uint64 _chainId,
581:         bytes calldata _proof
582:     )
583:         private
584:         view
585:         returns (bool success_)
586:     {
587:         bytes memory data = abi.encodeCall(
588:             ISignalService.proveSignalReceived,
589:             (_chainId, resolve(_chainId, "bridge", false), _signal, _proof)
590:         );
591:         (success_,) = _signalService.staticcall(data);
592:     }
```
[115](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/Bridge.sol#L115-L152), [340](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/Bridge.sol#L340), [352](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/Bridge.sol#L352), [374](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/Bridge.sol#L374), [392](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/Bridge.sol#L392-L399), [403](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/Bridge.sol#L403-L408), [417](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/Bridge.sol#L417-L446), [449](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/Bridge.sol#L449), [456](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/Bridge.sol#L456), [477](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/Bridge.sol#L477-L508), [555](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/Bridge.sol#L555), [577](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/Bridge.sol#L577-L592)

```solidity
📁 File: contracts/bridge/IBridge.sol

109:     function sendMessage(Message calldata _message) 
110:         external
111:         payable
112:         returns (bytes32 msgHash_, Message memory message_);

145:     function context() external view returns (Context memory ctx_); 

/// @audit Parameter of type 'bool' at index '0'
150:     function isMessageSent(Message calldata _message) external view returns (bool); 

/// @audit Parameter of type 'bytes32' at index '0'
155:     function hashMessage(Message memory _message) external pure returns (bytes32); 
```
[109](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/IBridge.sol#L109-L112), [145](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/IBridge.sol#L145), [150](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/IBridge.sol#L150), [155](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/IBridge.sol#L155)

```solidity
📁 File: contracts/common/AddressManager.sol

/// @audit Parameter of type 'address' at index '0'
54:     function getAddress(uint64 _chainId, bytes32 _name) public view override returns (address) { 
```
[54](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/common/AddressManager.sol#L54)

```solidity
📁 File: contracts/common/AddressResolver.sol

30:     function resolve( 

43:     function resolve( 

72:     function _resolve( 
73:         uint64 _chainId,
74:         bytes32 _name,
75:         bool _allowZeroAddress
76:     )
77:         private
78:         view
79:         returns (address payable addr_)
80:     {
81:         if (addressManager == address(0)) revert RESOLVER_INVALID_MANAGER();
82: 
83:         addr_ = payable(IAddressManager(addressManager).getAddress(_chainId, _name));
84: 
85:         if (!_allowZeroAddress && addr_ == address(0)) {
86:             revert RESOLVER_ZERO_ADDR(_chainId, _name);
87:         }
88:     }
```
[30](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/common/AddressResolver.sol#L30), [43](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/common/AddressResolver.sol#L43), [72](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/common/AddressResolver.sol#L72-L88)

```solidity
📁 File: contracts/common/EssentialContract.sol

/// @audit Parameter of type 'bool' at index '0'
88:     function paused() public view returns (bool) { 

130:     function _loadReentryLock() internal view virtual returns (uint8 reentry_) { 
131:         if (block.chainid == 1) {
132:             assembly {
133:                 reentry_ := tload(_REENTRY_SLOT)
134:             }
135:         } else {
136:             reentry_ = __reentry;
137:         }
138:     }

/// @audit Parameter of type 'bool' at index '0'
140:     function _inNonReentrant() internal view returns (bool) { 
```
[88](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/common/EssentialContract.sol#L88), [130](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/common/EssentialContract.sol#L130-L138), [140](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/common/EssentialContract.sol#L140)

```solidity
📁 File: contracts/common/IAddressManager.sol

/// @audit Parameter of type 'address' at index '0'
14:     function getAddress(uint64 _chainId, bytes32 _name) external view returns (address); 
```
[14](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/common/IAddressManager.sol#L14)

```solidity
📁 File: contracts/common/IAddressResolver.sol

19:     function resolve( 

34:     function resolve( 
```
[19](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/common/IAddressResolver.sol#L19), [34](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/common/IAddressResolver.sol#L34)

```solidity
📁 File: contracts/libs/LibAddress.sol

46:     function supportsInterface( 
47:         address _addr,
48:         bytes4 _interfaceId
49:     )
50:         internal
51:         view
52:         returns (bool result_)
53:     {
54:         if (!Address.isContract(_addr)) return false;
55: 
56:         try IERC165(_addr).supportsInterface(_interfaceId) returns (bool _result) {
57:             result_ = _result;
58:         } catch { }
59:     }

61:     function isValidSignature( 

/// @audit Parameter of type 'bool' at index '0'
77:     function isSenderEOA() internal view returns (bool) { 
```
[46](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/libs/LibAddress.sol#L46-L59), [61](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/libs/LibAddress.sol#L61), [77](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/libs/LibAddress.sol#L77)

```solidity
📁 File: contracts/libs/LibMath.sol

/// @audit Parameter of type 'uint256' at index '0'
12:     function min(uint256 _a, uint256 _b) internal pure returns (uint256) { 

/// @audit Parameter of type 'uint256' at index '0'
20:     function max(uint256 _a, uint256 _b) internal pure returns (uint256) { 
```
[12](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/libs/LibMath.sol#L12), [20](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/libs/LibMath.sol#L20)

```solidity
📁 File: contracts/libs/LibTrieProof.sol

34:     function verifyMerkleProof( 
35:         bytes32 _rootHash,
36:         address _addr,
37:         bytes32 _slot,
38:         bytes32 _value,
39:         bytes[] memory _accountProof,
40:         bytes[] memory _storageProof
41:     )
42:         internal
43:         pure
44:         returns (bytes32 storageRoot_)
45:     {
46:         if (_accountProof.length != 0) {
47:             bytes memory rlpAccount =
48:                 SecureMerkleTrie.get(abi.encodePacked(_addr), _accountProof, _rootHash);
49: 
50:             if (rlpAccount.length == 0) revert LTP_INVALID_ACCOUNT_PROOF();
51: 
52:             RLPReader.RLPItem[] memory accountState = RLPReader.readList(rlpAccount);
53: 
54:             storageRoot_ =
55:                 bytes32(RLPReader.readBytes(accountState[_ACCOUNT_FIELD_INDEX_STORAGE_HASH]));
56:         } else {
57:             storageRoot_ = _rootHash;
58:         }
59: 
60:         bool verified = SecureMerkleTrie.verifyInclusionProof(
61:             bytes.concat(_slot), RLPWriter.writeUint(uint256(_value)), _storageProof, storageRoot_
62:         );
63: 
64:         if (!verified) revert LTP_INVALID_INCLUSION_PROOF();
65:     }
```
[34](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/libs/LibTrieProof.sol#L34-L65)

```solidity
📁 File: contracts/signal/ISignalService.sol

59:     function sendSignal(bytes32 _signal) external returns (bytes32 slot_); 

68:     function syncChainData( 
69:         uint64 _chainId,
70:         bytes32 _kind,
71:         uint64 _blockId,
72:         bytes32 _chainData
73:     )
74:         external
75:         returns (bytes32 signal_);

/// @audit Parameter of type 'bool' at index '0'
96:     function isSignalSent(address _app, bytes32 _signal) external view returns (bool); 

105:     function isChainDataSynced( 

122:     function getSyncedChainData( 
123:         uint64 _chainId,
124:         bytes32 _kind,
125:         uint64 _blockId
126:     )
127:         external
128:         view
129:         returns (uint64 blockId_, bytes32 chainData_);

137:     function signalForChainData( 
138:         uint64 _chainId,
139:         bytes32 _kind,
140:         uint64 _blockId
141:     )
142:         external
143:         pure
144:         returns (bytes32 signal_);
```
[59](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/signal/ISignalService.sol#L59), [68](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/signal/ISignalService.sol#L68-L75), [96](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/signal/ISignalService.sol#L96), [105](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/signal/ISignalService.sol#L105), [122](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/signal/ISignalService.sol#L122-L129), [137](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/signal/ISignalService.sol#L137-L144)

```solidity
📁 File: contracts/signal/SignalService.sol

/// @audit Parameter of type 'bytes32' at index '0'
63:     function sendSignal(bytes32 _signal) external returns (bytes32) { 

68:     function syncChainData( 

137:     function isChainDataSynced( 

/// @audit Parameter of type 'bool' at index '0'
153:     function isSignalSent(address _app, bytes32 _signal) public view returns (bool) { 

158:     function getSyncedChainData( 
159:         uint64 _chainId,
160:         bytes32 _kind,
161:         uint64 _blockId
162:     )
163:         public
164:         view
165:         returns (uint64 blockId_, bytes32 chainData_)
166:     {
167:         blockId_ = _blockId != 0 ? _blockId : topBlockId[_chainId][_kind];
168: 
169:         if (blockId_ != 0) {
170:             bytes32 signal = signalForChainData(_chainId, _kind, blockId_);
171:             chainData_ = _loadSignalValue(address(this), signal);
172:             if (chainData_ == 0) revert SS_SIGNAL_NOT_FOUND();
173:         }
174:     }

177:     function signalForChainData( 

194:     function getSignalSlot( 

206:     function _verifyHopProof( 

235:     function _syncChainData( 
236:         uint64 _chainId,
237:         bytes32 _kind,
238:         uint64 _blockId,
239:         bytes32 _chainData
240:     )
241:         private
242:         returns (bytes32 signal_)
243:     {
244:         signal_ = signalForChainData(_chainId, _kind, _blockId);
245:         _sendSignal(address(this), signal_, _chainData);
246: 
247:         if (topBlockId[_chainId][_kind] < _blockId) {
248:             topBlockId[_chainId][_kind] = _blockId;
249:         }
250:         emit ChainDataSynced(_chainId, _blockId, _kind, _chainData, signal_);
251:     }

253:     function _sendSignal( 
254:         address _app,
255:         bytes32 _signal,
256:         bytes32 _value
257:     )
258:         private
259:         validSender(_app)
260:         nonZeroValue(_signal)
261:         nonZeroValue(_value)
262:         returns (bytes32 slot_)
263:     {
264:         slot_ = getSignalSlot(uint64(block.chainid), _app, _signal);
265:         assembly {
266:             sstore(slot_, _value)
267:         }
268:         emit SignalSent(_app, _signal, slot_, _value);
269:     }

298:     function _loadSignalValue( 
299:         address _app,
300:         bytes32 _signal
301:     )
302:         private
303:         view
304:         validSender(_app)
305:         nonZeroValue(_signal)
306:         returns (bytes32 value_)
307:     {
308:         bytes32 slot = getSignalSlot(uint64(block.chainid), _app, _signal);
309:         assembly {
310:             value_ := sload(slot)
311:         }
312:     }
```
[63](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/signal/SignalService.sol#L63), [68](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/signal/SignalService.sol#L68), [137](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/signal/SignalService.sol#L137), [153](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/signal/SignalService.sol#L153), [158](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/signal/SignalService.sol#L158-L174), [177](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/signal/SignalService.sol#L177), [194](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/signal/SignalService.sol#L194), [206](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/signal/SignalService.sol#L206), [235](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/signal/SignalService.sol#L235-L251), [253](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/signal/SignalService.sol#L253-L269), [298](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/signal/SignalService.sol#L298-L312)

```solidity
📁 File: contracts/team/TimelockTokenPool.sol

176:     function getMyGrantSummary(address _recipient) 
177:         public
178:         view
179:         returns (
180:             uint128 amountOwned,
181:             uint128 amountUnlocked,
182:             uint128 amountWithdrawn,
183:             uint128 amountToWithdraw,
184:             uint128 costToWithdraw
185:         )
186:     {
187:         Recipient storage r = recipients[_recipient];
188: 
189:         amountOwned = _getAmountOwned(r.grant);
190:         amountUnlocked = _getAmountUnlocked(r.grant);
191: 
192:         amountWithdrawn = r.amountWithdrawn;
193:         amountToWithdraw = amountUnlocked - amountWithdrawn;
194: 
195:         // Note: precision is maintained at the token level rather than the wei level, otherwise,
196:         // `costPaid` must be a uint256.
197:         uint128 _amountUnlocked = amountUnlocked / 1e18; // divide first
198:         costToWithdraw = _amountUnlocked * r.grant.costPerToken - r.costPaid;
199:     }

/// @audit Parameter of type 'struct TimelockTokenPool.Grant' at index '0'
204:     function getMyGrant(address _recipient) public view returns (Grant memory) { 

225:     function _voidGrant(Grant storage _grant) private returns (uint128 amountVoided) { 
226:         uint128 amountOwned = _getAmountOwned(_grant);
227: 
228:         amountVoided = _grant.amount - amountOwned;
229:         _grant.amount = amountOwned;
230: 
231:         _grant.grantStart = 0;
232:         _grant.grantPeriod = 0;
233:     }

/// @audit Parameter of type 'uint128' at index '0'
235:     function _getAmountOwned(Grant memory _grant) private view returns (uint128) { 

/// @audit Parameter of type 'uint128' at index '0'
239:     function _getAmountUnlocked(Grant memory _grant) private view returns (uint128) { 

245:     function _calcAmount( 
```
[176](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/TimelockTokenPool.sol#L176-L199), [204](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/TimelockTokenPool.sol#L204), [225](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/TimelockTokenPool.sol#L225-L233), [235](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/TimelockTokenPool.sol#L235), [239](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/TimelockTokenPool.sol#L239), [245](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/TimelockTokenPool.sol#L245)

```solidity
📁 File: contracts/team/airdrop/ERC20Airdrop2.sol

104:     function getBalance(address user) 
105:         public
106:         view
107:         returns (uint256 balance, uint256 withdrawableAmount)
108:     {
109:         balance = claimedAmount[user];
110:         // If balance is 0 then there is no balance and withdrawable amount
111:         if (balance == 0) return (0, 0);
112:         // Balance might be positive before end of claiming (claimEnd - if claimed already) but
113:         // withdrawable is 0.
114:         if (block.timestamp < claimEnd) return (balance, 0);
115: 
116:         // Hard cap timestamp - so range cannot go over - to get more allocation over time.
117:         uint256 timeBasedAllowance = balance
118:             * (block.timestamp.min(claimEnd + withdrawalWindow) - claimEnd) / withdrawalWindow;
119: 
120:         withdrawableAmount = timeBasedAllowance - withdrawnAmount[user];
121:     }
```
[104](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/airdrop/ERC20Airdrop2.sol#L104-L121)

```solidity
📁 File: contracts/team/airdrop/MerkleClaimable.sol

77:     function _verifyMerkleProof( 
```
[77](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/airdrop/MerkleClaimable.sol#L77)

```solidity
📁 File: contracts/thirdparty/nomad-xyz/ExcessivelySafeCall.sol

25:     function excessivelySafeCall( 
```
[25](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/nomad-xyz/ExcessivelySafeCall.sol#L25)

```solidity
📁 File: contracts/thirdparty/optimism/Bytes.sol

15:     function slice( 

/// @audit Parameter of type 'bytes' at index '0'
91:     function slice(bytes memory _bytes, uint256 _start) internal pure returns (bytes memory) { 

/// @audit Parameter of type 'bytes' at index '0'
102:     function toNibbles(bytes memory _bytes) internal pure returns (bytes memory) { 

/// @audit Parameter of type 'bool' at index '0'
149:     function equal(bytes memory _bytes, bytes memory _other) internal pure returns (bool) { 
```
[15](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/Bytes.sol#L15), [91](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/Bytes.sol#L91), [102](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/Bytes.sol#L102), [149](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/Bytes.sol#L149)

```solidity
📁 File: contracts/thirdparty/optimism/rlp/RLPReader.sol

35:     function toRLPItem(bytes memory _in) internal pure returns (RLPItem memory out_) { 
36:         // Empty arrays are not RLP items.
37:         require(
38:             _in.length > 0,
39:             "RLPReader: length of an RLP item must be greater than zero to be decodable"
40:         );
41: 
42:         MemoryPointer ptr;
43:         assembly {
44:             ptr := add(_in, 32)
45:         }
46: 
47:         out_ = RLPItem({ length: _in.length, ptr: ptr });
48:     }

53:     function readList(RLPItem memory _in) internal pure returns (RLPItem[] memory out_) { 
54:         (uint256 listOffset, uint256 listLength, RLPItemType itemType) = _decodeLength(_in);
55: 
56:         require(
57:             itemType == RLPItemType.LIST_ITEM,
58:             "RLPReader: decoded item type for list is not a list item"
59:         );
60: 
61:         require(
62:             listOffset + listLength == _in.length,
63:             "RLPReader: list item has an invalid data remainder"
64:         );
65: 
66:         // Solidity in-memory arrays can't be increased in size, but *can* be decreased in size by
67:         // writing to the length. Since we can't know the number of RLP items without looping over
68:         // the entire input, we'd have to loop twice to accurately size this array. It's easier to
69:         // simply set a reasonable maximum list length and decrease the size before we finish.
70:         out_ = new RLPItem[](MAX_LIST_LENGTH);
71: 
72:         uint256 itemCount = 0;
73:         uint256 offset = listOffset;
74:         while (offset < _in.length) {
75:             (uint256 itemOffset, uint256 itemLength,) = _decodeLength(
76:                 RLPItem({
77:                     length: _in.length - offset,
78:                     ptr: MemoryPointer.wrap(MemoryPointer.unwrap(_in.ptr) + offset)
79:                 })
80:             );
81: 
82:             // We don't need to check itemCount < out.length explicitly because Solidity already
83:             // handles this check on our behalf, we'd just be wasting gas.
84:             out_[itemCount] = RLPItem({
85:                 length: itemLength + itemOffset,
86:                 ptr: MemoryPointer.wrap(MemoryPointer.unwrap(_in.ptr) + offset)
87:             });
88: 
89:             itemCount += 1;
90:             offset += itemOffset + itemLength;
91:         }
92: 
93:         // Decrease the array size to match the actual item count.
94:         assembly {
95:             mstore(out_, itemCount)
96:         }
97:     }

102:     function readList(bytes memory _in) internal pure returns (RLPItem[] memory out_) { 
103:         out_ = readList(toRLPItem(_in));
104:     }

109:     function readBytes(RLPItem memory _in) internal pure returns (bytes memory out_) { 
110:         (uint256 itemOffset, uint256 itemLength, RLPItemType itemType) = _decodeLength(_in);
111: 
112:         require(
113:             itemType == RLPItemType.DATA_ITEM,
114:             "RLPReader: decoded item type for bytes is not a data item"
115:         );
116: 
117:         require(
118:             _in.length == itemOffset + itemLength,
119:             "RLPReader: bytes value contains an invalid remainder"
120:         );
121: 
122:         out_ = _copy(_in.ptr, itemOffset, itemLength);
123:     }

128:     function readBytes(bytes memory _in) internal pure returns (bytes memory out_) { 
129:         out_ = readBytes(toRLPItem(_in));
130:     }

135:     function readRawBytes(RLPItem memory _in) internal pure returns (bytes memory out_) { 
136:         out_ = _copy(_in.ptr, 0, _in.length);
137:     }

144:     function _decodeLength(RLPItem memory _in) 
145:         private
146:         pure
147:         returns (uint256 offset_, uint256 length_, RLPItemType type_)
148:     {
149:         // Short-circuit if there's nothing to decode, note that we perform this check when
150:         // the user creates an RLP item via toRLPItem, but it's always possible for them to bypass
151:         // that function and create an RLP item directly. So we need to check this anyway.
152:         require(
153:             _in.length > 0,
154:             "RLPReader: length of an RLP item must be greater than zero to be decodable"
155:         );
156: 
157:         MemoryPointer ptr = _in.ptr;
158:         uint256 prefix;
159:         assembly {
160:             prefix := byte(0, mload(ptr))
161:         }
162: 
163:         if (prefix <= 0x7f) {
164:             // Single byte.
165:             return (0, 1, RLPItemType.DATA_ITEM);
166:         } else if (prefix <= 0xb7) {
167:             // Short string.
168: 
169:             // slither-disable-next-line variable-scope
170:             uint256 strLen = prefix - 0x80;
171: 
172:             require(
173:                 _in.length > strLen,
174:                 "RLPReader: length of content must be greater than string length (short string)"
175:             );
176: 
177:             bytes1 firstByteOfContent;
178:             assembly {
179:                 firstByteOfContent := and(mload(add(ptr, 1)), shl(248, 0xff))
180:             }
181: 
182:             require(
183:                 strLen != 1 || firstByteOfContent >= 0x80,
184:                 "RLPReader: invalid prefix, single byte < 0x80 are not prefixed (short string)"
185:             );
186: 
187:             return (1, strLen, RLPItemType.DATA_ITEM);
188:         } else if (prefix <= 0xbf) {
189:             // Long string.
190:             uint256 lenOfStrLen = prefix - 0xb7;
191: 
192:             require(
193:                 _in.length > lenOfStrLen,
194:                 "RLPReader: length of content must be > than length of string length (long string)"
195:             );
196: 
197:             bytes1 firstByteOfContent;
198:             assembly {
199:                 firstByteOfContent := and(mload(add(ptr, 1)), shl(248, 0xff))
200:             }
201: 
202:             require(
203:                 firstByteOfContent != 0x00,
204:                 "RLPReader: length of content must not have any leading zeros (long string)"
205:             );
206: 
207:             uint256 strLen;
208:             assembly {
209:                 strLen := shr(sub(256, mul(8, lenOfStrLen)), mload(add(ptr, 1)))
210:             }
211: 
212:             require(
213:                 strLen > 55,
214:                 "RLPReader: length of content must be greater than 55 bytes (long string)"
215:             );
216: 
217:             require(
218:                 _in.length > lenOfStrLen + strLen,
219:                 "RLPReader: length of content must be greater than total length (long string)"
220:             );
221: 
222:             return (1 + lenOfStrLen, strLen, RLPItemType.DATA_ITEM);
223:         } else if (prefix <= 0xf7) {
224:             // Short list.
225:             // slither-disable-next-line variable-scope
226:             uint256 listLen = prefix - 0xc0;
227: 
228:             require(
229:                 _in.length > listLen,
230:                 "RLPReader: length of content must be greater than list length (short list)"
231:             );
232: 
233:             return (1, listLen, RLPItemType.LIST_ITEM);
234:         } else {
235:             // Long list.
236:             uint256 lenOfListLen = prefix - 0xf7;
237: 
238:             require(
239:                 _in.length > lenOfListLen,
240:                 "RLPReader: length of content must be > than length of list length (long list)"
241:             );
242: 
243:             bytes1 firstByteOfContent;
244:             assembly {
245:                 firstByteOfContent := and(mload(add(ptr, 1)), shl(248, 0xff))
246:             }
247: 
248:             require(
249:                 firstByteOfContent != 0x00,
250:                 "RLPReader: length of content must not have any leading zeros (long list)"
251:             );
252: 
253:             uint256 listLen;
254:             assembly {
255:                 listLen := shr(sub(256, mul(8, lenOfListLen)), mload(add(ptr, 1)))
256:             }
257: 
258:             require(
259:                 listLen > 55,
260:                 "RLPReader: length of content must be greater than 55 bytes (long list)"
261:             );
262: 
263:             require(
264:                 _in.length > lenOfListLen + listLen,
265:                 "RLPReader: length of content must be greater than total length (long list)"
266:             );
267: 
268:             return (1 + lenOfListLen, listLen, RLPItemType.LIST_ITEM);
269:         }
270:     }

277:     function _copy( 
278:         MemoryPointer _src,
279:         uint256 _offset,
280:         uint256 _length
281:     )
282:         private
283:         pure
284:         returns (bytes memory out_)
285:     {
286:         out_ = new bytes(_length);
287:         if (_length == 0) {
288:             return out_;
289:         }
290: 
291:         // Mostly based on Solidity's copy_memory_to_memory:
292:         // solhint-disable max-line-length
293:         // https://github.com/ethereum/solidity/blob/34dd30d71b4da730488be72ff6af7083cf2a91f6/libsolidity/codegen/YulUtilFunctions.cpp#L102-L114
294:         uint256 src = MemoryPointer.unwrap(_src) + _offset;
295:         assembly {
296:             let dest := add(out_, 32)
297:             let i := 0
298:             for { } lt(i, _length) { i := add(i, 32) } { mstore(add(dest, i), mload(add(src, i))) }
299: 
300:             if gt(i, _length) { mstore(add(dest, _length), 0) }
301:         }
302:     }
```
[35](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/rlp/RLPReader.sol#L35-L48), [53](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/rlp/RLPReader.sol#L53-L97), [102](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/rlp/RLPReader.sol#L102-L104), [109](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/rlp/RLPReader.sol#L109-L123), [128](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/rlp/RLPReader.sol#L128-L130), [135](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/rlp/RLPReader.sol#L135-L137), [144](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/rlp/RLPReader.sol#L144-L270), [277](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/rlp/RLPReader.sol#L277-L302)

```solidity
📁 File: contracts/thirdparty/optimism/rlp/RLPWriter.sol

13:     function writeBytes(bytes memory _in) internal pure returns (bytes memory out_) { 
14:         if (_in.length == 1 && uint8(_in[0]) < 128) {
15:             out_ = _in;
16:         } else {
17:             out_ = abi.encodePacked(_writeLength(_in.length, 128), _in);
18:         }
19:     }

24:     function writeUint(uint256 _in) internal pure returns (bytes memory out_) { 
25:         out_ = writeBytes(_toBinary(_in));
26:     }

32:     function _writeLength(uint256 _len, uint256 _offset) private pure returns (bytes memory out_) { 
33:         if (_len < 56) {
34:             out_ = new bytes(1);
35:             out_[0] = bytes1(uint8(_len) + uint8(_offset));
36:         } else {
37:             uint256 lenLen;
38:             uint256 i = 1;
39:             while (_len / i != 0) {
40:                 lenLen++;
41:                 i *= 256;
42:             }
43: 
44:             out_ = new bytes(lenLen + 1);
45:             out_[0] = bytes1(uint8(lenLen) + uint8(_offset) + 55);
46:             for (i = 1; i <= lenLen; i++) {
47:                 out_[i] = bytes1(uint8((_len / (256 ** (lenLen - i))) % 256));
48:             }
49:         }
50:     }

55:     function _toBinary(uint256 _x) private pure returns (bytes memory out_) { 
56:         bytes memory b = abi.encodePacked(_x);
57: 
58:         uint256 i = 0;
59:         for (; i < 32; i++) {
60:             if (b[i] != 0) {
61:                 break;
62:             }
63:         }
64: 
65:         out_ = new bytes(32 - i);
66:         for (uint256 j = 0; j < out_.length; j++) {
67:             out_[j] = b[i++];
68:         }
69:     }
```
[13](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/rlp/RLPWriter.sol#L13-L19), [24](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/rlp/RLPWriter.sol#L24-L26), [32](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/rlp/RLPWriter.sol#L32-L50), [55](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/rlp/RLPWriter.sol#L55-L69)

```solidity
📁 File: contracts/thirdparty/optimism/trie/MerkleTrie.sol

50:     function verifyInclusionProof( 
51:         bytes memory _key,
52:         bytes memory _value,
53:         bytes[] memory _proof,
54:         bytes32 _root
55:     )
56:         internal
57:         pure
58:         returns (bool valid_)
59:     {
60:         valid_ = Bytes.equal(_value, get(_key, _proof, _root));
61:     }

68:     function get( 
69:         bytes memory _key,
70:         bytes[] memory _proof,
71:         bytes32 _root
72:     )
73:         internal
74:         pure
75:         returns (bytes memory value_)
76:     {
77:         require(_key.length > 0, "MerkleTrie: empty key");
78: 
79:         TrieNode[] memory proof = _parseProof(_proof);
80:         bytes memory key = Bytes.toNibbles(_key);
81:         bytes memory currentNodeID = abi.encodePacked(_root);
82:         uint256 currentKeyIndex = 0;
83: 
84:         // Proof is top-down, so we start at the first element (root).
85:         for (uint256 i = 0; i < proof.length; i++) {
86:             TrieNode memory currentNode = proof[i];
87: 
88:             // Key index should never exceed total key length or we'll be out of bounds.
89:             require(currentKeyIndex <= key.length, "MerkleTrie: key index exceeds total key length");
90: 
91:             if (currentKeyIndex == 0) {
92:                 // First proof element is always the root node.
93:                 require(
94:                     Bytes.equal(abi.encodePacked(keccak256(currentNode.encoded)), currentNodeID),
95:                     "MerkleTrie: invalid root hash"
96:                 );
97:             } else if (currentNode.encoded.length >= 32) {
98:                 // Nodes 32 bytes or larger are hashed inside branch nodes.
99:                 require(
100:                     Bytes.equal(abi.encodePacked(keccak256(currentNode.encoded)), currentNodeID),
101:                     "MerkleTrie: invalid large internal hash"
102:                 );
103:             } else {
104:                 // Nodes smaller than 32 bytes aren't hashed.
105:                 require(
106:                     Bytes.equal(currentNode.encoded, currentNodeID),
107:                     "MerkleTrie: invalid internal node hash"
108:                 );
109:             }
110: 
111:             if (currentNode.decoded.length == BRANCH_NODE_LENGTH) {
112:                 if (currentKeyIndex == key.length) {
113:                     // Value is the last element of the decoded list (for branch nodes). There's
114:                     // some ambiguity in the Merkle trie specification because bytes(0) is a
115:                     // valid value to place into the trie, but for branch nodes bytes(0) can exist
116:                     // even when the value wasn't explicitly placed there. Geth treats a value of
117:                     // bytes(0) as "key does not exist" and so we do the same.
118:                     value_ = RLPReader.readBytes(currentNode.decoded[TREE_RADIX]);
119:                     require(
120:                         value_.length > 0,
121:                         "MerkleTrie: value length must be greater than zero (branch)"
122:                     );
123: 
124:                     // Extra proof elements are not allowed.
125:                     require(
126:                         i == proof.length - 1,
127:                         "MerkleTrie: value node must be last node in proof (branch)"
128:                     );
129: 
130:                     return value_;
131:                 } else {
132:                     // We're not at the end of the key yet.
133:                     // Figure out what the next node ID should be and continue.
134:                     uint8 branchKey = uint8(key[currentKeyIndex]);
135:                     RLPReader.RLPItem memory nextNode = currentNode.decoded[branchKey];
136:                     currentNodeID = _getNodeID(nextNode);
137:                     currentKeyIndex += 1;
138:                 }
139:             } else if (currentNode.decoded.length == LEAF_OR_EXTENSION_NODE_LENGTH) {
140:                 bytes memory path = _getNodePath(currentNode);
141:                 uint8 prefix = uint8(path[0]);
142:                 uint8 offset = 2 - (prefix % 2);
143:                 bytes memory pathRemainder = Bytes.slice(path, offset);
144:                 bytes memory keyRemainder = Bytes.slice(key, currentKeyIndex);
145:                 uint256 sharedNibbleLength = _getSharedNibbleLength(pathRemainder, keyRemainder);
146: 
147:                 // Whether this is a leaf node or an extension node, the path remainder MUST be a
148:                 // prefix of the key remainder (or be equal to the key remainder) or the proof is
149:                 // considered invalid.
150:                 require(
151:                     pathRemainder.length == sharedNibbleLength,
152:                     "MerkleTrie: path remainder must share all nibbles with key"
153:                 );
154: 
155:                 if (prefix == PREFIX_LEAF_EVEN || prefix == PREFIX_LEAF_ODD) {
156:                     // Prefix of 2 or 3 means this is a leaf node. For the leaf node to be valid,
157:                     // the key remainder must be exactly equal to the path remainder. We already
158:                     // did the necessary byte comparison, so it's more efficient here to check that
159:                     // the key remainder length equals the shared nibble length, which implies
160:                     // equality with the path remainder (since we already did the same check with
161:                     // the path remainder and the shared nibble length).
162:                     require(
163:                         keyRemainder.length == sharedNibbleLength,
164:                         "MerkleTrie: key remainder must be identical to path remainder"
165:                     );
166: 
167:                     // Our Merkle Trie is designed specifically for the purposes of the Ethereum
168:                     // state trie. Empty values are not allowed in the state trie, so we can safely
169:                     // say that if the value is empty, the key should not exist and the proof is
170:                     // invalid.
171:                     value_ = RLPReader.readBytes(currentNode.decoded[1]);
172:                     require(
173:                         value_.length > 0,
174:                         "MerkleTrie: value length must be greater than zero (leaf)"
175:                     );
176: 
177:                     // Extra proof elements are not allowed.
178:                     require(
179:                         i == proof.length - 1,
180:                         "MerkleTrie: value node must be last node in proof (leaf)"
181:                     );
182: 
183:                     return value_;
184:                 } else if (prefix == PREFIX_EXTENSION_EVEN || prefix == PREFIX_EXTENSION_ODD) {
185:                     // Prefix of 0 or 1 means this is an extension node. We move onto the next node
186:                     // in the proof and increment the key index by the length of the path remainder
187:                     // which is equal to the shared nibble length.
188:                     currentNodeID = _getNodeID(currentNode.decoded[1]);
189:                     currentKeyIndex += sharedNibbleLength;
190:                 } else {
191:                     revert("MerkleTrie: received a node with an unknown prefix");
192:                 }
193:             } else {
194:                 revert("MerkleTrie: received an unparseable node");
195:             }
196:         }
197: 
198:         revert("MerkleTrie: ran out of proof elements");
199:     }

205:     function _parseProof(bytes[] memory _proof) private pure returns (TrieNode[] memory proof_) { 
206:         uint256 length = _proof.length;
207:         proof_ = new TrieNode[](length);
208:         for (uint256 i = 0; i < length;) {
209:             proof_[i] = TrieNode({ encoded: _proof[i], decoded: RLPReader.readList(_proof[i]) });
210:             unchecked {
211:                 ++i;
212:             }
213:         }
214:     }

220:     function _getNodeID(RLPReader.RLPItem memory _node) private pure returns (bytes memory id_) { 
221:         id_ = _node.length < 32 ? RLPReader.readRawBytes(_node) : RLPReader.readBytes(_node);
222:     }

227:     function _getNodePath(TrieNode memory _node) private pure returns (bytes memory nibbles_) { 
228:         nibbles_ = Bytes.toNibbles(RLPReader.readBytes(_node.decoded[0]));
229:     }

235:     function _getSharedNibbleLength( 
236:         bytes memory _a,
237:         bytes memory _b
238:     )
239:         private
240:         pure
241:         returns (uint256 shared_)
242:     {
243:         uint256 max = (_a.length < _b.length) ? _a.length : _b.length;
244:         for (; shared_ < max && _a[shared_] == _b[shared_];) {
245:             unchecked {
246:                 ++shared_;
247:             }
248:         }
249:     }
```
[50](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/trie/MerkleTrie.sol#L50-L61), [68](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/trie/MerkleTrie.sol#L68-L199), [205](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/trie/MerkleTrie.sol#L205-L214), [220](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/trie/MerkleTrie.sol#L220-L222), [227](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/trie/MerkleTrie.sol#L227-L229), [235](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/trie/MerkleTrie.sol#L235-L249)

```solidity
📁 File: contracts/thirdparty/optimism/trie/SecureMerkleTrie.sol

19:     function verifyInclusionProof( 
20:         bytes memory _key,
21:         bytes memory _value,
22:         bytes[] memory _proof,
23:         bytes32 _root
24:     )
25:         internal
26:         pure
27:         returns (bool valid_)
28:     {
29:         bytes memory key = _getSecureKey(_key);
30:         valid_ = MerkleTrie.verifyInclusionProof(key, _value, _proof, _root);
31:     }

38:     function get( 
39:         bytes memory _key,
40:         bytes[] memory _proof,
41:         bytes32 _root
42:     )
43:         internal
44:         pure
45:         returns (bytes memory value_)
46:     {
47:         bytes memory key = _getSecureKey(_key);
48:         value_ = MerkleTrie.get(key, _proof, _root);
49:     }

54:     function _getSecureKey(bytes memory _key) private pure returns (bytes memory hash_) { 
55:         hash_ = abi.encodePacked(keccak256(_key));
56:     }
```
[19](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/trie/SecureMerkleTrie.sol#L19-L31), [38](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/trie/SecureMerkleTrie.sol#L38-L49), [54](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/trie/SecureMerkleTrie.sol#L54-L56)

```solidity
📁 File: contracts/thirdparty/solmate/LibFixedPointMath.sol

13:     function exp(int256 x) internal pure returns (int256 r) { 
14:         unchecked {
15:             // Input x is in fixed point format, with scale factor 1/1e18.
16: 
17:             // When the result is < 0.5 we return zero. This happens when
18:             // x <= floor(log(0.5e18) * 1e18) ~ -42e18
19:             if (x <= -42_139_678_854_452_767_551) {
20:                 return 0;
21:             }
22: 
23:             // When the result is > (2**255 - 1) / 1e18 we can not represent it
24:             // as an int256. This happens when x >= floor(log((2**255 -1) /
25:             // 1e18) * 1e18) ~ 135.
26:             if (x >= 135_305_999_368_893_231_589) revert Overflow();
27: 
28:             // x is now in the range (-42, 136) * 1e18. Convert to (-42, 136) *
29:             // 2**96
30:             // for more intermediate precision and a binary basis. This base
31:             // conversion
32:             // is a multiplication by 1e18 / 2**96 = 5**18 / 2**78.
33:             x = (x << 78) / 5 ** 18;
34: 
35:             // Reduce range of x to (-½ ln 2, ½ ln 2) * 2**96 by factoring out
36:             // powers of two
37:             // such that exp(x) = exp(x') * 2**k, where k is an integer.
38:             // Solving this gives k = round(x / log(2)) and x' = x - k * log(2).
39:             int256 k = ((x << 96) / 54_916_777_467_707_473_351_141_471_128 + 2 ** 95) >> 96;
40:             x = x - k * 54_916_777_467_707_473_351_141_471_128;
41:             // k is in the range [-61, 195].
42: 
43:             // Evaluate using a (6, 7)-term rational approximation.
44:             // p is made monic, we'll multiply by a scale factor later.
45:             int256 y = x + 1_346_386_616_545_796_478_920_950_773_328;
46:             y = ((y * x) >> 96) + 57_155_421_227_552_351_082_224_309_758_442;
47:             int256 p = y + x - 94_201_549_194_550_492_254_356_042_504_812;
48:             p = ((p * y) >> 96) + 28_719_021_644_029_726_153_956_944_680_412_240;
49:             p = p * x + (4_385_272_521_454_847_904_659_076_985_693_276 << 96);
50: 
51:             // We leave p in 2**192 basis so we don't need to scale it back up
52:             // for the division.
53:             int256 q = x - 2_855_989_394_907_223_263_936_484_059_900;
54:             q = ((q * x) >> 96) + 50_020_603_652_535_783_019_961_831_881_945;
55:             q = ((q * x) >> 96) - 533_845_033_583_426_703_283_633_433_725_380;
56:             q = ((q * x) >> 96) + 3_604_857_256_930_695_427_073_651_918_091_429;
57:             q = ((q * x) >> 96) - 14_423_608_567_350_463_180_887_372_962_807_573;
58:             q = ((q * x) >> 96) + 26_449_188_498_355_588_339_934_803_723_976_023;
59:             assembly {
60:                 // Div in assembly because solidity adds a zero check despite
61:                 // the `unchecked`.
62:                 // The q polynomial is known not to have zeros in the domain.
63:                 // (All roots are complex)
64:                 // No scaling required because p is already 2**96 too large.
65:                 r := sdiv(p, q)
66:             }
67:             // r should be in the range (0.09, 0.25) * 2**96.
68: 
69:             // We now need to multiply r by
70:             //  * the scale factor s = ~6.031367120...,
71:             //  * the 2**k factor from the range reduction, and
72:             //  * the 1e18 / 2**96 factor for base converison.
73:             // We do all of this at once, with an intermediate result in 2**213
74:             // basis
75:             // so the final right shift is always by a positive amount.
76:             r = int256(
77:                 (uint256(r) * 3_822_833_074_963_236_453_042_738_258_902_158_003_155_416_615_667)
78:                     >> uint256(195 - k)
79:             );
80:         }
81:     }
```
[13](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/solmate/LibFixedPointMath.sol#L13-L81)

```solidity
📁 File: contracts/tokenvault/BaseVault.sol

/// @audit Parameter of type 'bool' at index '0'
39:     function supportsInterface(bytes4 _interfaceId) public view virtual override returns (bool) { 

/// @audit Parameter of type 'bytes32' at index '0'
45:     function name() public pure virtual returns (bytes32); 

47:     function checkProcessMessageContext() 
48:         internal
49:         view
50:         onlyFromBridge
51:         returns (IBridge.Context memory ctx_)
52:     {
53:         ctx_ = IBridge(msg.sender).context();
54:         address selfOnSourceChain = resolve(ctx_.srcChainId, name(), false);
55:         if (ctx_.from != selfOnSourceChain) revert VAULT_PERMISSION_DENIED();
56:     }

58:     function checkRecallMessageContext() 
59:         internal
60:         view
61:         onlyFromBridge
62:         returns (IBridge.Context memory ctx_)
63:     {
64:         ctx_ = IBridge(msg.sender).context();
65:         if (ctx_.from != msg.sender) revert VAULT_PERMISSION_DENIED();
66:     }
```
[39](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BaseVault.sol#L39), [45](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BaseVault.sol#L45), [47](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BaseVault.sol#L47-L56), [58](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BaseVault.sol#L58-L66)

```solidity
📁 File: contracts/tokenvault/BridgedERC1155.sol

/// @audit Parameter of type 'string' at index '0'
115:     function name() public view returns (string memory) { 

/// @audit Parameter of type 'string' at index '0'
121:     function symbol() public view returns (string memory) { 
```
[115](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC1155.sol#L115), [121](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC1155.sol#L121)

```solidity
📁 File: contracts/tokenvault/BridgedERC20.sol

91:     function name() 

102:     function symbol() 

113:     function decimals() 

/// @audit Parameter of type 'address' at index '0'
/// @audit Parameter of type 'uint256' at index '1'
125:     function canonical() public view returns (address, uint256) { 
```
[91](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC20.sol#L91), [102](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC20.sol#L102), [113](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC20.sol#L113), [125](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC20.sol#L125)

```solidity
📁 File: contracts/tokenvault/BridgedERC20Base.sol

/// @audit Parameter of type 'address' at index '0'
93:     function owner() public view override(IBridgedERC20, OwnableUpgradeable) returns (address) { 

/// @audit Parameter of type 'bool' at index '0'
101:     function _isMigratingOut() internal view returns (bool) { 
```
[93](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC20Base.sol#L93), [101](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC20Base.sol#L101)

```solidity
📁 File: contracts/tokenvault/BridgedERC721.sol

/// @audit Parameter of type 'string' at index '0'
87:     function name() public view override(ERC721Upgradeable) returns (string memory) { 

/// @audit Parameter of type 'string' at index '0'
93:     function symbol() public view override(ERC721Upgradeable) returns (string memory) { 

/// @audit Parameter of type 'address' at index '0'
/// @audit Parameter of type 'uint256' at index '1'
100:     function source() public view returns (address, uint256) { 

/// @audit Parameter of type 'string' at index '0'
107:     function tokenURI(uint256 _tokenId) public view virtual override returns (string memory) { 
```
[87](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC721.sol#L87), [93](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC721.sol#L93), [100](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC721.sol#L100), [107](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC721.sol#L107)

```solidity
📁 File: contracts/tokenvault/ERC1155Vault.sol

/// @audit Parameter of type 'string' at index '0'
18:     function name() external view returns (string memory); 

/// @audit Parameter of type 'string' at index '0'
21:     function symbol() external view returns (string memory); 

39:     function sendToken(BridgeTransferOp memory _op) 
40:         external
41:         payable
42:         nonReentrant
43:         whenNotPaused
44:         withValidOperation(_op)
45:         returns (IBridge.Message memory message_)
46:     {
47:         for (uint256 i; i < _op.amounts.length; ++i) {
48:             if (_op.amounts[i] == 0) revert VAULT_INVALID_AMOUNT();
49:         }
50:         // Check token interface support
51:         if (!_op.token.supportsInterface(ERC1155_INTERFACE_ID)) {
52:             revert VAULT_INTERFACE_NOT_SUPPORTED();
53:         }
54: 
55:         (bytes memory data, CanonicalNFT memory ctoken) = _handleMessage(msg.sender, _op);
56: 
57:         // Create a message to send to the destination chain
58:         IBridge.Message memory message = IBridge.Message({
59:             id: 0, // will receive a new value
60:             from: address(0), // will receive a new value
61:             srcChainId: 0, // will receive a new value
62:             destChainId: _op.destChainId,
63:             srcOwner: msg.sender,
64:             destOwner: _op.destOwner != address(0) ? _op.destOwner : msg.sender,
65:             to: resolve(_op.destChainId, name(), false),
66:             refundTo: _op.refundTo,
67:             value: msg.value - _op.fee,
68:             fee: _op.fee,
69:             gasLimit: _op.gasLimit,
70:             data: data,
71:             memo: _op.memo
72:         });
73: 
74:         // Send the message and obtain the message hash
75:         bytes32 msgHash;
76:         (msgHash, message_) =
77:             IBridge(resolve("bridge", false)).sendMessage{ value: msg.value }(message);
78: 
79:         // Emit TokenSent event
80:         emit TokenSent({
81:             msgHash: msgHash,
82:             from: message_.srcOwner,
83:             to: _op.to,
84:             destChainId: message_.destChainId,
85:             ctoken: ctoken.addr,
86:             token: _op.token,
87:             tokenIds: _op.tokenIds,
88:             amounts: _op.amounts
89:         });
90:     }

160:     function onERC1155BatchReceived( 

175:     function onERC1155Received( 

192:     function supportsInterface(bytes4 interfaceId) 

/// @audit Parameter of type 'bytes32' at index '0'
204:     function name() public pure override returns (bytes32) { 

214:     function _transferTokens( 
215:         CanonicalNFT memory ctoken,
216:         address to,
217:         uint256[] memory tokenIds,
218:         uint256[] memory amounts
219:     )
220:         private
221:         returns (address token)
222:     {
223:         if (ctoken.chainId == block.chainid) {
224:             // Token lives on this chain
225:             token = ctoken.addr;
226:             IERC1155(token).safeBatchTransferFrom(address(this), to, tokenIds, amounts, "");
227:         } else {
228:             // Token does not live on this chain
229:             token = _getOrDeployBridgedToken(ctoken);
230:             BridgedERC1155(token).mintBatch(to, tokenIds, amounts);
231:         }
232:     }

240:     function _handleMessage( 
241:         address _user,
242:         BridgeTransferOp memory _op
243:     )
244:         private
245:         returns (bytes memory msgData_, CanonicalNFT memory ctoken_)
246:     {
247:         unchecked {
248:             // is a btoken, meaning, it does not live on this chain
249:             if (bridgedToCanonical[_op.token].addr != address(0)) {
250:                 ctoken_ = bridgedToCanonical[_op.token];
251:                 for (uint256 i; i < _op.tokenIds.length; ++i) {
252:                     BridgedERC1155(_op.token).burn(_user, _op.tokenIds[i], _op.amounts[i]);
253:                 }
254:             } else {
255:                 // is a ctoken token, meaning, it lives on this chain
256:                 ctoken_ = CanonicalNFT({
257:                     chainId: uint64(block.chainid),
258:                     addr: _op.token,
259:                     symbol: "",
260:                     name: ""
261:                 });
262:                 IERC1155NameAndSymbol t = IERC1155NameAndSymbol(_op.token);
263:                 try t.name() returns (string memory _name) {
264:                     ctoken_.name = _name;
265:                 } catch { }
266:                 try t.symbol() returns (string memory _symbol) {
267:                     ctoken_.symbol = _symbol;
268:                 } catch { }
269:                 for (uint256 i; i < _op.tokenIds.length; ++i) {
270:                     IERC1155(_op.token).safeTransferFrom({
271:                         from: msg.sender,
272:                         to: address(this),
273:                         id: _op.tokenIds[i],
274:                         amount: _op.amounts[i],
275:                         data: ""
276:                     });
277:                 }
278:             }
279:         }
280:         msgData_ = abi.encodeCall(
281:             this.onMessageInvocation, abi.encode(ctoken_, _user, _op.to, _op.tokenIds, _op.amounts)
282:         );
283:     }

288:     function _getOrDeployBridgedToken(CanonicalNFT memory _ctoken) 
289:         private
290:         returns (address btoken_)
291:     {
292:         btoken_ = canonicalToBridged[_ctoken.chainId][_ctoken.addr];
293:         if (btoken_ == address(0)) {
294:             btoken_ = _deployBridgedToken(_ctoken);
295:         }
296:     }

303:     function _deployBridgedToken(CanonicalNFT memory _ctoken) private returns (address btoken_) { 
304:         bytes memory data = abi.encodeCall(
305:             BridgedERC1155.init,
306:             (owner(), addressManager, _ctoken.addr, _ctoken.chainId, _ctoken.symbol, _ctoken.name)
307:         );
308: 
309:         btoken_ = address(new ERC1967Proxy(resolve("bridged_erc1155", false), data));
310: 
311:         bridgedToCanonical[btoken_] = _ctoken;
312:         canonicalToBridged[_ctoken.chainId][_ctoken.addr] = btoken_;
313: 
314:         emit BridgedTokenDeployed({
315:             chainId: _ctoken.chainId,
316:             ctoken: _ctoken.addr,
317:             btoken: btoken_,
318:             ctokenSymbol: _ctoken.symbol,
319:             ctokenName: _ctoken.name
320:         });
321:     }
```
[18](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC1155Vault.sol#L18), [21](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC1155Vault.sol#L21), [39](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC1155Vault.sol#L39-L90), [160](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC1155Vault.sol#L160), [175](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC1155Vault.sol#L175), [192](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC1155Vault.sol#L192), [204](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC1155Vault.sol#L204), [214](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC1155Vault.sol#L214-L232), [240](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC1155Vault.sol#L240-L283), [288](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC1155Vault.sol#L288-L296), [303](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC1155Vault.sol#L303-L321)

```solidity
📁 File: contracts/tokenvault/ERC20Vault.sol

148:     function changeBridgedToken( 
149:         CanonicalERC20 calldata _ctoken,
150:         address _btokenNew
151:     )
152:         external
153:         nonReentrant
154:         whenNotPaused
155:         onlyOwner
156:         returns (address btokenOld_)
157:     {
158:         if (_btokenNew == address(0) || bridgedToCanonical[_btokenNew].addr != address(0)) {
159:             revert VAULT_INVALID_NEW_BTOKEN();
160:         }
161: 
162:         if (btokenBlacklist[_btokenNew]) revert VAULT_BTOKEN_BLACKLISTED();
163: 
164:         if (IBridgedERC20(_btokenNew).owner() != owner()) {
165:             revert VAULT_NOT_SAME_OWNER();
166:         }
167: 
168:         btokenOld_ = canonicalToBridged[_ctoken.chainId][_ctoken.addr];
169: 
170:         if (btokenOld_ != address(0)) {
171:             CanonicalERC20 memory ctoken = bridgedToCanonical[btokenOld_];
172: 
173:             // The ctoken must match the saved one.
174:             if (
175:                 ctoken.decimals != _ctoken.decimals
176:                     || keccak256(bytes(ctoken.symbol)) != keccak256(bytes(_ctoken.symbol))
177:                     || keccak256(bytes(ctoken.name)) != keccak256(bytes(_ctoken.name))
178:             ) revert VAULT_CTOKEN_MISMATCH();
179: 
180:             delete bridgedToCanonical[_btokenNew];
181:             btokenBlacklist[btokenOld_] = true;
182: 
183:             // Start the migration
184:             IBridgedERC20(btokenOld_).changeMigrationStatus(_btokenNew, false);
185:             IBridgedERC20(_btokenNew).changeMigrationStatus(btokenOld_, true);
186:         }
187: 
188:         bridgedToCanonical[_btokenNew] = _ctoken;
189:         canonicalToBridged[_ctoken.chainId][_ctoken.addr] = _btokenNew;
190: 
191:         emit BridgedTokenChanged({
192:             srcChainId: _ctoken.chainId,
193:             ctoken: _ctoken.addr,
194:             btokenOld: btokenOld_,
195:             btokenNew: _btokenNew,
196:             ctokenSymbol: _ctoken.symbol,
197:             ctokenName: _ctoken.name,
198:             ctokenDecimal: _ctoken.decimals
199:         });
200:     }

207:     function sendToken(BridgeTransferOp calldata _op) 
208:         external
209:         payable
210:         nonReentrant
211:         whenNotPaused
212:         returns (IBridge.Message memory message_)
213:     {
214:         if (_op.amount == 0) revert VAULT_INVALID_AMOUNT();
215:         if (_op.token == address(0)) revert VAULT_INVALID_TOKEN();
216:         if (btokenBlacklist[_op.token]) revert VAULT_BTOKEN_BLACKLISTED();
217: 
218:         (bytes memory data, CanonicalERC20 memory ctoken, uint256 balanceChange) =
219:             _handleMessage(msg.sender, _op.token, _op.to, _op.amount);
220: 
221:         IBridge.Message memory message = IBridge.Message({
222:             id: 0, // will receive a new value
223:             from: address(0), // will receive a new value
224:             srcChainId: 0, // will receive a new value
225:             destChainId: _op.destChainId,
226:             srcOwner: msg.sender,
227:             destOwner: _op.destOwner != address(0) ? _op.destOwner : msg.sender,
228:             to: resolve(_op.destChainId, name(), false),
229:             refundTo: _op.refundTo,
230:             value: msg.value - _op.fee,
231:             fee: _op.fee,
232:             gasLimit: _op.gasLimit,
233:             data: data,
234:             memo: _op.memo
235:         });
236: 
237:         bytes32 msgHash;
238:         (msgHash, message_) =
239:             IBridge(resolve("bridge", false)).sendMessage{ value: msg.value }(message);
240: 
241:         emit TokenSent({
242:             msgHash: msgHash,
243:             from: message_.srcOwner,
244:             to: _op.to,
245:             destChainId: _op.destChainId,
246:             ctoken: ctoken.addr,
247:             token: _op.token,
248:             amount: balanceChange
249:         });
250:     }

/// @audit Parameter of type 'bytes32' at index '0'
316:     function name() public pure override returns (bytes32) { 

320:     function _transferTokens( 
321:         CanonicalERC20 memory _ctoken,
322:         address _to,
323:         uint256 _amount
324:     )
325:         private
326:         returns (address token_)
327:     {
328:         if (_ctoken.chainId == block.chainid) {
329:             token_ = _ctoken.addr;
330:             IERC20(token_).safeTransfer(_to, _amount);
331:         } else {
332:             token_ = _getOrDeployBridgedToken(_ctoken);
333:             IBridgedERC20(token_).mint(_to, _amount);
334:         }
335:     }

348:     function _handleMessage( 
349:         address _user,
350:         address _token,
351:         address _to,
352:         uint256 _amount
353:     )
354:         private
355:         returns (bytes memory msgData_, CanonicalERC20 memory ctoken_, uint256 balanceChange_)
356:     {
357:         // If it's a bridged token
358:         if (bridgedToCanonical[_token].addr != address(0)) {
359:             ctoken_ = bridgedToCanonical[_token];
360:             IBridgedERC20(_token).burn(msg.sender, _amount);
361:             balanceChange_ = _amount;
362:         } else {
363:             // If it's a canonical token
364:             IERC20Metadata meta = IERC20Metadata(_token);
365:             ctoken_ = CanonicalERC20({
366:                 chainId: uint64(block.chainid),
367:                 addr: _token,
368:                 decimals: meta.decimals(),
369:                 symbol: meta.symbol(),
370:                 name: meta.name()
371:             });
372: 
373:             // Query the balance then query it again to get the actual amount of
374:             // token transferred into this address, this is more accurate than
375:             // simply using `amount` -- some contract may deduct a fee from the
376:             // transferred amount.
377:             IERC20 t = IERC20(_token);
378:             uint256 _balance = t.balanceOf(address(this));
379:             t.safeTransferFrom({ from: msg.sender, to: address(this), value: _amount });
380:             balanceChange_ = t.balanceOf(address(this)) - _balance;
381:         }
382: 
383:         msgData_ = abi.encodeCall(
384:             this.onMessageInvocation, abi.encode(ctoken_, _user, _to, balanceChange_)
385:         );
386:     }

391:     function _getOrDeployBridgedToken(CanonicalERC20 memory ctoken) 
392:         private
393:         returns (address btoken)
394:     {
395:         btoken = canonicalToBridged[ctoken.chainId][ctoken.addr];
396: 
397:         if (btoken == address(0)) {
398:             btoken = _deployBridgedToken(ctoken);
399:         }
400:     }

407:     function _deployBridgedToken(CanonicalERC20 memory ctoken) private returns (address btoken) { 
408:         bytes memory data = abi.encodeCall(
409:             BridgedERC20.init,
410:             (
411:                 owner(),
412:                 addressManager,
413:                 ctoken.addr,
414:                 ctoken.chainId,
415:                 ctoken.decimals,
416:                 ctoken.symbol,
417:                 ctoken.name
418:             )
419:         );
420: 
421:         btoken = address(new ERC1967Proxy(resolve("bridged_erc20", false), data));
422:         bridgedToCanonical[btoken] = ctoken;
423:         canonicalToBridged[ctoken.chainId][ctoken.addr] = btoken;
424: 
425:         emit BridgedTokenDeployed({
426:             srcChainId: ctoken.chainId,
427:             ctoken: ctoken.addr,
428:             btoken: btoken,
429:             ctokenSymbol: ctoken.symbol,
430:             ctokenName: ctoken.name,
431:             ctokenDecimal: ctoken.decimals
432:         });
433:     }
```
[148](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC20Vault.sol#L148-L200), [207](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC20Vault.sol#L207-L250), [316](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC20Vault.sol#L316), [320](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC20Vault.sol#L320-L335), [348](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC20Vault.sol#L348-L386), [391](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC20Vault.sol#L391-L400), [407](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC20Vault.sol#L407-L433)

```solidity
📁 File: contracts/tokenvault/ERC721Vault.sol

26:     function sendToken(BridgeTransferOp memory _op) 
27:         external
28:         payable
29:         nonReentrant
30:         whenNotPaused
31:         withValidOperation(_op)
32:         returns (IBridge.Message memory message_)
33:     {
34:         for (uint256 i; i < _op.tokenIds.length; ++i) {
35:             if (_op.amounts[i] != 0) revert VAULT_INVALID_AMOUNT();
36:         }
37: 
38:         if (!_op.token.supportsInterface(ERC721_INTERFACE_ID)) {
39:             revert VAULT_INTERFACE_NOT_SUPPORTED();
40:         }
41: 
42:         (bytes memory data, CanonicalNFT memory ctoken) = _handleMessage(msg.sender, _op);
43: 
44:         IBridge.Message memory message = IBridge.Message({
45:             id: 0, // will receive a new value
46:             from: address(0), // will receive a new value
47:             srcChainId: 0, // will receive a new value
48:             destChainId: _op.destChainId,
49:             srcOwner: msg.sender,
50:             destOwner: _op.destOwner != address(0) ? _op.destOwner : msg.sender,
51:             to: resolve(_op.destChainId, name(), false),
52:             refundTo: _op.refundTo,
53:             value: msg.value - _op.fee,
54:             fee: _op.fee,
55:             gasLimit: _op.gasLimit,
56:             data: data,
57:             memo: _op.memo
58:         });
59: 
60:         bytes32 msgHash;
61:         (msgHash, message_) =
62:             IBridge(resolve("bridge", false)).sendMessage{ value: msg.value }(message);
63: 
64:         emit TokenSent({
65:             msgHash: msgHash,
66:             from: message_.srcOwner,
67:             to: _op.to,
68:             destChainId: message_.destChainId,
69:             ctoken: ctoken.addr,
70:             token: _op.token,
71:             tokenIds: _op.tokenIds,
72:             amounts: _op.amounts
73:         });
74:     }

142:     function onERC721Received( 

/// @audit Parameter of type 'bytes32' at index '0'
156:     function name() public pure override returns (bytes32) { 

160:     function _transferTokens( 
161:         CanonicalNFT memory _ctoken,
162:         address _to,
163:         uint256[] memory _tokenIds
164:     )
165:         private
166:         returns (address token_)
167:     {
168:         if (_ctoken.chainId == block.chainid) {
169:             token_ = _ctoken.addr;
170:             for (uint256 i; i < _tokenIds.length; ++i) {
171:                 IERC721(token_).safeTransferFrom(address(this), _to, _tokenIds[i]);
172:             }
173:         } else {
174:             token_ = _getOrDeployBridgedToken(_ctoken);
175:             for (uint256 i; i < _tokenIds.length; ++i) {
176:                 BridgedERC721(token_).mint(_to, _tokenIds[i]);
177:             }
178:         }
179:     }

187:     function _handleMessage( 
188:         address _user,
189:         BridgeTransferOp memory _op
190:     )
191:         private
192:         returns (bytes memory msgData_, CanonicalNFT memory ctoken_)
193:     {
194:         unchecked {
195:             if (bridgedToCanonical[_op.token].addr != address(0)) {
196:                 ctoken_ = bridgedToCanonical[_op.token];
197:                 for (uint256 i; i < _op.tokenIds.length; ++i) {
198:                     BridgedERC721(_op.token).burn(_user, _op.tokenIds[i]);
199:                 }
200:             } else {
201:                 ERC721Upgradeable t = ERC721Upgradeable(_op.token);
202: 
203:                 ctoken_ = CanonicalNFT({
204:                     chainId: uint64(block.chainid),
205:                     addr: _op.token,
206:                     symbol: t.symbol(),
207:                     name: t.name()
208:                 });
209: 
210:                 for (uint256 i; i < _op.tokenIds.length; ++i) {
211:                     t.safeTransferFrom(_user, address(this), _op.tokenIds[i]);
212:                 }
213:             }
214:         }
215: 
216:         msgData_ = abi.encodeCall(
217:             this.onMessageInvocation, abi.encode(ctoken_, _user, _op.to, _op.tokenIds)
218:         );
219:     }

224:     function _getOrDeployBridgedToken(CanonicalNFT memory _ctoken) 
225:         private
226:         returns (address btoken_)
227:     {
228:         btoken_ = canonicalToBridged[_ctoken.chainId][_ctoken.addr];
229: 
230:         if (btoken_ == address(0)) {
231:             btoken_ = _deployBridgedToken(_ctoken);
232:         }
233:     }

240:     function _deployBridgedToken(CanonicalNFT memory _ctoken) private returns (address btoken_) { 
241:         bytes memory data = abi.encodeCall(
242:             BridgedERC721.init,
243:             (owner(), addressManager, _ctoken.addr, _ctoken.chainId, _ctoken.symbol, _ctoken.name)
244:         );
245: 
246:         btoken_ = address(new ERC1967Proxy(resolve("bridged_erc721", false), data));
247:         bridgedToCanonical[btoken_] = _ctoken;
248:         canonicalToBridged[_ctoken.chainId][_ctoken.addr] = btoken_;
249: 
250:         emit BridgedTokenDeployed({
251:             chainId: _ctoken.chainId,
252:             ctoken: _ctoken.addr,
253:             btoken: btoken_,
254:             ctokenSymbol: _ctoken.symbol,
255:             ctokenName: _ctoken.name
256:         });
257:     }
```
[26](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC721Vault.sol#L26-L74), [142](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC721Vault.sol#L142), [156](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC721Vault.sol#L156), [160](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC721Vault.sol#L160-L179), [187](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC721Vault.sol#L187-L219), [224](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC721Vault.sol#L224-L233), [240](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC721Vault.sol#L240-L257)

```solidity
📁 File: contracts/tokenvault/IBridgedERC20.sol

/// @audit Parameter of type 'address' at index '0'
28:     function owner() external view returns (address); 
```
[28](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/IBridgedERC20.sol#L28)

```solidity
📁 File: contracts/tokenvault/LibBridgedToken.sol

28:     function buildName( 

/// @audit Parameter of type 'string' at index '0'
39:     function buildSymbol(string memory _symbol) internal pure returns (string memory) { 

43:     function buildURI( 
```
[28](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/LibBridgedToken.sol#L28), [39](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/LibBridgedToken.sol#L39), [43](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/LibBridgedToken.sol#L43)

```solidity
📁 File: contracts/tokenvault/adapters/USDCAdapter.sol

/// @audit Parameter of type 'bool' at index '0'
23:     function transferFrom(address from, address _to, uint256 _amount) external returns (bool); 
```
[23](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/adapters/USDCAdapter.sol#L23)

```solidity
📁 File: contracts/verifiers/SgxVerifier.sol

90:     function addInstances(address[] calldata _instances) 

118:     function registerInstance(V3Struct.ParsedV3QuoteStruct calldata _attestation) 

171:     function getSignedHash( 

195:     function _addInstances( 
196:         address[] memory _instances,
197:         bool instantValid
198:     )
199:         private
200:         returns (uint256[] memory ids)
201:     {
202:         ids = new uint256[](_instances.length);
203: 
204:         uint64 validSince = uint64(block.timestamp);
205: 
206:         if (!instantValid) {
207:             validSince += INSTANCE_VALIDITY_DELAY;
208:         }
209: 
210:         for (uint256 i; i < _instances.length; ++i) {
211:             if (addressRegistered[_instances[i]]) revert SGX_ALREADY_ATTESTED();
212: 
213:             addressRegistered[_instances[i]] = true;
214: 
215:             if (_instances[i] == address(0)) revert SGX_INVALID_INSTANCE();
216: 
217:             instances[nextInstanceId] = Instance(_instances[i], validSince);
218:             ids[i] = nextInstanceId;
219: 
220:             emit InstanceAdded(nextInstanceId, _instances[i], address(0), validSince);
221: 
222:             nextInstanceId++;
223:         }
224:     }

/// @audit Parameter of type 'bool' at index '0'
233:     function _isInstanceValid(uint256 id, address instance) private view returns (bool) { 
```
[90](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/verifiers/SgxVerifier.sol#L90), [118](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/verifiers/SgxVerifier.sol#L118), [171](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/verifiers/SgxVerifier.sol#L171), [195](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/verifiers/SgxVerifier.sol#L195-L224), [233](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/verifiers/SgxVerifier.sol#L233)

</details>


---
### [GAS&#x2011;48] Optimize Deployment Size by Fine-tuning IPFS Hash
The Solidity compiler appends 53 bytes of metadata to the smart contract code, incurring an extra cost of 10,600 gas. This additional expense arises from 200 gas per bytecode, plus calldata cost, which amounts to 16 gas for non-zero bytes and 4 gas for zero bytes. This results in a maximum of 848 extra gas in calldata cost.

Reducing this cost is crucial for the following reasons:

The metadata's 53-byte addition leads to a deployment cost increase of 10,600 gas.
It can also result in an additional calldata cost of up to 848 gas.
Ways to Minimize Gas Consumption:

Employ the `--no-cbor-metadata` compiler option to exclude metadata. Be cautious as this might impact contract verification.
Search for code comments that yield an IPFS hash with more zeros, thereby reducing calldata costs.


Gas saved per Instance: ~10,600 *(Total: ~858,600)*
<details>
<summary><i>There are 81 instances of this issue:</i></summary>

```solidity
📁 File: contracts/L1/ITaikoL1.sol

/// @audit Consider optimizing the IPFS hash during deployment.
1: // SPDX-License-Identifier: MIT 
```
[1](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/ITaikoL1.sol#L1)

```solidity
📁 File: contracts/L1/TaikoData.sol

/// @audit Consider optimizing the IPFS hash during deployment.
1: // SPDX-License-Identifier: MIT 
```
[1](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/TaikoData.sol#L1)

```solidity
📁 File: contracts/L1/TaikoErrors.sol

/// @audit Consider optimizing the IPFS hash during deployment.
1: // SPDX-License-Identifier: MIT 
```
[1](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/TaikoErrors.sol#L1)

```solidity
📁 File: contracts/L1/TaikoEvents.sol

/// @audit Consider optimizing the IPFS hash during deployment.
1: // SPDX-License-Identifier: MIT 
```
[1](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/TaikoEvents.sol#L1)

```solidity
📁 File: contracts/L1/TaikoL1.sol

/// @audit Consider optimizing the IPFS hash during deployment.
1: // SPDX-License-Identifier: MIT 
```
[1](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/TaikoL1.sol#L1)

```solidity
📁 File: contracts/L1/TaikoToken.sol

/// @audit Consider optimizing the IPFS hash during deployment.
1: // SPDX-License-Identifier: MIT 
```
[1](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/TaikoToken.sol#L1)

```solidity
📁 File: contracts/L1/gov/TaikoGovernor.sol

/// @audit Consider optimizing the IPFS hash during deployment.
1: // SPDX-License-Identifier: MIT 
```
[1](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/gov/TaikoGovernor.sol#L1)

```solidity
📁 File: contracts/L1/gov/TaikoTimelockController.sol

/// @audit Consider optimizing the IPFS hash during deployment.
1: // SPDX-License-Identifier: MIT 
```
[1](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/gov/TaikoTimelockController.sol#L1)

```solidity
📁 File: contracts/L1/hooks/AssignmentHook.sol

/// @audit Consider optimizing the IPFS hash during deployment.
1: // SPDX-License-Identifier: MIT 
```
[1](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/hooks/AssignmentHook.sol#L1)

```solidity
📁 File: contracts/L1/hooks/IHook.sol

/// @audit Consider optimizing the IPFS hash during deployment.
1: // SPDX-License-Identifier: MIT 
```
[1](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/hooks/IHook.sol#L1)

```solidity
📁 File: contracts/L1/libs/LibDepositing.sol

/// @audit Consider optimizing the IPFS hash during deployment.
1: // SPDX-License-Identifier: MIT 
```
[1](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibDepositing.sol#L1)

```solidity
📁 File: contracts/L1/libs/LibProposing.sol

/// @audit Consider optimizing the IPFS hash during deployment.
1: // SPDX-License-Identifier: MIT 
```
[1](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProposing.sol#L1)

```solidity
📁 File: contracts/L1/libs/LibProving.sol

/// @audit Consider optimizing the IPFS hash during deployment.
1: // SPDX-License-Identifier: MIT 
```
[1](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProving.sol#L1)

```solidity
📁 File: contracts/L1/libs/LibUtils.sol

/// @audit Consider optimizing the IPFS hash during deployment.
1: // SPDX-License-Identifier: MIT 
```
[1](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibUtils.sol#L1)

```solidity
📁 File: contracts/L1/libs/LibVerifying.sol

/// @audit Consider optimizing the IPFS hash during deployment.
1: // SPDX-License-Identifier: MIT 
```
[1](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibVerifying.sol#L1)

```solidity
📁 File: contracts/L1/provers/GuardianProver.sol

/// @audit Consider optimizing the IPFS hash during deployment.
1: // SPDX-License-Identifier: MIT 
```
[1](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/provers/GuardianProver.sol#L1)

```solidity
📁 File: contracts/L1/provers/Guardians.sol

/// @audit Consider optimizing the IPFS hash during deployment.
1: // SPDX-License-Identifier: MIT 
```
[1](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/provers/Guardians.sol#L1)

```solidity
📁 File: contracts/L1/tiers/DevnetTierProvider.sol

/// @audit Consider optimizing the IPFS hash during deployment.
1: // SPDX-License-Identifier: MIT 
```
[1](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/tiers/DevnetTierProvider.sol#L1)

```solidity
📁 File: contracts/L1/tiers/ITierProvider.sol

/// @audit Consider optimizing the IPFS hash during deployment.
1: // SPDX-License-Identifier: MIT 
```
[1](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/tiers/ITierProvider.sol#L1)

```solidity
📁 File: contracts/L1/tiers/MainnetTierProvider.sol

/// @audit Consider optimizing the IPFS hash during deployment.
1: // SPDX-License-Identifier: MIT 
```
[1](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/tiers/MainnetTierProvider.sol#L1)

```solidity
📁 File: contracts/L1/tiers/TestnetTierProvider.sol

/// @audit Consider optimizing the IPFS hash during deployment.
1: // SPDX-License-Identifier: MIT 
```
[1](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/tiers/TestnetTierProvider.sol#L1)

```solidity
📁 File: contracts/L2/CrossChainOwned.sol

/// @audit Consider optimizing the IPFS hash during deployment.
1: // SPDX-License-Identifier: MIT 
```
[1](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/CrossChainOwned.sol#L1)

```solidity
📁 File: contracts/L2/Lib1559Math.sol

/// @audit Consider optimizing the IPFS hash during deployment.
1: // SPDX-License-Identifier: MIT 
```
[1](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/Lib1559Math.sol#L1)

```solidity
📁 File: contracts/L2/TaikoL2.sol

/// @audit Consider optimizing the IPFS hash during deployment.
1: // SPDX-License-Identifier: MIT 
```
[1](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/TaikoL2.sol#L1)

```solidity
📁 File: contracts/L2/TaikoL2EIP1559Configurable.sol

/// @audit Consider optimizing the IPFS hash during deployment.
1: // SPDX-License-Identifier: MIT 
```
[1](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/TaikoL2EIP1559Configurable.sol#L1)

```solidity
📁 File: contracts/automata-attestation/AutomataDcapV3Attestation.sol

/// @audit Consider optimizing the IPFS hash during deployment.
1: //SPDX-License-Identifier: MIT 
```
[1](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/AutomataDcapV3Attestation.sol#L1)

```solidity
📁 File: contracts/automata-attestation/interfaces/IAttestation.sol

/// @audit Consider optimizing the IPFS hash during deployment.
1: //SPDX-License-Identifier: MIT 
```
[1](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/interfaces/IAttestation.sol#L1)

```solidity
📁 File: contracts/automata-attestation/interfaces/ISigVerifyLib.sol

/// @audit Consider optimizing the IPFS hash during deployment.
1: //SPDX-License-Identifier: MIT 
```
[1](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/interfaces/ISigVerifyLib.sol#L1)

```solidity
📁 File: contracts/automata-attestation/lib/EnclaveIdStruct.sol

/// @audit Consider optimizing the IPFS hash during deployment.
1: //SPDX-License-Identifier: MIT 
```
[1](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/EnclaveIdStruct.sol#L1)

```solidity
📁 File: contracts/automata-attestation/lib/PEMCertChainLib.sol

/// @audit Consider optimizing the IPFS hash during deployment.
1: // SPDX-License-Identifier: MIT 
```
[1](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/PEMCertChainLib.sol#L1)

```solidity
📁 File: contracts/automata-attestation/lib/QuoteV3Auth/V3Parser.sol

/// @audit Consider optimizing the IPFS hash during deployment.
1: //SPDX-License-Identifier: MIT 
```
[1](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/QuoteV3Auth/V3Parser.sol#L1)

```solidity
📁 File: contracts/automata-attestation/lib/QuoteV3Auth/V3Struct.sol

/// @audit Consider optimizing the IPFS hash during deployment.
1: //SPDX-License-Identifier: MIT 
```
[1](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/QuoteV3Auth/V3Struct.sol#L1)

```solidity
📁 File: contracts/automata-attestation/lib/TCBInfoStruct.sol

/// @audit Consider optimizing the IPFS hash during deployment.
1: //SPDX-License-Identifier: MIT 
```
[1](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/TCBInfoStruct.sol#L1)

```solidity
📁 File: contracts/automata-attestation/lib/interfaces/IPEMCertChainLib.sol

/// @audit Consider optimizing the IPFS hash during deployment.
1: // SPDX-License-Identifier: MIT 
```
[1](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/interfaces/IPEMCertChainLib.sol#L1)

```solidity
📁 File: contracts/automata-attestation/utils/Asn1Decode.sol

/// @audit Consider optimizing the IPFS hash during deployment.
1: // SPDX-License-Identifier: MIT 
```
[1](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/Asn1Decode.sol#L1)

```solidity
📁 File: contracts/automata-attestation/utils/BytesUtils.sol

/// @audit Consider optimizing the IPFS hash during deployment.
1: // SPDX-License-Identifier: BSD 2-Clause License 
```
[1](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/BytesUtils.sol#L1)

```solidity
📁 File: contracts/automata-attestation/utils/RsaVerify.sol

/// @audit Consider optimizing the IPFS hash during deployment.
1: // SPDX-License-Identifier: GPL-3.0 
```
[1](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/RsaVerify.sol#L1)

```solidity
📁 File: contracts/automata-attestation/utils/SHA1.sol

/// @audit Consider optimizing the IPFS hash during deployment.
1: // SPDX-License-Identifier: BSD 2-Clause License 
```
[1](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/SHA1.sol#L1)

```solidity
📁 File: contracts/automata-attestation/utils/SigVerifyLib.sol

/// @audit Consider optimizing the IPFS hash during deployment.
1: // SPDX-License-Identifier: GPL-3.0 
```
[1](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/SigVerifyLib.sol#L1)

```solidity
📁 File: contracts/automata-attestation/utils/X509DateUtils.sol

/// @audit Consider optimizing the IPFS hash during deployment.
1: // SPDX-License-Identifier: MIT 
```
[1](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/X509DateUtils.sol#L1)

```solidity
📁 File: contracts/bridge/Bridge.sol

/// @audit Consider optimizing the IPFS hash during deployment.
1: // SPDX-License-Identifier: MIT 
```
[1](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/Bridge.sol#L1)

```solidity
📁 File: contracts/bridge/IBridge.sol

/// @audit Consider optimizing the IPFS hash during deployment.
1: // SPDX-License-Identifier: MIT 
```
[1](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/IBridge.sol#L1)

```solidity
📁 File: contracts/common/AddressManager.sol

/// @audit Consider optimizing the IPFS hash during deployment.
1: // SPDX-License-Identifier: MIT 
```
[1](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/common/AddressManager.sol#L1)

```solidity
📁 File: contracts/common/AddressResolver.sol

/// @audit Consider optimizing the IPFS hash during deployment.
1: // SPDX-License-Identifier: MIT 
```
[1](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/common/AddressResolver.sol#L1)

```solidity
📁 File: contracts/common/EssentialContract.sol

/// @audit Consider optimizing the IPFS hash during deployment.
1: // SPDX-License-Identifier: MIT 
```
[1](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/common/EssentialContract.sol#L1)

```solidity
📁 File: contracts/common/IAddressManager.sol

/// @audit Consider optimizing the IPFS hash during deployment.
1: // SPDX-License-Identifier: MIT 
```
[1](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/common/IAddressManager.sol#L1)

```solidity
📁 File: contracts/common/IAddressResolver.sol

/// @audit Consider optimizing the IPFS hash during deployment.
1: // SPDX-License-Identifier: MIT 
```
[1](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/common/IAddressResolver.sol#L1)

```solidity
📁 File: contracts/libs/Lib4844.sol

/// @audit Consider optimizing the IPFS hash during deployment.
1: // SPDX-License-Identifier: MIT 
```
[1](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/libs/Lib4844.sol#L1)

```solidity
📁 File: contracts/libs/LibAddress.sol

/// @audit Consider optimizing the IPFS hash during deployment.
1: // SPDX-License-Identifier: MIT 
```
[1](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/libs/LibAddress.sol#L1)

```solidity
📁 File: contracts/libs/LibMath.sol

/// @audit Consider optimizing the IPFS hash during deployment.
1: // SPDX-License-Identifier: MIT 
```
[1](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/libs/LibMath.sol#L1)

```solidity
📁 File: contracts/libs/LibTrieProof.sol

/// @audit Consider optimizing the IPFS hash during deployment.
1: // SPDX-License-Identifier: MIT 
```
[1](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/libs/LibTrieProof.sol#L1)

```solidity
📁 File: contracts/signal/ISignalService.sol

/// @audit Consider optimizing the IPFS hash during deployment.
1: // SPDX-License-Identifier: MIT 
```
[1](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/signal/ISignalService.sol#L1)

```solidity
📁 File: contracts/signal/LibSignals.sol

/// @audit Consider optimizing the IPFS hash during deployment.
1: // SPDX-License-Identifier: MIT 
```
[1](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/signal/LibSignals.sol#L1)

```solidity
📁 File: contracts/signal/SignalService.sol

/// @audit Consider optimizing the IPFS hash during deployment.
1: // SPDX-License-Identifier: MIT 
```
[1](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/signal/SignalService.sol#L1)

```solidity
📁 File: contracts/team/TimelockTokenPool.sol

/// @audit Consider optimizing the IPFS hash during deployment.
1: // SPDX-License-Identifier: MIT 
```
[1](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/TimelockTokenPool.sol#L1)

```solidity
📁 File: contracts/team/airdrop/ERC20Airdrop.sol

/// @audit Consider optimizing the IPFS hash during deployment.
1: // SPDX-License-Identifier: MIT 
```
[1](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/airdrop/ERC20Airdrop.sol#L1)

```solidity
📁 File: contracts/team/airdrop/ERC20Airdrop2.sol

/// @audit Consider optimizing the IPFS hash during deployment.
1: // SPDX-License-Identifier: MIT 
```
[1](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/airdrop/ERC20Airdrop2.sol#L1)

```solidity
📁 File: contracts/team/airdrop/ERC721Airdrop.sol

/// @audit Consider optimizing the IPFS hash during deployment.
1: // SPDX-License-Identifier: MIT 
```
[1](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/airdrop/ERC721Airdrop.sol#L1)

```solidity
📁 File: contracts/team/airdrop/MerkleClaimable.sol

/// @audit Consider optimizing the IPFS hash during deployment.
1: // SPDX-License-Identifier: MIT 
```
[1](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/airdrop/MerkleClaimable.sol#L1)

```solidity
📁 File: contracts/thirdparty/nomad-xyz/ExcessivelySafeCall.sol

/// @audit Consider optimizing the IPFS hash during deployment.
1: // SPDX-License-Identifier: MIT OR Apache-2.0 
```
[1](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/nomad-xyz/ExcessivelySafeCall.sol#L1)

```solidity
📁 File: contracts/thirdparty/optimism/Bytes.sol

/// @audit Consider optimizing the IPFS hash during deployment.
1: // SPDX-License-Identifier: MIT 
```
[1](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/Bytes.sol#L1)

```solidity
📁 File: contracts/thirdparty/optimism/rlp/RLPReader.sol

/// @audit Consider optimizing the IPFS hash during deployment.
1: // SPDX-License-Identifier: MIT 
```
[1](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/rlp/RLPReader.sol#L1)

```solidity
📁 File: contracts/thirdparty/optimism/rlp/RLPWriter.sol

/// @audit Consider optimizing the IPFS hash during deployment.
1: // SPDX-License-Identifier: MIT 
```
[1](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/rlp/RLPWriter.sol#L1)

```solidity
📁 File: contracts/thirdparty/optimism/trie/MerkleTrie.sol

/// @audit Consider optimizing the IPFS hash during deployment.
1: // SPDX-License-Identifier: MIT 
```
[1](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/trie/MerkleTrie.sol#L1)

```solidity
📁 File: contracts/thirdparty/optimism/trie/SecureMerkleTrie.sol

/// @audit Consider optimizing the IPFS hash during deployment.
1: // SPDX-License-Identifier: MIT 
```
[1](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/trie/SecureMerkleTrie.sol#L1)

```solidity
📁 File: contracts/thirdparty/solmate/LibFixedPointMath.sol

/// @audit Consider optimizing the IPFS hash during deployment.
1: // SPDX-License-Identifier: MIT 
```
[1](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/solmate/LibFixedPointMath.sol#L1)

```solidity
📁 File: contracts/tokenvault/BaseNFTVault.sol

/// @audit Consider optimizing the IPFS hash during deployment.
1: // SPDX-License-Identifier: MIT 
```
[1](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BaseNFTVault.sol#L1)

```solidity
📁 File: contracts/tokenvault/BaseVault.sol

/// @audit Consider optimizing the IPFS hash during deployment.
1: // SPDX-License-Identifier: MIT 
```
[1](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BaseVault.sol#L1)

```solidity
📁 File: contracts/tokenvault/BridgedERC1155.sol

/// @audit Consider optimizing the IPFS hash during deployment.
1: // SPDX-License-Identifier: MIT 
```
[1](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC1155.sol#L1)

```solidity
📁 File: contracts/tokenvault/BridgedERC20.sol

/// @audit Consider optimizing the IPFS hash during deployment.
1: // SPDX-License-Identifier: MIT 
```
[1](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC20.sol#L1)

```solidity
📁 File: contracts/tokenvault/BridgedERC20Base.sol

/// @audit Consider optimizing the IPFS hash during deployment.
1: // SPDX-License-Identifier: MIT 
```
[1](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC20Base.sol#L1)

```solidity
📁 File: contracts/tokenvault/BridgedERC721.sol

/// @audit Consider optimizing the IPFS hash during deployment.
1: // SPDX-License-Identifier: MIT 
```
[1](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC721.sol#L1)

```solidity
📁 File: contracts/tokenvault/ERC1155Vault.sol

/// @audit Consider optimizing the IPFS hash during deployment.
1: // SPDX-License-Identifier: MIT 
```
[1](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC1155Vault.sol#L1)

```solidity
📁 File: contracts/tokenvault/ERC20Vault.sol

/// @audit Consider optimizing the IPFS hash during deployment.
1: // SPDX-License-Identifier: MIT 
```
[1](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC20Vault.sol#L1)

```solidity
📁 File: contracts/tokenvault/ERC721Vault.sol

/// @audit Consider optimizing the IPFS hash during deployment.
1: // SPDX-License-Identifier: MIT 
```
[1](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC721Vault.sol#L1)

```solidity
📁 File: contracts/tokenvault/IBridgedERC20.sol

/// @audit Consider optimizing the IPFS hash during deployment.
1: // SPDX-License-Identifier: MIT 
```
[1](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/IBridgedERC20.sol#L1)

```solidity
📁 File: contracts/tokenvault/LibBridgedToken.sol

/// @audit Consider optimizing the IPFS hash during deployment.
1: // SPDX-License-Identifier: MIT 
```
[1](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/LibBridgedToken.sol#L1)

```solidity
📁 File: contracts/tokenvault/adapters/USDCAdapter.sol

/// @audit Consider optimizing the IPFS hash during deployment.
1: // SPDX-License-Identifier: MIT 
```
[1](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/adapters/USDCAdapter.sol#L1)

```solidity
📁 File: contracts/verifiers/GuardianVerifier.sol

/// @audit Consider optimizing the IPFS hash during deployment.
1: // SPDX-License-Identifier: MIT 
```
[1](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/verifiers/GuardianVerifier.sol#L1)

```solidity
📁 File: contracts/verifiers/IVerifier.sol

/// @audit Consider optimizing the IPFS hash during deployment.
1: // SPDX-License-Identifier: MIT 
```
[1](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/verifiers/IVerifier.sol#L1)

```solidity
📁 File: contracts/verifiers/SgxVerifier.sol

/// @audit Consider optimizing the IPFS hash during deployment.
1: // SPDX-License-Identifier: MIT 
```
[1](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/verifiers/SgxVerifier.sol#L1)

</details>


---
### [GAS&#x2011;49] Optimize Ether deposits using the `receive()` function
Consider using receive() function instead of a specific deposit() (or similar) function. If there are several functions in the contract that can receive Ether, it is recommended to use receive() for the most frequently used function. The receive() or fallback() function can handle incoming Ether transfers directly, providing more gas-efficient way to manage deposits.


Gas saved per Instance: ~45 

<i>There is one instance of this issue:</i>

```solidity
📁 File: contracts/tokenvault/ERC20Vault.sol

207:     function sendToken(BridgeTransferOp calldata _op) 
208:         external
209:         payable
210:         nonReentrant
211:         whenNotPaused
212:         returns (IBridge.Message memory message_)
213:     {
```
[207](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC20Vault.sol#L207-L213)


---
### [GAS&#x2011;50] Pre-increments/pre-decrements are cheaper than `+1`/`+=1` or `-1`/`-=1`

Gas saved per Instance: ~11 *(Total: ~187)*
<details>
<summary><i>There are 17 instances of this issue:</i></summary>

```solidity
📁 File: contracts/L2/TaikoL2.sol

/// @audit prefer '++i'
234:             for (uint256 i; i < 255 && _blockId >= i + 1; ++i) { 
```
[234](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/TaikoL2.sol#L234)

```solidity
📁 File: contracts/automata-attestation/AutomataDcapV3Attestation.sol

/// @audit prefer '--n'
261:             if (i == n - 1) { 

/// @audit prefer '++i'
265:                 issuer = certs[i + 1]; 
```
[261](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/AutomataDcapV3Attestation.sol#L261), [265](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/AutomataDcapV3Attestation.sol#L265)

```solidity
📁 File: contracts/automata-attestation/lib/PEMCertChainLib.sol

/// @audit prefer '++SGX_TCB_CPUSVN_SIZE'
354:         for (uint256 i; i < SGX_TCB_CPUSVN_SIZE + 1; ++i) { 
```
[354](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/PEMCertChainLib.sol#L354)

```solidity
📁 File: contracts/automata-attestation/utils/Asn1Decode.sol

/// @audit prefer '--valueLength'
159:             return der.substring(ptr.ixf() + 1, valueLength - 1); 

/// @audit prefer '--valueLength'
184:         return der.substring(ptr.ixf() + 1, valueLength - 1); 

/// @audit prefer '++ix'
192:             length = uint8(der[ix + 1]); 

/// @audit prefer '++ix'
196:             uint8 lengthbytesLength = uint8(der[ix + 1] & 0x7F); 
```
[159](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/Asn1Decode.sol#L159), [184](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/Asn1Decode.sol#L184), [192](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/Asn1Decode.sol#L192), [196](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/Asn1Decode.sol#L196)

```solidity
📁 File: contracts/automata-attestation/utils/BytesUtils.sol

/// @audit prefer '--len'
338:             if (i == len - 1) { 

/// @audit prefer '--bitlen'
359:             bitlen -= 1; 
```
[338](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/BytesUtils.sol#L338), [359](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/BytesUtils.sol#L359)

```solidity
📁 File: contracts/automata-attestation/utils/X509DateUtils.sol

/// @audit prefer '++offset'
24:         yrs += (uint8(x509Time[offset + 0]) - 48) * 10 + uint8(x509Time[offset + 1]) - 48; 

/// @audit prefer '--i'
60:             timestamp += uint256(monthDays[i - 1]) * 86_400; // Days in seconds 

/// @audit prefer '--day'
63:         timestamp += uint256(day - 1) * 86_400; // Days in seconds 
```
[24](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/X509DateUtils.sol#L24), [60](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/X509DateUtils.sol#L60), [63](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/X509DateUtils.sol#L63)

```solidity
📁 File: contracts/thirdparty/optimism/rlp/RLPReader.sol

/// @audit prefer '++itemCount'
89:             itemCount += 1; 
```
[89](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/rlp/RLPReader.sol#L89)

```solidity
📁 File: contracts/thirdparty/optimism/rlp/RLPWriter.sol

/// @audit prefer '++lenLen'
44:             out_ = new bytes(lenLen + 1); 
```
[44](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/rlp/RLPWriter.sol#L44)

```solidity
📁 File: contracts/thirdparty/optimism/trie/MerkleTrie.sol

/// @audit prefer '++TREE_RADIX'
24:     uint256 internal constant BRANCH_NODE_LENGTH = TREE_RADIX + 1; 

/// @audit prefer '++currentKeyIndex'
137:                     currentKeyIndex += 1; 
```
[24](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/trie/MerkleTrie.sol#L24), [137](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/trie/MerkleTrie.sol#L137)

</details>


---
### [GAS&#x2011;51] Prefer using `storage` instead of `memory` for state variables saves gas
When fetching data from a storage location, assigning the data to a `memory` variable causes all fields of the struct/array to be read from storage, which incurs a Gcoldsload (**2100 gas**) for *each* field of the struct/array. If the fields are read from the new memory variable, they incur an additional `MLOAD` rather than a cheap stack read. Instead of declaring the variable with the `memory` keyword, declaring the variable with the `storage` keyword and caching any fields that need to be re-read in stack variables, will be much cheaper, only incurring the Gcoldsload for the fields actually read. The only time it makes sense to read the whole struct/array into a `memory` variable, is if the full struct/array is being returned by the function, is being passed to a function that requires `memory`, or if the array/struct is being read from another `memory` array/struct


Gas saved per Instance: ~2,100 *(Total: ~12,600)*
<details>
<summary><i>There are 6 instances of this issue:</i></summary>

```solidity
📁 File: contracts/L1/libs/LibProposing.sol

93:         TaikoData.SlotB memory b = _state.slotB; 
```
[93](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProposing.sol#L93)

```solidity
📁 File: contracts/L1/libs/LibProving.sol

110:         TaikoData.SlotB memory b = _state.slotB; 
```
[110](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProving.sol#L110)

```solidity
📁 File: contracts/L1/libs/LibUtils.sol

33:         TaikoData.SlotB memory b = _state.slotB; 
```
[33](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibUtils.sol#L33)

```solidity
📁 File: contracts/L1/libs/LibVerifying.sol

99:         TaikoData.SlotB memory b = _state.slotB; 
```
[99](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibVerifying.sol#L99)

```solidity
📁 File: contracts/automata-attestation/AutomataDcapV3Attestation.sol

180:         EnclaveIdStruct.EnclaveId memory enclaveId = qeIdentity; 
```
[180](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/AutomataDcapV3Attestation.sol#L180)

```solidity
📁 File: contracts/tokenvault/ERC20Vault.sol

171:             CanonicalERC20 memory ctoken = bridgedToCanonical[btokenOld_]; 
```
[171](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC20Vault.sol#L171)

</details>


---
### [GAS&#x2011;52] `private` functions used once can be inlined

Gas saved per Instance: ~30 *(Total: ~1,500)*
<details>
<summary><i>There are 50 instances of this issue:</i></summary>

```solidity
📁 File: contracts/L1/hooks/AssignmentHook.sol

164:     function _getProverFee( 
165:         TaikoData.TierFee[] memory _tierFees,
166:         uint16 _tierId
167:     )
168:         private
169:         pure
170:         returns (uint256)
171:     {
```
[164](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/hooks/AssignmentHook.sol#L164-L171)

```solidity
📁 File: contracts/L1/libs/LibProposing.sol

299:     function _isProposerPermitted( 
300:         TaikoData.SlotB memory _slotB,
301:         IAddressResolver _resolver
302:     )
303:         private
304:         view
305:         returns (bool)
306:     {
```
[299](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProposing.sol#L299-L306)

```solidity
📁 File: contracts/L1/libs/LibProving.sol

269:     function _createTransition( 
270:         TaikoData.State storage _state,
271:         TaikoData.Block storage _blk,
272:         TaikoData.Transition memory _tran,
273:         uint64 slot
274:     )
275:         private
276:         returns (uint32 tid_, TaikoData.TransitionState storage ts_)
277:     {

350:     function _overrideWithHigherProof( 
351:         TaikoData.TransitionState storage _ts,
352:         TaikoData.Transition memory _tran,
353:         TaikoData.TierProof memory _proof,
354:         ITierProvider.Tier memory _tier,
355:         IERC20 _tko,
356:         bool _sameTransition
357:     )
358:         private
359:     {

401:     function _checkProverPermission( 
402:         TaikoData.State storage _state,
403:         TaikoData.Block storage _blk,
404:         TaikoData.TransitionState storage _ts,
405:         uint32 _tid,
406:         ITierProvider.Tier memory _tier
407:     )
408:         private
409:         view
410:     {
```
[269](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProving.sol#L269-L277), [350](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProving.sol#L350-L359), [401](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProving.sol#L401-L410)

```solidity
📁 File: contracts/L1/libs/LibVerifying.sol

224:     function _syncChainData( 
225:         TaikoData.Config memory _config,
226:         IAddressResolver _resolver,
227:         uint64 _lastVerifiedBlockId,
228:         bytes32 _stateRoot
229:     )
230:         private
231:     {

245:     function _isConfigValid(TaikoData.Config memory _config) private view returns (bool) { 
```
[224](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibVerifying.sol#L224-L231), [245](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibVerifying.sol#L245)

```solidity
📁 File: contracts/L2/Lib1559Math.sol

33:     function _ethQty( 
34:         uint256 _gasExcess,
35:         uint256 _adjustmentFactor
36:     )
37:         private
38:         pure
39:         returns (uint256)
40:     {
```
[33](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/Lib1559Math.sol#L33-L40)

```solidity
📁 File: contracts/automata-attestation/AutomataDcapV3Attestation.sol

162:     function _verify(bytes calldata quote) private view returns (bool, bytes memory) { 

175:     function _verifyQEReportWithIdentity(V3Struct.EnclaveReport memory quoteEnclaveReport) 
176:         private
177:         view
178:         returns (bool, EnclaveIdStruct.EnclaveIdStatus status)
179:     {

206:     function _checkTcbLevels( 
207:         IPEMCertChainLib.PCKCertificateField memory pck,
208:         TCBInfoStruct.TCBInfo memory tcb
209:     )
210:         private
211:         pure
212:         returns (bool, TCBInfoStruct.TCBStatus status)
213:     {

229:     function _isCpuSvnHigherOrGreater( 
230:         uint256[] memory pckCpuSvns,
231:         uint8[] memory tcbCpuSvns
232:     )
233:         private
234:         pure
235:         returns (bool)
236:     {

248:     function _verifyCertChain(IPEMCertChainLib.ECSha256Certificate[] memory certs) 
249:         private
250:         view
251:         returns (bool)
252:     {

303:     function _enclaveReportSigVerification( 
304:         bytes memory pckCertPubKey,
305:         bytes memory signedQuoteData,
306:         V3Struct.ECDSAQuoteV3AuthData memory authDataV3,
307:         V3Struct.EnclaveReport memory qeEnclaveReport
308:     )
309:         private
310:         view
311:         returns (bool)
312:     {
```
[162](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/AutomataDcapV3Attestation.sol#L162), [175](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/AutomataDcapV3Attestation.sol#L175-L179), [206](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/AutomataDcapV3Attestation.sol#L206-L213), [229](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/AutomataDcapV3Attestation.sol#L229-L236), [248](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/AutomataDcapV3Attestation.sol#L248-L252), [303](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/AutomataDcapV3Attestation.sol#L303-L312)

```solidity
📁 File: contracts/automata-attestation/lib/PEMCertChainLib.sol

216:     function _removeHeadersAndFooters(string memory pemData) 
217:         private
218:         pure
219:         returns (bool success, bytes memory extracted, uint256 endIndex)
220:     {

269:     function _findPckTcbInfo( 
270:         bytes memory der,
271:         uint256 tbsPtr,
272:         uint256 tbsParentPtr
273:     )
274:         private
275:         pure
276:         returns (
277:             bool success,
278:             uint256 pcesvn,
279:             uint256[] memory cpusvns,
280:             bytes memory fmspcBytes,
281:             bytes memory pceidBytes
282:         )
283:     {

341:     function _findTcb( 
342:         bytes memory der,
343:         uint256 oidPtr
344:     )
345:         private
346:         pure
347:         returns (bool success, uint256 pcesvn, uint256[] memory cpusvns)
348:     {
```
[216](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/PEMCertChainLib.sol#L216-L220), [269](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/PEMCertChainLib.sol#L269-L283), [341](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/PEMCertChainLib.sol#L341-L348)

```solidity
📁 File: contracts/automata-attestation/lib/QuoteV3Auth/V3Parser.sol

165:     function parseAndVerifyHeader(bytes memory rawHeader) 
166:         private
167:         pure
168:         returns (bool success, V3Struct.Header memory header)
169:     {

203:     function parseAuthDataAndVerifyCertType( 
204:         bytes memory rawAuthData,
205:         address pemCertLibAddr
206:     )
207:         private
208:         pure
209:         returns (bool success, V3Struct.ECDSAQuoteV3AuthData memory authDataV3)
210:     {
```
[165](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/QuoteV3Auth/V3Parser.sol#L165-L169), [203](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/QuoteV3Auth/V3Parser.sol#L203-L210)

```solidity
📁 File: contracts/automata-attestation/utils/BytesUtils.sol

272:     function memcpy(uint256 dest, uint256 src, uint256 len) private pure { 
```
[272](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/BytesUtils.sol#L272)

```solidity
📁 File: contracts/bridge/Bridge.sol

555:     function _loadContext() private view returns (Context memory) { 
```
[555](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/Bridge.sol#L555)

```solidity
📁 File: contracts/signal/SignalService.sol

271:     function _cacheChainData( 
272:         HopProof memory _hop,
273:         uint64 _chainId,
274:         uint64 _blockId,
275:         bytes32 _signalRoot,
276:         bool _isFullProof,
277:         bool _isLastHop
278:     )
279:         private
280:     {
```
[271](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/signal/SignalService.sol#L271-L280)

```solidity
📁 File: contracts/team/TimelockTokenPool.sol

225:     function _voidGrant(Grant storage _grant) private returns (uint128 amountVoided) { 

239:     function _getAmountUnlocked(Grant memory _grant) private view returns (uint128) { 

267:     function _validateGrant(Grant memory _grant) private pure { 
```
[225](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/TimelockTokenPool.sol#L225), [239](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/TimelockTokenPool.sol#L239), [267](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/TimelockTokenPool.sol#L267)

```solidity
📁 File: contracts/thirdparty/optimism/rlp/RLPWriter.sol

32:     function _writeLength(uint256 _len, uint256 _offset) private pure returns (bytes memory out_) { 

55:     function _toBinary(uint256 _x) private pure returns (bytes memory out_) { 
```
[32](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/rlp/RLPWriter.sol#L32), [55](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/rlp/RLPWriter.sol#L55)

```solidity
📁 File: contracts/thirdparty/optimism/trie/MerkleTrie.sol

205:     function _parseProof(bytes[] memory _proof) private pure returns (TrieNode[] memory proof_) { 

227:     function _getNodePath(TrieNode memory _node) private pure returns (bytes memory nibbles_) { 

235:     function _getSharedNibbleLength( 
236:         bytes memory _a,
237:         bytes memory _b
238:     )
239:         private
240:         pure
241:         returns (uint256 shared_)
242:     {
```
[205](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/trie/MerkleTrie.sol#L205), [227](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/trie/MerkleTrie.sol#L227), [235](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/trie/MerkleTrie.sol#L235-L242)

```solidity
📁 File: contracts/tokenvault/ERC1155Vault.sol

240:     function _handleMessage( 
241:         address _user,
242:         BridgeTransferOp memory _op
243:     )
244:         private
245:         returns (bytes memory msgData_, CanonicalNFT memory ctoken_)
246:     {

288:     function _getOrDeployBridgedToken(CanonicalNFT memory _ctoken) 
289:         private
290:         returns (address btoken_)
291:     {

303:     function _deployBridgedToken(CanonicalNFT memory _ctoken) private returns (address btoken_) { 
```
[240](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC1155Vault.sol#L240-L246), [288](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC1155Vault.sol#L288-L291), [303](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC1155Vault.sol#L303)

```solidity
📁 File: contracts/tokenvault/ERC20Vault.sol

221:         IBridge.Message memory message = IBridge.Message({ 
222:             id: 0, // will receive a new value
223:             from: address(0), // will receive a new value
224:             srcChainId: 0, // will receive a new value
225:             destChainId: _op.destChainId,

276:             to: to, 
277:             srcChainId: ctx.srcChainId,
278:             ctoken: ctoken.addr,
279:             token: token,

298:         (bytes memory data) = abi.decode(_message.data[4:], (bytes)); 
299:         (CanonicalERC20 memory ctoken,,, uint256 amount) =
300:             abi.decode(data, (CanonicalERC20, address, address, uint256));

348:     function _handleMessage( 
349:         address _user,
350:         address _token,
351:         address _to,
352:         uint256 _amount
353:     )
354:         private
355:         returns (bytes memory msgData_, CanonicalERC20 memory ctoken_, uint256 balanceChange_)
356:     {

391:     function _getOrDeployBridgedToken(CanonicalERC20 memory ctoken) 
392:         private
393:         returns (address btoken)
394:     {

407:     function _deployBridgedToken(CanonicalERC20 memory ctoken) private returns (address btoken) { 
```
[221](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC20Vault.sol#L221-L225), [276](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC20Vault.sol#L276-L279), [298](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC20Vault.sol#L298-L300), [348](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC20Vault.sol#L348-L356), [391](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC20Vault.sol#L391-L394), [407](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC20Vault.sol#L407)

```solidity
📁 File: contracts/tokenvault/ERC721Vault.sol

187:     function _handleMessage( 
188:         address _user,
189:         BridgeTransferOp memory _op
190:     )
191:         private
192:         returns (bytes memory msgData_, CanonicalNFT memory ctoken_)
193:     {

224:     function _getOrDeployBridgedToken(CanonicalNFT memory _ctoken) 
225:         private
226:         returns (address btoken_)
227:     {

240:     function _deployBridgedToken(CanonicalNFT memory _ctoken) private returns (address btoken_) { 

242:             BridgedERC721.init, 
243:             (owner(), addressManager, _ctoken.addr, _ctoken.chainId, _ctoken.symbol, _ctoken.name)
244:         );
245: 
246:         btoken_ = address(new ERC1967Proxy(resolve("bridged_erc721", false), data));

259:  
```
[187](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC721Vault.sol#L187-L193), [224](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC721Vault.sol#L224-L227), [240](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC721Vault.sol#L240), [242](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC721Vault.sol#L242-L246), [259](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC721Vault.sol#L259)

```solidity
📁 File: contracts/verifiers/SgxVerifier.sol

226:     function _replaceInstance(uint256 id, address oldInstance, address newInstance) private { 

233:     function _isInstanceValid(uint256 id, address instance) private view returns (bool) { 
```
[226](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/verifiers/SgxVerifier.sol#L226), [233](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/verifiers/SgxVerifier.sol#L233)

</details>


---
### [GAS&#x2011;53] Redundant state variable getters
Getters for public state variables are automatically generated so there is no need to code them manually and waste gas.


Gas saved per Instance: ~3,000 *(Total: ~6,000)*
<details>
<summary><i>There are 2 instances of this issue:</i></summary>

```solidity
📁 File: contracts/L2/TaikoL2EIP1559Configurable.sol

43:     function getConfig() public view override returns (Config memory) { 
44:         return customConfig;
45:     }
```
[43](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/TaikoL2EIP1559Configurable.sol#L43-L45)

```solidity
📁 File: contracts/team/TimelockTokenPool.sol

204:     function getMyGrant(address _recipient) public view returns (Grant memory) { 
205:         return recipients[_recipient].grant;
206:     }
```
[204](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/TimelockTokenPool.sol#L204-L206)

</details>


---
### [GAS&#x2011;54] Refactor modifiers to call a local function
Modifiers code is copied in all instances where it's used, increasing bytecode size. By doing a refractor to the internal function, one can reduce bytecode size significantly at the cost of one `JUMP`.


Gas saved per Instance: ~600 *(Total: ~9,000)*
<details>
<summary><i>There are 15 instances of this issue:</i></summary>

```solidity
📁 File: contracts/L1/TaikoL1.sol

28:     modifier whenProvingNotPaused() { 
```
[28](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/TaikoL1.sol#L28)

```solidity
📁 File: contracts/automata-attestation/AutomataDcapV3Attestation.sol

60:     modifier onlyOwner() { 
```
[60](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/AutomataDcapV3Attestation.sol#L60)

```solidity
📁 File: contracts/bridge/Bridge.sol

64:     modifier sameChain(uint64 _chainId) { 
```
[64](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/Bridge.sol#L64)

```solidity
📁 File: contracts/common/AddressResolver.sol

24:     modifier onlyFromNamed(bytes32 _name) { 
```
[24](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/common/AddressResolver.sol#L24)

```solidity
📁 File: contracts/common/EssentialContract.sol

41:     modifier onlyFromOwnerOrNamed(bytes32 _name) { 

46:     modifier nonReentrant() { 

53:     modifier whenPaused() { 

58:     modifier whenNotPaused() { 
```
[41](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/common/EssentialContract.sol#L41), [46](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/common/EssentialContract.sol#L46), [53](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/common/EssentialContract.sol#L53), [58](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/common/EssentialContract.sol#L58)

```solidity
📁 File: contracts/signal/SignalService.sol

35:     modifier validSender(address _app) { 

40:     modifier nonZeroValue(bytes32 _input) { 
```
[35](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/signal/SignalService.sol#L35), [40](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/signal/SignalService.sol#L40)

```solidity
📁 File: contracts/team/airdrop/ERC20Airdrop2.sol

39:     modifier ongoingWithdrawals() { 
```
[39](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/airdrop/ERC20Airdrop2.sol#L39)

```solidity
📁 File: contracts/team/airdrop/MerkleClaimable.sol

33:     modifier ongoingClaim() { 
```
[33](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/airdrop/MerkleClaimable.sol#L33)

```solidity
📁 File: contracts/tokenvault/BaseNFTVault.sol

140:     modifier withValidOperation(BridgeTransferOp memory _op) { 
```
[140](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BaseNFTVault.sol#L140)

```solidity
📁 File: contracts/tokenvault/BaseVault.sol

22:     modifier onlyFromBridge() { 
```
[22](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BaseVault.sol#L22)

```solidity
📁 File: contracts/tokenvault/BridgedERC20.sol

37:     modifier onlyOwnerOrSnapshooter() { 
```
[37](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC20.sol#L37)

</details>


---
### [GAS&#x2011;55] Remove or replace unused state variables
Saves a storage slot. If the variable is assigned a non-zero value, saves Gsset (**20000 gas**). If it's assigned a zero value, saves Gsreset (**2900 gas**). If the variable remains unassigned, there is no gas savings unless the variable is `public`, in which case the compiler-generated non-payable getter deployment cost is saved. If the state variable is overriding an interface's public function, mark the variable as `constant` or `immutable` so that it does not use a storage slot


Gas saved per Instance: ~11,450 *(Total: ~332,050)*
<details>
<summary><i>There are 29 instances of this issue:</i></summary>

```solidity
📁 File: contracts/L1/TaikoL1.sol

26:     uint256[50] private __gap; 
```
[26](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/TaikoL1.sol#L26)

```solidity
📁 File: contracts/L1/TaikoToken.sol

16:     uint256[50] private __gap; 
```
[16](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/TaikoToken.sol#L16)

```solidity
📁 File: contracts/L1/gov/TaikoGovernor.sol

23:     uint256[50] private __gap; 
```
[23](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/gov/TaikoGovernor.sol#L23)

```solidity
📁 File: contracts/L1/gov/TaikoTimelockController.sol

10:     uint256[50] private __gap; 
```
[10](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/gov/TaikoTimelockController.sol#L10)

```solidity
📁 File: contracts/L1/provers/GuardianProver.sol

11:     uint256[50] private __gap; 
```
[11](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/provers/GuardianProver.sol#L11)

```solidity
📁 File: contracts/L1/provers/Guardians.sol

32:     uint256[46] private __gap; 
```
[32](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/provers/Guardians.sol#L32)

```solidity
📁 File: contracts/L1/tiers/DevnetTierProvider.sol

11:     uint256[50] private __gap; 
```
[11](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/tiers/DevnetTierProvider.sol#L11)

```solidity
📁 File: contracts/L1/tiers/MainnetTierProvider.sol

11:     uint256[50] private __gap; 
```
[11](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/tiers/MainnetTierProvider.sol#L11)

```solidity
📁 File: contracts/L1/tiers/TestnetTierProvider.sol

11:     uint256[50] private __gap; 
```
[11](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/tiers/TestnetTierProvider.sol#L11)

```solidity
📁 File: contracts/L2/CrossChainOwned.sol

21:     uint256[49] private __gap; 
```
[21](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/CrossChainOwned.sol#L21)

```solidity
📁 File: contracts/L2/TaikoL2EIP1559Configurable.sol

13:     uint256[49] private __gap; 
```
[13](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/TaikoL2EIP1559Configurable.sol#L13)

```solidity
📁 File: contracts/bridge/Bridge.sol

48:     uint256[43] private __gap; 
```
[48](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/Bridge.sol#L48)

```solidity
📁 File: contracts/common/AddressManager.sol

14:     uint256[49] private __gap; 
```
[14](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/common/AddressManager.sol#L14)

```solidity
📁 File: contracts/common/AddressResolver.sol

14:     uint256[49] private __gap; 
```
[14](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/common/AddressResolver.sol#L14)

```solidity
📁 File: contracts/common/EssentialContract.sol

25:     uint256[49] private __gap; 
```
[25](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/common/EssentialContract.sol#L25)

```solidity
📁 File: contracts/signal/SignalService.sol

23:     uint256[48] private __gap; 
```
[23](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/signal/SignalService.sol#L23)

```solidity
📁 File: contracts/team/airdrop/ERC20Airdrop.sol

18:     uint256[48] private __gap; 
```
[18](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/airdrop/ERC20Airdrop.sol#L18)

```solidity
📁 File: contracts/team/airdrop/ERC20Airdrop2.sol

30:     uint256[45] private __gap; 
```
[30](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/airdrop/ERC20Airdrop2.sol#L30)

```solidity
📁 File: contracts/team/airdrop/ERC721Airdrop.sol

16:     uint256[48] private __gap; 
```
[16](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/airdrop/ERC721Airdrop.sol#L16)

```solidity
📁 File: contracts/team/airdrop/MerkleClaimable.sol

23:     uint256[47] private __gap; 
```
[23](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/airdrop/MerkleClaimable.sol#L23)

```solidity
📁 File: contracts/tokenvault/BaseVault.sol

18:     uint256[50] private __gap; 
```
[18](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BaseVault.sol#L18)

```solidity
📁 File: contracts/tokenvault/BridgedERC1155.sol

27:     uint256[46] private __gap; 
```
[27](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC1155.sol#L27)

```solidity
📁 File: contracts/tokenvault/BridgedERC20.sol

32:     uint256[47] private __gap; 
```
[32](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC20.sol#L32)

```solidity
📁 File: contracts/tokenvault/BridgedERC20Base.sol

16:     uint256[49] private __gap; 
```
[16](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC20Base.sol#L16)

```solidity
📁 File: contracts/tokenvault/BridgedERC721.sol

19:     uint256[48] private __gap; 
```
[19](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC721.sol#L19)

```solidity
📁 File: contracts/tokenvault/ERC1155Vault.sol

32:     uint256[50] private __gap; 
```
[32](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC1155Vault.sol#L32)

```solidity
📁 File: contracts/tokenvault/ERC721Vault.sol

19:     uint256[50] private __gap; 
```
[19](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC721Vault.sol#L19)

```solidity
📁 File: contracts/tokenvault/adapters/USDCAdapter.sol

32:     uint256[49] private __gap; 
```
[32](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/adapters/USDCAdapter.sol#L32)

```solidity
📁 File: contracts/verifiers/GuardianVerifier.sol

11:     uint256[50] private __gap; 
```
[11](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/verifiers/GuardianVerifier.sol#L11)

</details>


---
### [GAS&#x2011;56] Reorder modifiers to save on expensive operations
According to the Solidity documentation, modifiers are executed in the order in which they are presented in the code. Reordering them so that modifiers containing only checks are executed first can prevent execution of expensive operations, such as external calls, SLOADS or SSTORES and **save gas**.


Gas saved per Instance: ~2,100 *(Total: ~6,300)*
<details>
<summary><i>There are 3 instances of this issue:</i></summary>

```solidity
📁 File: contracts/L1/provers/Guardians.sol

/// @audit Gas efficient modifier order:
/// @audit  - nonReentrant
/// @audit  - onlyOwner
53:     function setGuardians( 
54:         address[] memory _newGuardians,
55:         uint8 _minGuardians
56:     )
57:         external
58:         onlyOwner
59:         nonReentrant
60:     {
```
[53](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/provers/Guardians.sol#L53-L60)

```solidity
📁 File: contracts/L2/TaikoL2.sol

/// @audit Gas efficient modifier order:
/// @audit  - nonReentrant
/// @audit  - whenNotPaused
/// @audit  - onlyFromOwnerOrNamed (expensive operations)
163:     function withdraw( 
164:         address _token,
165:         address _to
166:     )
167:         external
168:         onlyFromOwnerOrNamed("withdrawer")
169:         nonReentrant
170:         whenNotPaused
171:     {
```
[163](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/TaikoL2.sol#L163-L171)

```solidity
📁 File: contracts/bridge/Bridge.sol

/// @audit Gas efficient modifier order:
/// @audit  - nonReentrant
/// @audit  - onlyFromOwnerOrNamed (expensive operations)
101:     function banAddress( 
102:         address _addr,
103:         bool _ban
104:     )
105:         external
106:         onlyFromOwnerOrNamed("bridge_watchdog")
107:         nonReentrant
108:     {
```
[101](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/Bridge.sol#L101-L108)

</details>


---
### [GAS&#x2011;57] `require()`/`revert()` strings longer than 32 bytes cost extra gas
Each extra memory word of bytes past the original 32 [incurs an MSTORE](https://gist.github.com/hrkrshnn/ee8fabd532058307229d65dcd5836ddc#consider-having-short-revert-strings) which costs **3 gas**


Gas saved per Instance: ~3 *(Total: ~81)*
<details>
<summary><i>There are 27 instances of this issue:</i></summary>

```solidity
📁 File: contracts/automata-attestation/lib/QuoteV3Auth/V3Parser.sol

/// @audit 63 bytes long
87:         require( 
88:             v3Quote.v3AuthData.certification.certType == 5,
89:             "certType must be 5: Concatenated PCK Cert Chain (PEM formatted)"
90:         );
```
[87](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/QuoteV3Auth/V3Parser.sol#L87-L90)

```solidity
📁 File: contracts/thirdparty/optimism/rlp/RLPReader.sol

/// @audit 74 bytes long
37:         require( 
38:             _in.length > 0,
39:             "RLPReader: length of an RLP item must be greater than zero to be decodable"
40:         );

/// @audit 56 bytes long
56:         require( 
57:             itemType == RLPItemType.LIST_ITEM,
58:             "RLPReader: decoded item type for list is not a list item"
59:         );

/// @audit 50 bytes long
61:         require( 
62:             listOffset + listLength == _in.length,
63:             "RLPReader: list item has an invalid data remainder"
64:         );

/// @audit 57 bytes long
112:         require( 
113:             itemType == RLPItemType.DATA_ITEM,
114:             "RLPReader: decoded item type for bytes is not a data item"
115:         );

/// @audit 52 bytes long
117:         require( 
118:             _in.length == itemOffset + itemLength,
119:             "RLPReader: bytes value contains an invalid remainder"
120:         );

/// @audit 74 bytes long
152:         require( 
153:             _in.length > 0,
154:             "RLPReader: length of an RLP item must be greater than zero to be decodable"
155:         );

/// @audit 78 bytes long
172:             require( 
173:                 _in.length > strLen,
174:                 "RLPReader: length of content must be greater than string length (short string)"
175:             );

/// @audit 77 bytes long
182:             require( 
183:                 strLen != 1 || firstByteOfContent >= 0x80,
184:                 "RLPReader: invalid prefix, single byte < 0x80 are not prefixed (short string)"
185:             );

/// @audit 81 bytes long
192:             require( 
193:                 _in.length > lenOfStrLen,
194:                 "RLPReader: length of content must be > than length of string length (long string)"
195:             );

/// @audit 74 bytes long
202:             require( 
203:                 firstByteOfContent != 0x00,
204:                 "RLPReader: length of content must not have any leading zeros (long string)"
205:             );

/// @audit 72 bytes long
212:             require( 
213:                 strLen > 55,
214:                 "RLPReader: length of content must be greater than 55 bytes (long string)"
215:             );

/// @audit 76 bytes long
217:             require( 
218:                 _in.length > lenOfStrLen + strLen,
219:                 "RLPReader: length of content must be greater than total length (long string)"
220:             );

/// @audit 74 bytes long
228:             require( 
229:                 _in.length > listLen,
230:                 "RLPReader: length of content must be greater than list length (short list)"
231:             );

/// @audit 77 bytes long
238:             require( 
239:                 _in.length > lenOfListLen,
240:                 "RLPReader: length of content must be > than length of list length (long list)"
241:             );

/// @audit 72 bytes long
248:             require( 
249:                 firstByteOfContent != 0x00,
250:                 "RLPReader: length of content must not have any leading zeros (long list)"
251:             );

/// @audit 70 bytes long
258:             require( 
259:                 listLen > 55,
260:                 "RLPReader: length of content must be greater than 55 bytes (long list)"
261:             );

/// @audit 74 bytes long
263:             require( 
264:                 _in.length > lenOfListLen + listLen,
265:                 "RLPReader: length of content must be greater than total length (long list)"
266:             );
```
[37](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/rlp/RLPReader.sol#L37-L40), [56](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/rlp/RLPReader.sol#L56-L59), [61](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/rlp/RLPReader.sol#L61-L64), [112](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/rlp/RLPReader.sol#L112-L115), [117](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/rlp/RLPReader.sol#L117-L120), [152](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/rlp/RLPReader.sol#L152-L155), [172](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/rlp/RLPReader.sol#L172-L175), [182](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/rlp/RLPReader.sol#L182-L185), [192](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/rlp/RLPReader.sol#L192-L195), [202](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/rlp/RLPReader.sol#L202-L205), [212](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/rlp/RLPReader.sol#L212-L215), [217](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/rlp/RLPReader.sol#L217-L220), [228](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/rlp/RLPReader.sol#L228-L231), [238](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/rlp/RLPReader.sol#L238-L241), [248](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/rlp/RLPReader.sol#L248-L251), [258](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/rlp/RLPReader.sol#L258-L261), [263](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/rlp/RLPReader.sol#L263-L266)

```solidity
📁 File: contracts/thirdparty/optimism/trie/MerkleTrie.sol

/// @audit 46 bytes long
89:             require(currentKeyIndex <= key.length, "MerkleTrie: key index exceeds total key length"); 

/// @audit 39 bytes long
99:                 require( 
100:                     Bytes.equal(abi.encodePacked(keccak256(currentNode.encoded)), currentNodeID),
101:                     "MerkleTrie: invalid large internal hash"
102:                 );

/// @audit 38 bytes long
105:                 require( 
106:                     Bytes.equal(currentNode.encoded, currentNodeID),
107:                     "MerkleTrie: invalid internal node hash"
108:                 );

/// @audit 59 bytes long
119:                     require( 
120:                         value_.length > 0,
121:                         "MerkleTrie: value length must be greater than zero (branch)"
122:                     );

/// @audit 58 bytes long
125:                     require( 
126:                         i == proof.length - 1,
127:                         "MerkleTrie: value node must be last node in proof (branch)"
128:                     );

/// @audit 58 bytes long
150:                 require( 
151:                     pathRemainder.length == sharedNibbleLength,
152:                     "MerkleTrie: path remainder must share all nibbles with key"
153:                 );

/// @audit 61 bytes long
162:                     require( 
163:                         keyRemainder.length == sharedNibbleLength,
164:                         "MerkleTrie: key remainder must be identical to path remainder"
165:                     );

/// @audit 57 bytes long
172:                     require( 
173:                         value_.length > 0,
174:                         "MerkleTrie: value length must be greater than zero (leaf)"
175:                     );

/// @audit 56 bytes long
178:                     require( 
179:                         i == proof.length - 1,
180:                         "MerkleTrie: value node must be last node in proof (leaf)"
181:                     );
```
[89](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/trie/MerkleTrie.sol#L89), [99](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/trie/MerkleTrie.sol#L99-L102), [105](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/trie/MerkleTrie.sol#L105-L108), [119](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/trie/MerkleTrie.sol#L119-L122), [125](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/trie/MerkleTrie.sol#L125-L128), [150](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/trie/MerkleTrie.sol#L150-L153), [162](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/trie/MerkleTrie.sol#L162-L165), [172](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/trie/MerkleTrie.sol#L172-L175), [178](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/trie/MerkleTrie.sol#L178-L181)

</details>


---
### [GAS&#x2011;58] Same cast is done multiple times
It's cheaper to do it once, and store the result to a variable. The examples below are the second+ instance of a given cast of the variable

<details>
<summary><i>There are 4 instances of this issue:</i></summary>

```solidity
📁 File: contracts/L1/libs/LibVerifying.sol

/// @audit 'uint64(block.timestamp)' is done 3 times total in this same function
58:         _state.slotA.genesisTimestamp = uint64(block.timestamp); 
```
[58](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibVerifying.sol#L58)

```solidity
📁 File: contracts/automata-attestation/lib/PEMCertChainLib.sol

/// @audit 'bytes2(svnValueBytes)' is done 2 times total in this same function
360:                 : uint16(bytes2(svnValueBytes)); 

/// @audit 'uint256(svnValue)' is done 2 times total in this same function
366:                 uint256 cpusvn = uint256(svnValue); 
```
[360](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/PEMCertChainLib.sol#L360), [366](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/PEMCertChainLib.sol#L366)

```solidity
📁 File: contracts/thirdparty/optimism/rlp/RLPWriter.sol

/// @audit 'uint8(_offset)' is done 2 times total in this same function
35:             out_[0] = bytes1(uint8(_len) + uint8(_offset)); 
```
[35](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/rlp/RLPWriter.sol#L35)

</details>


---
### [GAS&#x2011;59] Shortcircuit rules can be be used to optimize some gas usage
Some conditions may be reordered to save an `SLOAD` (2100 gas), as we avoid reading state variables when the first part of the condition fails (with `&&`), or succeeds (with `||`).


Gas saved per Instance: ~2,100 *(Total: ~4,200)*
<details>
<summary><i>There are 2 instances of this issue:</i></summary>

```solidity
📁 File: contracts/L2/CrossChainOwned.sol

46:         if (ctx.srcChainId != ownerChainId || ctx.from != owner()) { 
```
[46](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/CrossChainOwned.sol#L46)

```solidity
📁 File: contracts/team/airdrop/ERC20Airdrop2.sol

40:         if (claimEnd > block.timestamp || claimEnd + withdrawalWindow < block.timestamp) { 
```
[40](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/airdrop/ERC20Airdrop2.sol#L40)

</details>


---
### [GAS&#x2011;60] Simple checks for zero can be done using assembly to save gas

Gas saved per Instance: ~6 *(Total: ~1,050)*
<details>
<summary><i>There are 175 instances of this issue:</i></summary>

```solidity
📁 File: contracts/L1/TaikoL1.sol

153:         if (blk_.verifiedTransitionId != 0) { 
```
[153](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/TaikoL1.sol#L153)

```solidity
📁 File: contracts/L1/hooks/AssignmentHook.sol

81:         if ( 
82:             block.timestamp > assignment.expiry
83:                 || assignment.metaHash != 0 && _blk.metaHash != assignment.metaHash
84:                 || assignment.parentMetaHash != 0 && _meta.parentMetaHash != assignment.parentMetaHash
85:                 || assignment.maxBlockId != 0 && _meta.id > assignment.maxBlockId
86:                 || assignment.maxProposedIn != 0 && block.number > assignment.maxProposedIn

109:         if (assignment.feeToken == address(0)) { 

120:         if (input.tip != 0 && block.coinbase != address(0)) { 
```
[81](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/hooks/AssignmentHook.sol#L81-L86), [109](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/hooks/AssignmentHook.sol#L109), [120](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/hooks/AssignmentHook.sol#L120)

```solidity
📁 File: contracts/L1/libs/LibProposing.sol

81:         if (params.assignedProver == address(0)) { 

85:         if (params.coinbase == address(0)) { 

108:         if (params.parentMetaHash != 0 && parentMetaHash != params.parentMetaHash) { 

141:         if (meta_.blobUsed) { 

144:             if (params.blobHash != 0) { 

159:                 if (meta_.blobHash == 0) revert L1_BLOB_NOT_FOUND(); 

185:             if (params.txListByteOffset != 0) { 

195:         if (meta_.txListByteSize == 0 || meta_.txListByteSize > _config.blockMaxTxListBytes) { 

260:             if (address(this).balance != 0) { 

307:         if (_slotB.numBlocks == 1) { 

310:             if (proposerOne != address(0) && msg.sender != proposerOne) { 
```
[81](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProposing.sol#L81), [85](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProposing.sol#L85), [108](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProposing.sol#L108), [141](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProposing.sol#L141), [144](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProposing.sol#L144), [159](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProposing.sol#L159), [185](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProposing.sol#L185), [195](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProposing.sol#L195), [260](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProposing.sol#L260), [307](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProposing.sol#L307), [310](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProposing.sol#L310)

```solidity
📁 File: contracts/L1/libs/LibProving.sol

105:         if (_tran.parentHash == 0 || _tran.blockHash == 0 || _tran.stateRoot == 0) { 

134:         if (_proof.tier == 0 || _proof.tier < _meta.minTier || _proof.tier < ts.tier) { 

163:             if (verifier != address(0)) { 

203:         if (_proof.tier > ts.tier) { 

221:             if (isTopTier) { 

239:                 if (ts.contester != address(0)) revert L1_ALREADY_CONTESTED(); 

280:         if (tid_ == 0) { 

363:         if (_ts.contester != address(0)) { 

412:         if (_tier.contestBond == 0) return; 

419:         if (_tid == 1 && _ts.tier == 0 && inProvingWindow) { 
```
[105](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProving.sol#L105), [134](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProving.sol#L134), [163](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProving.sol#L163), [203](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProving.sol#L203), [221](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProving.sol#L221), [239](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProving.sol#L239), [280](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProving.sol#L280), [363](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProving.sol#L363), [412](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProving.sol#L412), [419](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProving.sol#L419)

```solidity
📁 File: contracts/L1/libs/LibUtils.sol

43:         if (tid == 0) revert L1_TRANSITION_NOT_FOUND(); 
```
[43](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibUtils.sol#L43)

```solidity
📁 File: contracts/L1/libs/LibVerifying.sol

93:         if (_maxBlocksToVerify == 0) { 

111:         if (tid == 0) revert L1_TRANSITION_ID_ZERO(); 

137:                 if (tid == 0) break; 

145:                 if (ts.contester != address(0)) { 

148:                     if (tierProvider == address(0)) { 

246:         if ( 
247:             _config.chainId <= 1 || _config.chainId == block.chainid //
248:                 || _config.blockMaxProposals == 1
249:                 || _config.blockRingBufferSize <= _config.blockMaxProposals + 1
250:                 || _config.blockMaxGasLimit == 0 || _config.blockMaxTxListBytes == 0
251:                 || _config.blockMaxTxListBytes > 128 * 1024 // calldata up to 128K
252:                 || _config.livenessBond == 0 || _config.ethDepositRingBufferSize <= 1
253:                 || _config.ethDepositMinCountPerBlock == 0
254:             // Audit recommendation, and gas tested. Processing 32 deposits (as initially set in
255:             // TaikoL1.sol) costs 72_502 gas.
256:             || _config.ethDepositMaxCountPerBlock > 32
257:                 || _config.ethDepositMaxCountPerBlock < _config.ethDepositMinCountPerBlock
258:                 || _config.ethDepositMinAmount == 0
259:                 || _config.ethDepositMaxAmount <= _config.ethDepositMinAmount
260:                 || _config.ethDepositMaxAmount > type(uint96).max || _config.ethDepositGas == 0
261:                 || _config.ethDepositMaxFee == 0
262:                 || _config.ethDepositMaxFee > type(uint96).max / _config.ethDepositMaxCountPerBlock
```
[93](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibVerifying.sol#L93), [111](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibVerifying.sol#L111), [137](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibVerifying.sol#L137), [145](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibVerifying.sol#L145), [148](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibVerifying.sol#L148), [246](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibVerifying.sol#L246-L262)

```solidity
📁 File: contracts/L1/provers/Guardians.sol

82:             if (guardian == address(0)) revert INVALID_GUARDIAN(); 

84:             if (guardianIds[guardian] != 0) revert INVALID_GUARDIAN_SET(); 

113:         if (id == 0) revert INVALID_GUARDIAN(); 
```
[82](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/provers/Guardians.sol#L82), [84](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/provers/Guardians.sol#L84), [113](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/provers/Guardians.sol#L113)

```solidity
📁 File: contracts/L1/tiers/MainnetTierProvider.sol

68:         if (_rand % 1000 == 0) return LibTiers.TIER_SGX_ZKVM; 
```
[68](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/tiers/MainnetTierProvider.sol#L68)

```solidity
📁 File: contracts/L1/tiers/TestnetTierProvider.sol

68:         if (_rand % 10 == 0) return LibTiers.TIER_SGX; 
```
[68](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/tiers/TestnetTierProvider.sol#L68)

```solidity
📁 File: contracts/L2/CrossChainOwned.sol

70:         if (_ownerChainId == 0 || _ownerChainId == block.chainid) { 
```
[70](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/CrossChainOwned.sol#L70)

```solidity
📁 File: contracts/L2/Lib1559Math.sol

24:         if (_adjustmentFactor == 0) { 
```
[24](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/Lib1559Math.sol#L24)

```solidity
📁 File: contracts/L2/TaikoL2.sol

86:         if (block.number == 0) { 

116:         if ( 
117:             _l1BlockHash == 0 || _l1StateRoot == 0 || _l1BlockId == 0
118:                 || (block.number != 1 && _parentGasUsed == 0)

172:         if (_to == address(0)) revert L2_INVALID_PARAM(); 
173:         if (_token == address(0)) {

296:         if (basefee_ == 0) basefee_ = 1; 
```
[86](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/TaikoL2.sol#L86), [116](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/TaikoL2.sol#L116-L118), [172](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/TaikoL2.sol#L172-L173), [296](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/TaikoL2.sol#L296)

```solidity
📁 File: contracts/L2/TaikoL2EIP1559Configurable.sol

33:         if (_newConfig.gasTargetPerL1Block == 0) revert L2_INVALID_CONFIG(); 
34:         if (_newConfig.basefeeAdjustmentQuotient == 0) revert L2_INVALID_CONFIG();
```
[33](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/TaikoL2EIP1559Configurable.sol#L33-L34)

```solidity
📁 File: contracts/automata-attestation/utils/Asn1Decode.sol

143:         require(der[ptr.ixf()] & 0x80 == 0, "Not positive"); 

156:         require(der[ptr.ixf()] & 0x80 == 0, "Not positive"); 

158:         if (der[ptr.ixf()] == 0) { 

182:         require(der[ptr.ixf()] == 0x00, "ixf Not 0"); 

191:         if ((der[ix + 1] & 0x80) == 0) { 
```
[143](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/Asn1Decode.sol#L143), [156](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/Asn1Decode.sol#L156), [158](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/Asn1Decode.sol#L158), [182](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/Asn1Decode.sol#L182), [191](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/Asn1Decode.sol#L191)

```solidity
📁 File: contracts/automata-attestation/utils/BytesUtils.sol

87:             if (a != b) { 

96:                 if (diff != 0) { 

345:         if (len % 8 == 0) { 
```
[87](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/BytesUtils.sol#L87), [96](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/BytesUtils.sol#L96), [345](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/BytesUtils.sol#L345)

```solidity
📁 File: contracts/automata-attestation/utils/RsaVerify.sol

137:         if (decipher[0] != 0 || decipher[1] != 0x01) { 

145:         if (decipher[2 + paddingLen] != 0) { 

270:         if (decipher[0] != 0 || decipher[1] != 0x01) { 

278:         if (decipher[2 + paddingLen] != 0) { 
```
[137](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/RsaVerify.sol#L137), [145](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/RsaVerify.sol#L145), [270](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/RsaVerify.sol#L270), [278](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/RsaVerify.sol#L278)

```solidity
📁 File: contracts/automata-attestation/utils/X509DateUtils.sol

72:         if (year % 4 != 0) return false; 
73:         if (year % 100 != 0) return true;
74:         if (year % 400 != 0) return false;
```
[72](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/X509DateUtils.sol#L72-L74)

```solidity
📁 File: contracts/bridge/Bridge.sol

124:         if (_message.srcOwner == address(0) || _message.destOwner == address(0)) { 

235:         if (!isMessageProven) { 

242:             if (invocationDelay != 0) { 

250:         if (invocationDelay != 0 && msg.sender != proofReceipt[msgHash].preferredExecutor) { 

258:         if (block.timestamp >= invocationDelay + receivedAt) { 

260:             if (_message.gasLimit == 0 && msg.sender != _message.destOwner) { 

269:             if ( 
270:                 _message.to == address(0) || _message.to == address(this)
271:                     || _message.to == signalService || addressBanned[_message.to]

321:         if (_message.gasLimit == 0 || _isLastAttempt) { 

405:         if (ctx_.msgHash == 0 || ctx_.msgHash == bytes32(PLACEHOLDER)) { 

485:         if (_gasLimit == 0) revert B_INVALID_GAS_LIMIT(); 
```
[124](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/Bridge.sol#L124), [235](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/Bridge.sol#L235), [242](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/Bridge.sol#L242), [250](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/Bridge.sol#L250), [258](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/Bridge.sol#L258), [260](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/Bridge.sol#L260), [269](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/Bridge.sol#L269-L271), [321](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/Bridge.sol#L321), [405](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/Bridge.sol#L405), [485](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/Bridge.sol#L485)

```solidity
📁 File: contracts/common/AddressResolver.sol

81:         if (addressManager == address(0)) revert RESOLVER_INVALID_MANAGER(); 

85:         if (!_allowZeroAddress && addr_ == address(0)) { 
```
[81](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/common/AddressResolver.sol#L81), [85](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/common/AddressResolver.sol#L85)

```solidity
📁 File: contracts/common/EssentialContract.sol

105:         if (_addressManager == address(0)) revert ZERO_ADDR_MANAGER(); 
```
[105](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/common/EssentialContract.sol#L105)

```solidity
📁 File: contracts/libs/LibAddress.sol

24:         if (_to == address(0)) revert ETH_TRANSFER_FAILED(); 
```
[24](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/libs/LibAddress.sol#L24)

```solidity
📁 File: contracts/libs/LibTrieProof.sol

46:         if (_accountProof.length != 0) { 

50:             if (rlpAccount.length == 0) revert LTP_INVALID_ACCOUNT_PROOF(); 
```
[46](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/libs/LibTrieProof.sol#L46), [50](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/libs/LibTrieProof.sol#L50)

```solidity
📁 File: contracts/signal/SignalService.sol

36:         if (_app == address(0)) revert SS_INVALID_SENDER(); 

41:         if (_input == 0) revert SS_INVALID_VALUE(); 

95:         if (hopProofs.length == 0) revert SS_EMPTY_PROOF(); 

110:             if (isLastHop) { 

114:                 if (hop.chainId == 0 || hop.chainId == block.chainid) { 

131:         if (value == 0 || value != _loadSignalValue(address(this), signal)) { 

169:         if (blockId_ != 0) { 

172:             if (chainData_ == 0) revert SS_SIGNAL_NOT_FOUND(); 
```
[36](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/signal/SignalService.sol#L36), [41](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/signal/SignalService.sol#L41), [95](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/signal/SignalService.sol#L95), [110](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/signal/SignalService.sol#L110), [114](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/signal/SignalService.sol#L114), [131](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/signal/SignalService.sol#L131), [169](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/signal/SignalService.sol#L169), [172](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/signal/SignalService.sol#L172)

```solidity
📁 File: contracts/team/TimelockTokenPool.sol

121:         if (_taikoToken == address(0)) revert INVALID_PARAM(); 

124:         if (_costToken == address(0)) revert INVALID_PARAM(); 

127:         if (_sharedVault == address(0)) revert INVALID_PARAM(); 

136:         if (_recipient == address(0)) revert INVALID_PARAM(); 
137:         if (recipients[_recipient].grant.amount != 0) revert ALREADY_GRANTED();

154:         if (amountVoided == 0) revert NOTHING_TO_VOID(); 

169:         if (_to == address(0)) revert INVALID_PARAM(); 

255:         if (_amount == 0) return 0; 
256:         if (_start == 0) return _amount;

259:         if (_period == 0) return _amount; 

268:         if (_grant.amount == 0) revert INVALID_GRANT(); 

274:         if (_start == 0 || _period == 0) { 
```
[121](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/TimelockTokenPool.sol#L121), [124](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/TimelockTokenPool.sol#L124), [127](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/TimelockTokenPool.sol#L127), [136](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/TimelockTokenPool.sol#L136-L137), [154](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/TimelockTokenPool.sol#L154), [169](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/TimelockTokenPool.sol#L169), [255](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/TimelockTokenPool.sol#L255-L256), [259](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/TimelockTokenPool.sol#L259), [268](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/TimelockTokenPool.sol#L268), [274](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/TimelockTokenPool.sol#L274)

```solidity
📁 File: contracts/team/airdrop/ERC20Airdrop2.sol

111:         if (balance == 0) return (0, 0); 
```
[111](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/airdrop/ERC20Airdrop2.sol#L111)

```solidity
📁 File: contracts/team/airdrop/MerkleClaimable.sol

34:         if ( 
35:             merkleRoot == 0x0 || claimStart == 0 || claimEnd == 0 || claimStart > block.timestamp
36:                 || claimEnd < block.timestamp
```
[34](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/airdrop/MerkleClaimable.sol#L34-L36)

```solidity
📁 File: contracts/thirdparty/optimism/rlp/RLPReader.sol

163:         if (prefix <= 0x7f) { 

166:         } else if (prefix <= 0xb7) { 

188:         } else if (prefix <= 0xbf) { 

202:             require( 
203:                 firstByteOfContent != 0x00,
204:                 "RLPReader: length of content must not have any leading zeros (long string)"
205:             );

223:         } else if (prefix <= 0xf7) { 

248:             require( 
249:                 firstByteOfContent != 0x00,
250:                 "RLPReader: length of content must not have any leading zeros (long list)"
251:             );

287:         if (_length == 0) { 
```
[163](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/rlp/RLPReader.sol#L163), [166](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/rlp/RLPReader.sol#L166), [188](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/rlp/RLPReader.sol#L188), [202](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/rlp/RLPReader.sol#L202-L205), [223](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/rlp/RLPReader.sol#L223), [248](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/rlp/RLPReader.sol#L248-L251), [287](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/rlp/RLPReader.sol#L287)

```solidity
📁 File: contracts/thirdparty/optimism/rlp/RLPWriter.sol

33:         if (_len < 56) { 

60:             if (b[i] != 0) { 
```
[33](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/rlp/RLPWriter.sol#L33), [60](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/rlp/RLPWriter.sol#L60)

```solidity
📁 File: contracts/thirdparty/optimism/trie/MerkleTrie.sol

91:             if (currentKeyIndex == 0) { 
```
[91](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/trie/MerkleTrie.sol#L91)

```solidity
📁 File: contracts/tokenvault/BaseNFTVault.sol

149:         if (_op.token == address(0)) revert VAULT_INVALID_TOKEN(); 
```
[149](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BaseNFTVault.sol#L149)

```solidity
📁 File: contracts/tokenvault/ERC1155Vault.sol

48:             if (_op.amounts[i] == 0) revert VAULT_INVALID_AMOUNT(); 

108:         if (to == address(0) || to == address(this)) revert VAULT_INVALID_TO(); 

249:             if (bridgedToCanonical[_op.token].addr != address(0)) { 

293:         if (btoken_ == address(0)) { 
```
[48](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC1155Vault.sol#L48), [108](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC1155Vault.sol#L108), [249](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC1155Vault.sol#L249), [293](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC1155Vault.sol#L293)

```solidity
📁 File: contracts/tokenvault/ERC20Vault.sol

158:         if (_btokenNew == address(0) || bridgedToCanonical[_btokenNew].addr != address(0)) { 

170:         if (btokenOld_ != address(0)) { 

214:         if (_op.amount == 0) revert VAULT_INVALID_AMOUNT(); 
215:         if (_op.token == address(0)) revert VAULT_INVALID_TOKEN();

267:         if (to == address(0) || to == address(this)) revert VAULT_INVALID_TO(); 

358:         if (bridgedToCanonical[_token].addr != address(0)) { 

397:         if (btoken == address(0)) { 
```
[158](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC20Vault.sol#L158), [170](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC20Vault.sol#L170), [214](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC20Vault.sol#L214-L215), [267](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC20Vault.sol#L267), [358](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC20Vault.sol#L358), [397](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC20Vault.sol#L397)

```solidity
📁 File: contracts/tokenvault/ERC721Vault.sol

35:             if (_op.amounts[i] != 0) revert VAULT_INVALID_AMOUNT(); 

91:         if (to == address(0) || to == address(this)) revert VAULT_INVALID_TO(); 

195:             if (bridgedToCanonical[_op.token].addr != address(0)) { 

230:         if (btoken_ == address(0)) { 
```
[35](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC721Vault.sol#L35), [91](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC721Vault.sol#L91), [195](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC721Vault.sol#L195), [230](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC721Vault.sol#L230)

```solidity
📁 File: contracts/tokenvault/LibBridgedToken.sol

20:         if ( 
21:             _srcToken == address(0) || _srcChainId == 0 || _srcChainId == block.chainid
22:                 || bytes(_symbol).length == 0 || bytes(_name).length == 0
```
[20](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/LibBridgedToken.sol#L20-L22)

```solidity
📁 File: contracts/verifiers/SgxVerifier.sol

107:             if (instances[idx].addr == address(0)) revert SGX_INVALID_INSTANCE(); 

124:         if (automataDcapAttestation == address(0)) { 

215:             if (_instances[i] == address(0)) revert SGX_INVALID_INSTANCE(); 

234:         if (instance == address(0)) return false; 
```
[107](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/verifiers/SgxVerifier.sol#L107), [124](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/verifiers/SgxVerifier.sol#L124), [215](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/verifiers/SgxVerifier.sol#L215), [234](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/verifiers/SgxVerifier.sol#L234)

</details>


---
### [GAS&#x2011;61] Sort Solidity operations using short-circuit mode
In Solidity, boolean expressions utilize short-circuiting. For || (logical OR) operations, the second expression is evaluated only if the first one is false. Similarly, for && (logical AND) operations, the second expression is evaluated only if the first one is true. This optimization saves gas by avoiding unnecessary evaluations. For instance, in require(msg.sender == owner || msg.sender == manager), if msg.sender == owner evaluates to true, msg.sender == manager isn't checked. It's recommended to place the less expensive expression first to optimize gas usage.

<details>
<summary><i>There are 190 instances of this issue:</i></summary>

```solidity
📁 File: contracts/L1/TaikoL1.sol

/// @audit Lines: 96 to 102
/// @audit Lines: 96 to 102
/// @audit Lines: 96 to 102
42:     function init( 
43:         address _owner,
44:         address _addressManager,
45:         bytes32 _genesisBlockHash
46:     )
47:         external
48:         initializer
49:     {
50:         __Essential_init(_owner, _addressManager);
51:         LibVerifying.init(state, getConfig(), _genesisBlockHash);
52:     }

/// @audit Lines: 39 to 41
220:     function _authorizePause(address) 
221:         internal
222:         view
223:         virtual
224:         override
225:         onlyFromOwnerOrNamed("chain_pauser")
226:     { }
```
[42](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/TaikoL1.sol#L42-L52), [220](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/TaikoL1.sol#L220-L226)

```solidity
📁 File: contracts/L1/TaikoToken.sol

/// @audit Lines: 95 to 98
/// @audit Lines: 95 to 98
/// @audit Lines: 95 to 98
25:     function init( 
26:         address _owner,
27:         string calldata _name,
28:         string calldata _symbol,
29:         address _recipient
30:     )
31:         public
32:         initializer
33:     {
34:         __Essential_init(_owner);
35:         __ERC20_init(_name, _symbol);
36:         __ERC20Snapshot_init();
37:         __ERC20Votes_init();
38:         __ERC20Permit_init(_name);
39: 
40:         // Mint 1 billion tokens
41:         _mint(_recipient, 1_000_000_000 ether);
42:     }

/// @audit Lines: 38 to 40
52:     function snapshot() public onlyFromOwnerOrNamed("snapshooter") { 
53:         _snapshot();
54:     }
```
[25](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/TaikoToken.sol#L25-L42), [52](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/TaikoToken.sol#L52-L54)

```solidity
📁 File: contracts/L1/gov/TaikoGovernor.sol

/// @audit Lines: 89 to 93
/// @audit Lines: 89 to 93
/// @audit Lines: 89 to 93
31:     function init( 
32:         address _owner,
33:         IVotesUpgradeable _token,
34:         TimelockControllerUpgradeable _timelock
35:     )
36:         external
37:         initializer
38:     {
39:         __Essential_init(_owner);
40:         __Governor_init("TaikoGovernor");
41:         __GovernorCompatibilityBravo_init();
42:         __GovernorVotes_init(_token);
43:         __GovernorVotesQuorumFraction_init(4);
44:         __GovernorTimelockControl_init(_timelock);
45:     }
```
[31](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/gov/TaikoGovernor.sol#L31-L45)

```solidity
📁 File: contracts/L1/gov/TaikoTimelockController.sol

/// @audit Lines: 28 to 33
/// @audit Lines: 28 to 33
/// @audit Lines: 28 to 33
15:     function init(address _owner, uint256 _minDelay) external initializer { 
16:         __Essential_init(_owner);
17:         address[] memory nil = new address[](0);
18:         __TimelockController_init(_minDelay, nil, nil, owner());
19:     }
```
[15](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/gov/TaikoTimelockController.sol#L15-L19)

```solidity
📁 File: contracts/L1/hooks/AssignmentHook.sol

/// @audit Lines: 91 to 95
/// @audit Lines: 91 to 95
/// @audit Lines: 91 to 95
57:     function init(address _owner, address _addressManager) external initializer { 
58:         __Essential_init(_owner, _addressManager);
59:     }

/// @audit Lines: 81 to 93
/// @audit Lines: 81 to 93
/// @audit Lines: 81 to 93
/// @audit Lines: 81 to 93
/// @audit Lines: 81 to 93
/// @audit Lines: 81 to 93
/// @audit Lines: 81 to 93
/// @audit Lines: 81 to 93
/// @audit Lines: 120 to 123
62:     function onBlockProposed( 
63:         TaikoData.Block memory _blk,
64:         TaikoData.BlockMetadata memory _meta,
65:         bytes memory _data
66:     )
67:         external
68:         payable
69:         nonReentrant
70:         onlyFromNamed("taiko")
71:     {
72:         // Note that
73:         // - 'msg.sender' is the TaikoL1 contract address
74:         // - 'block.coinbase' is the L1 block builder
75:         // - 'meta.coinbase' is the L2 block proposer
76: 
77:         Input memory input = abi.decode(_data, (Input));
78:         ProverAssignment memory assignment = input.assignment;
79: 
80:         // Check assignment validity
81:         if (
82:             block.timestamp > assignment.expiry
83:                 || assignment.metaHash != 0 && _blk.metaHash != assignment.metaHash
84:                 || assignment.parentMetaHash != 0 && _meta.parentMetaHash != assignment.parentMetaHash
85:                 || assignment.maxBlockId != 0 && _meta.id > assignment.maxBlockId
86:                 || assignment.maxProposedIn != 0 && block.number > assignment.maxProposedIn
87:         ) {
88:             revert HOOK_ASSIGNMENT_EXPIRED();
89:         }
90: 
91:         // Hash the assignment with the blobHash, this hash will be signed by
92:         // the prover, therefore, we add a string as a prefix.
93:         address taikoL1Address = msg.sender;
94:         bytes32 hash = hashAssignment(assignment, taikoL1Address, _meta.blobHash);
95: 
96:         if (!_blk.assignedProver.isValidSignature(hash, assignment.signature)) {
97:             revert HOOK_ASSIGNMENT_INVALID_SIG();
98:         }
99: 
100:         // Send the liveness bond to the Taiko contract
101:         IERC20 tko = IERC20(resolve("taiko_token", false));
102:         tko.transferFrom(_blk.assignedProver, taikoL1Address, _blk.livenessBond);
103: 
104:         // Find the prover fee using the minimal tier
105:         uint256 proverFee = _getProverFee(assignment.tierFees, _meta.minTier);
106: 
107:         // The proposer irrevocably pays a fee to the assigned prover, either in
108:         // Ether or ERC20 tokens.
109:         if (assignment.feeToken == address(0)) {
110:             // Paying Ether
111:             _blk.assignedProver.sendEther(proverFee, MAX_GAS_PAYING_PROVER);
112:         } else {
113:             // Paying ERC20 tokens
114:             IERC20(assignment.feeToken).safeTransferFrom(
115:                 _meta.coinbase, _blk.assignedProver, proverFee
116:             );
117:         }
118: 
119:         // block.coinbase can be address(0) in tests
120:         if (input.tip != 0 && block.coinbase != address(0)) {
121:             address(block.coinbase).sendEther(input.tip);
122:         }
123: 
124:         // Send all remaining Ether back to TaikoL1 contract
125:         if (address(this).balance > 0) {
126:             taikoL1Address.sendEther(address(this).balance);
127:         }
128: 
129:         emit BlockAssigned(_blk.assignedProver, _meta, assignment);
130:     }
```
[57](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/hooks/AssignmentHook.sol#L57-L59), [62](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/hooks/AssignmentHook.sol#L62-L130)

```solidity
📁 File: contracts/L1/libs/LibProposing.sol

/// @audit Lines: 108 to 111
/// @audit Lines: 195 to 198
/// @audit Lines: 164 to 169
68:     function proposeBlock( 
69:         TaikoData.State storage _state,
70:         TaikoData.Config memory _config,
71:         IAddressResolver _resolver,
72:         bytes calldata _data,
73:         bytes calldata _txList
74:     )
75:         internal
76:         returns (TaikoData.BlockMetadata memory meta_, TaikoData.EthDeposit[] memory deposits_)
77:     {
78:         TaikoData.BlockParams memory params = abi.decode(_data, (TaikoData.BlockParams));
79: 
80:         // We need a prover that will submit proofs after the block has been submitted
81:         if (params.assignedProver == address(0)) {
82:             revert L1_INVALID_PROVER();
83:         }
84: 
85:         if (params.coinbase == address(0)) {
86:             params.coinbase = msg.sender;
87:         }
88: 
89:         // Taiko, as a Based Rollup, enables permissionless block proposals.
90:         // However, if the "proposer" address is set to a non-zero value, we
91:         // ensure that only that specific address has the authority to propose
92:         // blocks.
93:         TaikoData.SlotB memory b = _state.slotB;
94:         if (!_isProposerPermitted(b, _resolver)) revert L1_UNAUTHORIZED();
95: 
96:         // It's essential to ensure that the ring buffer for proposed blocks
97:         // still has space for at least one more block.
98:         if (b.numBlocks >= b.lastVerifiedBlockId + _config.blockMaxProposals + 1) {
99:             revert L1_TOO_MANY_BLOCKS();
100:         }
101: 
102:         bytes32 parentMetaHash =
103:             _state.blocks[(b.numBlocks - 1) % _config.blockRingBufferSize].metaHash;
104: 
105:         // Check if parent block has the right meta hash
106:         // This is to allow the proposer to make sure the block builds on the expected latest chain
107:         // state
108:         if (params.parentMetaHash != 0 && parentMetaHash != params.parentMetaHash) {
109:             revert L1_UNEXPECTED_PARENT();
110:         }
111: 
112:         // Each transaction must handle a specific quantity of L1-to-L2
113:         // Ether deposits.
114:         deposits_ = LibDepositing.processDeposits(_state, _config, params.coinbase);
115: 
116:         // Initialize metadata to compute a metaHash, which forms a part of
117:         // the block data to be stored on-chain for future integrity checks.
118:         // If we choose to persist all data fields in the metadata, it will
119:         // require additional storage slots.
120:         unchecked {
121:             meta_ = TaikoData.BlockMetadata({
122:                 l1Hash: blockhash(block.number - 1),
123:                 difficulty: 0, // to be initialized below
124:                 blobHash: 0, // to be initialized below
125:                 extraData: params.extraData,
126:                 depositsHash: keccak256(abi.encode(deposits_)),
127:                 coinbase: params.coinbase,
128:                 id: b.numBlocks,
129:                 gasLimit: _config.blockMaxGasLimit,
130:                 timestamp: uint64(block.timestamp),
131:                 l1Height: uint64(block.number - 1),
132:                 txListByteOffset: 0, // to be initialized below
133:                 txListByteSize: 0, // to be initialized below
134:                 minTier: 0, // to be initialized below
135:                 blobUsed: _txList.length == 0,
136:                 parentMetaHash: parentMetaHash
137:             });
138:         }
139: 
140:         // Update certain meta fields
141:         if (meta_.blobUsed) {
142:             if (!_config.blobAllowedForDA) revert L1_BLOB_FOR_DA_DISABLED();
143: 
144:             if (params.blobHash != 0) {
145:                 if (!_config.blobReuseEnabled) revert L1_BLOB_REUSE_DISABLED();
146: 
147:                 // We try to reuse an old blob
148:                 if (!isBlobReusable(_state, _config, params.blobHash)) {
149:                     revert L1_BLOB_NOT_REUSABLE();
150:                 }
151:                 meta_.blobHash = params.blobHash;
152:             } else {
153:                 // Always use the first blob in this transaction. If the
154:                 // proposeBlock functions are called more than once in the same
155:                 // L1 transaction, these multiple L2 blocks will share the same
156:                 // blob.
157:                 meta_.blobHash = blockhash(0);
158: 
159:                 if (meta_.blobHash == 0) revert L1_BLOB_NOT_FOUND();
160: 
161:                 // Depends on the blob data price, it may not make sense to
162:                 // cache the blob which costs 20,000 (sstore) + 631 (event)
163:                 // extra gas.
164:                 if (_config.blobReuseEnabled && params.cacheBlobForReuse) {
165:                     _state.reusableBlobs[meta_.blobHash] = block.timestamp;
166:                     emit BlobCached(meta_.blobHash);
167:                 }
168:             }
169: 
170:             // Check that the txList data range is within the max size of a blob
171:             if (uint256(params.txListByteOffset) + params.txListByteSize > MAX_BYTES_PER_BLOB) {
172:                 revert L1_TXLIST_OFFSET();
173:             }
174: 
175:             meta_.txListByteOffset = params.txListByteOffset;
176:             meta_.txListByteSize = params.txListByteSize;
177:         } else {
178:             // The proposer must be an Externally Owned Account (EOA) for
179:             // calldata usage. This ensures that the transaction is not an
180:             // internal one, making calldata retrieval more straightforward for
181:             // Taiko node software.
182:             if (!LibAddress.isSenderEOA()) revert L1_PROPOSER_NOT_EOA();
183: 
184:             // The txList is the full byte array without any offset
185:             if (params.txListByteOffset != 0) {
186:                 revert L1_INVALID_PARAM();
187:             }
188: 
189:             meta_.blobHash = keccak256(_txList);
190:             meta_.txListByteOffset = 0;
191:             meta_.txListByteSize = uint24(_txList.length);
192:         }
193: 
194:         // Check that the tx length is non-zero and within the supported range
195:         if (meta_.txListByteSize == 0 || meta_.txListByteSize > _config.blockMaxTxListBytes) {
196:             revert L1_TXLIST_SIZE();
197:         }
198: 
199:         // Following the Merge, the L1 mixHash incorporates the
200:         // prevrandao value from the beacon chain. Given the possibility
201:         // of multiple Taiko blocks being proposed within a single
202:         // Ethereum block, we choose to introduce a salt to this random
203:         // number as the L2 mixHash.
204:         meta_.difficulty = keccak256(abi.encodePacked(block.prevrandao, b.numBlocks, block.number));
205: 
206:         // Use the difficulty as a random number
207:         meta_.minTier = ITierProvider(_resolver.resolve("tier_provider", false)).getMinTier(
208:             uint256(meta_.difficulty)
209:         );
210: 
211:         // Create the block that will be stored onchain
212:         TaikoData.Block memory blk = TaikoData.Block({
213:             metaHash: keccak256(abi.encode(meta_)),
214:             // Safeguard the liveness bond to ensure its preservation,
215:             // particularly in scenarios where it might be altered after the
216:             // block's proposal but before it has been proven or verified.
217:             livenessBond: _config.livenessBond,
218:             blockId: b.numBlocks,
219:             proposedAt: meta_.timestamp,
220:             proposedIn: uint64(block.number),
221:             // For a new block, the next transition ID is always 1, not 0.
222:             nextTransitionId: 1,
223:             // For unverified block, its verifiedTransitionId is always 0.
224:             verifiedTransitionId: 0,
225:             assignedProver: params.assignedProver
226:         });
227: 
228:         // Store the block in the ring buffer
229:         _state.blocks[b.numBlocks % _config.blockRingBufferSize] = blk;
230: 
231:         // Increment the counter (cursor) by 1.
232:         unchecked {
233:             ++_state.slotB.numBlocks;
234:         }
235: 
236:         {
237:             IERC20 tko = IERC20(_resolver.resolve("taiko_token", false));
238:             uint256 tkoBalance = tko.balanceOf(address(this));
239: 
240:             // Run all hooks.
241:             // Note that address(this).balance has been updated with msg.value,
242:             // prior to any code in this function has been executed.
243:             address prevHook;
244:             for (uint256 i; i < params.hookCalls.length; ++i) {
245:                 if (uint160(prevHook) >= uint160(params.hookCalls[i].hook)) {
246:                     revert L1_INVALID_HOOK();
247:                 }
248: 
249:                 // When a hook is called, all ether in this contract will be send to the hook.
250:                 // If the ether sent to the hook is not used entirely, the hook shall send the Ether
251:                 // back to this contract for the next hook to use.
252:                 // Proposers shall choose use extra hooks wisely.
253:                 IHook(params.hookCalls[i].hook).onBlockProposed{ value: address(this).balance }(
254:                     blk, meta_, params.hookCalls[i].data
255:                 );
256: 
257:                 prevHook = params.hookCalls[i].hook;
258:             }
259:             // Refund Ether
260:             if (address(this).balance != 0) {
261:                 msg.sender.sendEther(address(this).balance);
262:             }
263: 
264:             // Check that after hooks, the Taiko Token balance of this contract
265:             // have increased by the same amount as _config.livenessBond (to prevent)
266:             // multiple draining payments by a malicious proposer nesting the same
267:             // hook.
268:             if (tko.balanceOf(address(this)) != tkoBalance + _config.livenessBond) {
269:                 revert L1_LIVENESS_BOND_NOT_RECEIVED();
270:             }
271:         }
272: 
273:         emit BlockProposed({
274:             blockId: blk.blockId,
275:             assignedProver: blk.assignedProver,
276:             livenessBond: _config.livenessBond,
277:             meta: meta_,
278:             depositsProcessed: deposits_
279:         });
280:     }

/// @audit Lines: 310 to 312
299:     function _isProposerPermitted( 
300:         TaikoData.SlotB memory _slotB,
301:         IAddressResolver _resolver
302:     )
303:         private
304:         view
305:         returns (bool)
306:     {
307:         if (_slotB.numBlocks == 1) {
308:             // Only proposer_one can propose the first block after genesis
309:             address proposerOne = _resolver.resolve("proposer_one", true);
310:             if (proposerOne != address(0) && msg.sender != proposerOne) {
311:                 return false;
312:             }
313:         }
314: 
315:         address proposer = _resolver.resolve("proposer", true);
316:         return proposer == address(0) || msg.sender == proposer;
317:     }
```
[68](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProposing.sol#L68-L280), [299](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProposing.sol#L299-L317)

```solidity
📁 File: contracts/L1/libs/LibProving.sol

/// @audit Lines: 105 to 108
/// @audit Lines: 105 to 108
/// @audit Lines: 111 to 114
/// @audit Lines: 121 to 124
/// @audit Lines: 134 to 137
/// @audit Lines: 134 to 137
91:     function proveBlock( 
92:         TaikoData.State storage _state,
93:         TaikoData.Config memory _config,
94:         IAddressResolver _resolver,
95:         TaikoData.BlockMetadata memory _meta,
96:         TaikoData.Transition memory _tran,
97:         TaikoData.TierProof memory _proof
98:     )
99:         internal
100:         returns (uint8 maxBlocksToVerify_)
101:     {
102:         // Make sure parentHash is not zero
103:         // To contest an existing transition, simply use any non-zero value as
104:         // the blockHash and stateRoot.
105:         if (_tran.parentHash == 0 || _tran.blockHash == 0 || _tran.stateRoot == 0) {
106:             revert L1_INVALID_TRANSITION();
107:         }
108: 
109:         // Check that the block has been proposed but has not yet been verified.
110:         TaikoData.SlotB memory b = _state.slotB;
111:         if (_meta.id <= b.lastVerifiedBlockId || _meta.id >= b.numBlocks) {
112:             revert L1_INVALID_BLOCK_ID();
113:         }
114: 
115:         uint64 slot = _meta.id % _config.blockRingBufferSize;
116:         TaikoData.Block storage blk = _state.blocks[slot];
117: 
118:         // Check the integrity of the block data. It's worth noting that in
119:         // theory, this check may be skipped, but it's included for added
120:         // caution.
121:         if (blk.blockId != _meta.id || blk.metaHash != keccak256(abi.encode(_meta))) {
122:             revert L1_BLOCK_MISMATCH();
123:         }
124: 
125:         // Each transition is uniquely identified by the parentHash, with the
126:         // blockHash and stateRoot open for later updates as higher-tier proofs
127:         // become available. In cases where a transition with the specified
128:         // parentHash does not exist, the transition ID (tid) will be set to 0.
129:         (uint32 tid, TaikoData.TransitionState storage ts) =
130:             _createTransition(_state, blk, _tran, slot);
131: 
132:         // The new proof must meet or exceed the minimum tier required by the
133:         // block or the previous proof; it cannot be on a lower tier.
134:         if (_proof.tier == 0 || _proof.tier < _meta.minTier || _proof.tier < ts.tier) {
135:             revert L1_INVALID_TIER();
136:         }
137: 
138:         // Retrieve the tier configurations. If the tier is not supported, the
139:         // subsequent action will result in a revert.
140:         ITierProvider.Tier memory tier =
141:             ITierProvider(_resolver.resolve("tier_provider", false)).getTier(_proof.tier);
142: 
143:         // Check if this prover is allowed to submit a proof for this block
144:         _checkProverPermission(_state, blk, ts, tid, tier);
145: 
146:         // We must verify the proof, and any failure in proof verification will
147:         // result in a revert.
148:         //
149:         // It's crucial to emphasize that the proof can be assessed in two
150:         // potential modes: "proving mode" and "contesting mode." However, the
151:         // precise verification logic is defined within each tier's IVerifier
152:         // contract implementation. We simply specify to the verifier contract
153:         // which mode it should utilize - if the new tier is higher than the
154:         // previous tier, we employ the proving mode; otherwise, we employ the
155:         // contesting mode (the new tier cannot be lower than the previous tier,
156:         // this has been checked above).
157:         //
158:         // It's obvious that proof verification is entirely decoupled from
159:         // Taiko's core protocol.
160:         {
161:             address verifier = _resolver.resolve(tier.verifierName, true);
162: 
163:             if (verifier != address(0)) {
164:                 bool isContesting = _proof.tier == ts.tier && tier.contestBond != 0;
165: 
166:                 IVerifier.Context memory ctx = IVerifier.Context({
167:                     metaHash: blk.metaHash,
168:                     blobHash: _meta.blobHash,
169:                     // Separate msgSender to allow the prover to be any address in the future.
170:                     prover: msg.sender,
171:                     msgSender: msg.sender,
172:                     blockId: blk.blockId,
173:                     isContesting: isContesting,
174:                     blobUsed: _meta.blobUsed
175:                 });
176: 
177:                 IVerifier(verifier).verifyProof(ctx, _tran, _proof);
178:             } else if (tier.verifierName != TIER_OP) {
179:                 // The verifier can be address-zero, signifying that there are no
180:                 // proof checks for the tier. In practice, this only applies to
181:                 // optimistic proofs.
182:                 revert L1_MISSING_VERIFIER();
183:             }
184:         }
185: 
186:         bool isTopTier = tier.contestBond == 0;
187:         IERC20 tko = IERC20(_resolver.resolve("taiko_token", false));
188: 
189:         if (isTopTier) {
190:             // A special return value from the top tier prover can signal this
191:             // contract to return all liveness bond.
192:             bool returnLivenessBond = blk.livenessBond > 0 && _proof.data.length == 32
193:                 && bytes32(_proof.data) == RETURN_LIVENESS_BOND;
194: 
195:             if (returnLivenessBond) {
196:                 tko.transfer(blk.assignedProver, blk.livenessBond);
197:                 blk.livenessBond = 0;
198:             }
199:         }
200: 
201:         bool sameTransition = _tran.blockHash == ts.blockHash && _tran.stateRoot == ts.stateRoot;
202: 
203:         if (_proof.tier > ts.tier) {
204:             // Handles the case when an incoming tier is higher than the current transition's tier.
205:             // Reverts when the incoming proof tries to prove the same transition
206:             // (L1_ALREADY_PROVED).
207:             _overrideWithHigherProof(ts, _tran, _proof, tier, tko, sameTransition);
208: 
209:             emit TransitionProved({
210:                 blockId: blk.blockId,
211:                 tran: _tran,
212:                 prover: msg.sender,
213:                 validityBond: tier.validityBond,
214:                 tier: _proof.tier
215:             });
216:         } else {
217:             // New transition and old transition on the same tier - and if this transaction tries to
218:             // prove the same, it reverts
219:             if (sameTransition) revert L1_ALREADY_PROVED();
220: 
221:             if (isTopTier) {
222:                 // The top tier prover re-proves.
223:                 assert(tier.validityBond == 0);
224:                 assert(ts.validityBond == 0 && ts.contestBond == 0 && ts.contester == address(0));
225: 
226:                 ts.prover = msg.sender;
227:                 ts.blockHash = _tran.blockHash;
228:                 ts.stateRoot = _tran.stateRoot;
229: 
230:                 emit TransitionProved({
231:                     blockId: blk.blockId,
232:                     tran: _tran,
233:                     prover: msg.sender,
234:                     validityBond: 0,
235:                     tier: _proof.tier
236:                 });
237:             } else {
238:                 // Contesting but not on the highest tier
239:                 if (ts.contester != address(0)) revert L1_ALREADY_CONTESTED();
240: 
241:                 // Burn the contest bond from the prover.
242:                 tko.transferFrom(msg.sender, address(this), tier.contestBond);
243: 
244:                 // We retain the contest bond within the transition, just in
245:                 // case this configuration is altered to a different value
246:                 // before the contest is resolved.
247:                 //
248:                 // It's worth noting that the previous value of ts.contestBond
249:                 // doesn't have any significance.
250:                 ts.contestBond = tier.contestBond;
251:                 ts.contester = msg.sender;
252:                 ts.contestations += 1;
253: 
254:                 emit TransitionContested({
255:                     blockId: blk.blockId,
256:                     tran: _tran,
257:                     contester: msg.sender,
258:                     contestBond: tier.contestBond,
259:                     tier: _proof.tier
260:                 });
261:             }
262:         }
263: 
264:         ts.timestamp = uint64(block.timestamp);
265:         return tier.maxBlocksToVerifyPerProof;
266:     }

/// @audit Lines: 419 to 430
401:     function _checkProverPermission( 
402:         TaikoData.State storage _state,
403:         TaikoData.Block storage _blk,
404:         TaikoData.TransitionState storage _ts,
405:         uint32 _tid,
406:         ITierProvider.Tier memory _tier
407:     )
408:         private
409:         view
410:     {
411:         // The highest tier proof can always submit new proofs
412:         if (_tier.contestBond == 0) return;
413: 
414:         bool inProvingWindow = uint256(_ts.timestamp).max(_state.slotB.lastUnpausedAt)
415:             + _tier.provingWindow * 60 >= block.timestamp;
416:         bool isAssignedPover = msg.sender == _blk.assignedProver;
417: 
418:         // The assigned prover can only submit the very first transition.
419:         if (_tid == 1 && _ts.tier == 0 && inProvingWindow) {
420:             if (!isAssignedPover) revert L1_NOT_ASSIGNED_PROVER();
421:         } else {
422:             // Disallow the same address to prove the block so that we can detect that the
423:             // assigned prover should not receive his liveness bond back
424:             if (isAssignedPover) revert L1_ASSIGNED_PROVER_NOT_ALLOWED();
425:         }
426:     }
```
[91](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProving.sol#L91-L266), [401](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProving.sol#L401-L426)

```solidity
📁 File: contracts/L1/libs/LibUtils.sol

/// @audit Lines: 34 to 39
23:     function getTransition( 
24:         TaikoData.State storage _state,
25:         TaikoData.Config memory _config,
26:         uint64 _blockId,
27:         bytes32 _parentHash
28:     )
29:         external
30:         view
31:         returns (TaikoData.TransitionState storage)
32:     {
33:         TaikoData.SlotB memory b = _state.slotB;
34:         if (_blockId < b.lastVerifiedBlockId || _blockId >= b.numBlocks) {
35:             revert L1_INVALID_BLOCK_ID();
36:         }
37: 
38:         uint64 slot = _blockId % _config.blockRingBufferSize;
39:         TaikoData.Block storage blk = _state.blocks[slot];
40:         if (blk.blockId != _blockId) revert L1_BLOCK_MISMATCH();
41: 
42:         uint32 tid = getTransitionId(_state, blk, slot, _parentHash);
43:         if (tid == 0) revert L1_TRANSITION_NOT_FOUND();
44: 
45:         return _state.transitions[slot][tid];
46:     }
```
[23](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibUtils.sol#L23-L46)

```solidity
📁 File: contracts/L1/libs/LibVerifying.sol

/// @audit Lines: 246 to 276
/// @audit Lines: 246 to 276
/// @audit Lines: 246 to 276
/// @audit Lines: 246 to 276
/// @audit Lines: 246 to 276
/// @audit Lines: 246 to 276
/// @audit Lines: 246 to 276
/// @audit Lines: 246 to 276
/// @audit Lines: 246 to 276
/// @audit Lines: 246 to 276
/// @audit Lines: 246 to 276
/// @audit Lines: 246 to 276
/// @audit Lines: 246 to 276
/// @audit Lines: 246 to 276
/// @audit Lines: 246 to 276
/// @audit Lines: 246 to 276
/// @audit Lines: 246 to 276
245:     function _isConfigValid(TaikoData.Config memory _config) private view returns (bool) { 
246:         if (
247:             _config.chainId <= 1 || _config.chainId == block.chainid //
248:                 || _config.blockMaxProposals == 1
249:                 || _config.blockRingBufferSize <= _config.blockMaxProposals + 1
250:                 || _config.blockMaxGasLimit == 0 || _config.blockMaxTxListBytes == 0
251:                 || _config.blockMaxTxListBytes > 128 * 1024 // calldata up to 128K
252:                 || _config.livenessBond == 0 || _config.ethDepositRingBufferSize <= 1
253:                 || _config.ethDepositMinCountPerBlock == 0
254:             // Audit recommendation, and gas tested. Processing 32 deposits (as initially set in
255:             // TaikoL1.sol) costs 72_502 gas.
256:             || _config.ethDepositMaxCountPerBlock > 32
257:                 || _config.ethDepositMaxCountPerBlock < _config.ethDepositMinCountPerBlock
258:                 || _config.ethDepositMinAmount == 0
259:                 || _config.ethDepositMaxAmount <= _config.ethDepositMinAmount
260:                 || _config.ethDepositMaxAmount > type(uint96).max || _config.ethDepositGas == 0
261:                 || _config.ethDepositMaxFee == 0
262:                 || _config.ethDepositMaxFee > type(uint96).max / _config.ethDepositMaxCountPerBlock
263:         ) return false;
264: 
265:         return true;
266:     }
```
[245](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibVerifying.sol#L245-L266)

```solidity
📁 File: contracts/L1/provers/GuardianProver.sol

/// @audit Lines: 57 to 64
/// @audit Lines: 57 to 64
/// @audit Lines: 57 to 64
25:     function init(address _owner, address _addressManager) external initializer { 
26:         __Essential_init(_owner, _addressManager);
27:     }
```
[25](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/provers/GuardianProver.sol#L25-L27)

```solidity
📁 File: contracts/L1/provers/Guardians.sol

/// @audit Lines: 63 to 68
/// @audit Lines: 68 to 73
53:     function setGuardians( 
54:         address[] memory _newGuardians,
55:         uint8 _minGuardians
56:     )
57:         external
58:         onlyOwner
59:         nonReentrant
60:     {
61:         // We need at least MIN_NUM_GUARDIANS and at most 255 guardians (so the approval bits fit in
62:         // a uint256)
63:         if (_newGuardians.length < MIN_NUM_GUARDIANS || _newGuardians.length > type(uint8).max) {
64:             revert INVALID_GUARDIAN_SET();
65:         }
66:         // Minimum number of guardians to approve is at least equal or greater than half the
67:         // guardians (rounded up) and less or equal than the total number of guardians
68:         if (_minGuardians < (_newGuardians.length + 1) >> 1 || _minGuardians > _newGuardians.length)
69:         {
70:             revert INVALID_MIN_GUARDIANS();
71:         }
72: 
73:         // Delete the current guardians
74:         for (uint256 i; i < guardians.length; ++i) {
75:             delete guardianIds[guardians[i]];
76:         }
77:         delete guardians;
78: 
79:         // Set the new guardians
80:         for (uint256 i = 0; i < _newGuardians.length; ++i) {
81:             address guardian = _newGuardians[i];
82:             if (guardian == address(0)) revert INVALID_GUARDIAN();
83:             // This makes sure there are not duplicate addresses
84:             if (guardianIds[guardian] != 0) revert INVALID_GUARDIAN_SET();
85: 
86:             // Save and index the guardian
87:             guardians.push(guardian);
88:             guardianIds[guardian] = guardians.length;
89:         }
90: 
91:         // Bump the version so previous approvals get invalidated
92:         ++version;
93: 
94:         minGuardians = _minGuardians;
95:         emit GuardiansUpdated(version, _newGuardians);
96:     }
```
[53](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/provers/Guardians.sol#L53-L96)

```solidity
📁 File: contracts/L1/tiers/DevnetTierProvider.sol

/// @audit Lines: 58 to 64
/// @audit Lines: 58 to 64
/// @audit Lines: 58 to 64
15:     function init(address _owner) external initializer { 
16:         __Essential_init(_owner);
17:     }
```
[15](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/tiers/DevnetTierProvider.sol#L15-L17)

```solidity
📁 File: contracts/L1/tiers/MainnetTierProvider.sol

/// @audit Lines: 72 to 78
/// @audit Lines: 72 to 78
/// @audit Lines: 72 to 78
15:     function init(address _owner) external initializer { 
16:         __Essential_init(_owner);
17:     }
```
[15](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/tiers/MainnetTierProvider.sol#L15-L17)

```solidity
📁 File: contracts/L1/tiers/TestnetTierProvider.sol

/// @audit Lines: 73 to 79
/// @audit Lines: 73 to 79
/// @audit Lines: 73 to 79
15:     function init(address _owner) external initializer { 
16:         __Essential_init(_owner);
17:     }
```
[15](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/tiers/TestnetTierProvider.sol#L15-L17)

```solidity
📁 File: contracts/L2/CrossChainOwned.sol

/// @audit Lines: 46 to 49
36:     function onMessageInvocation(bytes calldata _data) 
37:         external
38:         payable
39:         whenNotPaused
40:         onlyFromNamed("bridge")
41:     {
42:         (uint64 txId, bytes memory txdata) = abi.decode(_data, (uint64, bytes));
43:         if (txId != nextTxId) revert XCO_INVALID_TX_ID();
44: 
45:         IBridge.Context memory ctx = IBridge(msg.sender).context();
46:         if (ctx.srcChainId != ownerChainId || ctx.from != owner()) {
47:             revert XCO_PERMISSION_DENIED();
48:         }
49: 
50:         (bool success,) = address(this).call(txdata);
51:         if (!success) revert XCO_TX_REVERTED();
52: 
53:         emit TransactionExecuted(nextTxId++, bytes4(txdata));
54:     }

/// @audit Lines: 70 to 73
60:     function __CrossChainOwned_init( 
61:         address _owner,
62:         address _addressManager,
63:         uint64 _ownerChainId
64:     )
65:         internal
66:         virtual
67:         onlyInitializing
68:     {
69:         __Essential_init(_owner, _addressManager);
70:         if (_ownerChainId == 0 || _ownerChainId == block.chainid) {
71:             revert XCO_INVALID_OWNER_CHAINID();
72:         }
73:         ownerChainId = _ownerChainId;
74:     }
```
[36](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/CrossChainOwned.sol#L36-L54), [60](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/CrossChainOwned.sol#L60-L74)

```solidity
📁 File: contracts/L2/TaikoL2.sol

/// @audit Lines: 82 to 84
/// @audit Lines: 91 to 96
/// @audit Lines: 91 to 96
/// @audit Lines: 91 to 96
71:     function init( 
72:         address _owner,
73:         address _addressManager,
74:         uint64 _l1ChainId,
75:         uint64 _gasExcess
76:     )
77:         external
78:         initializer
79:     {
80:         __CrossChainOwned_init(_owner, _addressManager, _l1ChainId);
81: 
82:         if (block.chainid <= 1 || block.chainid > type(uint64).max) {
83:             revert L2_INVALID_CHAIN_ID();
84:         }
85: 
86:         if (block.number == 0) {
87:             // This is the case in real L2 genesis
88:         } else if (block.number == 1) {
89:             // This is the case in tests
90:             uint256 parentHeight = block.number - 1;
91:             l2Hashes[parentHeight] = blockhash(parentHeight);
92:         } else {
93:             revert L2_TOO_LATE();
94:         }
95: 
96:         gasExcess = _gasExcess;
97:         (publicInputHash,) = _calcPublicInputHash(block.number);
98:     }

/// @audit Lines: 116 to 121
/// @audit Lines: 116 to 121
/// @audit Lines: 116 to 121
/// @audit Lines: 116 to 121
/// @audit Lines: 141 to 143
107:     function anchor( 
108:         bytes32 _l1BlockHash,
109:         bytes32 _l1StateRoot,
110:         uint64 _l1BlockId,
111:         uint32 _parentGasUsed
112:     )
113:         external
114:         nonReentrant
115:     {
116:         if (
117:             _l1BlockHash == 0 || _l1StateRoot == 0 || _l1BlockId == 0
118:                 || (block.number != 1 && _parentGasUsed == 0)
119:         ) {
120:             revert L2_INVALID_PARAM();
121:         }
122: 
123:         if (msg.sender != GOLDEN_TOUCH_ADDRESS) revert L2_INVALID_SENDER();
124: 
125:         uint256 parentId;
126:         unchecked {
127:             parentId = block.number - 1;
128:         }
129: 
130:         // Verify ancestor hashes
131:         (bytes32 publicInputHashOld, bytes32 publicInputHashNew) = _calcPublicInputHash(parentId);
132:         if (publicInputHash != publicInputHashOld) {
133:             revert L2_PUBLIC_INPUT_HASH_MISMATCH();
134:         }
135: 
136:         Config memory config = getConfig();
137: 
138:         // Verify the base fee per gas is correct
139:         uint256 basefee;
140:         (basefee, gasExcess) = _calc1559BaseFee(config, _l1BlockId, _parentGasUsed);
141:         if (!skipFeeCheck() && block.basefee != basefee) {
142:             revert L2_BASEFEE_MISMATCH();
143:         }
144: 
145:         if (_l1BlockId > lastSyncedBlock + BLOCK_SYNC_THRESHOLD) {
146:             // Store the L1's state root as a signal to the local signal service to
147:             // allow for multi-hop bridging.
148:             ISignalService(resolve("signal_service", false)).syncChainData(
149:                 ownerChainId, LibSignals.STATE_ROOT, _l1BlockId, _l1StateRoot
150:             );
151:             lastSyncedBlock = _l1BlockId;
152:         }
153:         // Update state variables
154:         l2Hashes[parentId] = blockhash(parentId);
155:         publicInputHash = publicInputHashNew;
156: 
157:         emit Anchored(blockhash(parentId), gasExcess);
158:     }

/// @audit Lines: 38 to 40
163:     function withdraw( 
164:         address _token,
165:         address _to
166:     )
167:         external
168:         onlyFromOwnerOrNamed("withdrawer")
169:         nonReentrant
170:         whenNotPaused
171:     {
172:         if (_to == address(0)) revert L2_INVALID_PARAM();
173:         if (_token == address(0)) {
174:             _to.sendEther(address(this).balance);
175:         } else {
176:             IERC20(_token).safeTransfer(_to, IERC20(_token).balanceOf(address(this)));
177:         }
178:     }

/// @audit Lines: 275 to 278
252:     function _calc1559BaseFee( 
253:         Config memory _config,
254:         uint64 _l1BlockId,
255:         uint32 _parentGasUsed
256:     )
257:         private
258:         view
259:         returns (uint256 basefee_, uint64 gasExcess_)
260:     {
261:         // gasExcess being 0 indicate the dynamic 1559 base fee is disabled.
262:         if (gasExcess > 0) {
263:             // We always add the gas used by parent block to the gas excess
264:             // value as this has already happened
265:             uint256 excess = uint256(gasExcess) + _parentGasUsed;
266: 
267:             // Calculate how much more gas to issue to offset gas excess.
268:             // after each L1 block time, config.gasTarget more gas is issued,
269:             // the gas excess will be reduced accordingly.
270:             // Note that when lastSyncedBlock is zero, we skip this step
271:             // because that means this is the first time calculating the basefee
272:             // and the difference between the L1 height would be extremely big,
273:             // reverting the initial gas excess value back to 0.
274:             uint256 numL1Blocks;
275:             if (lastSyncedBlock > 0 && _l1BlockId > lastSyncedBlock) {
276:                 numL1Blocks = _l1BlockId - lastSyncedBlock;
277:             }
278: 
279:             if (numL1Blocks > 0) {
280:                 uint256 issuance = numL1Blocks * _config.gasTargetPerL1Block;
281:                 excess = excess > issuance ? excess - issuance : 1;
282:             }
283: 
284:             gasExcess_ = uint64(excess.min(type(uint64).max));
285: 
286:             // The base fee per gas used by this block is the spot price at the
287:             // bonding curve, regardless the actual amount of gas used by this
288:             // block, however, this block's gas used will affect the next
289:             // block's base fee.
290:             basefee_ = Lib1559Math.basefee(
291:                 gasExcess_, uint256(_config.basefeeAdjustmentQuotient) * _config.gasTargetPerL1Block
292:             );
293:         }
294: 
295:         // Always make sure basefee is nonzero, this is required by the node.
296:         if (basefee_ == 0) basefee_ = 1;
297:     }
```
[71](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/TaikoL2.sol#L71-L98), [107](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/TaikoL2.sol#L107-L158), [163](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/TaikoL2.sol#L163-L178), [252](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/TaikoL2.sol#L252-L297)

```solidity
📁 File: contracts/automata-attestation/AutomataDcapV3Attestation.sol

/// @audit Lines: 237 to 240
229:     function _isCpuSvnHigherOrGreater( 
230:         uint256[] memory pckCpuSvns,
231:         uint8[] memory tcbCpuSvns
232:     )
233:         private
234:         pure
235:         returns (bool)
236:     {
237:         if (pckCpuSvns.length != CPUSVN_LENGTH || tcbCpuSvns.length != CPUSVN_LENGTH) {
238:             return false;
239:         }
240:         for (uint256 i; i < CPUSVN_LENGTH; ++i) {
241:             if (pckCpuSvns[i] < tcbCpuSvns[i]) {
242:                 return false;
243:             }
244:         }
245:         return true;
246:     }

/// @audit Lines: 406 to 410
364:     function _verifyParsedQuote(V3Struct.ParsedV3QuoteStruct memory v3quote) 
365:         internal
366:         view
367:         returns (bool, bytes memory)
368:     {
369:         bytes memory retData = abi.encodePacked(INVALID_EXIT_CODE);
370: 
371:         // // Step 1: Parse the quote input = 152k gas
372:         (
373:             bool successful,
374:             ,
375:             ,
376:             bytes memory signedQuoteData,
377:             V3Struct.ECDSAQuoteV3AuthData memory authDataV3
378:         ) = V3Parser.validateParsedInput(v3quote);
379:         if (!successful) {
380:             return (false, retData);
381:         }
382: 
383:         // Step 2: Verify application enclave report MRENCLAVE and MRSIGNER
384:         {
385:             if (_checkLocalEnclaveReport) {
386:                 // 4k gas
387:                 bool mrEnclaveIsTrusted =
388:                     _trustedUserMrEnclave[v3quote.localEnclaveReport.mrEnclave];
389:                 bool mrSignerIsTrusted = _trustedUserMrSigner[v3quote.localEnclaveReport.mrSigner];
390: 
391:                 if (!mrEnclaveIsTrusted || !mrSignerIsTrusted) {
392:                     return (false, retData);
393:                 }
394:             }
395:         }
396: 
397:         // Step 3: Verify enclave identity = 43k gas
398:         EnclaveIdStruct.EnclaveIdStatus qeTcbStatus;
399:         {
400:             bool verifiedEnclaveIdSuccessfully;
401:             (verifiedEnclaveIdSuccessfully, qeTcbStatus) =
402:                 _verifyQEReportWithIdentity(v3quote.v3AuthData.pckSignedQeReport);
403:             if (!verifiedEnclaveIdSuccessfully) {
404:                 return (false, retData);
405:             }
406:             if (
407:                 !verifiedEnclaveIdSuccessfully
408:                     || qeTcbStatus == EnclaveIdStruct.EnclaveIdStatus.SGX_ENCLAVE_REPORT_ISVSVN_REVOKED
409:             ) {
410:                 return (false, retData);
411:             }
412:         }
413: 
414:         // Step 4: Parse Quote CertChain
415:         IPEMCertChainLib.ECSha256Certificate[] memory parsedQuoteCerts;
416:         TCBInfoStruct.TCBInfo memory fetchedTcbInfo;
417:         {
418:             // 536k gas
419:             parsedQuoteCerts = new IPEMCertChainLib.ECSha256Certificate[](3);
420:             for (uint256 i; i < 3; ++i) {
421:                 bool isPckCert = i == 0; // additional parsing for PCKCert
422:                 bool certDecodedSuccessfully;
423:                 // todo! move decodeCert offchain
424:                 (certDecodedSuccessfully, parsedQuoteCerts[i]) = pemCertLib.decodeCert(
425:                     authDataV3.certification.decodedCertDataArray[i], isPckCert
426:                 );
427:                 if (!certDecodedSuccessfully) {
428:                     return (false, retData);
429:                 }
430:             }
431:         }
432: 
433:         // Step 5: basic PCK and TCB check = 381k gas
434:         {
435:             string memory parsedFmspc = parsedQuoteCerts[0].pck.sgxExtension.fmspc;
436:             fetchedTcbInfo = tcbInfo[parsedFmspc];
437:             bool tcbConfigured = LibString.eq(parsedFmspc, fetchedTcbInfo.fmspc);
438:             if (!tcbConfigured) {
439:                 return (false, retData);
440:             }
441: 
442:             IPEMCertChainLib.ECSha256Certificate memory pckCert = parsedQuoteCerts[0];
443:             bool pceidMatched = LibString.eq(pckCert.pck.sgxExtension.pceid, fetchedTcbInfo.pceid);
444:             if (!pceidMatched) {
445:                 return (false, retData);
446:             }
447:         }
448: 
449:         // Step 6: Verify TCB Level
450:         TCBInfoStruct.TCBStatus tcbStatus;
451:         {
452:             // 4k gas
453:             bool tcbVerified;
454:             (tcbVerified, tcbStatus) = _checkTcbLevels(parsedQuoteCerts[0].pck, fetchedTcbInfo);
455:             if (!tcbVerified) {
456:                 return (false, retData);
457:             }
458:         }
459: 
460:         // Step 7: Verify cert chain for PCK
461:         {
462:             // 660k gas (rootCA pubkey is trusted)
463:             bool pckCertChainVerified = _verifyCertChain(parsedQuoteCerts);
464:             if (!pckCertChainVerified) {
465:                 return (false, retData);
466:             }
467:         }
468: 
469:         // Step 8: Verify the local attestation sig and qe report sig = 670k gas
470:         {
471:             bool enclaveReportSigsVerified = _enclaveReportSigVerification(
472:                 parsedQuoteCerts[0].pubKey,
473:                 signedQuoteData,
474:                 authDataV3,
475:                 v3quote.v3AuthData.pckSignedQeReport
476:             );
477:             if (!enclaveReportSigsVerified) {
478:                 return (false, retData);
479:             }
480:         }
481: 
482:         retData = abi.encodePacked(sha256(abi.encode(v3quote)), tcbStatus);
483: 
484:         return (_attestationTcbIsValid(tcbStatus), retData);
485:     }
```
[229](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/AutomataDcapV3Attestation.sol#L229-L246), [364](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/AutomataDcapV3Attestation.sol#L364-L485)

```solidity
📁 File: contracts/automata-attestation/lib/PEMCertChainLib.sol

/// @audit Lines: 134 to 138
/// @audit Lines: 134 to 138
/// @audit Lines: 134 to 138
74:     function decodeCert( 
75:         bytes memory der,
76:         bool isPckCert
77:     )
78:         external
79:         pure
80:         returns (bool success, ECSha256Certificate memory cert)
81:     {
82:         uint256 root = der.root();
83: 
84:         // Entering tbsCertificate sequence
85:         uint256 tbsParentPtr = der.firstChildOf(root);
86: 
87:         // Begin iterating through the descendants of tbsCertificate
88:         uint256 tbsPtr = der.firstChildOf(tbsParentPtr);
89: 
90:         // The Serial Number is located one element below Version
91: 
92:         // The issuer commonName value is contained in the Issuer sequence
93:         // which is 3 elements below the first element of the tbsCertificate sequence
94: 
95:         // The Validity sequence is located 4 elements below the first element of the tbsCertificate
96:         // sequence
97: 
98:         // The subject commanName value is contained in the Subject sequence
99:         // which is 5 elements below the first element of the tbsCertificate sequence
100: 
101:         // The PublicKey is located in the second element of subjectPublicKeyInfo sequence
102:         // which is 6 elements below the first element of the tbsCertificate sequence
103: 
104:         tbsPtr = der.nextSiblingOf(tbsPtr);
105: 
106:         {
107:             bytes memory serialNumBytes = der.bytesAt(tbsPtr);
108:             cert.serialNumber = serialNumBytes;
109:         }
110: 
111:         tbsPtr = der.nextSiblingOf(tbsPtr);
112:         tbsPtr = der.nextSiblingOf(tbsPtr);
113: 
114:         if (isPckCert) {
115:             uint256 issuerPtr = der.firstChildOf(tbsPtr);
116:             issuerPtr = der.firstChildOf(issuerPtr);
117:             issuerPtr = der.firstChildOf(issuerPtr);
118:             issuerPtr = der.nextSiblingOf(issuerPtr);
119:             cert.pck.issuerName = string(der.bytesAt(issuerPtr));
120:             bool issuerNameIsValid = LibString.eq(cert.pck.issuerName, PLATFORM_ISSUER_NAME)
121:                 || LibString.eq(cert.pck.issuerName, PROCESSOR_ISSUER_NAME);
122:             if (!issuerNameIsValid) {
123:                 return (false, cert);
124:             }
125:         }
126: 
127:         tbsPtr = der.nextSiblingOf(tbsPtr);
128: 
129:         {
130:             uint256 notBeforePtr = der.firstChildOf(tbsPtr);
131:             uint256 notAfterPtr = der.nextSiblingOf(notBeforePtr);
132:             bytes1 notBeforeTag = der[notBeforePtr.ixs()];
133:             bytes1 notAfterTag = der[notAfterPtr.ixs()];
134:             if (
135:                 (notBeforeTag != 0x17 && notBeforeTag == 0x18)
136:                     || (notAfterTag != 0x17 && notAfterTag != 0x18)
137:             ) {
138:                 return (false, cert);
139:             }
140:             cert.notBefore = X509DateUtils.toTimestamp(der.bytesAt(notBeforePtr));
141:             cert.notAfter = X509DateUtils.toTimestamp(der.bytesAt(notAfterPtr));
142:         }
143: 
144:         tbsPtr = der.nextSiblingOf(tbsPtr);
145: 
146:         if (isPckCert) {
147:             uint256 subjectPtr = der.firstChildOf(tbsPtr);
148:             subjectPtr = der.firstChildOf(subjectPtr);
149:             subjectPtr = der.firstChildOf(subjectPtr);
150:             subjectPtr = der.nextSiblingOf(subjectPtr);
151:             cert.pck.commonName = string(der.bytesAt(subjectPtr));
152:             if (!LibString.eq(cert.pck.commonName, PCK_COMMON_NAME)) {
153:                 return (false, cert);
154:             }
155:         }
156: 
157:         tbsPtr = der.nextSiblingOf(tbsPtr);
158: 
159:         {
160:             // Entering subjectPublicKeyInfo sequence
161:             uint256 subjectPublicKeyInfoPtr = der.firstChildOf(tbsPtr);
162:             subjectPublicKeyInfoPtr = der.nextSiblingOf(subjectPublicKeyInfoPtr);
163: 
164:             // The Signature sequence is located two sibling elements below the tbsCertificate
165:             // element
166:             uint256 sigPtr = der.nextSiblingOf(tbsParentPtr);
167:             sigPtr = der.nextSiblingOf(sigPtr);
168: 
169:             // Skip three bytes to the right
170:             // the three bytes in question: 0x034700 or 0x034800 or 0x034900
171:             sigPtr = NodePtr.getPtr(sigPtr.ixs() + 3, sigPtr.ixf() + 3, sigPtr.ixl());
172: 
173:             sigPtr = der.firstChildOf(sigPtr);
174:             bytes memory sigX = _trimBytes(der.bytesAt(sigPtr), 32);
175: 
176:             sigPtr = der.nextSiblingOf(sigPtr);
177:             bytes memory sigY = _trimBytes(der.bytesAt(sigPtr), 32);
178: 
179:             cert.tbsCertificate = der.allBytesAt(tbsParentPtr);
180:             cert.pubKey = _trimBytes(der.bytesAt(subjectPublicKeyInfoPtr), 64);
181:             cert.signature = abi.encodePacked(sigX, sigY);
182:         }
183: 
184:         if (isPckCert) {
185:             // entering Extension sequence
186:             tbsPtr = der.nextSiblingOf(tbsPtr);
187: 
188:             // check for the extension tag
189:             if (der[tbsPtr.ixs()] != 0xA3) {
190:                 return (false, cert);
191:             }
192: 
193:             tbsPtr = der.firstChildOf(tbsPtr);
194:             tbsPtr = der.firstChildOf(tbsPtr);
195: 
196:             bool sgxExtnTraversedSuccessfully;
197:             uint256 pcesvn;
198:             uint256[] memory cpuSvns;
199:             bytes memory fmspcBytes;
200:             bytes memory pceidBytes;
201:             (sgxExtnTraversedSuccessfully, pcesvn, cpuSvns, fmspcBytes, pceidBytes) =
202:                 _findPckTcbInfo(der, tbsPtr, tbsParentPtr);
203:             if (!sgxExtnTraversedSuccessfully) {
204:                 return (false, cert);
205:             }
206:             cert.pck.sgxExtension.pcesvn = pcesvn;
207:             cert.pck.sgxExtension.sgxTcbCompSvnArr = cpuSvns;
208:             cert.pck.sgxExtension.pceid = LibString.toHexStringNoPrefix(pceidBytes);
209:             cert.pck.sgxExtension.fmspc = LibString.toHexStringNoPrefix(fmspcBytes);
210:             cert.isPck = true;
211:         }
212: 
213:         success = true;
214:     }
```
[74](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/PEMCertChainLib.sol#L74-L214)

```solidity
📁 File: contracts/automata-attestation/lib/QuoteV3Auth/V3Parser.sol

/// @audit Lines: 77 to 81
/// @audit Lines: 77 to 81
/// @audit Lines: 82 to 86
/// @audit Lines: 82 to 86
/// @audit Lines: 94 to 99
/// @audit Lines: 94 to 99
62:     function validateParsedInput(V3Struct.ParsedV3QuoteStruct memory v3Quote) 
63:         internal
64:         pure
65:         returns (
66:             bool success,
67:             V3Struct.Header memory header,
68:             V3Struct.EnclaveReport memory localEnclaveReport,
69:             bytes memory signedQuoteData, // concatenation of header and local enclave report bytes
70:             V3Struct.ECDSAQuoteV3AuthData memory authDataV3
71:         )
72:     {
73:         success = true;
74:         localEnclaveReport = v3Quote.localEnclaveReport;
75:         V3Struct.EnclaveReport memory pckSignedQeReport = v3Quote.v3AuthData.pckSignedQeReport;
76: 
77:         require(
78:             localEnclaveReport.reserved3.length == 96 && localEnclaveReport.reserved4.length == 60
79:                 && localEnclaveReport.reportData.length == 64,
80:             "local QE report has wrong length"
81:         );
82:         require(
83:             pckSignedQeReport.reserved3.length == 96 && pckSignedQeReport.reserved4.length == 60
84:                 && pckSignedQeReport.reportData.length == 64,
85:             "QE report has wrong length"
86:         );
87:         require(
88:             v3Quote.v3AuthData.certification.certType == 5,
89:             "certType must be 5: Concatenated PCK Cert Chain (PEM formatted)"
90:         );
91:         require(
92:             v3Quote.v3AuthData.certification.decodedCertDataArray.length == 3, "3 certs in chain"
93:         );
94:         require(
95:             v3Quote.v3AuthData.ecdsa256BitSignature.length == 64
96:                 && v3Quote.v3AuthData.ecdsaAttestationKey.length == 64
97:                 && v3Quote.v3AuthData.qeReportSignature.length == 64,
98:             "Invalid ECDSA signature format"
99:         );
100:         require(
101:             v3Quote.v3AuthData.qeAuthData.parsedDataSize
102:                 == v3Quote.v3AuthData.qeAuthData.data.length,
103:             "Invalid QEAuthData size"
104:         );
105: 
106:         uint32 totalQuoteSize = 48 // header
107:             + 384 // local QE report
108:             + 64 // ecdsa256BitSignature
109:             + 64 // ecdsaAttestationKey
110:             + 384 // QE report
111:             + 64 // qeReportSignature
112:             + 2 // sizeof(v3Quote.v3AuthData.qeAuthData.parsedDataSize)
113:             + v3Quote.v3AuthData.qeAuthData.parsedDataSize + 2 // sizeof(v3Quote.v3AuthData.certification.certType)
114:             + 4 // sizeof(v3Quote.v3AuthData.certification.certDataSize)
115:             + v3Quote.v3AuthData.certification.certDataSize;
116:         require(totalQuoteSize >= MINIMUM_QUOTE_LENGTH, "Invalid quote size");
117: 
118:         header = v3Quote.header;
119:         bytes memory headerBytes = abi.encodePacked(
120:             header.version,
121:             header.attestationKeyType,
122:             header.teeType,
123:             header.qeSvn,
124:             header.pceSvn,
125:             header.qeVendorId,
126:             header.userData
127:         );
128: 
129:         signedQuoteData = abi.encodePacked(headerBytes, V3Parser.packQEReport(localEnclaveReport));
130:         authDataV3 = v3Quote.v3AuthData;
131:     }

/// @audit Lines: 218 to 220
203:     function parseAuthDataAndVerifyCertType( 
204:         bytes memory rawAuthData,
205:         address pemCertLibAddr
206:     )
207:         private
208:         pure
209:         returns (bool success, V3Struct.ECDSAQuoteV3AuthData memory authDataV3)
210:     {
211:         V3Struct.QEAuthData memory qeAuthData;
212:         qeAuthData.parsedDataSize = uint16(littleEndianDecode(rawAuthData.substring(576, 2)));
213:         qeAuthData.data = rawAuthData.substring(578, qeAuthData.parsedDataSize);
214: 
215:         uint256 offset = 578 + qeAuthData.parsedDataSize;
216:         V3Struct.CertificationData memory cert;
217:         cert.certType = uint16(littleEndianDecode(rawAuthData.substring(offset, 2)));
218:         if (cert.certType < 1 || cert.certType > 5) {
219:             return (false, authDataV3);
220:         }
221:         offset += 2;
222:         cert.certDataSize = uint32(littleEndianDecode(rawAuthData.substring(offset, 4)));
223:         offset += 4;
224:         bytes memory certData = rawAuthData.substring(offset, cert.certDataSize);
225:         cert.decodedCertDataArray = parseCerificationChainBytes(certData, pemCertLibAddr);
226: 
227:         authDataV3.ecdsa256BitSignature = rawAuthData.substring(0, 64);
228:         authDataV3.ecdsaAttestationKey = rawAuthData.substring(64, 64);
229:         bytes memory rawQeReport = rawAuthData.substring(128, 384);
230:         authDataV3.pckSignedQeReport = parseEnclaveReport(rawQeReport);
231:         authDataV3.qeReportSignature = rawAuthData.substring(512, 64);
232:         authDataV3.qeAuthData = qeAuthData;
233:         authDataV3.certification = cert;
234: 
235:         success = true;
236:     }
```
[62](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/QuoteV3Auth/V3Parser.sol#L62-L131), [203](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/QuoteV3Auth/V3Parser.sol#L203-L236)

```solidity
📁 File: contracts/automata-attestation/utils/BytesUtils.sol

/// @audit Lines: 335 
320:     function base32HexDecodeWord( 
321:         bytes memory self,
322:         uint256 off,
323:         uint256 len
324:     )
325:         internal
326:         pure
327:         returns (bytes32)
328:     {
329:         require(len <= 52, "unexpected len");
330: 
331:         uint256 ret = 0;
332:         uint8 decoded;
333:         for (uint256 i; i < len; ++i) {
334:             bytes1 char = self[off + i];
335:             require(char >= 0x30 && char <= 0x7A, "invalid char");
336:             decoded = uint8(BASE32_HEX_TABLE[uint256(uint8(char)) - 0x30]);
337:             require(decoded <= 0x20, "invalid decoded");
338:             if (i == len - 1) {
339:                 break;
340:             }
341:             ret = (ret << 5) | decoded;
342:         }
343: 
344:         uint256 bitlen = len * 5;
345:         if (len % 8 == 0) {
346:             // Multiple of 8 characters, no padding
347:             ret = (ret << 5) | decoded;
348:         } else if (len % 8 == 2) {
349:             // Two extra characters - 1 byte
350:             ret = (ret << 3) | (decoded >> 2);
351:             bitlen -= 2;
352:         } else if (len % 8 == 4) {
353:             // Four extra characters - 2 bytes
354:             ret = (ret << 1) | (decoded >> 4);
355:             bitlen -= 4;
356:         } else if (len % 8 == 5) {
357:             // Five extra characters - 3 bytes
358:             ret = (ret << 4) | (decoded >> 1);
359:             bitlen -= 1;
360:         } else if (len % 8 == 7) {
361:             // Seven extra characters - 4 bytes
362:             ret = (ret << 2) | (decoded >> 3);
363:             bitlen -= 3;
364:         } else {
365:             revert("unexpected len");
366:         }
367: 
368:         return bytes32(ret << (256 - bitlen));
369:     }
```
[320](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/BytesUtils.sol#L320-L369)

```solidity
📁 File: contracts/automata-attestation/utils/RsaVerify.sol

/// @audit Lines: 137 to 140
/// @audit Lines: 167 to 173
43:     function pkcs1Sha256( 
44:         bytes32 _sha256,
45:         bytes memory _s,
46:         bytes memory _e,
47:         bytes memory _m
48:     )
49:         internal
50:         view
51:         returns (bool)
52:     {
53:         uint8[17] memory sha256ExplicitNullParam = [
54:             0x30,
55:             0x31,
56:             0x30,
57:             0x0d,
58:             0x06,
59:             0x09,
60:             0x60,
61:             0x86,
62:             0x48,
63:             0x01,
64:             0x65,
65:             0x03,
66:             0x04,
67:             0x02,
68:             0x01,
69:             0x05,
70:             0x00
71:         ];
72: 
73:         uint8[15] memory sha256ImplicitNullParam = [
74:             0x30,
75:             0x2f,
76:             0x30,
77:             0x0b,
78:             0x06,
79:             0x09,
80:             0x60,
81:             0x86,
82:             0x48,
83:             0x01,
84:             0x65,
85:             0x03,
86:             0x04,
87:             0x02,
88:             0x01
89:         ];
90: 
91:         // decipher
92: 
93:         bytes memory input =
94:             bytes.concat(bytes32(_s.length), bytes32(_e.length), bytes32(_m.length), _s, _e, _m);
95:         uint256 inputlen = input.length;
96: 
97:         uint256 decipherlen = _m.length;
98:         bytes memory decipher = new bytes(decipherlen);
99:         assembly {
100:             pop(
101:                 staticcall(
102:                     sub(gas(), 2000),
103:                     5,
104:                     add(input, 0x20),
105:                     inputlen,
106:                     add(decipher, 0x20),
107:                     decipherlen
108:                 )
109:             )
110:         }
111: 
112:         // Check that is well encoded:
113:         //
114:         // 0x00 || 0x01 || PS || 0x00 || DigestInfo
115:         // PS is padding filled with 0xff
116:         // DigestInfo ::= SEQUENCE {
117:         //    digestAlgorithm AlgorithmIdentifier,
118:         //      [optional algorithm parameters]
119:         //    digest OCTET STRING
120:         // }
121: 
122:         bool hasNullParam;
123:         uint256 digestAlgoWithParamLen;
124: 
125:         if (uint8(decipher[decipherlen - 50]) == 0x31) {
126:             hasNullParam = true;
127:             digestAlgoWithParamLen = sha256ExplicitNullParam.length;
128:         } else if (uint8(decipher[decipherlen - 48]) == 0x2f) {
129:             hasNullParam = false;
130:             digestAlgoWithParamLen = sha256ImplicitNullParam.length;
131:         } else {
132:             return false;
133:         }
134: 
135:         uint256 paddingLen = decipherlen - 5 - digestAlgoWithParamLen - 32;
136: 
137:         if (decipher[0] != 0 || decipher[1] != 0x01) {
138:             return false;
139:         }
140:         for (uint256 i = 2; i < 2 + paddingLen; ++i) {
141:             if (decipher[i] != 0xff) {
142:                 return false;
143:             }
144:         }
145:         if (decipher[2 + paddingLen] != 0) {
146:             return false;
147:         }
148: 
149:         // check digest algorithm
150: 
151:         if (digestAlgoWithParamLen == sha256ExplicitNullParam.length) {
152:             for (uint256 i; i < digestAlgoWithParamLen; ++i) {
153:                 if (decipher[3 + paddingLen + i] != bytes1(sha256ExplicitNullParam[i])) {
154:                     return false;
155:                 }
156:             }
157:         } else {
158:             for (uint256 i; i < digestAlgoWithParamLen; ++i) {
159:                 if (decipher[3 + paddingLen + i] != bytes1(sha256ImplicitNullParam[i])) {
160:                     return false;
161:                 }
162:             }
163:         }
164: 
165:         // check digest
166: 
167:         if (
168:             decipher[3 + paddingLen + digestAlgoWithParamLen] != 0x04
169:                 || decipher[4 + paddingLen + digestAlgoWithParamLen] != 0x20
170:         ) {
171:             return false;
172:         }
173: 
174:         for (uint256 i; i < _sha256.length; ++i) {
175:             if (decipher[5 + paddingLen + digestAlgoWithParamLen + i] != _sha256[i]) {
176:                 return false;
177:             }
178:         }
179: 
180:         return true;
181:     }

/// @audit Lines: 270 to 273
212:     function pkcs1Sha1( 
213:         bytes20 _sha1,
214:         bytes memory _s,
215:         bytes memory _e,
216:         bytes memory _m
217:     )
218:         internal
219:         view
220:         returns (bool)
221:     {
222:         uint8[15] memory sha1Prefix = [
223:             0x30,
224:             0x21,
225:             0x30,
226:             0x09,
227:             0x06,
228:             0x05,
229:             0x2b,
230:             0x0e,
231:             0x03,
232:             0x02,
233:             0x1a,
234:             0x05,
235:             0x00,
236:             0x04,
237:             0x14
238:         ];
239: 
240:         // decipher
241:         bytes memory input =
242:             bytes.concat(bytes32(_s.length), bytes32(_e.length), bytes32(_m.length), _s, _e, _m);
243:         uint256 inputlen = input.length;
244: 
245:         uint256 decipherlen = _m.length;
246:         bytes memory decipher = new bytes(decipherlen);
247:         assembly {
248:             pop(
249:                 staticcall(
250:                     sub(gas(), 2000),
251:                     5,
252:                     add(input, 0x20),
253:                     inputlen,
254:                     add(decipher, 0x20),
255:                     decipherlen
256:                 )
257:             )
258:         }
259: 
260:         // Check that is well encoded:
261:         // 0x00 || 0x01 || PS || 0x00 || DigestInfo
262:         // PS is padding filled with 0xff
263:         // DigestInfo ::= SEQUENCE {
264:         //    digestAlgorithm AlgorithmIdentifier,
265:         //    digest OCTET STRING
266:         // }
267: 
268:         uint256 paddingLen = decipherlen - 3 - sha1Prefix.length - 20;
269: 
270:         if (decipher[0] != 0 || decipher[1] != 0x01) {
271:             return false;
272:         }
273:         for (uint256 i = 2; i < 2 + paddingLen; ++i) {
274:             if (decipher[i] != 0xff) {
275:                 return false;
276:             }
277:         }
278:         if (decipher[2 + paddingLen] != 0) {
279:             return false;
280:         }
281: 
282:         // check digest algorithm
283:         for (uint256 i; i < sha1Prefix.length; ++i) {
284:             if (decipher[3 + paddingLen + i] != bytes1(sha1Prefix[i])) {
285:                 return false;
286:             }
287:         }
288: 
289:         // check digest
290:         for (uint256 i; i < _sha1.length; ++i) {
291:             if (decipher[3 + paddingLen + sha1Prefix.length + i] != _sha1[i]) {
292:                 return false;
293:             }
294:         }
295: 
296:         return true;
297:     }
```
[43](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/RsaVerify.sol#L43-L181), [212](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/RsaVerify.sol#L212-L297)

```solidity
📁 File: contracts/bridge/Bridge.sol

/// @audit Lines: 93 to 98
/// @audit Lines: 93 to 98
/// @audit Lines: 93 to 98
75:     function init(address _owner, address _addressManager) external initializer { 
76:         __Essential_init(_owner, _addressManager);
77:     }

/// @audit Lines: 41 to 43
82:     function suspendMessages( 
83:         bytes32[] calldata _msgHashes,
84:         bool _suspend
85:     )
86:         external
87:         onlyFromOwnerOrNamed("bridge_watchdog")
88:     {
89:         uint64 _timestamp = _suspend ? type(uint64).max : uint64(block.timestamp);
90:         for (uint256 i; i < _msgHashes.length; ++i) {
91:             bytes32 msgHash = _msgHashes[i];
92:             proofReceipt[msgHash].receivedAt = _timestamp;
93:             emit MessageSuspended(msgHash, _suspend);
94:         }
95:     }

/// @audit Lines: 41 to 43
101:     function banAddress( 
102:         address _addr,
103:         bool _ban
104:     )
105:         external
106:         onlyFromOwnerOrNamed("bridge_watchdog")
107:         nonReentrant
108:     {
109:         if (addressBanned[_addr] == _ban) revert B_INVALID_STATUS();
110:         addressBanned[_addr] = _ban;
111:         emit AddressBanned(_addr, _ban);
112:     }

/// @audit Lines: 124 to 127
115:     function sendMessage(Message calldata _message) 
116:         external
117:         payable
118:         override
119:         nonReentrant
120:         whenNotPaused
121:         returns (bytes32 msgHash_, Message memory message_)
122:     {
123:         // Ensure the message owner is not null.
124:         if (_message.srcOwner == address(0) || _message.destOwner == address(0)) {
125:             revert B_INVALID_USER();
126:         }
127: 
128:         // Check if the destination chain is enabled.
129:         (bool destChainEnabled,) = isDestChainEnabled(_message.destChainId);
130: 
131:         // Verify destination chain and to address.
132:         if (!destChainEnabled) revert B_INVALID_CHAINID();
133:         if (_message.destChainId == block.chainid) {
134:             revert B_INVALID_CHAINID();
135:         }
136: 
137:         // Ensure the sent value matches the expected amount.
138:         uint256 expectedAmount = _message.value + _message.fee;
139:         if (expectedAmount != msg.value) revert B_INVALID_VALUE();
140: 
141:         message_ = _message;
142: 
143:         // Configure message details and send signal to indicate message sending.
144:         message_.id = nextMessageId++;
145:         message_.from = msg.sender;
146:         message_.srcChainId = uint64(block.chainid);
147: 
148:         msgHash_ = hashMessage(message_);
149: 
150:         ISignalService(resolve("signal_service", false)).sendSignal(msgHash_);
151:         emit MessageSent(msgHash_, message_);
152:     }

/// @audit Lines: 250 to 257
/// @audit Lines: 260 to 263
/// @audit Lines: 269 to 291
/// @audit Lines: 269 to 291
/// @audit Lines: 269 to 291
217:     function processMessage( 
218:         Message calldata _message,
219:         bytes calldata _proof
220:     )
221:         external
222:         nonReentrant
223:         whenNotPaused
224:         sameChain(_message.destChainId)
225:     {
226:         bytes32 msgHash = hashMessage(_message);
227:         if (messageStatus[msgHash] != Status.NEW) revert B_STATUS_MISMATCH();
228: 
229:         address signalService = resolve("signal_service", false);
230:         uint64 receivedAt = proofReceipt[msgHash].receivedAt;
231:         bool isMessageProven = receivedAt != 0;
232: 
233:         (uint256 invocationDelay, uint256 invocationExtraDelay) = getInvocationDelays();
234: 
235:         if (!isMessageProven) {
236:             if (!_proveSignalReceived(signalService, msgHash, _message.srcChainId, _proof)) {
237:                 revert B_NOT_RECEIVED();
238:             }
239: 
240:             receivedAt = uint64(block.timestamp);
241: 
242:             if (invocationDelay != 0) {
243:                 proofReceipt[msgHash] = ProofReceipt({
244:                     receivedAt: receivedAt,
245:                     preferredExecutor: _message.gasLimit == 0 ? _message.destOwner : msg.sender
246:                 });
247:             }
248:         }
249: 
250:         if (invocationDelay != 0 && msg.sender != proofReceipt[msgHash].preferredExecutor) {
251:             // If msg.sender is not the one that proved the message, then there
252:             // is an extra delay.
253:             unchecked {
254:                 invocationDelay += invocationExtraDelay;
255:             }
256:         }
257: 
258:         if (block.timestamp >= invocationDelay + receivedAt) {
259:             // If the gas limit is set to zero, only the owner can process the message.
260:             if (_message.gasLimit == 0 && msg.sender != _message.destOwner) {
261:                 revert B_PERMISSION_DENIED();
262:             }
263: 
264:             delete proofReceipt[msgHash];
265: 
266:             uint256 refundAmount;
267: 
268:             // Process message differently based on the target address
269:             if (
270:                 _message.to == address(0) || _message.to == address(this)
271:                     || _message.to == signalService || addressBanned[_message.to]
272:             ) {
273:                 // Handle special addresses that don't require actual invocation but
274:                 // mark message as DONE
275:                 refundAmount = _message.value;
276:                 _updateMessageStatus(msgHash, Status.DONE);
277:             } else {
278:                 // Use the specified message gas limit if called by the owner, else
279:                 // use remaining gas
280:                 uint256 gasLimit = msg.sender == _message.destOwner ? gasleft() : _message.gasLimit;
281: 
282:                 if (_invokeMessageCall(_message, msgHash, gasLimit)) {
283:                     _updateMessageStatus(msgHash, Status.DONE);
284:                 } else {
285:                     _updateMessageStatus(msgHash, Status.RETRIABLE);
286:                 }
287:             }
288: 
289:             // Determine the refund recipient
290:             address refundTo =
291:                 _message.refundTo == address(0) ? _message.destOwner : _message.refundTo;
292: 
293:             // Refund the processing fee
294:             if (msg.sender == refundTo) {
295:                 refundTo.sendEther(_message.fee + refundAmount);
296:             } else {
297:                 // If sender is another address, reward it and refund the rest
298:                 msg.sender.sendEther(_message.fee);
299:                 refundTo.sendEther(refundAmount);
300:             }
301:             emit MessageExecuted(msgHash);
302:         } else if (!isMessageProven) {
303:             emit MessageReceived(msgHash, _message, false);
304:         } else {
305:             revert B_INVOCATION_TOO_EARLY();
306:         }
307:     }

/// @audit Lines: 321 to 324
310:     function retryMessage( 
311:         Message calldata _message,
312:         bool _isLastAttempt
313:     )
314:         external
315:         nonReentrant
316:         whenNotPaused
317:         sameChain(_message.destChainId)
318:     {
319:         // If the gasLimit is set to 0 or isLastAttempt is true, the caller must
320:         // be the message.destOwner.
321:         if (_message.gasLimit == 0 || _isLastAttempt) {
322:             if (msg.sender != _message.destOwner) revert B_PERMISSION_DENIED();
323:         }
324: 
325:         bytes32 msgHash = hashMessage(_message);
326:         if (messageStatus[msgHash] != Status.RETRIABLE) {
327:             revert B_NON_RETRIABLE();
328:         }
329: 
330:         // Attempt to invoke the messageCall.
331:         if (_invokeMessageCall(_message, msgHash, gasleft())) {
332:             _updateMessageStatus(msgHash, Status.DONE);
333:         } else if (_isLastAttempt) {
334:             _updateMessageStatus(msgHash, Status.FAILED);
335:         }
336:         emit MessageRetried(msgHash);
337:     }

/// @audit Lines: 405 to 408
403:     function context() public view returns (Context memory ctx_) { 
404:         ctx_ = _loadContext();
405:         if (ctx_.msgHash == 0 || ctx_.msgHash == bytes32(PLACEHOLDER)) {
406:             revert B_INVALID_CONTEXT();
407:         }
408:     }

/// @audit Lines: 429 to 446
/// @audit Lines: 429 to 446
/// @audit Lines: 429 to 446
/// @audit Lines: 429 to 446
/// @audit Lines: 429 to 446
/// @audit Lines: 439 to 445
417:     function getInvocationDelays() 
418:         public
419:         view
420:         virtual
421:         returns (uint256 invocationDelay_, uint256 invocationExtraDelay_)
422:     {
423:         if (
424:             block.chainid == 1 // Ethereum mainnet
425:         ) {
426:             // For Taiko mainnet
427:             // 384 seconds = 6.4 minutes = one ethereum epoch
428:             return (1 hours, 384 seconds);
429:         } else if (
430:             block.chainid == 2 // Ropsten
431:                 || block.chainid == 4 // Rinkeby
432:                 || block.chainid == 5 // Goerli
433:                 || block.chainid == 42 // Kovan
434:                 || block.chainid == 17_000 // Holesky
435:                 || block.chainid == 11_155_111 // Sepolia
436:         ) {
437:             // For all Taiko public testnets
438:             return (30 minutes, 384 seconds);
439:         } else if (block.chainid >= 32_300 && block.chainid <= 32_400) {
440:             // For all Taiko internal devnets
441:             return (5 minutes, 384 seconds);
442:         } else {
443:             // This is a Taiko L2 chain where no deleys are applied.
444:             return (0, 0);
445:         }
446:     }

/// @audit Lines: 41 to 43
461:     function _authorizePause(address) 
462:         internal
463:         view
464:         virtual
465:         override
466:         onlyFromOwnerOrNamed("bridge_pauser")
467:     { }

/// @audit Lines: 490 to 503
/// @audit Lines: 490 to 503
477:     function _invokeMessageCall( 
478:         Message calldata _message,
479:         bytes32 _msgHash,
480:         uint256 _gasLimit
481:     )
482:         private
483:         returns (bool success_)
484:     {
485:         if (_gasLimit == 0) revert B_INVALID_GAS_LIMIT();
486:         assert(_message.from != address(this));
487: 
488:         _storeContext(_msgHash, _message.from, _message.srcChainId);
489: 
490:         if (
491:             _message.data.length >= 4 // msg can be empty
492:                 && bytes4(_message.data) != IMessageInvocable.onMessageInvocation.selector
493:                 && _message.to.isContract()
494:         ) {
495:             success_ = false;
496:         } else {
497:             (success_,) = ExcessivelySafeCall.excessivelySafeCall(
498:                 _message.to,
499:                 _gasLimit,
500:                 _message.value,
501:                 64, // return max 64 bytes
502:                 _message.data
503:             );
504:         }
505: 
506:         // Must reset the context after the message call
507:         _resetContext();
508:     }
```
[75](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/Bridge.sol#L75-L77), [82](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/Bridge.sol#L82-L95), [101](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/Bridge.sol#L101-L112), [115](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/Bridge.sol#L115-L152), [217](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/Bridge.sol#L217-L307), [310](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/Bridge.sol#L310-L337), [403](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/Bridge.sol#L403-L408), [417](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/Bridge.sol#L417-L446), [461](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/Bridge.sol#L461-L467), [477](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/Bridge.sol#L477-L508)

```solidity
📁 File: contracts/common/AddressManager.sol

/// @audit Lines: 62 to 68
/// @audit Lines: 62 to 68
/// @audit Lines: 62 to 68
30:     function init(address _owner) external initializer { 
31:         __Essential_init(_owner);
32:     }
```
[30](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/common/AddressManager.sol#L30-L32)

```solidity
📁 File: contracts/common/AddressResolver.sol

/// @audit Lines: 85 to 87
72:     function _resolve( 
73:         uint64 _chainId,
74:         bytes32 _name,
75:         bool _allowZeroAddress
76:     )
77:         private
78:         view
79:         returns (address payable addr_)
80:     {
81:         if (addressManager == address(0)) revert RESOLVER_INVALID_MANAGER();
82: 
83:         addr_ = payable(IAddressManager(addressManager).getAddress(_chainId, _name));
84: 
85:         if (!_allowZeroAddress && addr_ == address(0)) {
86:             revert RESOLVER_ZERO_ADDR(_chainId, _name);
87:         }
88:     }
```
[72](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/common/AddressResolver.sol#L72-L88)

```solidity
📁 File: contracts/libs/Lib4844.sol

/// @audit Lines: 57 to 61
30:     function evaluatePoint( 
31:         bytes32 _blobHash,
32:         uint256 _x,
33:         uint256 _y,
34:         bytes1[48] memory _commitment,
35:         bytes1[48] memory _pointProof
36:     )
37:         internal
38:         view
39:     {
40:         if (_x >= BLS_MODULUS) revert POINT_X_TOO_LARGE();
41:         if (_y >= BLS_MODULUS) revert POINT_Y_TOO_LARGE();
42: 
43:         (bool ok, bytes memory ret) = POINT_EVALUATION_PRECOMPILE_ADDRESS.staticcall(
44:             abi.encodePacked(_blobHash, _x, _y, _commitment, _pointProof)
45:         );
46: 
47:         if (!ok) revert EVAL_FAILED_1();
48: 
49:         if (ret.length != 64) revert EVAL_FAILED_2();
50: 
51:         bytes32 first;
52:         bytes32 second;
53:         assembly {
54:             first := mload(add(ret, 32))
55:             second := mload(add(ret, 64))
56:         }
57:         if (uint256(first) != FIELD_ELEMENTS_PER_BLOB || uint256(second) != BLS_MODULUS) {
58:             revert EVAL_FAILED_2();
59:         }
60:     }
```
[30](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/libs/Lib4844.sol#L30-L60)

```solidity
📁 File: contracts/signal/SignalService.sol

/// @audit Lines: 99 to 104
/// @audit Lines: 99 to 104
/// @audit Lines: 99 to 104
48:     function init(address _owner, address _addressManager) external initializer { 
49:         __Essential_init(_owner, _addressManager);
50:     }

/// @audit Lines: 131 to 134
/// @audit Lines: 114 to 117
83:     function proveSignalReceived( 
84:         uint64 _chainId,
85:         address _app,
86:         bytes32 _signal,
87:         bytes calldata _proof
88:     )
89:         public
90:         virtual
91:         validSender(_app)
92:         nonZeroValue(_signal)
93:     {
94:         HopProof[] memory hopProofs = abi.decode(_proof, (HopProof[]));
95:         if (hopProofs.length == 0) revert SS_EMPTY_PROOF();
96: 
97:         uint64 chainId = _chainId;
98:         address app = _app;
99:         bytes32 signal = _signal;
100:         bytes32 value = _signal;
101:         address signalService = resolve(chainId, "signal_service", false);
102: 
103:         HopProof memory hop;
104:         for (uint256 i; i < hopProofs.length; ++i) {
105:             hop = hopProofs[i];
106: 
107:             bytes32 signalRoot = _verifyHopProof(chainId, app, signal, value, hop, signalService);
108:             bool isLastHop = i == hopProofs.length - 1;
109: 
110:             if (isLastHop) {
111:                 if (hop.chainId != block.chainid) revert SS_INVALID_LAST_HOP_CHAINID();
112:                 signalService = address(this);
113:             } else {
114:                 if (hop.chainId == 0 || hop.chainId == block.chainid) {
115:                     revert SS_INVALID_MID_HOP_CHAINID();
116:                 }
117:                 signalService = resolve(hop.chainId, "signal_service", false);
118:             }
119: 
120:             bool isFullProof = hop.accountProof.length > 0;
121: 
122:             _cacheChainData(hop, chainId, hop.blockId, signalRoot, isFullProof, isLastHop);
123: 
124:             bytes32 kind = isFullProof ? LibSignals.STATE_ROOT : LibSignals.SIGNAL_ROOT;
125:             signal = signalForChainData(chainId, kind, hop.blockId);
126:             value = hop.rootHash;
127:             chainId = hop.chainId;
128:             app = signalService;
129:         }
130: 
131:         if (value == 0 || value != _loadSignalValue(address(this), signal)) {
132:             revert SS_SIGNAL_NOT_FOUND();
133:         }
134:     }

/// @audit Lines: 285 to 288
/// @audit Lines: 293 to 296
271:     function _cacheChainData( 
272:         HopProof memory _hop,
273:         uint64 _chainId,
274:         uint64 _blockId,
275:         bytes32 _signalRoot,
276:         bool _isFullProof,
277:         bool _isLastHop
278:     )
279:         private
280:     {
281:         // cache state root
282:         bool cacheStateRoot = _hop.cacheOption == CacheOption.CACHE_BOTH
283:             || _hop.cacheOption == CacheOption.CACHE_STATE_ROOT;
284: 
285:         if (cacheStateRoot && _isFullProof && !_isLastHop) {
286:             _syncChainData(_chainId, LibSignals.STATE_ROOT, _blockId, _hop.rootHash);
287:         }
288: 
289:         // cache signal root
290:         bool cacheSignalRoot = _hop.cacheOption == CacheOption.CACHE_BOTH
291:             || _hop.cacheOption == CacheOption.CACHE_SIGNAL_ROOT;
292: 
293:         if (cacheSignalRoot && (_isFullProof || !_isLastHop)) {
294:             _syncChainData(_chainId, LibSignals.SIGNAL_ROOT, _blockId, _signalRoot);
295:         }
296:     }
```
[48](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/signal/SignalService.sol#L48-L50), [83](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/signal/SignalService.sol#L83-L134), [271](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/signal/SignalService.sol#L271-L296)

```solidity
📁 File: contracts/team/TimelockTokenPool.sol

/// @audit Lines: 91 to 95
/// @audit Lines: 91 to 95
/// @audit Lines: 91 to 95
111:     function init( 
112:         address _owner,
113:         address _taikoToken,
114:         address _costToken,
115:         address _sharedVault
116:     )
117:         external
118:         initializer
119:     {
120:         __Essential_init(_owner);
121:         if (_taikoToken == address(0)) revert INVALID_PARAM();
122:         taikoToken = _taikoToken;
123: 
124:         if (_costToken == address(0)) revert INVALID_PARAM();
125:         costToken = _costToken;
126: 
127:         if (_sharedVault == address(0)) revert INVALID_PARAM();
128:         sharedVault = _sharedVault;
129:     }

/// @audit Lines: 274 to 279
/// @audit Lines: 277 to 279
273:     function _validateCliff(uint64 _start, uint64 _cliff, uint32 _period) private pure { 
274:         if (_start == 0 || _period == 0) {
275:             if (_cliff > 0) revert INVALID_GRANT();
276:         } else {
277:             if (_cliff > 0 && _cliff <= _start) revert INVALID_GRANT();
278:             if (_cliff >= _start + _period) revert INVALID_GRANT();
279:         }
280:     }
```
[111](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/TimelockTokenPool.sol#L111-L129), [273](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/TimelockTokenPool.sol#L273-L280)

```solidity
📁 File: contracts/team/airdrop/ERC20Airdrop.sol

/// @audit Lines: 74 to 78
/// @audit Lines: 74 to 78
/// @audit Lines: 74 to 78
27:     function init( 
28:         address _owner,
29:         uint64 _claimStart,
30:         uint64 _claimEnd,
31:         bytes32 _merkleRoot,
32:         address _token,
33:         address _vault
34:     )
35:         external
36:         initializer
37:     {
38:         __Essential_init(_owner);
39:         __MerkleClaimable_init(_claimStart, _claimEnd, _merkleRoot);
40: 
41:         token = _token;
42:         vault = _vault;
43:     }
```
[27](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/airdrop/ERC20Airdrop.sol#L27-L43)

```solidity
📁 File: contracts/team/airdrop/ERC20Airdrop2.sol

/// @audit Lines: 97 to 103
/// @audit Lines: 97 to 103
/// @audit Lines: 97 to 103
54:     function init( 
55:         address _owner,
56:         uint64 _claimStart,
57:         uint64 _claimEnd,
58:         bytes32 _merkleRoot,
59:         address _token,
60:         address _vault,
61:         uint64 _withdrawalWindow
62:     )
63:         external
64:         initializer
65:     {
66:         __Essential_init(_owner);
67:         __MerkleClaimable_init(_claimStart, _claimEnd, _merkleRoot);
68: 
69:         token = _token;
70:         vault = _vault;
71:         withdrawalWindow = _withdrawalWindow;
72:     }

/// @audit Lines: 40 to 43
88:     function withdraw(address user) external ongoingWithdrawals { 
89:         (, uint256 amount) = getBalance(user);
90:         withdrawnAmount[user] += amount;
91:         IERC20(token).transferFrom(vault, user, amount);
92: 
93:         emit Withdrawn(user, amount);
94:     }
```
[54](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/airdrop/ERC20Airdrop2.sol#L54-L72), [88](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/airdrop/ERC20Airdrop2.sol#L88-L94)

```solidity
📁 File: contracts/team/airdrop/ERC721Airdrop.sol

/// @audit Lines: 64 to 70
/// @audit Lines: 64 to 70
/// @audit Lines: 64 to 70
25:     function init( 
26:         address _owner,
27:         uint64 _claimStart,
28:         uint64 _claimEnd,
29:         bytes32 _merkleRoot,
30:         address _token,
31:         address _vault
32:     )
33:         external
34:         initializer
35:     {
36:         __Essential_init(_owner);
37:         __MerkleClaimable_init(_claimStart, _claimEnd, _merkleRoot);
38: 
39:         token = _token;
40:         vault = _vault;
41:     }
```
[25](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/airdrop/ERC721Airdrop.sol#L25-L41)

```solidity
📁 File: contracts/team/airdrop/MerkleClaimable.sol

/// @audit Lines: 34 to 39
/// @audit Lines: 34 to 39
/// @audit Lines: 34 to 39
/// @audit Lines: 34 to 39
67:     function _verifyClaim(bytes memory data, bytes32[] calldata proof) internal ongoingClaim { 
68:         bytes32 hash = keccak256(abi.encode("CLAIM_TAIKO_AIRDROP", data));
69: 
70:         if (isClaimed[hash]) revert CLAIMED_ALREADY();
71:         if (!_verifyMerkleProof(proof, merkleRoot, hash)) revert INVALID_PROOF();
72: 
73:         isClaimed[hash] = true;
74:         emit Claimed(hash);
75:     }
```
[67](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/airdrop/MerkleClaimable.sol#L67-L75)

```solidity
📁 File: contracts/thirdparty/optimism/rlp/RLPReader.sol

/// @audit Lines: 182 to 186
144:     function _decodeLength(RLPItem memory _in) 
145:         private
146:         pure
147:         returns (uint256 offset_, uint256 length_, RLPItemType type_)
148:     {
149:         // Short-circuit if there's nothing to decode, note that we perform this check when
150:         // the user creates an RLP item via toRLPItem, but it's always possible for them to bypass
151:         // that function and create an RLP item directly. So we need to check this anyway.
152:         require(
153:             _in.length > 0,
154:             "RLPReader: length of an RLP item must be greater than zero to be decodable"
155:         );
156: 
157:         MemoryPointer ptr = _in.ptr;
158:         uint256 prefix;
159:         assembly {
160:             prefix := byte(0, mload(ptr))
161:         }
162: 
163:         if (prefix <= 0x7f) {
164:             // Single byte.
165:             return (0, 1, RLPItemType.DATA_ITEM);
166:         } else if (prefix <= 0xb7) {
167:             // Short string.
168: 
169:             // slither-disable-next-line variable-scope
170:             uint256 strLen = prefix - 0x80;
171: 
172:             require(
173:                 _in.length > strLen,
174:                 "RLPReader: length of content must be greater than string length (short string)"
175:             );
176: 
177:             bytes1 firstByteOfContent;
178:             assembly {
179:                 firstByteOfContent := and(mload(add(ptr, 1)), shl(248, 0xff))
180:             }
181: 
182:             require(
183:                 strLen != 1 || firstByteOfContent >= 0x80,
184:                 "RLPReader: invalid prefix, single byte < 0x80 are not prefixed (short string)"
185:             );
186: 
187:             return (1, strLen, RLPItemType.DATA_ITEM);
188:         } else if (prefix <= 0xbf) {
189:             // Long string.
190:             uint256 lenOfStrLen = prefix - 0xb7;
191: 
192:             require(
193:                 _in.length > lenOfStrLen,
194:                 "RLPReader: length of content must be > than length of string length (long string)"
195:             );
196: 
197:             bytes1 firstByteOfContent;
198:             assembly {
199:                 firstByteOfContent := and(mload(add(ptr, 1)), shl(248, 0xff))
200:             }
201: 
202:             require(
203:                 firstByteOfContent != 0x00,
204:                 "RLPReader: length of content must not have any leading zeros (long string)"
205:             );
206: 
207:             uint256 strLen;
208:             assembly {
209:                 strLen := shr(sub(256, mul(8, lenOfStrLen)), mload(add(ptr, 1)))
210:             }
211: 
212:             require(
213:                 strLen > 55,
214:                 "RLPReader: length of content must be greater than 55 bytes (long string)"
215:             );
216: 
217:             require(
218:                 _in.length > lenOfStrLen + strLen,
219:                 "RLPReader: length of content must be greater than total length (long string)"
220:             );
221: 
222:             return (1 + lenOfStrLen, strLen, RLPItemType.DATA_ITEM);
223:         } else if (prefix <= 0xf7) {
224:             // Short list.
225:             // slither-disable-next-line variable-scope
226:             uint256 listLen = prefix - 0xc0;
227: 
228:             require(
229:                 _in.length > listLen,
230:                 "RLPReader: length of content must be greater than list length (short list)"
231:             );
232: 
233:             return (1, listLen, RLPItemType.LIST_ITEM);
234:         } else {
235:             // Long list.
236:             uint256 lenOfListLen = prefix - 0xf7;
237: 
238:             require(
239:                 _in.length > lenOfListLen,
240:                 "RLPReader: length of content must be > than length of list length (long list)"
241:             );
242: 
243:             bytes1 firstByteOfContent;
244:             assembly {
245:                 firstByteOfContent := and(mload(add(ptr, 1)), shl(248, 0xff))
246:             }
247: 
248:             require(
249:                 firstByteOfContent != 0x00,
250:                 "RLPReader: length of content must not have any leading zeros (long list)"
251:             );
252: 
253:             uint256 listLen;
254:             assembly {
255:                 listLen := shr(sub(256, mul(8, lenOfListLen)), mload(add(ptr, 1)))
256:             }
257: 
258:             require(
259:                 listLen > 55,
260:                 "RLPReader: length of content must be greater than 55 bytes (long list)"
261:             );
262: 
263:             require(
264:                 _in.length > lenOfListLen + listLen,
265:                 "RLPReader: length of content must be greater than total length (long list)"
266:             );
267: 
268:             return (1 + lenOfListLen, listLen, RLPItemType.LIST_ITEM);
269:         }
270:     }
```
[144](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/rlp/RLPReader.sol#L144-L270)

```solidity
📁 File: contracts/thirdparty/optimism/rlp/RLPWriter.sol

/// @audit Lines: 14 to 18
13:     function writeBytes(bytes memory _in) internal pure returns (bytes memory out_) { 
14:         if (_in.length == 1 && uint8(_in[0]) < 128) {
15:             out_ = _in;
16:         } else {
17:             out_ = abi.encodePacked(_writeLength(_in.length, 128), _in);
18:         }
19:     }
```
[13](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/rlp/RLPWriter.sol#L13-L19)

```solidity
📁 File: contracts/thirdparty/optimism/trie/MerkleTrie.sol

/// @audit Lines: 155 to 204
/// @audit Lines: 184 to 196
68:     function get( 
69:         bytes memory _key,
70:         bytes[] memory _proof,
71:         bytes32 _root
72:     )
73:         internal
74:         pure
75:         returns (bytes memory value_)
76:     {
77:         require(_key.length > 0, "MerkleTrie: empty key");
78: 
79:         TrieNode[] memory proof = _parseProof(_proof);
80:         bytes memory key = Bytes.toNibbles(_key);
81:         bytes memory currentNodeID = abi.encodePacked(_root);
82:         uint256 currentKeyIndex = 0;
83: 
84:         // Proof is top-down, so we start at the first element (root).
85:         for (uint256 i = 0; i < proof.length; i++) {
86:             TrieNode memory currentNode = proof[i];
87: 
88:             // Key index should never exceed total key length or we'll be out of bounds.
89:             require(currentKeyIndex <= key.length, "MerkleTrie: key index exceeds total key length");
90: 
91:             if (currentKeyIndex == 0) {
92:                 // First proof element is always the root node.
93:                 require(
94:                     Bytes.equal(abi.encodePacked(keccak256(currentNode.encoded)), currentNodeID),
95:                     "MerkleTrie: invalid root hash"
96:                 );
97:             } else if (currentNode.encoded.length >= 32) {
98:                 // Nodes 32 bytes or larger are hashed inside branch nodes.
99:                 require(
100:                     Bytes.equal(abi.encodePacked(keccak256(currentNode.encoded)), currentNodeID),
101:                     "MerkleTrie: invalid large internal hash"
102:                 );
103:             } else {
104:                 // Nodes smaller than 32 bytes aren't hashed.
105:                 require(
106:                     Bytes.equal(currentNode.encoded, currentNodeID),
107:                     "MerkleTrie: invalid internal node hash"
108:                 );
109:             }
110: 
111:             if (currentNode.decoded.length == BRANCH_NODE_LENGTH) {
112:                 if (currentKeyIndex == key.length) {
113:                     // Value is the last element of the decoded list (for branch nodes). There's
114:                     // some ambiguity in the Merkle trie specification because bytes(0) is a
115:                     // valid value to place into the trie, but for branch nodes bytes(0) can exist
116:                     // even when the value wasn't explicitly placed there. Geth treats a value of
117:                     // bytes(0) as "key does not exist" and so we do the same.
118:                     value_ = RLPReader.readBytes(currentNode.decoded[TREE_RADIX]);
119:                     require(
120:                         value_.length > 0,
121:                         "MerkleTrie: value length must be greater than zero (branch)"
122:                     );
123: 
124:                     // Extra proof elements are not allowed.
125:                     require(
126:                         i == proof.length - 1,
127:                         "MerkleTrie: value node must be last node in proof (branch)"
128:                     );
129: 
130:                     return value_;
131:                 } else {
132:                     // We're not at the end of the key yet.
133:                     // Figure out what the next node ID should be and continue.
134:                     uint8 branchKey = uint8(key[currentKeyIndex]);
135:                     RLPReader.RLPItem memory nextNode = currentNode.decoded[branchKey];
136:                     currentNodeID = _getNodeID(nextNode);
137:                     currentKeyIndex += 1;
138:                 }
139:             } else if (currentNode.decoded.length == LEAF_OR_EXTENSION_NODE_LENGTH) {
140:                 bytes memory path = _getNodePath(currentNode);
141:                 uint8 prefix = uint8(path[0]);
142:                 uint8 offset = 2 - (prefix % 2);
143:                 bytes memory pathRemainder = Bytes.slice(path, offset);
144:                 bytes memory keyRemainder = Bytes.slice(key, currentKeyIndex);
145:                 uint256 sharedNibbleLength = _getSharedNibbleLength(pathRemainder, keyRemainder);
146: 
147:                 // Whether this is a leaf node or an extension node, the path remainder MUST be a
148:                 // prefix of the key remainder (or be equal to the key remainder) or the proof is
149:                 // considered invalid.
150:                 require(
151:                     pathRemainder.length == sharedNibbleLength,
152:                     "MerkleTrie: path remainder must share all nibbles with key"
153:                 );
154: 
155:                 if (prefix == PREFIX_LEAF_EVEN || prefix == PREFIX_LEAF_ODD) {
156:                     // Prefix of 2 or 3 means this is a leaf node. For the leaf node to be valid,
157:                     // the key remainder must be exactly equal to the path remainder. We already
158:                     // did the necessary byte comparison, so it's more efficient here to check that
159:                     // the key remainder length equals the shared nibble length, which implies
160:                     // equality with the path remainder (since we already did the same check with
161:                     // the path remainder and the shared nibble length).
162:                     require(
163:                         keyRemainder.length == sharedNibbleLength,
164:                         "MerkleTrie: key remainder must be identical to path remainder"
165:                     );
166: 
167:                     // Our Merkle Trie is designed specifically for the purposes of the Ethereum
168:                     // state trie. Empty values are not allowed in the state trie, so we can safely
169:                     // say that if the value is empty, the key should not exist and the proof is
170:                     // invalid.
171:                     value_ = RLPReader.readBytes(currentNode.decoded[1]);
172:                     require(
173:                         value_.length > 0,
174:                         "MerkleTrie: value length must be greater than zero (leaf)"
175:                     );
176: 
177:                     // Extra proof elements are not allowed.
178:                     require(
179:                         i == proof.length - 1,
180:                         "MerkleTrie: value node must be last node in proof (leaf)"
181:                     );
182: 
183:                     return value_;
184:                 } else if (prefix == PREFIX_EXTENSION_EVEN || prefix == PREFIX_EXTENSION_ODD) {
185:                     // Prefix of 0 or 1 means this is an extension node. We move onto the next node
186:                     // in the proof and increment the key index by the length of the path remainder
187:                     // which is equal to the shared nibble length.
188:                     currentNodeID = _getNodeID(currentNode.decoded[1]);
189:                     currentKeyIndex += sharedNibbleLength;
190:                 } else {
191:                     revert("MerkleTrie: received a node with an unknown prefix");
192:                 }
193:             } else {
194:                 revert("MerkleTrie: received an unparseable node");
195:             }
196:         }
197: 
198:         revert("MerkleTrie: ran out of proof elements");
199:     }
```
[68](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/trie/MerkleTrie.sol#L68-L199)

```solidity
📁 File: contracts/tokenvault/BaseVault.sol

/// @audit Lines: 68 to 71
/// @audit Lines: 68 to 71
/// @audit Lines: 68 to 71
32:     function init(address _owner, address _addressManager) external initializer { 
33:         __Essential_init(_owner, _addressManager);
34:     }
```
[32](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BaseVault.sol#L32-L34)

```solidity
📁 File: contracts/tokenvault/BridgedERC1155.sol

/// @audit Lines: 102 to 107
/// @audit Lines: 102 to 107
/// @audit Lines: 102 to 107
38:     function init( 
39:         address _owner,
40:         address _addressManager,
41:         address _srcToken,
42:         uint256 _srcChainId,
43:         string memory _symbol,
44:         string memory _name
45:     )
46:         external
47:         initializer
48:     {
49:         // Check if provided parameters are valid.
50:         // The symbol and the name can be empty for ERC1155 tokens so we use some placeholder data
51:         // for them instead.
52:         LibBridgedToken.validateInputs(_srcToken, _srcChainId, "foo", "foo");
53:         __Essential_init(_owner, _addressManager);
54:         __ERC1155_init(LibBridgedToken.buildURI(_srcToken, _srcChainId));
55: 
56:         srcToken = _srcToken;
57:         srcChainId = _srcChainId;
58:         __symbol = _symbol;
59:         __name = _name;
60:     }
```
[38](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC1155.sol#L38-L60)

```solidity
📁 File: contracts/tokenvault/BridgedERC20.sol

/// @audit Lines: 108 to 111
/// @audit Lines: 108 to 111
/// @audit Lines: 108 to 111
52:     function init( 
53:         address _owner,
54:         address _addressManager,
55:         address _srcToken,
56:         uint256 _srcChainId,
57:         uint8 _decimals,
58:         string memory _symbol,
59:         string memory _name
60:     )
61:         external
62:         initializer
63:     {
64:         // Check if provided parameters are valid
65:         LibBridgedToken.validateInputs(_srcToken, _srcChainId, _symbol, _name);
66:         __Essential_init(_owner, _addressManager);
67:         __ERC20_init(_name, _symbol);
68:         __ERC20Snapshot_init();
69:         __ERC20Votes_init();
70:         __ERC20Permit_init(_name);
71: 
72:         // Set contract properties
73:         srcToken = _srcToken;
74:         srcChainId = _srcChainId;
75:         __srcDecimals = _decimals;
76:     }

/// @audit Lines: 38 to 40
85:     function snapshot() external onlyOwnerOrSnapshooter { 
86:         _snapshot();
87:     }
```
[52](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC20.sol#L52-L76), [85](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC20.sol#L85-L87)

```solidity
📁 File: contracts/tokenvault/BridgedERC20Base.sol

/// @audit Lines: 45 to 50
/// @audit Lines: 35 to 37
36:     function changeMigrationStatus( 
37:         address _migratingAddress,
38:         bool _migratingInbound
39:     )
40:         external
41:         nonReentrant
42:         whenNotPaused
43:         onlyFromOwnerOrNamed("erc20_vault")
44:     {
45:         if (_migratingAddress == migratingAddress && _migratingInbound == migratingInbound) {
46:             revert BB_INVALID_PARAMS();
47:         }
48: 
49:         migratingAddress = _migratingAddress;
50:         migratingInbound = _migratingInbound;
51:         emit MigrationStatusChanged(_migratingAddress, _migratingInbound);
52:     }
```
[36](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC20Base.sol#L36-L52)

```solidity
📁 File: contracts/tokenvault/BridgedERC721.sol

/// @audit Lines: 104 to 108
/// @audit Lines: 104 to 108
/// @audit Lines: 104 to 108
31:     function init( 
32:         address _owner,
33:         address _addressManager,
34:         address _srcToken,
35:         uint256 _srcChainId,
36:         string memory _symbol,
37:         string memory _name
38:     )
39:         external
40:         initializer
41:     {
42:         // Check if provided parameters are valid
43:         LibBridgedToken.validateInputs(_srcToken, _srcChainId, _symbol, _name);
44:         __Essential_init(_owner, _addressManager);
45:         __ERC721_init(_name, _symbol);
46: 
47:         srcToken = _srcToken;
48:         srcChainId = _srcChainId;
49:     }
```
[31](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC721.sol#L31-L49)

```solidity
📁 File: contracts/tokenvault/ERC1155Vault.sol

/// @audit Lines: 108 to 110
93:     function onMessageInvocation(bytes calldata data) external payable nonReentrant whenNotPaused { 
94:         (
95:             CanonicalNFT memory ctoken,
96:             address from,
97:             address to,
98:             uint256[] memory tokenIds,
99:             uint256[] memory amounts
100:         ) = abi.decode(data, (CanonicalNFT, address, address, uint256[], uint256[]));
101: 
102:         // Check context validity
103:         // `onlyFromBridge` checked in checkProcessMessageContext
104:         IBridge.Context memory ctx = checkProcessMessageContext();
105: 
106:         // Don't allow sending to disallowed addresses.
107:         // Don't send the tokens back to `from` because `from` is on the source chain.
108:         if (to == address(0) || to == address(this)) revert VAULT_INVALID_TO();
109: 
110:         // Transfer the ETH and the tokens to the `to` address
111:         address token = _transferTokens(ctoken, to, tokenIds, amounts);
112:         to.sendEther(msg.value);
113: 
114:         emit TokenReceived({
115:             msgHash: ctx.msgHash,
116:             from: from,
117:             to: to,
118:             srcChainId: ctx.srcChainId,
119:             ctoken: ctoken.addr,
120:             token: token,
121:             tokenIds: tokenIds,
122:             amounts: amounts
123:         });
124:     }
```
[93](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC1155Vault.sol#L93-L124)

```solidity
📁 File: contracts/tokenvault/ERC20Vault.sol

/// @audit Lines: 158 to 161
/// @audit Lines: 174 to 179
/// @audit Lines: 174 to 179
148:     function changeBridgedToken( 
149:         CanonicalERC20 calldata _ctoken,
150:         address _btokenNew
151:     )
152:         external
153:         nonReentrant
154:         whenNotPaused
155:         onlyOwner
156:         returns (address btokenOld_)
157:     {
158:         if (_btokenNew == address(0) || bridgedToCanonical[_btokenNew].addr != address(0)) {
159:             revert VAULT_INVALID_NEW_BTOKEN();
160:         }
161: 
162:         if (btokenBlacklist[_btokenNew]) revert VAULT_BTOKEN_BLACKLISTED();
163: 
164:         if (IBridgedERC20(_btokenNew).owner() != owner()) {
165:             revert VAULT_NOT_SAME_OWNER();
166:         }
167: 
168:         btokenOld_ = canonicalToBridged[_ctoken.chainId][_ctoken.addr];
169: 
170:         if (btokenOld_ != address(0)) {
171:             CanonicalERC20 memory ctoken = bridgedToCanonical[btokenOld_];
172: 
173:             // The ctoken must match the saved one.
174:             if (
175:                 ctoken.decimals != _ctoken.decimals
176:                     || keccak256(bytes(ctoken.symbol)) != keccak256(bytes(_ctoken.symbol))
177:                     || keccak256(bytes(ctoken.name)) != keccak256(bytes(_ctoken.name))
178:             ) revert VAULT_CTOKEN_MISMATCH();
179: 
180:             delete bridgedToCanonical[_btokenNew];
181:             btokenBlacklist[btokenOld_] = true;
182: 
183:             // Start the migration
184:             IBridgedERC20(btokenOld_).changeMigrationStatus(_btokenNew, false);
185:             IBridgedERC20(_btokenNew).changeMigrationStatus(btokenOld_, true);
186:         }
187: 
188:         bridgedToCanonical[_btokenNew] = _ctoken;
189:         canonicalToBridged[_ctoken.chainId][_ctoken.addr] = _btokenNew;
190: 
191:         emit BridgedTokenChanged({
192:             srcChainId: _ctoken.chainId,
193:             ctoken: _ctoken.addr,
194:             btokenOld: btokenOld_,
195:             btokenNew: _btokenNew,
196:             ctokenSymbol: _ctoken.symbol,
197:             ctokenName: _ctoken.name,
198:             ctokenDecimal: _ctoken.decimals
199:         });
200:     }

/// @audit Lines: 267 to 269
253:     function onMessageInvocation(bytes calldata _data) 
254:         external
255:         payable
256:         nonReentrant
257:         whenNotPaused
258:     {
259:         (CanonicalERC20 memory ctoken, address from, address to, uint256 amount) =
260:             abi.decode(_data, (CanonicalERC20, address, address, uint256));
261: 
262:         // `onlyFromBridge` checked in checkProcessMessageContext
263:         IBridge.Context memory ctx = checkProcessMessageContext();
264: 
265:         // Don't allow sending to disallowed addresses.
266:         // Don't send the tokens back to `from` because `from` is on the source chain.
267:         if (to == address(0) || to == address(this)) revert VAULT_INVALID_TO();
268: 
269:         // Transfer the ETH and the tokens to the `to` address
270:         address token = _transferTokens(ctoken, to, amount);
271:         to.sendEther(msg.value);
272: 
273:         emit TokenReceived({
274:             msgHash: ctx.msgHash,
275:             from: from,
276:             to: to,
277:             srcChainId: ctx.srcChainId,
278:             ctoken: ctoken.addr,
279:             token: token,
280:             amount: amount
281:         });
282:     }
```
[148](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC20Vault.sol#L148-L200), [253](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC20Vault.sol#L253-L282)

```solidity
📁 File: contracts/tokenvault/ERC721Vault.sol

/// @audit Lines: 91 to 93
77:     function onMessageInvocation(bytes calldata _data) 
78:         external
79:         payable
80:         nonReentrant
81:         whenNotPaused
82:     {
83:         (CanonicalNFT memory ctoken, address from, address to, uint256[] memory tokenIds) =
84:             abi.decode(_data, (CanonicalNFT, address, address, uint256[]));
85: 
86:         // `onlyFromBridge` checked in checkProcessMessageContext
87:         IBridge.Context memory ctx = checkProcessMessageContext();
88: 
89:         // Don't allow sending to disallowed addresses.
90:         // Don't send the tokens back to `from` because `from` is on the source chain.
91:         if (to == address(0) || to == address(this)) revert VAULT_INVALID_TO();
92: 
93:         // Transfer the ETH and the tokens to the `to` address
94:         address token = _transferTokens(ctoken, to, tokenIds);
95:         to.sendEther(msg.value);
96: 
97:         emit TokenReceived({
98:             msgHash: ctx.msgHash,
99:             from: from,
100:             to: to,
101:             srcChainId: ctx.srcChainId,
102:             ctoken: ctoken.addr,
103:             token: token,
104:             tokenIds: tokenIds,
105:             amounts: new uint256[](tokenIds.length)
106:         });
107:     }
```
[77](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC721Vault.sol#L77-L107)

```solidity
📁 File: contracts/tokenvault/LibBridgedToken.sol

/// @audit Lines: 20 to 27
/// @audit Lines: 20 to 27
/// @audit Lines: 20 to 27
/// @audit Lines: 20 to 27
11:     function validateInputs( 
12:         address _srcToken,
13:         uint256 _srcChainId,
14:         string memory _symbol,
15:         string memory _name
16:     )
17:         internal
18:         view
19:     {
20:         if (
21:             _srcToken == address(0) || _srcChainId == 0 || _srcChainId == block.chainid
22:                 || bytes(_symbol).length == 0 || bytes(_name).length == 0
23:         ) {
24:             revert BTOKEN_INVALID_PARAMS();
25:         }
26:     }
```
[11](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/LibBridgedToken.sol#L11-L26)

```solidity
📁 File: contracts/tokenvault/adapters/USDCAdapter.sol

/// @audit Lines: 52 to 59
/// @audit Lines: 52 to 59
/// @audit Lines: 52 to 59
38:     function init(address _owner, address _addressManager, IUSDC _usdc) external initializer { 
39:         __Essential_init(_owner, _addressManager);
40:         usdc = _usdc;
41:     }
```
[38](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/adapters/USDCAdapter.sol#L38-L41)

```solidity
📁 File: contracts/verifiers/GuardianVerifier.sol

/// @audit Lines: 36 to 43
/// @audit Lines: 36 to 43
/// @audit Lines: 36 to 43
18:     function init(address _owner, address _addressManager) external initializer { 
19:         __Essential_init(_owner, _addressManager);
20:     }
```
[18](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/verifiers/GuardianVerifier.sol#L18-L20)

```solidity
📁 File: contracts/verifiers/SgxVerifier.sol

/// @audit Lines: 69 to 74
/// @audit Lines: 69 to 74
/// @audit Lines: 69 to 74
83:     function init(address _owner, address _addressManager) external initializer { 
84:         __Essential_init(_owner, _addressManager);
85:     }

/// @audit Lines: 35 to 37
100:     function deleteInstances(uint256[] calldata _ids) 
101:         external
102:         onlyFromOwnerOrNamed("rollup_watchdog")
103:     {
104:         for (uint256 i; i < _ids.length; ++i) {
105:             uint256 idx = _ids[i];
106: 
107:             if (instances[idx].addr == address(0)) revert SGX_INVALID_INSTANCE();
108: 
109:             emit InstanceDeleted(idx, instances[idx].addr);
110: 
111:             delete instances[idx];
112:         }
113:     }
```
[83](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/verifiers/SgxVerifier.sol#L83-L85), [100](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/verifiers/SgxVerifier.sol#L100-L113)

</details>


---
### [GAS&#x2011;62] Splitting `require()` statements that use `&&` saves gas
See [this issue](https://github.com/code-423n4/2022-01-xdefi-findings/issues/128) which describes the fact that there is a larger deployment gas cost, but with enough runtime calls, the change ends up being cheaper by **3 gas**


Gas saved per Instance: ~3 *(Total: ~12)*
<details>
<summary><i>There are 4 instances of this issue:</i></summary>

```solidity
📁 File: contracts/automata-attestation/lib/QuoteV3Auth/V3Parser.sol

77:         require( 
78:             localEnclaveReport.reserved3.length == 96 && localEnclaveReport.reserved4.length == 60
79:                 && localEnclaveReport.reportData.length == 64,
80:             "local QE report has wrong length"
81:         );
82:         require(
83:             pckSignedQeReport.reserved3.length == 96 && pckSignedQeReport.reserved4.length == 60
84:                 && pckSignedQeReport.reportData.length == 64,
85:             "QE report has wrong length"
86:         );

94:         require( 
95:             v3Quote.v3AuthData.ecdsa256BitSignature.length == 64
96:                 && v3Quote.v3AuthData.ecdsaAttestationKey.length == 64
97:                 && v3Quote.v3AuthData.qeReportSignature.length == 64,
98:             "Invalid ECDSA signature format"
99:         );
```
[77](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/QuoteV3Auth/V3Parser.sol#L77-L86), [94](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/QuoteV3Auth/V3Parser.sol#L94-L99)

```solidity
📁 File: contracts/automata-attestation/utils/BytesUtils.sol

335:             require(char >= 0x30 && char <= 0x7A, "invalid char"); 
```
[335](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/BytesUtils.sol#L335)

</details>


---
### [GAS&#x2011;63] Splitting `revert()` statements saves gas
Splitting the conditions into two separate checks [saves](https://gist.github.com/IllIllI000/7e25b0fca6bd9d57d9b9bcb9d2018959) 2 **gas**


Gas saved per Instance: ~2 *(Total: ~10)*
<details>
<summary><i>There are 5 instances of this issue:</i></summary>

```solidity
📁 File: contracts/team/airdrop/MerkleClaimable.sol

34:         if ( 
35:             merkleRoot == 0x0 || claimStart == 0 || claimEnd == 0 || claimStart > block.timestamp
36:                 || claimEnd < block.timestamp
37:         ) revert CLAIM_NOT_ONGOING();
```
[34](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/airdrop/MerkleClaimable.sol#L34-L37)

```solidity
📁 File: contracts/tokenvault/ERC1155Vault.sol

108:         if (to == address(0) || to == address(this)) revert VAULT_INVALID_TO(); 
```
[108](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC1155Vault.sol#L108)

```solidity
📁 File: contracts/tokenvault/ERC20Vault.sol

174:             if ( 
175:                 ctoken.decimals != _ctoken.decimals
176:                     || keccak256(bytes(ctoken.symbol)) != keccak256(bytes(_ctoken.symbol))
177:                     || keccak256(bytes(ctoken.name)) != keccak256(bytes(_ctoken.name))
178:             ) revert VAULT_CTOKEN_MISMATCH();

267:         if (to == address(0) || to == address(this)) revert VAULT_INVALID_TO(); 
```
[174](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC20Vault.sol#L174-L178), [267](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC20Vault.sol#L267)

```solidity
📁 File: contracts/tokenvault/ERC721Vault.sol

91:         if (to == address(0) || to == address(this)) revert VAULT_INVALID_TO(); 
```
[91](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC721Vault.sol#L91)

</details>


---
### [GAS&#x2011;64] Stack variable is only used once
If the variable is only accessed once, it's cheaper to use the assigned value directly that one time, and save the 3 gas the extra stack assignment would spend.


Gas saved per Instance: ~3 *(Total: ~411)*
<details>
<summary><i>There are 137 instances of this issue:</i></summary>

```solidity
📁 File: contracts/L1/TaikoL1.sol

94:         uint8 maxBlocksToVerify = LibProving.proveBlock(state, config, this, meta, tran, proof); 
```
[94](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/TaikoL1.sol#L94)

```solidity
📁 File: contracts/L1/hooks/AssignmentHook.sol

94:         bytes32 hash = hashAssignment(assignment, taikoL1Address, _meta.blobHash); 

101:         IERC20 tko = IERC20(resolve("taiko_token", false)); 
```
[94](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/hooks/AssignmentHook.sol#L94), [101](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/hooks/AssignmentHook.sol#L101)

```solidity
📁 File: contracts/L1/libs/LibDepositing.sol

45:         uint256 slot = _state.slotA.numEthDeposits % _config.ethDepositRingBufferSize; 
```
[45](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibDepositing.sol#L45)

```solidity
📁 File: contracts/L1/libs/LibProposing.sol

238:             uint256 tkoBalance = tko.balanceOf(address(this)); 
```
[238](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProposing.sol#L238)

```solidity
📁 File: contracts/L1/libs/LibProving.sol

164:                 bool isContesting = _proof.tier == ts.tier && tier.contestBond != 0; 

166:                 IVerifier.Context memory ctx = IVerifier.Context({ 

192:             bool returnLivenessBond = blk.livenessBond > 0 && _proof.data.length == 32 

414:         bool inProvingWindow = uint256(_ts.timestamp).max(_state.slotB.lastUnpausedAt) 
```
[164](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProving.sol#L164), [166](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProving.sol#L166), [192](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProving.sol#L192), [414](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProving.sol#L414)

```solidity
📁 File: contracts/L1/libs/LibVerifying.sol

188:                 IERC20 tko = IERC20(_resolver.resolve("taiko_token", false)); 
```
[188](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibVerifying.sol#L188)

```solidity
📁 File: contracts/L2/TaikoL2.sol

136:         Config memory config = getConfig(); 
```
[136](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/TaikoL2.sol#L136)

```solidity
📁 File: contracts/automata-attestation/AutomataDcapV3Attestation.sol

163:         bytes memory retData = abi.encodePacked(INVALID_EXIT_CODE); 

181:         bool miscselectMatched = 

184:         bool attributesMatched = 

186:         bool mrsignerMatched = quoteEnclaveReport.mrSigner == enclaveId.mrsigner; 

188:         bool isvprodidMatched = quoteEnclaveReport.isvProdId == enclaveId.isvprodid; 

216:             bool pceSvnIsHigherOrGreater = pck.sgxExtension.pcesvn >= current.pcesvn; 
217:             bool cpuSvnsAreHigherOrGreater = _isCpuSvnHigherOrGreater(

222:                 bool tcbIsRevoked = status == TCBInfoStruct.TCBStatus.TCB_REVOKED; 

292:             bytes32 issuerPubKeyHash = keccak256(issuer.pubKey); 

313:         bytes32 expectedAuthDataHash = bytes32(qeEnclaveReport.reportData.substring(0, 32)); 
314:         bytes memory concatOfAttestKeyAndQeAuthData =

316:         bytes32 computedAuthDataHash = sha256(concatOfAttestKeyAndQeAuthData); 

318:         bool qeReportDataIsValid = expectedAuthDataHash == computedAuthDataHash; 

320:             bytes memory pckSignedQeReportBytes = 

322:             bool qeSigVerified = sigVerifyLib.verifyES256Signature( 

325:             bool quoteSigVerified = sigVerifyLib.verifyES256Signature( 

387:                 bool mrEnclaveIsTrusted = 

389:                 bool mrSignerIsTrusted = _trustedUserMrSigner[v3quote.localEnclaveReport.mrSigner]; 

421:                 bool isPckCert = i == 0; // additional parsing for PCKCert 

437:             bool tcbConfigured = LibString.eq(parsedFmspc, fetchedTcbInfo.fmspc); 

442:             IPEMCertChainLib.ECSha256Certificate memory pckCert = parsedQuoteCerts[0]; 
443:             bool pceidMatched = LibString.eq(pckCert.pck.sgxExtension.pceid, fetchedTcbInfo.pceid);

463:             bool pckCertChainVerified = _verifyCertChain(parsedQuoteCerts); 

471:             bool enclaveReportSigsVerified = _enclaveReportSigVerification( 
```
[163](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/AutomataDcapV3Attestation.sol#L163), [181](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/AutomataDcapV3Attestation.sol#L181), [184](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/AutomataDcapV3Attestation.sol#L184), [186](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/AutomataDcapV3Attestation.sol#L186), [188](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/AutomataDcapV3Attestation.sol#L188), [216](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/AutomataDcapV3Attestation.sol#L216-L217), [222](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/AutomataDcapV3Attestation.sol#L222), [292](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/AutomataDcapV3Attestation.sol#L292), [313](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/AutomataDcapV3Attestation.sol#L313-L314), [316](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/AutomataDcapV3Attestation.sol#L316), [318](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/AutomataDcapV3Attestation.sol#L318), [320](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/AutomataDcapV3Attestation.sol#L320), [322](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/AutomataDcapV3Attestation.sol#L322), [325](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/AutomataDcapV3Attestation.sol#L325), [387](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/AutomataDcapV3Attestation.sol#L387), [389](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/AutomataDcapV3Attestation.sol#L389), [421](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/AutomataDcapV3Attestation.sol#L421), [437](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/AutomataDcapV3Attestation.sol#L437), [442](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/AutomataDcapV3Attestation.sol#L442-L443), [463](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/AutomataDcapV3Attestation.sol#L463), [471](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/AutomataDcapV3Attestation.sol#L471)

```solidity
📁 File: contracts/automata-attestation/lib/PEMCertChainLib.sol

52:         uint256 len = pemChain.length; 

82:         uint256 root = der.root(); 

107:             bytes memory serialNumBytes = der.bytesAt(tbsPtr); 

120:             bool issuerNameIsValid = LibString.eq(cert.pck.issuerName, PLATFORM_ISSUER_NAME) 

174:             bytes memory sigX = _trimBytes(der.bytesAt(sigPtr), 32); 

177:             bytes memory sigY = _trimBytes(der.bytesAt(sigPtr), 32); 

225:         bool headerFound = beginPos != LibString.NOT_FOUND; 
226:         bool footerFound = endPos != LibString.NOT_FOUND;

233:         uint256 contentStart = beginPos + HEADER_LENGTH; 

239:         bytes memory delimiter = hex"0a"; 
240:         string memory contentSlice = LibString.slice(pemData, contentStart, endPos);

265:         uint256 lengthDiff = n - expectedLength; 

312:                         uint256 pceidPtr = der.nextSiblingOf(extnValueOidPtr); 

318:                         uint256 fmspcPtr = der.nextSiblingOf(extnValueOidPtr); 

350:         uint256 tcbPtr = der.nextSiblingOf(oidPtr); 

356:             uint256 svnValuePtr = der.nextSiblingOf(svnPtr); // value 

366:                 uint256 cpusvn = uint256(svnValue); 
```
[52](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/PEMCertChainLib.sol#L52), [82](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/PEMCertChainLib.sol#L82), [107](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/PEMCertChainLib.sol#L107), [120](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/PEMCertChainLib.sol#L120), [174](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/PEMCertChainLib.sol#L174), [177](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/PEMCertChainLib.sol#L177), [225](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/PEMCertChainLib.sol#L225-L226), [233](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/PEMCertChainLib.sol#L233), [239](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/PEMCertChainLib.sol#L239-L240), [265](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/PEMCertChainLib.sol#L265), [312](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/PEMCertChainLib.sol#L312), [318](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/PEMCertChainLib.sol#L318), [350](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/PEMCertChainLib.sol#L350), [356](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/PEMCertChainLib.sol#L356), [366](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/PEMCertChainLib.sol#L366)

```solidity
📁 File: contracts/automata-attestation/lib/QuoteV3Auth/V3Parser.sol

38:         bytes memory rawHeader = quote.substring(0, 48); 

51:         bytes memory rawLocalEnclaveReport = quote.substring(48, 384); 
52:         V3Struct.EnclaveReport memory localEnclaveReport = parseEnclaveReport(rawLocalEnclaveReport);

106:         uint32 totalQuoteSize = 48 // header 

119:         bytes memory headerBytes = abi.encodePacked( 

155:             uint256 upperDigit = digits / 16; 
156:             uint256 lowerDigit = digits % 16;

224:         bytes memory certData = rawAuthData.substring(offset, cert.certDataSize); 

229:         bytes memory rawQeReport = rawAuthData.substring(128, 384); 

249:         uint16 isvProdIdPackBE = (enclaveReport.isvProdId >> 8) | (enclaveReport.isvProdId << 8); 
250:         uint16 isvSvnPackBE = (enclaveReport.isvSvn >> 8) | (enclaveReport.isvSvn << 8);

275:         IPEMCertChainLib pemCertLib = PEMCertChainLib(pemCertLibAddr); 
276:         IPEMCertChainLib.ECSha256Certificate[] memory parsedQuoteCerts;
```
[38](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/QuoteV3Auth/V3Parser.sol#L38), [51](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/QuoteV3Auth/V3Parser.sol#L51-L52), [106](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/QuoteV3Auth/V3Parser.sol#L106), [119](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/QuoteV3Auth/V3Parser.sol#L119), [155](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/QuoteV3Auth/V3Parser.sol#L155-L156), [224](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/QuoteV3Auth/V3Parser.sol#L224), [229](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/QuoteV3Auth/V3Parser.sol#L229), [249](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/QuoteV3Auth/V3Parser.sol#L249-L250), [275](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/QuoteV3Auth/V3Parser.sol#L275-L276)

```solidity
📁 File: contracts/automata-attestation/utils/Asn1Decode.sol

183:         uint256 valueLength = ptr.ixl() + 1 - ptr.ixf(); 
```
[183](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/Asn1Decode.sol#L183)

```solidity
📁 File: contracts/automata-attestation/utils/BytesUtils.sol

73:         uint256 selfptr; 
74:         uint256 otherptr;

295:         bytes memory ret = new bytes(len); 
296:         uint256 dest;
297:         uint256 src;
```
[73](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/BytesUtils.sol#L73-L74), [295](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/BytesUtils.sol#L295-L297)

```solidity
📁 File: contracts/automata-attestation/utils/RsaVerify.sol

93:         bytes memory input = 

241:         bytes memory input = 
```
[93](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/RsaVerify.sol#L93), [241](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/RsaVerify.sol#L241)

```solidity
📁 File: contracts/automata-attestation/utils/SigVerifyLib.sol

89:         bytes memory exponent = publicKey.substring(0, 3); 
90:         bytes memory modulus = publicKey.substring(3, publicKey.length - 3);

106:         bytes memory exponent = publicKey.substring(0, 3); 
107:         bytes memory modulus = publicKey.substring(3, publicKey.length - 3);

126:         uint256 r = uint256(bytes32(signature.substring(0, 32))); 
127:         uint256 s = uint256(bytes32(signature.substring(32, 32)));

132:         uint256 gx = uint256(bytes32(publicKey.substring(0, 32))); 
133:         uint256 gy = uint256(bytes32(publicKey.substring(32, 32)));

136:         bytes memory args = abi.encode(sha256(tbs), r, s, gx, gy); 
```
[89](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/SigVerifyLib.sol#L89-L90), [106](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/SigVerifyLib.sol#L106-L107), [126](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/SigVerifyLib.sol#L126-L127), [132](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/SigVerifyLib.sol#L132-L133), [136](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/SigVerifyLib.sol#L136)

```solidity
📁 File: contracts/bridge/Bridge.sol

89:         uint64 _timestamp = _suspend ? type(uint64).max : uint64(block.timestamp); 

138:         uint256 expectedAmount = _message.value + _message.fee; 

178:             bytes32 failureSignal = signalForFailedMessage(msgHash); 

280:                 uint256 gasLimit = msg.sender == _message.destOwner ? gasleft() : _message.gasLimit; 

557:             bytes32 msgHash; 
558:             address from;
559:             uint64 srcChainId;

587:         bytes memory data = abi.encodeCall( 
```
[89](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/Bridge.sol#L89), [138](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/Bridge.sol#L138), [178](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/Bridge.sol#L178), [280](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/Bridge.sol#L280), [557](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/Bridge.sol#L557-L559), [587](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/Bridge.sol#L587)

```solidity
📁 File: contracts/libs/Lib4844.sol

51:         bytes32 first; 
52:         bytes32 second;
```
[51](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/libs/Lib4844.sol#L51-L52)

```solidity
📁 File: contracts/libs/LibAddress.sol

56:         try IERC165(_addr).supportsInterface(_interfaceId) returns (bool _result) { 
```
[56](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/libs/LibAddress.sol#L56)

```solidity
📁 File: contracts/libs/LibTrieProof.sol

52:             RLPReader.RLPItem[] memory accountState = RLPReader.readList(rlpAccount); 

60:         bool verified = SecureMerkleTrie.verifyInclusionProof( 
```
[52](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/libs/LibTrieProof.sol#L52), [60](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/libs/LibTrieProof.sol#L60)

```solidity
📁 File: contracts/signal/SignalService.sol

107:             bytes32 signalRoot = _verifyHopProof(chainId, app, signal, value, hop, signalService); 

124:             bytes32 kind = isFullProof ? LibSignals.STATE_ROOT : LibSignals.SIGNAL_ROOT; 

148:         bytes32 signal = signalForChainData(_chainId, _kind, _blockId); 

170:             bytes32 signal = signalForChainData(_chainId, _kind, blockId_); 

282:         bool cacheStateRoot = _hop.cacheOption == CacheOption.CACHE_BOTH 

290:         bool cacheSignalRoot = _hop.cacheOption == CacheOption.CACHE_BOTH 
```
[107](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/signal/SignalService.sol#L107), [124](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/signal/SignalService.sol#L124), [148](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/signal/SignalService.sol#L148), [170](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/signal/SignalService.sol#L170), [282](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/signal/SignalService.sol#L282), [290](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/signal/SignalService.sol#L290)

```solidity
📁 File: contracts/team/TimelockTokenPool.sol

151:         Recipient storage r = recipients[_recipient]; 

170:         bytes32 hash = keccak256(abi.encodePacked("Withdraw unlocked Taiko token to: ", _to)); 
171:         address recipient = ECDSA.recover(hash, _sig);

197:         uint128 _amountUnlocked = amountUnlocked / 1e18; // divide first 
```
[151](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/TimelockTokenPool.sol#L151), [170](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/TimelockTokenPool.sol#L170-L171), [197](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/TimelockTokenPool.sol#L197)

```solidity
📁 File: contracts/team/airdrop/ERC20Airdrop2.sol

117:         uint256 timeBasedAllowance = balance 
```
[117](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/airdrop/ERC20Airdrop2.sol#L117)

```solidity
📁 File: contracts/thirdparty/nomad-xyz/ExcessivelySafeCall.sol

37:         bool _success; 
38:         bytes memory _returnData = new bytes(_maxCopy);
```
[37](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/nomad-xyz/ExcessivelySafeCall.sol#L37-L38)

```solidity
📁 File: contracts/thirdparty/optimism/Bytes.sol

30:         bytes memory tempBytes; 

103:         bytes memory _nibbles; 
```
[30](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/Bytes.sol#L30), [103](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/Bytes.sol#L103)

```solidity
📁 File: contracts/thirdparty/optimism/rlp/RLPReader.sol

42:         MemoryPointer ptr; 
```
[42](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/rlp/RLPReader.sol#L42)

```solidity
📁 File: contracts/thirdparty/optimism/trie/MerkleTrie.sol

134:                     uint8 branchKey = uint8(key[currentKeyIndex]); 
135:                     RLPReader.RLPItem memory nextNode = currentNode.decoded[branchKey];

142:                 uint8 offset = 2 - (prefix % 2); 
```
[134](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/trie/MerkleTrie.sol#L134-L135), [142](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/trie/MerkleTrie.sol#L142)

```solidity
📁 File: contracts/thirdparty/optimism/trie/SecureMerkleTrie.sol

29:         bytes memory key = _getSecureKey(_key); 

47:         bytes memory key = _getSecureKey(_key); 
```
[29](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/trie/SecureMerkleTrie.sol#L29), [47](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/trie/SecureMerkleTrie.sol#L47)

```solidity
📁 File: contracts/tokenvault/BaseVault.sol

54:         address selfOnSourceChain = resolve(ctx_.srcChainId, name(), false); 
```
[54](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BaseVault.sol#L54)

```solidity
📁 File: contracts/tokenvault/ERC1155Vault.sol

58:         IBridge.Message memory message = IBridge.Message({ 

111:         address token = _transferTokens(ctoken, to, tokenIds, amounts); 

140:         (bytes memory data) = abi.decode(message.data[4:], (bytes)); 

145:         address token = _transferTokens(ctoken, message.srcOwner, tokenIds, amounts); 

263:                 try t.name() returns (string memory _name) { 

266:                 try t.symbol() returns (string memory _symbol) { 

304:         bytes memory data = abi.encodeCall( 
```
[58](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC1155Vault.sol#L58), [111](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC1155Vault.sol#L111), [140](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC1155Vault.sol#L140), [145](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC1155Vault.sol#L145), [263](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC1155Vault.sol#L263), [266](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC1155Vault.sol#L266), [304](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC1155Vault.sol#L304)

```solidity
📁 File: contracts/tokenvault/ERC20Vault.sol

221:         IBridge.Message memory message = IBridge.Message({ 

270:         address token = _transferTokens(ctoken, to, amount); 

298:         (bytes memory data) = abi.decode(_message.data[4:], (bytes)); 

303:         address token = _transferTokens(ctoken, _message.srcOwner, amount); 

378:             uint256 _balance = t.balanceOf(address(this)); 

408:         bytes memory data = abi.encodeCall( 
```
[221](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC20Vault.sol#L221), [270](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC20Vault.sol#L270), [298](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC20Vault.sol#L298), [303](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC20Vault.sol#L303), [378](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC20Vault.sol#L378), [408](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC20Vault.sol#L408)

```solidity
📁 File: contracts/tokenvault/ERC721Vault.sol

44:         IBridge.Message memory message = IBridge.Message({ 

94:         address token = _transferTokens(ctoken, to, tokenIds); 

123:         (bytes memory data) = abi.decode(_message.data[4:], (bytes)); 

128:         address token = _transferTokens(ctoken, _message.srcOwner, tokenIds); 

241:         bytes memory data = abi.encodeCall( 
```
[44](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC721Vault.sol#L44), [94](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC721Vault.sol#L94), [123](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC721Vault.sol#L123), [128](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC721Vault.sol#L128), [241](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC721Vault.sol#L241)

```solidity
📁 File: contracts/verifiers/SgxVerifier.sol

156:         bytes memory signature = Bytes.slice(_proof.data, 24); 

181:         address taikoL1 = resolve("taiko", false); 
```
[156](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/verifiers/SgxVerifier.sol#L156), [181](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/verifiers/SgxVerifier.sol#L181)

</details>


---
### [GAS&#x2011;65] State variable read in a loop
The state variable should be cached in and read from a local variable, or accumulated in a local variable then written to storage once outside of the loop, rather than reading/updating it on every iteration of the loop, which will replace each Gwarmaccess (**100 gas**) with a much cheaper stack read.


Gas saved per Instance: ~97 *(Total: ~776)*
<details>
<summary><i>There are 8 instances of this issue:</i></summary>

```solidity
📁 File: contracts/L1/provers/Guardians.sol

/// @audit guardianIds, guardians
74:         for (uint256 i; i < guardians.length; ++i) { 
75:             delete guardianIds[guardians[i]];
76:         }

/// @audit guardians, guardians
80:         for (uint256 i = 0; i < _newGuardians.length; ++i) { 
81:             address guardian = _newGuardians[i];
82:             if (guardian == address(0)) revert INVALID_GUARDIAN();
83:             // This makes sure there are not duplicate addresses
84:             if (guardianIds[guardian] != 0) revert INVALID_GUARDIAN_SET();
85: 
86:             // Save and index the guardian
87:             guardians.push(guardian);
88:             guardianIds[guardian] = guardians.length;
89:         }

/// @audit minGuardians
133:             for (uint256 i; i < guardiansLength; ++i) { 
134:                 if (bits & 1 == 1) ++count;
135:                 if (count == minGuardians) return true;
136:                 bits >>= 1;
137:             }
```
[74](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/provers/Guardians.sol#L74-L76), [80](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/provers/Guardians.sol#L80-L89), [133](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/provers/Guardians.sol#L133-L137)

```solidity
📁 File: contracts/automata-attestation/AutomataDcapV3Attestation.sol

/// @audit _serialNumIsRevoked, _serialNumIsRevoked
95:         for (uint256 i; i < serialNumBatch.length; ++i) { 
96:             if (!_serialNumIsRevoked[index][serialNumBatch[i]]) {
97:                 continue;
98:             }
99:             delete _serialNumIsRevoked[index][serialNumBatch[i]];
100:         }

/// @audit _serialNumIsRevoked, _serialNumIsRevoked
259:         for (uint256 i; i < n; ++i) { 
260:             IPEMCertChainLib.ECSha256Certificate memory issuer;
261:             if (i == n - 1) {
262:                 // rootCA
263:                 issuer = certs[i];
264:             } else {
265:                 issuer = certs[i + 1];
266:                 if (i == n - 2) {
267:                     // this cert is expected to be signed by the root
268:                     certRevoked = _serialNumIsRevoked[uint256(IPEMCertChainLib.CRL.ROOT)][certs[i]
269:                         .serialNumber];
270:                 } else if (certs[i].isPck) {
271:                     certRevoked = _serialNumIsRevoked[uint256(IPEMCertChainLib.CRL.PCK)][certs[i]
272:                         .serialNumber];
273:                 }
274:                 if (certRevoked) {
275:                     break;
276:                 }
277:             }
278: 
279:             certNotExpired =
280:                 block.timestamp > certs[i].notBefore && block.timestamp < certs[i].notAfter;
281:             if (!certNotExpired) {
282:                 break;
283:             }
284: 
285:             verified = sigVerifyLib.verifyES256Signature(
286:                 certs[i].tbsCertificate, certs[i].signature, issuer.pubKey
287:             );
288:             if (!verified) {
289:                 break;
290:             }
291: 
292:             bytes32 issuerPubKeyHash = keccak256(issuer.pubKey);
293: 
294:             if (issuerPubKeyHash == ROOTCA_PUBKEY_HASH) {
295:                 certChainCanBeTrusted = true;
296:                 break;
297:             }
298:         }
```
[95](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/AutomataDcapV3Attestation.sol#L95-L100), [259](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/AutomataDcapV3Attestation.sol#L259-L298)

```solidity
📁 File: contracts/team/airdrop/ERC721Airdrop.sol

/// @audit vault, token
59:         for (uint256 i; i < tokenIds.length; ++i) { 
60:             IERC721(token).safeTransferFrom(vault, user, tokenIds[i]);
61:         }
```
[59](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/airdrop/ERC721Airdrop.sol#L59-L61)

```solidity
📁 File: contracts/verifiers/SgxVerifier.sol

/// @audit instances, instances, instances
104:         for (uint256 i; i < _ids.length; ++i) { 
105:             uint256 idx = _ids[i];
106: 
107:             if (instances[idx].addr == address(0)) revert SGX_INVALID_INSTANCE();
108: 
109:             emit InstanceDeleted(idx, instances[idx].addr);
110: 
111:             delete instances[idx];
112:         }

/// @audit validSince, validSince
210:         for (uint256 i; i < _instances.length; ++i) { 
211:             if (addressRegistered[_instances[i]]) revert SGX_ALREADY_ATTESTED();
212: 
213:             addressRegistered[_instances[i]] = true;
214: 
215:             if (_instances[i] == address(0)) revert SGX_INVALID_INSTANCE();
216: 
217:             instances[nextInstanceId] = Instance(_instances[i], validSince);
218:             ids[i] = nextInstanceId;
219: 
220:             emit InstanceAdded(nextInstanceId, _instances[i], address(0), validSince);
221: 
222:             nextInstanceId++;
223:         }
```
[104](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/verifiers/SgxVerifier.sol#L104-L112), [210](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/verifiers/SgxVerifier.sol#L210-L223)

</details>


---
### [GAS&#x2011;66] State variables can be reordered to fit into fewer storage slots
If variables occupying the same slot are both written the same function or by the constructor, avoids a separate Gsset (**20000 gas**). Reads of the variables can also be cheaper


Gas saved per Instance: ~20,000 *(Total: ~40,000)*
<details>
<summary><i>There are 2 instances of this issue:</i></summary>

```solidity
📁 File: contracts/automata-attestation/AutomataDcapV3Attestation.sol

/// @audit use this order: 
/// - _trustedUserMrEnclave,
/// - _trustedUserMrSigner,
/// - _serialNumIsRevoked,
/// - tcbInfo,
/// - qeIdentity,
/// - owner,
/// - _checkLocalEnclaveReport
/// @audit to save 1 storage slots, (before 7, after 6)
22: contract AutomataDcapV3Attestation is IAttestation { 
```
[22](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/AutomataDcapV3Attestation.sol#L22)

```solidity
📁 File: contracts/team/airdrop/ERC20Airdrop2.sol

/// @audit use this order: 
/// - claimedAmount,
/// - withdrawnAmount,
/// - __gap,
/// - token,
/// - withdrawalWindow,
/// - vault
/// @audit to save 1 storage slots, (before 6, after 5)
12: contract ERC20Airdrop2 is MerkleClaimable { 
```
[12](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/airdrop/ERC20Airdrop2.sol#L12)

</details>


---
### [GAS&#x2011;67] State variables only set in the constructor should be declared `immutable`
Avoids a Gsset (**20000 gas**) in the constructor, and replaces the first access in each transaction (Gcoldsload - **2100 gas**) and each access thereafter (Gwarmacces - **100 gas**) with a `PUSH32` (**3 gas**).

While `string`s are not value types, and therefore cannot be `immutable`/`constant` if not hard-coded outside of the constructor, the same behavior can be achieved by making the current contract `abstract` with `virtual` functions for the `string` accessors, and having a child contract override the functions with the hard-coded implementation-specific values.


Gas saved per Instance: ~2,097 *(Total: ~4,194)*
<details>
<summary><i>There are 2 instances of this issue:</i></summary>

```solidity
📁 File: contracts/automata-attestation/AutomataDcapV3Attestation.sol

52:     address public owner; 
```
[52](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/AutomataDcapV3Attestation.sol#L52)

```solidity
📁 File: contracts/automata-attestation/utils/SigVerifyLib.sol

18:     address private ES256VERIFIER; 
```
[18](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/SigVerifyLib.sol#L18)

</details>


---
### [GAS&#x2011;68] State variables should be cached in stack variables rather than re-reading them from storage
When performing multiple operations on a state variable in a function, it is recommended to cache it first. Either multiple reads or multiple writes to a state variable can save gas by caching it on the stack. Caching of a state variable replaces each Gwarmaccess (100 gas) with a much cheaper stack read. Other less obvious fixes/optimizations include having local memory caches of state variable structs, or having local caches of state variable contracts/addresses. *Saves 100 gas per instance*.


Gas saved per Instance: ~100 *(Total: ~6,000)*
<details>
<summary><i>There are 60 instances of this issue:</i></summary>

```solidity
📁 File: contracts/L1/TaikoL1.sol

/// @audit _initialized: 2 reads (2 in modifiers)
42:     function init( 
43:         address _owner,
44:         address _addressManager,
45:         bytes32 _genesisBlockHash
46:     )
47:         external
48:         initializer
49:     {

/// @audit state: 3 reads 
55:     function proposeBlock( 
56:         bytes calldata _params,
57:         bytes calldata _txList
58:     )
59:         external
60:         payable
61:         nonReentrant
62:         whenNotPaused
63:         returns (TaikoData.BlockMetadata memory meta_, TaikoData.EthDeposit[] memory deposits_)
64:     {

/// @audit state: 3 reads (1 in modifiers)
75:     function proveBlock( 
76:         uint64 _blockId,
77:         bytes calldata _input
78:     )
79:         external
80:         nonReentrant
81:         whenNotPaused
82:         whenProvingNotPaused
83:     {

/// @audit state: 2 reads (1 in modifiers)
100:     function verifyBlocks(uint64 _maxBlocksToVerify) 
101:         external
102:         nonReentrant
103:         whenNotPaused
104:         whenProvingNotPaused
105:     {

/// @audit state: 2 reads 
145:     function getBlock(uint64 _blockId) 
146:         public
147:         view
148:         returns (TaikoData.Block memory blk_, TaikoData.TransitionState memory ts_)
149:     {

/// @audit state: 2 reads 
176:     function getStateVariables() 
177:         public
178:         view
179:         returns (TaikoData.SlotA memory a_, TaikoData.SlotB memory b_)
180:     {
```
[42](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/TaikoL1.sol#L42-L49), [55](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/TaikoL1.sol#L55-L64), [75](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/TaikoL1.sol#L75-L83), [100](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/TaikoL1.sol#L100-L105), [145](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/TaikoL1.sol#L145-L149), [176](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/TaikoL1.sol#L176-L180)

```solidity
📁 File: contracts/L1/TaikoToken.sol

/// @audit _initialized: 2 reads (2 in modifiers)
25:     function init( 
26:         address _owner,
27:         string calldata _name,
28:         string calldata _symbol,
29:         address _recipient
30:     )
31:         public
32:         initializer
33:     {
```
[25](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/TaikoToken.sol#L25-L33)

```solidity
📁 File: contracts/L1/gov/TaikoGovernor.sol

/// @audit _initialized: 2 reads (2 in modifiers)
31:     function init( 
32:         address _owner,
33:         IVotesUpgradeable _token,
34:         TimelockControllerUpgradeable _timelock
35:     )
36:         external
37:         initializer
38:     {
```
[31](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/gov/TaikoGovernor.sol#L31-L38)

```solidity
📁 File: contracts/L1/gov/TaikoTimelockController.sol

/// @audit _initialized: 2 reads (2 in modifiers)
15:     function init(address _owner, uint256 _minDelay) external initializer { 
```
[15](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/gov/TaikoTimelockController.sol#L15)

```solidity
📁 File: contracts/L1/hooks/AssignmentHook.sol

/// @audit _initialized: 2 reads (2 in modifiers)
57:     function init(address _owner, address _addressManager) external initializer { 
```
[57](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/hooks/AssignmentHook.sol#L57)

```solidity
📁 File: contracts/L1/provers/GuardianProver.sol

/// @audit _initialized: 2 reads (2 in modifiers)
25:     function init(address _owner, address _addressManager) external initializer { 
```
[25](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/provers/GuardianProver.sol#L25)

```solidity
📁 File: contracts/L1/provers/Guardians.sol

/// @audit guardianIds: 2 reads 
/// @audit guardians: 5 reads 
/// @audit version: 2 reads 
53:     function setGuardians( 
54:         address[] memory _newGuardians,
55:         uint8 _minGuardians
56:     )
57:         external
58:         onlyOwner
59:         nonReentrant
60:     {

/// @audit _approvals: 2 reads 
/// @audit version: 2 reads 
111:     function approve(uint256 _operationId, bytes32 _hash) internal returns (bool approved_) { 
```
[53](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/provers/Guardians.sol#L53-L60), [111](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/provers/Guardians.sol#L111)

```solidity
📁 File: contracts/L1/tiers/DevnetTierProvider.sol

/// @audit _initialized: 2 reads (2 in modifiers)
15:     function init(address _owner) external initializer { 
```
[15](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/tiers/DevnetTierProvider.sol#L15)

```solidity
📁 File: contracts/L1/tiers/MainnetTierProvider.sol

/// @audit _initialized: 2 reads (2 in modifiers)
15:     function init(address _owner) external initializer { 
```
[15](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/tiers/MainnetTierProvider.sol#L15)

```solidity
📁 File: contracts/L1/tiers/TestnetTierProvider.sol

/// @audit _initialized: 2 reads (2 in modifiers)
15:     function init(address _owner) external initializer { 
```
[15](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/tiers/TestnetTierProvider.sol#L15)

```solidity
📁 File: contracts/L2/CrossChainOwned.sol

/// @audit nextTxId: 2 reads 
36:     function onMessageInvocation(bytes calldata _data) 
37:         external
38:         payable
39:         whenNotPaused
40:         onlyFromNamed("bridge")
41:     {
```
[36](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/CrossChainOwned.sol#L36-L41)

```solidity
📁 File: contracts/L2/TaikoL2.sol

/// @audit _initialized: 2 reads (2 in modifiers)
71:     function init( 
72:         address _owner,
73:         address _addressManager,
74:         uint64 _l1ChainId,
75:         uint64 _gasExcess
76:     )
77:         external
78:         initializer
79:     {

/// @audit gasExcess: 2 reads 
/// @audit lastSyncedBlock: 3 reads 
252:     function _calc1559BaseFee( 
253:         Config memory _config,
254:         uint64 _l1BlockId,
255:         uint32 _parentGasUsed
256:     )
257:         private
258:         view
259:         returns (uint256 basefee_, uint64 gasExcess_)
260:     {
```
[71](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/TaikoL2.sol#L71-L79), [252](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/TaikoL2.sol#L252-L260)

```solidity
📁 File: contracts/automata-attestation/AutomataDcapV3Attestation.sol

/// @audit _serialNumIsRevoked: 2 reads 
88:     function removeRevokedCertSerialNum( 
89:         uint256 index,
90:         bytes[] calldata serialNumBatch
91:     )
92:         external
93:         onlyOwner
94:     {

/// @audit _serialNumIsRevoked: 2 reads 
248:     function _verifyCertChain(IPEMCertChainLib.ECSha256Certificate[] memory certs) 
249:         private
250:         view
251:         returns (bool)
252:     {
```
[88](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/AutomataDcapV3Attestation.sol#L88-L94), [248](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/AutomataDcapV3Attestation.sol#L248-L252)

```solidity
📁 File: contracts/bridge/Bridge.sol

/// @audit _initialized: 2 reads (2 in modifiers)
75:     function init(address _owner, address _addressManager) external initializer { 

/// @audit proofReceipt: 2 reads 
155:     function recallMessage( 
156:         Message calldata _message,
157:         bytes calldata _proof
158:     )
159:         external
160:         nonReentrant
161:         whenNotPaused
162:         sameChain(_message.srcChainId)
163:     {

/// @audit proofReceipt: 3 reads 
217:     function processMessage( 
218:         Message calldata _message,
219:         bytes calldata _proof
220:     )
221:         external
222:         nonReentrant
223:         whenNotPaused
224:         sameChain(_message.destChainId)
225:     {
```
[75](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/Bridge.sol#L75), [155](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/Bridge.sol#L155-L163), [217](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/Bridge.sol#L217-L225)

```solidity
📁 File: contracts/common/AddressManager.sol

/// @audit _initialized: 2 reads (2 in modifiers)
30:     function init(address _owner) external initializer { 
```
[30](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/common/AddressManager.sol#L30)

```solidity
📁 File: contracts/common/AddressResolver.sol

/// @audit addressManager: 2 reads 
72:     function _resolve( 
73:         uint64 _chainId,
74:         bytes32 _name,
75:         bool _allowZeroAddress
76:     )
77:         private
78:         view
79:         returns (address payable addr_)
80:     {
```
[72](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/common/AddressResolver.sol#L72-L80)

```solidity
📁 File: contracts/signal/SignalService.sol

/// @audit _initialized: 2 reads (2 in modifiers)
48:     function init(address _owner, address _addressManager) external initializer { 
```
[48](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/signal/SignalService.sol#L48)

```solidity
📁 File: contracts/team/TimelockTokenPool.sol

/// @audit _initialized: 2 reads (2 in modifiers)
111:     function init( 
112:         address _owner,
113:         address _taikoToken,
114:         address _costToken,
115:         address _sharedVault
116:     )
117:         external
118:         initializer
119:     {

/// @audit sharedVault: 2 reads 
208:     function _withdraw(address _recipient, address _to) private { 
```
[111](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/TimelockTokenPool.sol#L111-L119), [208](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/TimelockTokenPool.sol#L208)

```solidity
📁 File: contracts/team/airdrop/ERC20Airdrop.sol

/// @audit _initialized: 2 reads (2 in modifiers)
27:     function init( 
28:         address _owner,
29:         uint64 _claimStart,
30:         uint64 _claimEnd,
31:         bytes32 _merkleRoot,
32:         address _token,
33:         address _vault
34:     )
35:         external
36:         initializer
37:     {

/// @audit token: 2 reads 
50:     function claimAndDelegate( 
51:         address user,
52:         uint256 amount,
53:         bytes32[] calldata proof,
54:         bytes calldata delegationData
55:     )
56:         external
57:         nonReentrant
58:     {
```
[27](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/airdrop/ERC20Airdrop.sol#L27-L37), [50](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/airdrop/ERC20Airdrop.sol#L50-L58)

```solidity
📁 File: contracts/team/airdrop/ERC20Airdrop2.sol

/// @audit _initialized: 2 reads (2 in modifiers)
54:     function init( 
55:         address _owner,
56:         uint64 _claimStart,
57:         uint64 _claimEnd,
58:         bytes32 _merkleRoot,
59:         address _token,
60:         address _vault,
61:         uint64 _withdrawalWindow
62:     )
63:         external
64:         initializer
65:     {

/// @audit claimEnd: 2 reads (2 in modifiers)
88:     function withdraw(address user) external ongoingWithdrawals { 

/// @audit withdrawalWindow: 2 reads 
/// @audit claimEnd: 3 reads 
104:     function getBalance(address user) 
105:         public
106:         view
107:         returns (uint256 balance, uint256 withdrawableAmount)
108:     {
```
[54](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/airdrop/ERC20Airdrop2.sol#L54-L65), [88](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/airdrop/ERC20Airdrop2.sol#L88), [104](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/airdrop/ERC20Airdrop2.sol#L104-L108)

```solidity
📁 File: contracts/team/airdrop/ERC721Airdrop.sol

/// @audit _initialized: 2 reads (2 in modifiers)
25:     function init( 
26:         address _owner,
27:         uint64 _claimStart,
28:         uint64 _claimEnd,
29:         bytes32 _merkleRoot,
30:         address _token,
31:         address _vault
32:     )
33:         external
34:         initializer
35:     {
```
[25](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/airdrop/ERC721Airdrop.sol#L25-L35)

```solidity
📁 File: contracts/team/airdrop/MerkleClaimable.sol

/// @audit merkleRoot: 2 reads (1 in modifiers)
/// @audit claimStart: 2 reads (2 in modifiers)
/// @audit claimEnd: 2 reads (2 in modifiers)
67:     function _verifyClaim(bytes memory data, bytes32[] calldata proof) internal ongoingClaim { 
```
[67](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/airdrop/MerkleClaimable.sol#L67)

```solidity
📁 File: contracts/tokenvault/BaseVault.sol

/// @audit _initialized: 2 reads (2 in modifiers)
32:     function init(address _owner, address _addressManager) external initializer { 
```
[32](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BaseVault.sol#L32)

```solidity
📁 File: contracts/tokenvault/BridgedERC1155.sol

/// @audit _initialized: 2 reads (2 in modifiers)
38:     function init( 
39:         address _owner,
40:         address _addressManager,
41:         address _srcToken,
42:         uint256 _srcChainId,
43:         string memory _symbol,
44:         string memory _name
45:     )
46:         external
47:         initializer
48:     {
```
[38](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC1155.sol#L38-L48)

```solidity
📁 File: contracts/tokenvault/BridgedERC20.sol

/// @audit _initialized: 2 reads (2 in modifiers)
52:     function init( 
53:         address _owner,
54:         address _addressManager,
55:         address _srcToken,
56:         uint256 _srcChainId,
57:         uint8 _decimals,
58:         string memory _symbol,
59:         string memory _name
60:     )
61:         external
62:         initializer
63:     {
```
[52](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC20.sol#L52-L63)

```solidity
📁 File: contracts/tokenvault/BridgedERC20Base.sol

/// @audit migratingAddress: 2 reads 
57:     function mint(address _account, uint256 _amount) public nonReentrant whenNotPaused { 

/// @audit migratingAddress: 2 reads 
75:     function burn(address _account, uint256 _amount) public nonReentrant whenNotPaused { 
```
[57](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC20Base.sol#L57), [75](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC20Base.sol#L75)

```solidity
📁 File: contracts/tokenvault/BridgedERC721.sol

/// @audit _initialized: 2 reads (2 in modifiers)
31:     function init( 
32:         address _owner,
33:         address _addressManager,
34:         address _srcToken,
35:         uint256 _srcChainId,
36:         string memory _symbol,
37:         string memory _name
38:     )
39:         external
40:         initializer
41:     {
```
[31](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC721.sol#L31-L41)

```solidity
📁 File: contracts/tokenvault/ERC1155Vault.sol

/// @audit bridgedToCanonical: 2 reads 
240:     function _handleMessage( 
241:         address _user,
242:         BridgeTransferOp memory _op
243:     )
244:         private
245:         returns (bytes memory msgData_, CanonicalNFT memory ctoken_)
246:     {
```
[240](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC1155Vault.sol#L240-L246)

```solidity
📁 File: contracts/tokenvault/ERC20Vault.sol

/// @audit bridgedToCanonical: 3 reads 
148:     function changeBridgedToken( 
149:         CanonicalERC20 calldata _ctoken,
150:         address _btokenNew
151:     )
152:         external
153:         nonReentrant
154:         whenNotPaused
155:         onlyOwner
156:         returns (address btokenOld_)
157:     {

/// @audit bridgedToCanonical: 2 reads 
348:     function _handleMessage( 
349:         address _user,
350:         address _token,
351:         address _to,
352:         uint256 _amount
353:     )
354:         private
355:         returns (bytes memory msgData_, CanonicalERC20 memory ctoken_, uint256 balanceChange_)
356:     {
```
[148](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC20Vault.sol#L148-L157), [348](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC20Vault.sol#L348-L356)

```solidity
📁 File: contracts/tokenvault/ERC721Vault.sol

/// @audit bridgedToCanonical: 2 reads 
187:     function _handleMessage( 
188:         address _user,
189:         BridgeTransferOp memory _op
190:     )
191:         private
192:         returns (bytes memory msgData_, CanonicalNFT memory ctoken_)
193:     {
```
[187](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC721Vault.sol#L187-L193)

```solidity
📁 File: contracts/tokenvault/adapters/USDCAdapter.sol

/// @audit _initialized: 2 reads (2 in modifiers)
38:     function init(address _owner, address _addressManager, IUSDC _usdc) external initializer { 

/// @audit usdc: 2 reads 
47:     function _burnToken(address _from, uint256 _amount) internal override { 
```
[38](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/adapters/USDCAdapter.sol#L38), [47](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/adapters/USDCAdapter.sol#L47)

```solidity
📁 File: contracts/verifiers/GuardianVerifier.sol

/// @audit _initialized: 2 reads (2 in modifiers)
18:     function init(address _owner, address _addressManager) external initializer { 
```
[18](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/verifiers/GuardianVerifier.sol#L18)

```solidity
📁 File: contracts/verifiers/SgxVerifier.sol

/// @audit _initialized: 2 reads (2 in modifiers)
83:     function init(address _owner, address _addressManager) external initializer { 

/// @audit instances: 3 reads 
100:     function deleteInstances(uint256[] calldata _ids) 
101:         external
102:         onlyFromOwnerOrNamed("rollup_watchdog")
103:     {

/// @audit nextInstanceId: 3 reads 
195:     function _addInstances( 
196:         address[] memory _instances,
197:         bool instantValid
198:     )
199:         private
200:         returns (uint256[] memory ids)
201:     {

/// @audit instances: 3 reads 
233:     function _isInstanceValid(uint256 id, address instance) private view returns (bool) { 
```
[83](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/verifiers/SgxVerifier.sol#L83), [100](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/verifiers/SgxVerifier.sol#L100-L103), [195](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/verifiers/SgxVerifier.sol#L195-L201), [233](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/verifiers/SgxVerifier.sol#L233)

</details>


---
### [GAS&#x2011;69] Struct can be reordered to fit into fewer storage slots
In Solidity, data type packing within struct variables is a recommended practice to optimize gas usage and efficiency in smart contracts.

This technique leverages the fact that Ethereum’s storage model stores variables in slots, with each slot offering a capacity of 32 bytes. When data types that consume less than 32 bytes, such as **uint8**, **bool**, or **address**, are declared individually, each occupies a whole storage slot. However, when these smaller variables are grouped into a struct, they can share a storage slot, resulting in a significant reduction in storage requirements and, by extension, gas costs.


Gas saved per Instance: ~20,000 *(Total: ~80,000)*
<details>
<summary><i>There are 4 instances of this issue:</i></summary>

```solidity
📁 File: contracts/L1/TaikoData.sol

/// @audit use this order:  ethDepositRingBufferSize, ethDepositGas, ethDepositMaxFee, livenessBond, blobAllowedForDA, blobReuseEnabled, blockSyncThreshold, blockMaxTxListBytes, blobExpiry, blockMaxGasLimit, ethDepositMinCountPerBlock, ethDepositMaxCountPerBlock, maxBlocksToVerifyPerProposal, blockMaxProposals, blockRingBufferSize, chainId, ethDepositMaxAmount, ethDepositMinAmount
/// @audit 1 storage slot(s) saved, (before 8, after 7)
10:     struct Config { 

/// @audit use this order:  extraData, blobHash, parentMetaHash, hookCalls, assignedProver, cacheBlobForReuse, txListByteOffset, txListByteSize, coinbase
/// @audit 1 storage slot(s) saved, (before 7, after 6)
78:     struct BlockParams { 
```
[10](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/TaikoData.sol#L10), [78](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/TaikoData.sol#L78)

```solidity
📁 File: contracts/automata-attestation/lib/QuoteV3Auth/V3Struct.sol

/// @audit use this order:  mrEnclave, reserved2, mrSigner, reserved3, reserved4, reportData, reserved1, isvProdId, isvSvn, miscSelect, cpuSvn, attributes
/// @audit 1 storage slot(s) saved, (before 10, after 9)
17:     struct EnclaveReport { 
```
[17](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/QuoteV3Auth/V3Struct.sol#L17)

```solidity
📁 File: contracts/team/TimelockTokenPool.sol

/// @audit use this order:  amount, grantPeriod, unlockPeriod, grantCliff, unlockStart, unlockCliff, grantStart, costPerToken
/// @audit 1 storage slot(s) saved, (before 4, after 3)
28:     struct Grant { 
```
[28](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/TimelockTokenPool.sol#L28)

</details>


---
### [GAS&#x2011;70] Structs can be assigned more efficiently
Rather defining the struct in a single line, it is more efficient to declare an empty struct and then assign each struct element individually. This can net quite a large gas saving of **130 per instance**.


Gas saved per Instance: ~130 *(Total: ~2,860)*
<details>
<summary><i>There are 22 instances of this issue:</i></summary>

```solidity
📁 File: contracts/L1/TaikoL1.sol

191:         return TaikoData.Config({ 
192:             chainId: 167_008,
193:             // Assume the block time is 3s, the protocol will allow ~1 month of
194:             // new blocks without any verification.
195:             blockMaxProposals: 864_000,
196:             blockRingBufferSize: 864_100,
197:             // Can be overridden by the tier config.
198:             maxBlocksToVerifyPerProposal: 10,
199:             blockMaxGasLimit: 15_000_000,
200:             // Each go-ethereum transaction has a size limit of 128KB,
201:             // and right now txList is still saved in calldata, so we set it
202:             // to 120KB.
203:             blockMaxTxListBytes: 120_000,
204:             blobExpiry: 24 hours,
205:             blobAllowedForDA: false,
206:             blobReuseEnabled: false,
207:             livenessBond: 250e18, // 250 Taiko token
208:             // ETH deposit related.
209:             ethDepositRingBufferSize: 1024,
210:             ethDepositMinCountPerBlock: 8,
211:             ethDepositMaxCountPerBlock: 32,
212:             ethDepositMinAmount: 1 ether,
213:             ethDepositMaxAmount: 10_000 ether,
214:             ethDepositGas: 21_000,
215:             ethDepositMaxFee: 1 ether / 10,
216:             blockSyncThreshold: 16
217:         });
```
[191](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/TaikoL1.sol#L191-L217)

```solidity
📁 File: contracts/L1/libs/LibDepositing.sol

51:             TaikoData.EthDeposit({ 
52:                 recipient: recipient_,
53:                 amount: uint96(msg.value),
54:                 id: _state.slotA.numEthDeposits
55:             })

88:                 deposits_[i] = TaikoData.EthDeposit({ 
89:                     recipient: address(uint160(data >> 96)),
90:                     amount: uint96(data),
91:                     id: j
92:                 });
```
[51](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibDepositing.sol#L51-L55), [88](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibDepositing.sol#L88-L92)

```solidity
📁 File: contracts/L1/libs/LibProposing.sol

121:             meta_ = TaikoData.BlockMetadata({ 
122:                 l1Hash: blockhash(block.number - 1),
123:                 difficulty: 0, // to be initialized below
124:                 blobHash: 0, // to be initialized below
125:                 extraData: params.extraData,
126:                 depositsHash: keccak256(abi.encode(deposits_)),
127:                 coinbase: params.coinbase,
128:                 id: b.numBlocks,
129:                 gasLimit: _config.blockMaxGasLimit,
130:                 timestamp: uint64(block.timestamp),
131:                 l1Height: uint64(block.number - 1),
132:                 txListByteOffset: 0, // to be initialized below
133:                 txListByteSize: 0, // to be initialized below
134:                 minTier: 0, // to be initialized below
135:                 blobUsed: _txList.length == 0,
136:                 parentMetaHash: parentMetaHash
137:             });

212:         TaikoData.Block memory blk = TaikoData.Block({ 
213:             metaHash: keccak256(abi.encode(meta_)),
214:             // Safeguard the liveness bond to ensure its preservation,
215:             // particularly in scenarios where it might be altered after the
216:             // block's proposal but before it has been proven or verified.
217:             livenessBond: _config.livenessBond,
218:             blockId: b.numBlocks,
219:             proposedAt: meta_.timestamp,
220:             proposedIn: uint64(block.number),
221:             // For a new block, the next transition ID is always 1, not 0.
222:             nextTransitionId: 1,
223:             // For unverified block, its verifiedTransitionId is always 0.
224:             verifiedTransitionId: 0,
225:             assignedProver: params.assignedProver
226:         });
```
[121](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProposing.sol#L121-L137), [212](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProposing.sol#L212-L226)

```solidity
📁 File: contracts/L1/libs/LibProving.sol

166:                 IVerifier.Context memory ctx = IVerifier.Context({ 
167:                     metaHash: blk.metaHash,
168:                     blobHash: _meta.blobHash,
169:                     // Separate msgSender to allow the prover to be any address in the future.
170:                     prover: msg.sender,
171:                     msgSender: msg.sender,
172:                     blockId: blk.blockId,
173:                     isContesting: isContesting,
174:                     blobUsed: _meta.blobUsed
175:                 });
```
[166](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProving.sol#L166-L175)

```solidity
📁 File: contracts/L1/tiers/DevnetTierProvider.sol

22:             return ITierProvider.Tier({ 
23:                 verifierName: "tier_optimistic",
24:                 validityBond: 250 ether, // TKO
25:                 contestBond: 500 ether, // TKO
26:                 cooldownWindow: 1440, //24 hours
27:                 provingWindow: 120, // 2 hours
28:                 maxBlocksToVerifyPerProof: 16
29:             });

33:             return ITierProvider.Tier({ 
34:                 verifierName: "tier_guardian",
35:                 validityBond: 0, // must be 0 for top tier
36:                 contestBond: 0, // must be 0 for top tier
37:                 cooldownWindow: 60, //1 hours
38:                 provingWindow: 2880, // 48 hours
39:                 maxBlocksToVerifyPerProof: 16
40:             });
```
[22](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/tiers/DevnetTierProvider.sol#L22-L29), [33](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/tiers/DevnetTierProvider.sol#L33-L40)

```solidity
📁 File: contracts/L1/tiers/MainnetTierProvider.sol

22:             return ITierProvider.Tier({ 
23:                 verifierName: "tier_sgx",
24:                 validityBond: 250 ether, // TKO
25:                 contestBond: 500 ether, // TKO
26:                 cooldownWindow: 1440, //24 hours
27:                 provingWindow: 60, // 1 hours
28:                 maxBlocksToVerifyPerProof: 8
29:             });

33:             return ITierProvider.Tier({ 
34:                 verifierName: "tier_sgx_zkvm",
35:                 validityBond: 500 ether, // TKO
36:                 contestBond: 1000 ether, // TKO
37:                 cooldownWindow: 1440, //24 hours
38:                 provingWindow: 240, // 4 hours
39:                 maxBlocksToVerifyPerProof: 4
40:             });

44:             return ITierProvider.Tier({ 
45:                 verifierName: "tier_guardian",
46:                 validityBond: 0, // must be 0 for top tier
47:                 contestBond: 0, // must be 0 for top tier
48:                 cooldownWindow: 60, //1 hours
49:                 provingWindow: 2880, // 48 hours
50:                 maxBlocksToVerifyPerProof: 16
51:             });
```
[22](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/tiers/MainnetTierProvider.sol#L22-L29), [33](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/tiers/MainnetTierProvider.sol#L33-L40), [44](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/tiers/MainnetTierProvider.sol#L44-L51)

```solidity
📁 File: contracts/L1/tiers/TestnetTierProvider.sol

22:             return ITierProvider.Tier({ 
23:                 verifierName: "tier_optimistic",
24:                 validityBond: 250 ether, // TKO
25:                 contestBond: 500 ether, // TKO
26:                 cooldownWindow: 1440, //24 hours
27:                 provingWindow: 30, // 0.5 hours
28:                 maxBlocksToVerifyPerProof: 12
29:             });

33:             return ITierProvider.Tier({ 
34:                 verifierName: "tier_sgx",
35:                 validityBond: 500 ether, // TKO
36:                 contestBond: 1000 ether, // TKO
37:                 cooldownWindow: 1440, //24 hours
38:                 provingWindow: 60, // 1 hours
39:                 maxBlocksToVerifyPerProof: 8
40:             });

44:             return ITierProvider.Tier({ 
45:                 verifierName: "tier_guardian",
46:                 validityBond: 0, // must be 0 for top tier
47:                 contestBond: 0, // must be 0 for top tier
48:                 cooldownWindow: 60, //1 hours
49:                 provingWindow: 2880, // 48 hours
50:                 maxBlocksToVerifyPerProof: 16
51:             });
```
[22](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/tiers/TestnetTierProvider.sol#L22-L29), [33](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/tiers/TestnetTierProvider.sol#L33-L40), [44](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/tiers/TestnetTierProvider.sol#L44-L51)

```solidity
📁 File: contracts/automata-attestation/lib/QuoteV3Auth/V3Parser.sol

54:         v3ParsedQuote = V3Struct.ParsedV3QuoteStruct({ 
55:             header: header,
56:             localEnclaveReport: localEnclaveReport,
57:             v3AuthData: authDataV3
58:         });

190:         header = V3Struct.Header({ 
191:             version: version,
192:             attestationKeyType: attestationKeyType,
193:             teeType: teeType,
194:             qeSvn: bytes2(rawHeader.substring(8, 2)),
195:             pceSvn: bytes2(rawHeader.substring(10, 2)),
196:             qeVendorId: qeVendorId,
197:             userData: bytes20(rawHeader.substring(28, 20))
198:         });
```
[54](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/QuoteV3Auth/V3Parser.sol#L54-L58), [190](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/QuoteV3Auth/V3Parser.sol#L190-L198)

```solidity
📁 File: contracts/tokenvault/ERC1155Vault.sol

58:         IBridge.Message memory message = IBridge.Message({ 
59:             id: 0, // will receive a new value
60:             from: address(0), // will receive a new value
61:             srcChainId: 0, // will receive a new value
62:             destChainId: _op.destChainId,
63:             srcOwner: msg.sender,
64:             destOwner: _op.destOwner != address(0) ? _op.destOwner : msg.sender,
65:             to: resolve(_op.destChainId, name(), false),
66:             refundTo: _op.refundTo,
67:             value: msg.value - _op.fee,
68:             fee: _op.fee,
69:             gasLimit: _op.gasLimit,
70:             data: data,
71:             memo: _op.memo
72:         });

256:                 ctoken_ = CanonicalNFT({ 
257:                     chainId: uint64(block.chainid),
258:                     addr: _op.token,
259:                     symbol: "",
260:                     name: ""
261:                 });
```
[58](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC1155Vault.sol#L58-L72), [256](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC1155Vault.sol#L256-L261)

```solidity
📁 File: contracts/tokenvault/ERC20Vault.sol

221:         IBridge.Message memory message = IBridge.Message({ 
222:             id: 0, // will receive a new value
223:             from: address(0), // will receive a new value
224:             srcChainId: 0, // will receive a new value
225:             destChainId: _op.destChainId,
226:             srcOwner: msg.sender,
227:             destOwner: _op.destOwner != address(0) ? _op.destOwner : msg.sender,
228:             to: resolve(_op.destChainId, name(), false),
229:             refundTo: _op.refundTo,
230:             value: msg.value - _op.fee,
231:             fee: _op.fee,
232:             gasLimit: _op.gasLimit,
233:             data: data,
234:             memo: _op.memo
235:         });

365:             ctoken_ = CanonicalERC20({ 
366:                 chainId: uint64(block.chainid),
367:                 addr: _token,
368:                 decimals: meta.decimals(),
369:                 symbol: meta.symbol(),
370:                 name: meta.name()
371:             });
```
[221](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC20Vault.sol#L221-L235), [365](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC20Vault.sol#L365-L371)

```solidity
📁 File: contracts/tokenvault/ERC721Vault.sol

44:         IBridge.Message memory message = IBridge.Message({ 
45:             id: 0, // will receive a new value
46:             from: address(0), // will receive a new value
47:             srcChainId: 0, // will receive a new value
48:             destChainId: _op.destChainId,
49:             srcOwner: msg.sender,
50:             destOwner: _op.destOwner != address(0) ? _op.destOwner : msg.sender,
51:             to: resolve(_op.destChainId, name(), false),
52:             refundTo: _op.refundTo,
53:             value: msg.value - _op.fee,
54:             fee: _op.fee,
55:             gasLimit: _op.gasLimit,
56:             data: data,
57:             memo: _op.memo
58:         });

203:                 ctoken_ = CanonicalNFT({ 
204:                     chainId: uint64(block.chainid),
205:                     addr: _op.token,
206:                     symbol: t.symbol(),
207:                     name: t.name()
208:                 });
```
[44](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC721Vault.sol#L44-L58), [203](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC721Vault.sol#L203-L208)

</details>


---
### [GAS&#x2011;71] Structs can be packed into fewer storage slots by truncating timestamp bytes
By using a `uint32` rather than a larger type for variables that track timestamps, one can save gas by using fewer storage slots per struct, at the expense of the protocol breaking after the year 2106 (when `uint32` wraps). If this is an acceptable tradeoff, each slot saved can avoid an extra Gsset (**20000 gas**) for the first setting of the struct. Subsequent reads as well as writes have smaller gas savings


Gas saved per Instance: ~20,000 

<i>There is one instance of this issue:</i>

```solidity
📁 File: contracts/L1/hooks/AssignmentHook.sol

/// @audit use this order:
/// -  metaHash 
/// -  parentMetaHash 
/// -  tierFees 
/// -  signature 
/// -  feeToken 
/// -  expiry (uint32)
/// -  maxProposedIn 
/// -  maxBlockId 
/// @audit 1 storage slot(s) saved, (before 7, after 6)
18:     struct ProverAssignment { 
```
[18](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/hooks/AssignmentHook.sol#L18)


---
### [GAS&#x2011;72] Superfluous event fields
`block.number` and `block.timestamp` are added to the event information by default, so adding them manually will waste additional gas.


Gas saved per Instance: ~35 *(Total: ~350)*
<details>
<summary><i>There are 10 instances of this issue:</i></summary>

```solidity
📁 File: contracts/L1/TaikoEvents.sol

21:     event BlockProposed( 
22:         uint256 indexed blockId,
23:         address indexed assignedProver,
24:         uint96 livenessBond,
25:         TaikoData.BlockMetadata meta,
26:         TaikoData.EthDeposit[] depositsProcessed
27:     );

37:     event BlockVerified( 
38:         uint256 indexed blockId,
39:         address indexed assignedProver,
40:         address indexed prover,
41:         bytes32 blockHash,
42:         bytes32 stateRoot,
43:         uint16 tier,
44:         uint8 contestations
45:     );

53:     event TransitionProved( 
54:         uint256 indexed blockId,
55:         TaikoData.Transition tran,
56:         address prover,
57:         uint96 validityBond,
58:         uint16 tier
59:     );

67:     event TransitionContested( 
68:         uint256 indexed blockId,
69:         TaikoData.Transition tran,
70:         address contester,
71:         uint96 contestBond,
72:         uint16 tier
73:     );
```
[21](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/TaikoEvents.sol#L21-L27), [37](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/TaikoEvents.sol#L37-L45), [53](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/TaikoEvents.sol#L53-L59), [67](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/TaikoEvents.sol#L67-L73)

```solidity
📁 File: contracts/L1/libs/LibProposing.sol

31:     event BlockProposed( 
32:         uint256 indexed blockId,
33:         address indexed assignedProver,
34:         uint96 livenessBond,
35:         TaikoData.BlockMetadata meta,
36:         TaikoData.EthDeposit[] depositsProcessed
37:     );
```
[31](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProposing.sol#L31-L37)

```solidity
📁 File: contracts/L1/libs/LibProving.sol

32:     event TransitionProved( 
33:         uint256 indexed blockId,
34:         TaikoData.Transition tran,
35:         address prover,
36:         uint96 validityBond,
37:         uint16 tier
38:     );

46:     event TransitionContested( 
47:         uint256 indexed blockId,
48:         TaikoData.Transition tran,
49:         address contester,
50:         uint96 contestBond,
51:         uint16 tier
52:     );
```
[32](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProving.sol#L32-L38), [46](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProving.sol#L46-L52)

```solidity
📁 File: contracts/L1/libs/LibVerifying.sol

28:     event BlockVerified( 
29:         uint256 indexed blockId,
30:         address indexed assignedProver,
31:         address indexed prover,
32:         bytes32 blockHash,
33:         bytes32 stateRoot,
34:         uint16 tier,
35:         uint8 contestations
36:     );
```
[28](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibVerifying.sol#L28-L36)

```solidity
📁 File: contracts/L1/provers/GuardianProver.sol

18:     event GuardianApproval( 
19:         address indexed addr, uint256 indexed blockId, bytes32 blockHash, bool approved
20:     );
```
[18](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/provers/GuardianProver.sol#L18-L20)

```solidity
📁 File: contracts/signal/ISignalService.sol

36:     event ChainDataSynced( 
37:         uint64 indexed chainId,
38:         uint64 indexed blockId,
39:         bytes32 indexed kind,
40:         bytes32 data,
41:         bytes32 signal
42:     );
```
[36](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/signal/ISignalService.sol#L36-L42)

</details>


---
### [GAS&#x2011;73] The result of a function call should be cached rather than re-calling the function
External calls are expensive. Results of external function calls should be cached rather than call them multiple times. Consider caching the following:


Gas saved per Instance: ~100 *(Total: ~1,000)*

<i>There are 10 instaces of this issue:</i>

```solidity
📁 File: contracts/automata-attestation/utils/Asn1Decode.sol

/// @audit j.ixl() called on lines 100, 101
/// @audit i.ixl() called on lines 100, 101
98:     function isChildOf(uint256 i, uint256 j) internal pure returns (bool) { 

/// @audit ptr.ixf() called on lines 112, 112
111:     function bytesAt(bytes memory der, uint256 ptr) internal pure returns (bytes memory) { 

/// @audit ptr.ixs() called on lines 122, 122
121:     function allBytesAt(bytes memory der, uint256 ptr) internal pure returns (bytes memory) { 

/// @audit ptr.ixf() called on lines 132, 132
131:     function bytes32At(bytes memory der, uint256 ptr) internal pure returns (bytes32) { 

/// @audit ptr.ixf() called on lines 144, 145, 143
141:     function uintAt(bytes memory der, uint256 ptr) internal pure returns (uint256) { 

/// @audit ptr.ixf() called on lines 157, 158, 161, 156, 159
154:     function uintBytesAt(bytes memory der, uint256 ptr) internal pure returns (bytes memory) { 

/// @audit ptr.ixf() called on lines 166, 166
165:     function keccakOfBytesAt(bytes memory der, uint256 ptr) internal pure returns (bytes32) { 

/// @audit ptr.ixs() called on lines 170, 170
169:     function keccakOfAllBytesAt(bytes memory der, uint256 ptr) internal pure returns (bytes32) { 

/// @audit ptr.ixf() called on lines 183, 184, 182
179:     function bitstringAt(bytes memory der, uint256 ptr) internal pure returns (bytes memory) { 
```
[98](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/Asn1Decode.sol#L98), [111](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/Asn1Decode.sol#L111), [121](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/Asn1Decode.sol#L121), [131](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/Asn1Decode.sol#L131), [141](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/Asn1Decode.sol#L141), [154](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/Asn1Decode.sol#L154), [165](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/Asn1Decode.sol#L165), [169](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/Asn1Decode.sol#L169), [179](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/Asn1Decode.sol#L179)


---
### [GAS&#x2011;74] `unchecked {}` can be used on the division of two `uint`s in order to save gas
The division cannot overflow, since both the numerator and the denominator are non-negative


Gas saved per Instance: ~60 *(Total: ~300)*
<details>
<summary><i>There are 5 instances of this issue:</i></summary>

```solidity
📁 File: contracts/L1/libs/LibVerifying.sol

262:                 || _config.ethDepositMaxFee > type(uint96).max / _config.ethDepositMaxCountPerBlock 
```
[262](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibVerifying.sol#L262)

```solidity
📁 File: contracts/L2/Lib1559Math.sol

28:         return _ethQty(_gasExcess, _adjustmentFactor) / LibFixedPointMath.SCALING_FACTOR 
29:             / _adjustmentFactor;
```
[28](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/Lib1559Math.sol#L28-L29)

```solidity
📁 File: contracts/thirdparty/optimism/rlp/RLPWriter.sol

39:             while (_len / i != 0) { 

47:                 out_[i] = bytes1(uint8((_len / (256 ** (lenLen - i))) % 256)); 
```
[39](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/rlp/RLPWriter.sol#L39), [47](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/rlp/RLPWriter.sol#L47)

</details>


---
### [GAS&#x2011;75] Unnecessary `nonReentrant` modifier in certain functions
Function not calling any external contract can't be in re-entrancy or function can only be called by `onlyOwner`/`onlyMinter` so no chance to re-enter here.


Gas saved per Instance: ~24,700 *(Total: ~123,500)*
<details>
<summary><i>There are 5 instances of this issue:</i></summary>

```solidity
📁 File: contracts/L1/provers/Guardians.sol

53:     function setGuardians( 
54:         address[] memory _newGuardians,
55:         uint8 _minGuardians
56:     )
57:         external
58:         onlyOwner
59:         nonReentrant
60:     {
```
[53](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/provers/Guardians.sol#L53-L60)

```solidity
📁 File: contracts/L2/TaikoL2.sol

163:     function withdraw( 
164:         address _token,
165:         address _to
166:     )
167:         external
168:         onlyFromOwnerOrNamed("withdrawer")
169:         nonReentrant
170:         whenNotPaused
171:     {
```
[163](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/TaikoL2.sol#L163-L171)

```solidity
📁 File: contracts/bridge/Bridge.sol

101:     function banAddress( 
102:         address _addr,
103:         bool _ban
104:     )
105:         external
106:         onlyFromOwnerOrNamed("bridge_watchdog")
107:         nonReentrant
108:     {
```
[101](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/Bridge.sol#L101-L108)

```solidity
📁 File: contracts/tokenvault/BridgedERC20Base.sol

36:     function changeMigrationStatus( 
37:         address _migratingAddress,
38:         bool _migratingInbound
39:     )
40:         external
41:         nonReentrant
42:         whenNotPaused
43:         onlyFromOwnerOrNamed("erc20_vault")
44:     {
```
[36](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC20Base.sol#L36-L44)

```solidity
📁 File: contracts/tokenvault/ERC20Vault.sol

148:     function changeBridgedToken( 
149:         CanonicalERC20 calldata _ctoken,
150:         address _btokenNew
151:     )
152:         external
153:         nonReentrant
154:         whenNotPaused
155:         onlyOwner
156:         returns (address btokenOld_)
157:     {
```
[148](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC20Vault.sol#L148-L157)

</details>


---
### [GAS&#x2011;76] Update OpenZeppelin dependency to the latest version
Every release contains new gas optimizations. Use the [latest version](https://github.com/OpenZeppelin/openzeppelin-contracts/releases) to take advantage of this.

 Current version is : `4.8.2`

<details>
<summary><i>There are 54 instances of this issue:</i></summary>

```solidity
📁 File: contracts/L1/TaikoToken.sol

4: import "@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol"; 
5: import "@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20SnapshotUpgradeable.sol";
6: import "@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20VotesUpgradeable.sol";
```
[4](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/TaikoToken.sol#L4-L6)

```solidity
📁 File: contracts/L1/gov/TaikoGovernor.sol

4: import "@openzeppelin/contracts-upgradeable/governance/GovernorUpgradeable.sol"; 
5: import
6:     "@openzeppelin/contracts-upgradeable/governance/compatibility/GovernorCompatibilityBravoUpgradeable.sol";
7: import "@openzeppelin/contracts-upgradeable/governance/extensions/GovernorVotesUpgradeable.sol";
8: import
9:     "@openzeppelin/contracts-upgradeable/governance/extensions/GovernorVotesQuorumFractionUpgradeable.sol";
10: import
11:     "@openzeppelin/contracts-upgradeable/governance/extensions/GovernorTimelockControlUpgradeable.sol";
```
[4](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/gov/TaikoGovernor.sol#L4-L11)

```solidity
📁 File: contracts/L1/gov/TaikoTimelockController.sol

4: import "@openzeppelin/contracts-upgradeable/governance/TimelockControllerUpgradeable.sol"; 
```
[4](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/gov/TaikoTimelockController.sol#L4)

```solidity
📁 File: contracts/L1/hooks/AssignmentHook.sol

4: import "@openzeppelin/contracts/token/ERC20/IERC20.sol"; 
5: import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
```
[4](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/hooks/AssignmentHook.sol#L4-L5)

```solidity
📁 File: contracts/L1/libs/LibProposing.sol

4: import "@openzeppelin/contracts/token/ERC20/IERC20.sol"; 
```
[4](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProposing.sol#L4)

```solidity
📁 File: contracts/L1/libs/LibProving.sol

4: import "@openzeppelin/contracts/token/ERC20/IERC20.sol"; 
```
[4](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProving.sol#L4)

```solidity
📁 File: contracts/L1/libs/LibVerifying.sol

4: import "@openzeppelin/contracts/token/ERC20/IERC20.sol"; 
```
[4](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibVerifying.sol#L4)

```solidity
📁 File: contracts/L2/CrossChainOwned.sol

4: import "@openzeppelin/contracts/token/ERC20/IERC20.sol"; 
```
[4](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/CrossChainOwned.sol#L4)

```solidity
📁 File: contracts/L2/TaikoL2.sol

4: import "@openzeppelin/contracts/token/ERC20/IERC20.sol"; 
5: import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
```
[4](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/TaikoL2.sol#L4-L5)

```solidity
📁 File: contracts/bridge/Bridge.sol

4: import "@openzeppelin/contracts/utils/Address.sol"; 
```
[4](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/Bridge.sol#L4)

```solidity
📁 File: contracts/common/AddressResolver.sol

4: import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol"; 
```
[4](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/common/AddressResolver.sol#L4)

```solidity
📁 File: contracts/common/EssentialContract.sol

4: import "@openzeppelin/contracts/proxy/utils/UUPSUpgradeable.sol"; 
5: import "@openzeppelin/contracts-upgradeable/access/Ownable2StepUpgradeable.sol";
```
[4](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/common/EssentialContract.sol#L4-L5)

```solidity
📁 File: contracts/libs/LibAddress.sol

4: import "@openzeppelin/contracts/utils/Address.sol"; 
5: import "@openzeppelin/contracts/utils/cryptography/ECDSA.sol";
6: import "@openzeppelin/contracts/utils/introspection/IERC165.sol";
7: import "@openzeppelin/contracts/interfaces/IERC1271.sol";
```
[4](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/libs/LibAddress.sol#L4-L7)

```solidity
📁 File: contracts/signal/SignalService.sol

4: import "@openzeppelin/contracts/utils/math/SafeCast.sol"; 
```
[4](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/signal/SignalService.sol#L4)

```solidity
📁 File: contracts/team/TimelockTokenPool.sol

4: import "@openzeppelin/contracts/utils/cryptography/ECDSA.sol"; 
5: import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
6: import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
```
[4](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/TimelockTokenPool.sol#L4-L6)

```solidity
📁 File: contracts/team/airdrop/ERC20Airdrop.sol

4: import "@openzeppelin/contracts/token/ERC20/IERC20.sol"; 
5: import "@openzeppelin/contracts/governance/utils/IVotes.sol";
```
[4](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/airdrop/ERC20Airdrop.sol#L4-L5)

```solidity
📁 File: contracts/team/airdrop/ERC20Airdrop2.sol

4: import "@openzeppelin/contracts/token/ERC20/IERC20.sol"; 
```
[4](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/airdrop/ERC20Airdrop2.sol#L4)

```solidity
📁 File: contracts/team/airdrop/ERC721Airdrop.sol

4: import "@openzeppelin/contracts/token/ERC721/IERC721.sol"; 
```
[4](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/airdrop/ERC721Airdrop.sol#L4)

```solidity
📁 File: contracts/team/airdrop/MerkleClaimable.sol

4: import "@openzeppelin/contracts/utils/cryptography/MerkleProof.sol"; 
```
[4](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/airdrop/MerkleClaimable.sol#L4)

```solidity
📁 File: contracts/tokenvault/BaseVault.sol

4: import "@openzeppelin/contracts-upgradeable/utils/introspection/IERC165Upgradeable.sol"; 
5: import "@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol";
```
[4](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BaseVault.sol#L4-L5)

```solidity
📁 File: contracts/tokenvault/BridgedERC1155.sol

4: import "@openzeppelin/contracts/utils/Strings.sol"; 
5: import "@openzeppelin/contracts-upgradeable/token/ERC1155/ERC1155Upgradeable.sol";
6: import
7:     "@openzeppelin/contracts-upgradeable/token/ERC1155/extensions/IERC1155MetadataURIUpgradeable.sol";
```
[4](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC1155.sol#L4-L7)

```solidity
📁 File: contracts/tokenvault/BridgedERC20.sol

4: import "@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol"; 
5: import "@openzeppelin/contracts/utils/Strings.sol";
6: import "@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20SnapshotUpgradeable.sol";
7: import "@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20VotesUpgradeable.sol";
```
[4](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC20.sol#L4-L7)

```solidity
📁 File: contracts/tokenvault/BridgedERC721.sol

4: import "@openzeppelin/contracts-upgradeable/token/ERC721/ERC721Upgradeable.sol"; 
5: import "@openzeppelin/contracts/utils/Strings.sol";
```
[4](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC721.sol#L4-L5)

```solidity
📁 File: contracts/tokenvault/ERC1155Vault.sol

4: import "@openzeppelin/contracts/token/ERC1155/IERC1155.sol"; 
5: import "@openzeppelin/contracts-upgradeable/token/ERC1155/utils/ERC1155ReceiverUpgradeable.sol";
```
[4](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC1155Vault.sol#L4-L5)

```solidity
📁 File: contracts/tokenvault/ERC20Vault.sol

4: import "@openzeppelin/contracts/token/ERC20/IERC20.sol"; 
5: import "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol";
6: import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
```
[4](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC20Vault.sol#L4-L6)

```solidity
📁 File: contracts/tokenvault/ERC721Vault.sol

4: import "@openzeppelin/contracts/token/ERC721/IERC721.sol"; 
5: import "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol";
```
[4](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC721Vault.sol#L4-L5)

```solidity
📁 File: contracts/tokenvault/LibBridgedToken.sol

4: import "@openzeppelin/contracts/utils/Strings.sol"; 
```
[4](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/LibBridgedToken.sol#L4)

```solidity
📁 File: contracts/verifiers/SgxVerifier.sol

4: import "@openzeppelin/contracts/utils/cryptography/ECDSA.sol"; 
```
[4](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/verifiers/SgxVerifier.sol#L4)

</details>


---
### [GAS&#x2011;77] Update Solady dependency to the latest version
Every release contains new gas optimizations. Use the [latest version](https://github.com/vectorized/solady/tags) to take advantage of this.

 Current version is : `github:Vectorized/solady#v0.0.167`

<details>
<summary><i>There are 4 instances of this issue:</i></summary>

```solidity
📁 File: contracts/automata-attestation/AutomataDcapV3Attestation.sol

13: import { Base64 } from "solady/src/utils/Base64.sol"; 
14: import { LibString } from "solady/src/utils/LibString.sol";
```
[13](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/AutomataDcapV3Attestation.sol#L13-L14)

```solidity
📁 File: contracts/automata-attestation/lib/PEMCertChainLib.sol

4: import { LibString } from "solady/src/utils/LibString.sol"; 
```
[4](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/PEMCertChainLib.sol#L4)

```solidity
📁 File: contracts/automata-attestation/lib/QuoteV3Auth/V3Parser.sol

4: import { Base64 } from "solady/src/utils/Base64.sol"; 
```
[4](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/QuoteV3Auth/V3Parser.sol#L4)

</details>


---
### [GAS&#x2011;78] Usage of `uints`/`ints` smaller than 32 bytes (256 bits) incurs overhead
Citing the [documentation](https://docs.soliditylang.org/en/latest/internals/layout_in_storage.html):

> When using elements that are smaller than 32 bytes, your contract’s gas usage may be higher.This is because the EVM operates on 32 bytes at a time.Therefore, if the element is smaller than that, the EVM must use more operations in order to reduce the size of the element from 32 bytes to the desired size.

For example, each operation involving a `uint8` costs an extra ** 22 - 28 gas ** (depending on whether the other operand is also a variable of type `uint8`) as compared to ones involving`uint256`, due to the compiler having to clear the higher bits of the memory word before operating on the`uint8`, as well as the associated stack operations of doing so.

Consider using a larger size, then downcast where needed.


Gas saved per Instance: ~6 *(Total: ~1,134)*
<details>
<summary><i>There are 189 instances of this issue:</i></summary>

```solidity
📁 File: contracts/L1/ITaikoL1.sol

27:     function proveBlock(uint64 _blockId, bytes calldata _input) external; 

31:     function verifyBlocks(uint64 _maxBlocksToVerify) external; 
```
[27](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/ITaikoL1.sol#L27), [31](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/ITaikoL1.sol#L31)

```solidity
📁 File: contracts/L1/TaikoData.sol

22:         uint64 blockRingBufferSize; 

24:         uint64 maxBlocksToVerifyPerProposal; 

30:         uint24 blobExpiry; 

39:         uint96 livenessBond; 

46:         uint64 ethDepositMinCountPerBlock; 

52:         uint96 ethDepositMaxAmount; 

65:         uint128 fee; 

69:         uint16 tier; 

83:         uint24 txListByteOffset; 

101:         uint64 id; 

104:         uint64 l1Height; 

106:         uint24 txListByteSize; 
107:         uint16 minTier;

127:         uint96 validityBond; 

130:         uint64 timestamp; // slot 6 (90 bits) 

141:         uint64 blockId; // slot 3 
142:         uint64 proposedAt; // timestamp

144:         uint32 nextTransitionId; 

153:         uint64 id; 

162:         uint64 genesisHeight; 

164:         uint64 numEthDeposits; 

169:         uint64 numBlocks; 

174:         uint32 __reserved3; 
175:         uint64 lastUnpausedAt;
```
[22](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/TaikoData.sol#L22), [24](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/TaikoData.sol#L24), [30](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/TaikoData.sol#L30), [39](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/TaikoData.sol#L39), [46](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/TaikoData.sol#L46), [52](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/TaikoData.sol#L52), [65](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/TaikoData.sol#L65), [69](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/TaikoData.sol#L69), [83](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/TaikoData.sol#L83), [101](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/TaikoData.sol#L101), [104](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/TaikoData.sol#L104), [106](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/TaikoData.sol#L106-L107), [127](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/TaikoData.sol#L127), [130](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/TaikoData.sol#L130), [141](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/TaikoData.sol#L141-L142), [144](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/TaikoData.sol#L144), [153](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/TaikoData.sol#L153), [162](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/TaikoData.sol#L162), [164](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/TaikoData.sol#L164), [169](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/TaikoData.sol#L169), [174](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/TaikoData.sol#L174-L175)

```solidity
📁 File: contracts/L1/TaikoEvents.sol

24:         uint96 livenessBond, 

43:         uint16 tier, 

57:         uint96 validityBond, 

71:         uint96 contestBond, 
```
[24](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/TaikoEvents.sol#L24), [43](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/TaikoEvents.sol#L43), [57](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/TaikoEvents.sol#L57), [71](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/TaikoEvents.sol#L71)

```solidity
📁 File: contracts/L1/TaikoL1.sol

76:         uint64 _blockId, 

100:     function verifyBlocks(uint64 _maxBlocksToVerify) 

145:     function getBlock(uint64 _blockId) 

163:         uint64 _blockId, 
```
[76](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/TaikoL1.sol#L76), [100](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/TaikoL1.sol#L100), [145](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/TaikoL1.sol#L145), [163](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/TaikoL1.sol#L163)

```solidity
📁 File: contracts/L1/hooks/AssignmentHook.sol

20:         uint64 expiry; 

22:         uint64 maxProposedIn; 

166:         uint16 _tierId 
```
[20](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/hooks/AssignmentHook.sol#L20), [22](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/hooks/AssignmentHook.sol#L22), [166](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/hooks/AssignmentHook.sol#L166)

```solidity
📁 File: contracts/L1/libs/LibDepositing.sol

83:             uint96 fee = uint96(_config.ethDepositMaxFee.min(block.basefee * _config.ethDepositGas)); 

85:             uint96 totalFee; 
```
[83](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibDepositing.sol#L83), [85](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibDepositing.sol#L85)

```solidity
📁 File: contracts/L1/libs/LibProposing.sol

34:         uint96 livenessBond, 
```
[34](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProposing.sol#L34)

```solidity
📁 File: contracts/L1/libs/LibProving.sol

36:         uint96 validityBond, 

50:         uint96 contestBond, 

115:         uint64 slot = _meta.id % _config.blockRingBufferSize; 

129:         (uint32 tid, TaikoData.TransitionState storage ts) = 

273:         uint64 slot 

405:         uint32 _tid, 
```
[36](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProving.sol#L36), [50](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProving.sol#L50), [115](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProving.sol#L115), [129](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProving.sol#L129), [273](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProving.sol#L273), [405](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProving.sol#L405)

```solidity
📁 File: contracts/L1/libs/LibUtils.sol

26:         uint64 _blockId, 

38:         uint64 slot = _blockId % _config.blockRingBufferSize; 

42:         uint32 tid = getTransitionId(_state, blk, slot, _parentHash); 

55:         uint64 _blockId 

59:         returns (TaikoData.Block storage blk_, uint64 slot_) 

73:         uint64 _slot, 

78:         returns (uint32 tid_) 
```
[26](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibUtils.sol#L26), [38](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibUtils.sol#L38), [42](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibUtils.sol#L42), [55](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibUtils.sol#L55), [59](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibUtils.sol#L59), [73](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibUtils.sol#L73), [78](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibUtils.sol#L78)

```solidity
📁 File: contracts/L1/libs/LibVerifying.sol

34:         uint16 tier, 

89:         uint64 _maxBlocksToVerify 

100:         uint64 blockId = b.lastVerifiedBlockId; 

107:         uint32 tid = blk.verifiedTransitionId; 

117:         uint64 numBlocksVerified; 

213:                 uint64 lastVerifiedBlockId = b.lastVerifiedBlockId + numBlocksVerified; 

227:         uint64 _lastVerifiedBlockId, 

234:         (uint64 lastSyncedBlock,) = signalService.getSyncedChainData( 
```
[34](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibVerifying.sol#L34), [89](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibVerifying.sol#L89), [100](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibVerifying.sol#L100), [107](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibVerifying.sol#L107), [117](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibVerifying.sol#L117), [213](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibVerifying.sol#L213), [227](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibVerifying.sol#L227), [234](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibVerifying.sol#L234)

```solidity
📁 File: contracts/L1/provers/Guardians.sol

27:     uint32 public version; 

37:     event GuardiansUpdated(uint32 version, address[] guardians); 
```
[27](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/provers/Guardians.sol#L27), [37](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/provers/Guardians.sol#L37)

```solidity
📁 File: contracts/L1/tiers/DevnetTierProvider.sol

20:     function getTier(uint16 _tierId) public pure override returns (ITierProvider.Tier memory) { 
```
[20](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/tiers/DevnetTierProvider.sol#L20)

```solidity
📁 File: contracts/L1/tiers/ITierProvider.sol

10:         uint96 validityBond; 
11:         uint96 contestBond;

13:         uint16 provingWindow; // in minutes 

39:     uint16 public constant TIER_OPTIMISTIC = 100; 

45:     uint16 public constant TIER_SGX_ZKVM = 300; 
```
[10](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/tiers/ITierProvider.sol#L10-L11), [13](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/tiers/ITierProvider.sol#L13), [39](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/tiers/ITierProvider.sol#L39), [45](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/tiers/ITierProvider.sol#L45)

```solidity
📁 File: contracts/L1/tiers/MainnetTierProvider.sol

20:     function getTier(uint16 _tierId) public pure override returns (ITierProvider.Tier memory) { 
```
[20](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/tiers/MainnetTierProvider.sol#L20)

```solidity
📁 File: contracts/L1/tiers/TestnetTierProvider.sol

20:     function getTier(uint16 _tierId) public pure override returns (ITierProvider.Tier memory) { 
```
[20](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/tiers/TestnetTierProvider.sol#L20)

```solidity
📁 File: contracts/L2/CrossChainOwned.sol

16:     uint64 public ownerChainId; 

26:     event TransactionExecuted(uint64 indexed txId, bytes4 indexed selector); 

63:         uint64 _ownerChainId 
```
[16](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/CrossChainOwned.sol#L16), [26](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/CrossChainOwned.sol#L26), [63](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/CrossChainOwned.sol#L63)

```solidity
📁 File: contracts/L2/TaikoL2.sol

27:         uint32 gasTargetPerL1Block; 

47:     uint64 public gasExcess; 

57:     event Anchored(bytes32 parentHash, uint64 gasExcess); 

74:         uint64 _l1ChainId, 

110:         uint64 _l1BlockId, 

186:         uint64 _l1BlockId, 

254:         uint64 _l1BlockId, 
```
[27](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/TaikoL2.sol#L27), [47](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/TaikoL2.sol#L47), [57](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/TaikoL2.sol#L57), [74](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/TaikoL2.sol#L74), [110](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/TaikoL2.sol#L110), [186](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/TaikoL2.sol#L186), [254](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/TaikoL2.sol#L254)

```solidity
📁 File: contracts/L2/TaikoL2EIP1559Configurable.sol

18:     event ConfigAndExcessChanged(Config config, uint64 gasExcess); 

27:         uint64 _newGasExcess 
```
[18](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/TaikoL2EIP1559Configurable.sol#L18), [27](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/TaikoL2EIP1559Configurable.sol#L27)

```solidity
📁 File: contracts/automata-attestation/lib/EnclaveIdStruct.sol

10:         uint16 isvprodid; 

23:         uint16 isvsvn; 
```
[10](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/EnclaveIdStruct.sol#L10), [23](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/EnclaveIdStruct.sol#L23)

```solidity
📁 File: contracts/automata-attestation/lib/PEMCertChainLib.sol

358:             uint16 svnValue = svnValueBytes.length < 2 
```
[358](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/PEMCertChainLib.sol#L358)

```solidity
📁 File: contracts/automata-attestation/lib/QuoteV3Auth/V3Parser.sol

106:         uint32 totalQuoteSize = 48 // header 

249:         uint16 isvProdIdPackBE = (enclaveReport.isvProdId >> 8) | (enclaveReport.isvProdId << 8); 
```
[106](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/QuoteV3Auth/V3Parser.sol#L106), [249](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/QuoteV3Auth/V3Parser.sol#L249)

```solidity
📁 File: contracts/automata-attestation/lib/QuoteV3Auth/V3Struct.sol

26:         uint16 isvProdId; 

34:         uint16 parsedDataSize; 

43:         uint32 certDataSize; 
```
[26](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/QuoteV3Auth/V3Struct.sol#L26), [34](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/QuoteV3Auth/V3Struct.sol#L34), [43](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/QuoteV3Auth/V3Struct.sol#L43)

```solidity
📁 File: contracts/automata-attestation/utils/Asn1Decode.sol

189:         uint80 ixFirstContentByte; 
```
[189](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/Asn1Decode.sol#L189)

```solidity
📁 File: contracts/automata-attestation/utils/X509DateUtils.sol

9:         uint16 yrs; 

48:         for (uint16 i = 1970; i < year; ++i) { 

71:     function isLeapYear(uint16 year) internal pure returns (bool) { 
```
[9](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/X509DateUtils.sol#L9), [48](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/X509DateUtils.sol#L48), [71](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/X509DateUtils.sol#L71)

```solidity
📁 File: contracts/bridge/Bridge.sol

64:     modifier sameChain(uint64 _chainId) { 

89:         uint64 _timestamp = _suspend ? type(uint64).max : uint64(block.timestamp); 

168:         uint64 receivedAt = proofReceipt[msgHash].receivedAt; 

230:         uint64 receivedAt = proofReceipt[msgHash].receivedAt; 

392:     function isDestChainEnabled(uint64 _chainId) 

541:     function _storeContext(bytes32 _msgHash, address _from, uint64 _srcChainId) private { 

559:             uint64 srcChainId; 

580:         uint64 _chainId, 
```
[64](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/Bridge.sol#L64), [89](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/Bridge.sol#L89), [168](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/Bridge.sol#L168), [230](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/Bridge.sol#L230), [392](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/Bridge.sol#L392), [541](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/Bridge.sol#L541), [559](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/Bridge.sol#L559), [580](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/Bridge.sol#L580)

```solidity
📁 File: contracts/bridge/IBridge.sol

19:         uint128 id; 

24:         uint64 srcChainId; 

51:         uint64 receivedAt; 

63:         uint64 srcChainId; // Source chain ID. 
```
[19](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/IBridge.sol#L19), [24](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/IBridge.sol#L24), [51](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/IBridge.sol#L51), [63](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/IBridge.sol#L63)

```solidity
📁 File: contracts/common/AddressManager.sol

22:         uint64 indexed chainId, bytes32 indexed name, address newAddress, address oldAddress 

39:         uint64 _chainId, 

54:     function getAddress(uint64 _chainId, bytes32 _name) public view override returns (address) { 
```
[22](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/common/AddressManager.sol#L22), [39](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/common/AddressManager.sol#L39), [54](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/common/AddressManager.sol#L54)

```solidity
📁 File: contracts/common/AddressResolver.sol

19:     error RESOLVER_ZERO_ADDR(uint64 chainId, bytes32 name); 

44:         uint64 _chainId, 

73:         uint64 _chainId, 
```
[19](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/common/AddressResolver.sol#L19), [44](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/common/AddressResolver.sol#L44), [73](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/common/AddressResolver.sol#L73)

```solidity
📁 File: contracts/common/IAddressManager.sol

14:     function getAddress(uint64 _chainId, bytes32 _name) external view returns (address); 
```
[14](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/common/IAddressManager.sol#L14)

```solidity
📁 File: contracts/common/IAddressResolver.sol

35:         uint64 _chainId, 
```
[35](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/common/IAddressResolver.sol#L35)

```solidity
📁 File: contracts/libs/Lib4844.sol

13:     uint32 public constant FIELD_ELEMENTS_PER_BLOB = 4096; 
```
[13](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/libs/Lib4844.sol#L13)

```solidity
📁 File: contracts/signal/ISignalService.sol

21:         uint64 chainId; 

37:         uint64 indexed chainId, 

69:         uint64 _chainId, 

71:         uint64 _blockId, 

85:         uint64 _chainId, 

106:         uint64 _chainId, 

108:         uint64 _blockId, 

123:         uint64 _chainId, 

125:         uint64 _blockId 

138:         uint64 _chainId, 

140:         uint64 _blockId 
```
[21](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/signal/ISignalService.sol#L21), [37](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/signal/ISignalService.sol#L37), [69](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/signal/ISignalService.sol#L69), [71](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/signal/ISignalService.sol#L71), [85](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/signal/ISignalService.sol#L85), [106](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/signal/ISignalService.sol#L106), [108](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/signal/ISignalService.sol#L108), [123](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/signal/ISignalService.sol#L123), [125](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/signal/ISignalService.sol#L125), [138](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/signal/ISignalService.sol#L138), [140](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/signal/ISignalService.sol#L140)

```solidity
📁 File: contracts/signal/SignalService.sol

69:         uint64 _chainId, 

71:         uint64 _blockId, 

84:         uint64 _chainId, 

97:         uint64 chainId = _chainId; 

138:         uint64 _chainId, 

140:         uint64 _blockId, 

159:         uint64 _chainId, 

161:         uint64 _blockId 

178:         uint64 _chainId, 

180:         uint64 _blockId 

195:         uint64 _chainId, 

207:         uint64 _chainId, 

236:         uint64 _chainId, 

238:         uint64 _blockId, 

273:         uint64 _chainId, 
```
[69](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/signal/SignalService.sol#L69), [71](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/signal/SignalService.sol#L71), [84](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/signal/SignalService.sol#L84), [97](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/signal/SignalService.sol#L97), [138](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/signal/SignalService.sol#L138), [140](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/signal/SignalService.sol#L140), [159](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/signal/SignalService.sol#L159), [161](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/signal/SignalService.sol#L161), [178](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/signal/SignalService.sol#L178), [180](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/signal/SignalService.sol#L180), [195](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/signal/SignalService.sol#L195), [207](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/signal/SignalService.sol#L207), [236](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/signal/SignalService.sol#L236), [238](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/signal/SignalService.sol#L238), [273](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/signal/SignalService.sol#L273)

```solidity
📁 File: contracts/team/TimelockTokenPool.sol

29:         uint128 amount; 

34:         uint64 grantStart; 

43:         uint64 unlockStart; 

49:         uint32 unlockPeriod; 

53:         uint128 amountWithdrawn; 

68:     uint128 public totalAmountGranted; 

74:     uint128 public totalAmountWithdrawn; 

92:     event Voided(address indexed recipient, uint128 amount); 

99:     event Withdrawn(address indexed recipient, address to, uint128 amount, uint128 cost); 

152:         uint128 amountVoided = _voidGrant(r.grant); 

180:             uint128 amountOwned, 

182:             uint128 amountWithdrawn, 

184:             uint128 costToWithdraw 

197:         uint128 _amountUnlocked = amountUnlocked / 1e18; // divide first 

211:         (,,, uint128 amountToWithdraw, uint128 costToWithdraw) = getMyGrantSummary(_recipient); 

225:     function _voidGrant(Grant storage _grant) private returns (uint128 amountVoided) { 
226:         uint128 amountOwned = _getAmountOwned(_grant);

235:     function _getAmountOwned(Grant memory _grant) private view returns (uint128) { 

239:     function _getAmountUnlocked(Grant memory _grant) private view returns (uint128) { 

247:         uint64 _start, 

249:         uint64 _period 

273:     function _validateCliff(uint64 _start, uint64 _cliff, uint32 _period) private pure { 
```
[29](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/TimelockTokenPool.sol#L29), [34](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/TimelockTokenPool.sol#L34), [43](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/TimelockTokenPool.sol#L43), [49](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/TimelockTokenPool.sol#L49), [53](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/TimelockTokenPool.sol#L53), [68](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/TimelockTokenPool.sol#L68), [74](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/TimelockTokenPool.sol#L74), [92](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/TimelockTokenPool.sol#L92), [99](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/TimelockTokenPool.sol#L99), [152](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/TimelockTokenPool.sol#L152), [180](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/TimelockTokenPool.sol#L180), [182](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/TimelockTokenPool.sol#L182), [184](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/TimelockTokenPool.sol#L184), [197](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/TimelockTokenPool.sol#L197), [211](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/TimelockTokenPool.sol#L211), [225](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/TimelockTokenPool.sol#L225-L226), [235](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/TimelockTokenPool.sol#L235), [239](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/TimelockTokenPool.sol#L239), [247](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/TimelockTokenPool.sol#L247), [249](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/TimelockTokenPool.sol#L249), [273](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/TimelockTokenPool.sol#L273)

```solidity
📁 File: contracts/team/airdrop/ERC20Airdrop.sol

29:         uint64 _claimStart, 
```
[29](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/airdrop/ERC20Airdrop.sol#L29)

```solidity
📁 File: contracts/team/airdrop/ERC20Airdrop2.sol

28:     uint64 public withdrawalWindow; 

56:         uint64 _claimStart, 

61:         uint64 _withdrawalWindow 
```
[28](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/airdrop/ERC20Airdrop2.sol#L28), [56](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/airdrop/ERC20Airdrop2.sol#L56), [61](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/airdrop/ERC20Airdrop2.sol#L61)

```solidity
📁 File: contracts/team/airdrop/ERC721Airdrop.sol

27:         uint64 _claimStart, 
```
[27](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/airdrop/ERC721Airdrop.sol#L27)

```solidity
📁 File: contracts/team/airdrop/MerkleClaimable.sol

18:     uint64 public claimStart; 

46:         uint64 _claimStart, 

57:         uint64 _claimStart, 

90:     function _setConfig(uint64 _claimStart, uint64 _claimEnd, bytes32 _merkleRoot) private { 
```
[18](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/airdrop/MerkleClaimable.sol#L18), [46](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/airdrop/MerkleClaimable.sol#L46), [57](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/airdrop/MerkleClaimable.sol#L57), [90](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/airdrop/MerkleClaimable.sol#L90)

```solidity
📁 File: contracts/thirdparty/nomad-xyz/ExcessivelySafeCall.sol

29:         uint16 _maxCopy, 
```
[29](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/nomad-xyz/ExcessivelySafeCall.sol#L29)

```solidity
📁 File: contracts/thirdparty/solmate/LibFixedPointMath.sol

7:     uint128 public constant MAX_EXP_INPUT = 135_305_999_368_893_231_588; 
```
[7](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/solmate/LibFixedPointMath.sol#L7)

```solidity
📁 File: contracts/tokenvault/BaseNFTVault.sol

13:         uint64 chainId; 

25:         uint64 destChainId; 

70:         uint64 indexed chainId, 

90:         uint64 destChainId, 

126:         uint64 srcChainId, 
```
[13](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BaseNFTVault.sol#L13), [25](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BaseNFTVault.sol#L25), [70](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BaseNFTVault.sol#L70), [90](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BaseNFTVault.sol#L90), [126](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BaseNFTVault.sol#L126)

```solidity
📁 File: contracts/tokenvault/ERC20Vault.sol

33:         uint64 destChainId; 

102:         uint64 destChainId, 

130:         uint64 srcChainId, 
```
[33](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC20Vault.sol#L33), [102](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC20Vault.sol#L102), [130](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC20Vault.sol#L130)

```solidity
📁 File: contracts/verifiers/IVerifier.sol

14:         uint64 blockId; 
```
[14](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/verifiers/IVerifier.sol#L14)

```solidity
📁 File: contracts/verifiers/SgxVerifier.sol

26:         uint64 validSince; 

30:     uint64 public constant INSTANCE_EXPIRY = 180 days; 

154:         uint32 id = uint32(bytes4(Bytes.slice(_proof.data, 0, 4))); 

204:         uint64 validSince = uint64(block.timestamp); 
```
[26](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/verifiers/SgxVerifier.sol#L26), [30](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/verifiers/SgxVerifier.sol#L30), [154](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/verifiers/SgxVerifier.sol#L154), [204](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/verifiers/SgxVerifier.sol#L204)

</details>


---
### [GAS&#x2011;79] Use `Array.unsafeAccess()` to avoid repeated array length checks
When using storage arrays, solidity adds an internal lookup of the array's length (a Gcoldsload **2100 gas**) to ensure you don't read past the array's end. You can avoid this lookup by using [`Array.unsafeAccess()`](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/94697be8a3f0dfcd95dfb13ffbd39b5973f5c65d/contracts/utils/Arrays.sol#L57) in cases where the length has already been checked, as is the case with the instances below


Gas saved per Instance: ~2,100 *(Total: ~113,400)*
<details>
<summary><i>There are 54 instances of this issue:</i></summary>

```solidity
📁 File: contracts/L1/hooks/AssignmentHook.sol

173:             if (_tierFees[i].tier == _tierId) return _tierFees[i].fee; 
```
[173](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/hooks/AssignmentHook.sol#L173)

```solidity
📁 File: contracts/L1/libs/LibDepositing.sol

88:                 deposits_[i] = TaikoData.EthDeposit({ 

93:                 uint96 _fee = deposits_[i].amount > fee ? fee : deposits_[i].amount; 

101:                     deposits_[i].amount -= _fee; 
```
[88](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibDepositing.sol#L88), [93](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibDepositing.sol#L93), [101](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibDepositing.sol#L101)

```solidity
📁 File: contracts/L1/libs/LibProposing.sol

245:                 if (uint160(prevHook) >= uint160(params.hookCalls[i].hook)) { 

253:                 IHook(params.hookCalls[i].hook).onBlockProposed{ value: address(this).balance }( 
254:                     blk, meta_, params.hookCalls[i].data

257:                 prevHook = params.hookCalls[i].hook; 
```
[245](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProposing.sol#L245), [253](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProposing.sol#L253-L254), [257](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProposing.sol#L257)

```solidity
📁 File: contracts/L1/provers/Guardians.sol

75:             delete guardianIds[guardians[i]]; 

81:             address guardian = _newGuardians[i]; 

88:             guardianIds[guardian] = guardians.length; 
```
[75](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/provers/Guardians.sol#L75), [81](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/provers/Guardians.sol#L81), [88](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/provers/Guardians.sol#L88)

```solidity
📁 File: contracts/automata-attestation/AutomataDcapV3Attestation.sol

81:             if (_serialNumIsRevoked[index][serialNumBatch[i]]) { 

84:             _serialNumIsRevoked[index][serialNumBatch[i]] = true; 

96:             if (!_serialNumIsRevoked[index][serialNumBatch[i]]) { 

99:             delete _serialNumIsRevoked[index][serialNumBatch[i]]; 

192:             EnclaveIdStruct.TcbLevel memory tcb = enclaveId.tcbLevels[i]; 

215:             TCBInfoStruct.TCBLevelObj memory current = tcb.tcbLevels[i]; 

263:                 issuer = certs[i]; 

265:                 issuer = certs[i + 1]; 

268:                     certRevoked = _serialNumIsRevoked[uint256(IPEMCertChainLib.CRL.ROOT)][certs[i] 

270:                 } else if (certs[i].isPck) { 
271:                     certRevoked = _serialNumIsRevoked[uint256(IPEMCertChainLib.CRL.PCK)][certs[i]

280:                 block.timestamp > certs[i].notBefore && block.timestamp < certs[i].notAfter; 

286:                 certs[i].tbsCertificate, certs[i].signature, issuer.pubKey 
```
[81](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/AutomataDcapV3Attestation.sol#L81), [84](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/AutomataDcapV3Attestation.sol#L84), [96](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/AutomataDcapV3Attestation.sol#L96), [99](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/AutomataDcapV3Attestation.sol#L99), [192](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/AutomataDcapV3Attestation.sol#L192), [215](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/AutomataDcapV3Attestation.sol#L215), [263](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/AutomataDcapV3Attestation.sol#L263), [265](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/AutomataDcapV3Attestation.sol#L265), [268](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/AutomataDcapV3Attestation.sol#L268), [270](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/AutomataDcapV3Attestation.sol#L270-L271), [280](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/AutomataDcapV3Attestation.sol#L280), [286](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/AutomataDcapV3Attestation.sol#L286)

```solidity
📁 File: contracts/automata-attestation/lib/PEMCertChainLib.sol

245:             contentStr = LibString.concat(contentStr, split[i]); 
```
[245](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/PEMCertChainLib.sol#L245)

```solidity
📁 File: contracts/automata-attestation/lib/QuoteV3Auth/V3Parser.sol

154:             uint256 digits = uint256(uint8(bytes1(encoded[i]))); 
```
[154](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/QuoteV3Auth/V3Parser.sol#L154)

```solidity
📁 File: contracts/automata-attestation/utils/RsaVerify.sol

159:                 if (decipher[3 + paddingLen + i] != bytes1(sha256ImplicitNullParam[i])) { 

175:             if (decipher[5 + paddingLen + digestAlgoWithParamLen + i] != _sha256[i]) { 

284:             if (decipher[3 + paddingLen + i] != bytes1(sha1Prefix[i])) { 

291:             if (decipher[3 + paddingLen + sha1Prefix.length + i] != _sha1[i]) { 
```
[159](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/RsaVerify.sol#L159), [175](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/RsaVerify.sol#L175), [284](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/RsaVerify.sol#L284), [291](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/RsaVerify.sol#L291)

```solidity
📁 File: contracts/bridge/Bridge.sol

91:             bytes32 msgHash = _msgHashes[i]; 
```
[91](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/Bridge.sol#L91)

```solidity
📁 File: contracts/signal/SignalService.sol

105:             hop = hopProofs[i]; 
```
[105](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/signal/SignalService.sol#L105)

```solidity
📁 File: contracts/team/airdrop/ERC721Airdrop.sol

60:             IERC721(token).safeTransferFrom(vault, user, tokenIds[i]); 
```
[60](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/airdrop/ERC721Airdrop.sol#L60)

```solidity
📁 File: contracts/thirdparty/optimism/rlp/RLPWriter.sol

67:             out_[j] = b[i++]; 
```
[67](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/rlp/RLPWriter.sol#L67)

```solidity
📁 File: contracts/thirdparty/optimism/trie/MerkleTrie.sol

86:             TrieNode memory currentNode = proof[i]; 

209:             proof_[i] = TrieNode({ encoded: _proof[i], decoded: RLPReader.readList(_proof[i]) }); 
```
[86](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/trie/MerkleTrie.sol#L86), [209](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/trie/MerkleTrie.sol#L209)

```solidity
📁 File: contracts/tokenvault/ERC1155Vault.sol

48:             if (_op.amounts[i] == 0) revert VAULT_INVALID_AMOUNT(); 

252:                     BridgedERC1155(_op.token).burn(_user, _op.tokenIds[i], _op.amounts[i]); 

273:                         id: _op.tokenIds[i], 
```
[48](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC1155Vault.sol#L48), [252](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC1155Vault.sol#L252), [273](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC1155Vault.sol#L273)

```solidity
📁 File: contracts/tokenvault/ERC721Vault.sol

171:                 IERC721(token_).safeTransferFrom(address(this), _to, _tokenIds[i]); 

176:                 BridgedERC721(token_).mint(_to, _tokenIds[i]); 

198:                     BridgedERC721(_op.token).burn(_user, _op.tokenIds[i]); 

211:                     t.safeTransferFrom(_user, address(this), _op.tokenIds[i]); 
```
[171](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC721Vault.sol#L171), [176](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC721Vault.sol#L176), [198](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC721Vault.sol#L198), [211](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC721Vault.sol#L211)

```solidity
📁 File: contracts/verifiers/SgxVerifier.sol

105:             uint256 idx = _ids[i]; 

211:             if (addressRegistered[_instances[i]]) revert SGX_ALREADY_ATTESTED(); 

213:             addressRegistered[_instances[i]] = true; 

215:             if (_instances[i] == address(0)) revert SGX_INVALID_INSTANCE(); 

217:             instances[nextInstanceId] = Instance(_instances[i], validSince); 

220:             emit InstanceAdded(nextInstanceId, _instances[i], address(0), validSince); 
```
[105](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/verifiers/SgxVerifier.sol#L105), [211](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/verifiers/SgxVerifier.sol#L211), [213](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/verifiers/SgxVerifier.sol#L213), [215](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/verifiers/SgxVerifier.sol#L215), [217](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/verifiers/SgxVerifier.sol#L217), [220](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/verifiers/SgxVerifier.sol#L220)

</details>


---
### [GAS&#x2011;80] Use assembly for small `keccak256` hashes, in order to save gas
The assembly version of the keccak256 hashing function can be more gas efficient than the high-level Solidity version.


Gas saved per Instance: ~80 *(Total: ~1,840)*
<details>
<summary><i>There are 23 instances of this issue:</i></summary>

```solidity
📁 File: contracts/L1/hooks/AssignmentHook.sol

146:         return keccak256( 
147:             abi.encode(
148:                 "PROVER_ASSIGNMENT",
149:                 ITaikoL1(_taikoL1Address).getConfig().chainId,
150:                 _taikoL1Address,
151:                 address(this),
152:                 _assignment.metaHash,
153:                 _assignment.parentMetaHash,
154:                 _blobHash,
155:                 _assignment.feeToken,
156:                 _assignment.expiry,
157:                 _assignment.maxBlockId,
158:                 _assignment.maxProposedIn,
159:                 _assignment.tierFees
160:             )
161:         );
```
[146](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/hooks/AssignmentHook.sol#L146-L161)

```solidity
📁 File: contracts/L1/libs/LibProposing.sol

126:                 depositsHash: keccak256(abi.encode(deposits_)), 

213:             metaHash: keccak256(abi.encode(meta_)), 
```
[126](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProposing.sol#L126), [213](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProposing.sol#L213)

```solidity
📁 File: contracts/L1/libs/LibProving.sol

121:         if (blk.blockId != _meta.id || blk.metaHash != keccak256(abi.encode(_meta))) { 
```
[121](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProving.sol#L121)

```solidity
📁 File: contracts/L1/provers/GuardianProver.sol

46:         bytes32 hash = keccak256(abi.encode(_meta, _tran)); 
```
[46](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/provers/GuardianProver.sol#L46)

```solidity
📁 File: contracts/automata-attestation/AutomataDcapV3Attestation.sol

292:             bytes32 issuerPubKeyHash = keccak256(issuer.pubKey); 
```
[292](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/AutomataDcapV3Attestation.sol#L292)

```solidity
📁 File: contracts/automata-attestation/utils/BytesUtils.sol

372:         return keccak256(a) == keccak256(b); 
```
[372](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/BytesUtils.sol#L372)

```solidity
📁 File: contracts/bridge/Bridge.sol

450:         return keccak256(abi.encode("TAIKO_MESSAGE", _message)); 
```
[450](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/Bridge.sol#L450)

```solidity
📁 File: contracts/signal/SignalService.sol

186:         return keccak256(abi.encode(_chainId, _kind, _blockId)); 

203:         return keccak256(abi.encodePacked("SIGNAL", _chainId, _app, _signal)); 
```
[186](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/signal/SignalService.sol#L186), [203](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/signal/SignalService.sol#L203)

```solidity
📁 File: contracts/team/TimelockTokenPool.sol

170:         bytes32 hash = keccak256(abi.encodePacked("Withdraw unlocked Taiko token to: ", _to)); 
```
[170](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/TimelockTokenPool.sol#L170)

```solidity
📁 File: contracts/team/airdrop/MerkleClaimable.sol

68:         bytes32 hash = keccak256(abi.encode("CLAIM_TAIKO_AIRDROP", data)); 
```
[68](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/airdrop/MerkleClaimable.sol#L68)

```solidity
📁 File: contracts/thirdparty/optimism/Bytes.sol

150:         return keccak256(_bytes) == keccak256(_other); 
```
[150](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/Bytes.sol#L150)

```solidity
📁 File: contracts/thirdparty/optimism/trie/MerkleTrie.sol

94:                     Bytes.equal(abi.encodePacked(keccak256(currentNode.encoded)), currentNodeID), 

100:                     Bytes.equal(abi.encodePacked(keccak256(currentNode.encoded)), currentNodeID), 
```
[94](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/trie/MerkleTrie.sol#L94), [100](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/trie/MerkleTrie.sol#L100)

```solidity
📁 File: contracts/thirdparty/optimism/trie/SecureMerkleTrie.sol

55:         hash_ = abi.encodePacked(keccak256(_key)); 
```
[55](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/trie/SecureMerkleTrie.sol#L55)

```solidity
📁 File: contracts/tokenvault/ERC20Vault.sol

176:                     || keccak256(bytes(ctoken.symbol)) != keccak256(bytes(_ctoken.symbol)) 
177:                     || keccak256(bytes(ctoken.name)) != keccak256(bytes(_ctoken.name))
```
[176](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC20Vault.sol#L176-L177)

```solidity
📁 File: contracts/verifiers/SgxVerifier.sol

182:         return keccak256( 
183:             abi.encode(
184:                 "VERIFY_PROOF",
185:                 ITaikoL1(taikoL1).getConfig().chainId,
186:                 address(this),
187:                 _tran,
188:                 _newInstance,
189:                 _prover,
190:                 _metaHash
191:             )
192:         );
```
[182](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/verifiers/SgxVerifier.sol#L182-L192)

</details>


---
### [GAS&#x2011;81] Use assembly in place of `abi.decode` to save gas
Instead of using abi.decode, we can use assembly to decode our desired calldata values directly. This will allow us to avoid decoding calldata values that we will not use.


Gas saved per Instance: ~112 *(Total: ~1,792)*
<details>
<summary><i>There are 16 instances of this issue:</i></summary>

```solidity
📁 File: contracts/L1/TaikoL1.sol

88:         ) = abi.decode(_input, (TaikoData.BlockMetadata, TaikoData.Transition, TaikoData.TierProof)); 
```
[88](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/TaikoL1.sol#L88)

```solidity
📁 File: contracts/L1/hooks/AssignmentHook.sol

77:         Input memory input = abi.decode(_data, (Input)); 
```
[77](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/hooks/AssignmentHook.sol#L77)

```solidity
📁 File: contracts/L1/libs/LibProposing.sol

78:         TaikoData.BlockParams memory params = abi.decode(_data, (TaikoData.BlockParams)); 
```
[78](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProposing.sol#L78)

```solidity
📁 File: contracts/L2/CrossChainOwned.sol

42:         (uint64 txId, bytes memory txdata) = abi.decode(_data, (uint64, bytes)); 
```
[42](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/CrossChainOwned.sol#L42)

```solidity
📁 File: contracts/automata-attestation/utils/SigVerifyLib.sol

140:         return abi.decode(ret, (uint256)) == 1; 
```
[140](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/SigVerifyLib.sol#L140)

```solidity
📁 File: contracts/signal/SignalService.sol

94:         HopProof[] memory hopProofs = abi.decode(_proof, (HopProof[])); 
```
[94](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/signal/SignalService.sol#L94)

```solidity
📁 File: contracts/team/airdrop/ERC20Airdrop.sol

70:             abi.decode(delegationData, (address, uint256, uint256, uint8, bytes32, bytes32)); 
```
[70](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/airdrop/ERC20Airdrop.sol#L70)

```solidity
📁 File: contracts/tokenvault/ERC1155Vault.sol

100:         ) = abi.decode(data, (CanonicalNFT, address, address, uint256[], uint256[])); 

140:         (bytes memory data) = abi.decode(message.data[4:], (bytes)); 

142:             abi.decode(data, (CanonicalNFT, address, address, uint256[], uint256[])); 
```
[100](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC1155Vault.sol#L100), [140](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC1155Vault.sol#L140), [142](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC1155Vault.sol#L142)

```solidity
📁 File: contracts/tokenvault/ERC20Vault.sol

260:             abi.decode(_data, (CanonicalERC20, address, address, uint256)); 

298:         (bytes memory data) = abi.decode(_message.data[4:], (bytes)); 

300:             abi.decode(data, (CanonicalERC20, address, address, uint256)); 
```
[260](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC20Vault.sol#L260), [298](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC20Vault.sol#L298), [300](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC20Vault.sol#L300)

```solidity
📁 File: contracts/tokenvault/ERC721Vault.sol

84:             abi.decode(_data, (CanonicalNFT, address, address, uint256[])); 

123:         (bytes memory data) = abi.decode(_message.data[4:], (bytes)); 

125:             abi.decode(data, (CanonicalNFT, address, address, uint256[])); 
```
[84](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC721Vault.sol#L84), [123](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC721Vault.sol#L123), [125](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC721Vault.sol#L125)

</details>


---
### [GAS&#x2011;82] Use assembly scratch space to build calldata for external calls
Using Solidity's assembly scratch space for constructing calldata in external calls with one or two arguments can be a gas-efficient approach. This method leverages the designated memory area (the first 64 bytes of memory) for temporary data storage during assembly operations. By directly writing arguments into this scratch space, it eliminates the need for additional memory allocation typically required for calldata preparation. This technique can lead to notable gas savings, especially in high-frequency or gas-sensitive operations. However, it requires careful implementation to avoid data corruption and should be used with a thorough understanding of low-level EVM operations and memory handling. Proper testing and validation are crucial when employing such optimizations.


Gas saved per Instance: ~220 *(Total: ~11,220)*
<details>
<summary><i>There are 51 instances of this issue:</i></summary>

```solidity
📁 File: contracts/L1/libs/LibDepositing.sol

41:         _resolver.resolve("bridge", false).sendEther(msg.value); 
```
[41](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibDepositing.sol#L41)

```solidity
📁 File: contracts/L1/libs/LibProposing.sol

207:         meta_.minTier = ITierProvider(_resolver.resolve("tier_provider", false)).getMinTier( 

237:             IERC20 tko = IERC20(_resolver.resolve("taiko_token", false)); 
238:             uint256 tkoBalance = tko.balanceOf(address(this));

268:             if (tko.balanceOf(address(this)) != tkoBalance + _config.livenessBond) { 

309:             address proposerOne = _resolver.resolve("proposer_one", true); 

315:         address proposer = _resolver.resolve("proposer", true); 
```
[207](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProposing.sol#L207), [237](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProposing.sol#L237-L238), [268](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProposing.sol#L268), [309](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProposing.sol#L309), [315](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProposing.sol#L315)

```solidity
📁 File: contracts/L1/libs/LibProving.sol

141:             ITierProvider(_resolver.resolve("tier_provider", false)).getTier(_proof.tier); 

161:             address verifier = _resolver.resolve(tier.verifierName, true); 

187:         IERC20 tko = IERC20(_resolver.resolve("taiko_token", false)); 

196:                 tko.transfer(blk.assignedProver, blk.livenessBond); 

367:                 _tko.transfer(_ts.prover, _ts.validityBond + reward); 

371:                 _tko.transfer(_ts.contester, _ts.contestBond + reward); 

382:                 _tko.transfer(msg.sender, reward - _tier.validityBond); 
```
[141](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProving.sol#L141), [161](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProving.sol#L161), [187](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProving.sol#L187), [196](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProving.sol#L196), [367](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProving.sol#L367), [371](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProving.sol#L371), [382](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProving.sol#L382)

```solidity
📁 File: contracts/L1/libs/LibVerifying.sol

149:                         tierProvider = _resolver.resolve("tier_provider", false); 

152:                         uint256(ITierProvider(tierProvider).getTier(ts.tier).cooldownWindow) * 60 

188:                 IERC20 tko = IERC20(_resolver.resolve("taiko_token", false)); 
189:                 tko.transfer(ts.prover, bondToReturn);

232:         ISignalService signalService = ISignalService(_resolver.resolve("signal_service", false)); 
```
[149](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibVerifying.sol#L149), [152](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibVerifying.sol#L152), [188](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibVerifying.sol#L188-L189), [232](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibVerifying.sol#L232)

```solidity
📁 File: contracts/L1/provers/GuardianProver.sol

51:             ITaikoL1(resolve("taiko", false)).proveBlock(_meta.id, abi.encode(_meta, _tran, _proof)); 
```
[51](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/provers/GuardianProver.sol#L51)

```solidity
📁 File: contracts/L2/TaikoL2.sol

176:             IERC20(_token).safeTransfer(_to, IERC20(_token).balanceOf(address(this))); 
```
[176](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/TaikoL2.sol#L176)

```solidity
📁 File: contracts/automata-attestation/AutomataDcapV3Attestation.sol

424:                 (certDecodedSuccessfully, parsedQuoteCerts[i]) = pemCertLib.decodeCert( 
```
[424](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/AutomataDcapV3Attestation.sol#L424)

```solidity
📁 File: contracts/automata-attestation/lib/QuoteV3Auth/V3Parser.sol

278:             pemCertLib.splitCertificateChain(certBytes, 3); 
```
[278](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/QuoteV3Auth/V3Parser.sol#L278)

```solidity
📁 File: contracts/bridge/Bridge.sol

150:         ISignalService(resolve("signal_service", false)).sendSignal(msgHash_); 

174:             if (!ISignalService(signalService).isSignalSent(address(this), msgHash)) { 

199:                 IRecallableSender(_message.from).onMessageRecalled{ value: _message.value }( 

342:         return ISignalService(resolve("signal_service", false)).isSignalSent({ 

522:             ISignalService(resolve("signal_service", false)).sendSignal( 
```
[150](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/Bridge.sol#L150), [174](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/Bridge.sol#L174), [199](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/Bridge.sol#L199), [342](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/Bridge.sol#L342), [522](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/Bridge.sol#L522)

```solidity
📁 File: contracts/common/AddressResolver.sol

83:         addr_ = payable(IAddressManager(addressManager).getAddress(_chainId, _name)); 
```
[83](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/common/AddressResolver.sol#L83)

```solidity
📁 File: contracts/libs/LibAddress.sol

56:         try IERC165(_addr).supportsInterface(_interfaceId) returns (bool _result) { 

71:             return IERC1271(_addr).isValidSignature(_hash, _sig) == _EIP1271_MAGICVALUE; 
```
[56](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/libs/LibAddress.sol#L56), [71](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/libs/LibAddress.sol#L71)

```solidity
📁 File: contracts/tokenvault/BridgedERC20Base.sol

82:             IBridgedERC20(migratingAddress).mint(_account, _amount); 
```
[82](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC20Base.sol#L82)

```solidity
📁 File: contracts/tokenvault/ERC1155Vault.sol

77:             IBridge(resolve("bridge", false)).sendMessage{ value: msg.value }(message); 

281:             this.onMessageInvocation, abi.encode(ctoken_, _user, _op.to, _op.tokenIds, _op.amounts) 
```
[77](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC1155Vault.sol#L77), [281](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC1155Vault.sol#L281)

```solidity
📁 File: contracts/tokenvault/ERC20Vault.sol

184:             IBridgedERC20(btokenOld_).changeMigrationStatus(_btokenNew, false); 
185:             IBridgedERC20(_btokenNew).changeMigrationStatus(btokenOld_, true);

239:             IBridge(resolve("bridge", false)).sendMessage{ value: msg.value }(message); 

333:             IBridgedERC20(token_).mint(_to, _amount); 

360:             IBridgedERC20(_token).burn(msg.sender, _amount); 

378:             uint256 _balance = t.balanceOf(address(this)); 

380:             balanceChange_ = t.balanceOf(address(this)) - _balance; 

384:             this.onMessageInvocation, abi.encode(ctoken_, _user, _to, balanceChange_) 
```
[184](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC20Vault.sol#L184-L185), [239](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC20Vault.sol#L239), [333](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC20Vault.sol#L333), [360](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC20Vault.sol#L360), [378](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC20Vault.sol#L378), [380](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC20Vault.sol#L380), [384](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC20Vault.sol#L384)

```solidity
📁 File: contracts/tokenvault/ERC721Vault.sol

62:             IBridge(resolve("bridge", false)).sendMessage{ value: msg.value }(message); 

176:                 BridgedERC721(token_).mint(_to, _tokenIds[i]); 

198:                     BridgedERC721(_op.token).burn(_user, _op.tokenIds[i]); 

217:             this.onMessageInvocation, abi.encode(ctoken_, _user, _op.to, _op.tokenIds) 
```
[62](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC721Vault.sol#L62), [176](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC721Vault.sol#L176), [198](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC721Vault.sol#L198), [217](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC721Vault.sol#L217)

```solidity
📁 File: contracts/tokenvault/adapters/USDCAdapter.sol

44:         usdc.mint(_account, _amount); 

49:         usdc.burn(_amount); 
```
[44](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/adapters/USDCAdapter.sol#L44), [49](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/adapters/USDCAdapter.sol#L49)

```solidity
📁 File: contracts/verifiers/SgxVerifier.sol

128:         (bool verified,) = IAttestation(automataDcapAttestation).verifyParsedQuote(_attestation); 
```
[128](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/verifiers/SgxVerifier.sol#L128)

</details>


---
### [GAS&#x2011;83] Use assembly to perform efficient back-to-back calls
If a similar external call is performed back-to-back, we can use assembly to reuse any function signatures and function parameters that stay the same. In addition, we can also reuse the same memory space for each function call (`scratch space` + `free memory pointer` + `zero slot`), which can potentially allow us to avoid memory expansion costs.


Gas saved per Instance: ~300 *(Total: ~600)*

<i>There are 2 instaces of this issue:</i>

```solidity
📁 File: contracts/bridge/Bridge.sol

295:                 refundTo.sendEther(_message.fee + refundAmount); 

299:                 refundTo.sendEther(refundAmount); 
```
[295](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/Bridge.sol#L295), [299](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/Bridge.sol#L299)


---
### [GAS&#x2011;84] Use assembly to validate `msg.sender`
We can use assembly to efficiently validate msg.sender with the least amount of opcodes necessary. For more details check the following report [Here](https://code4rena.com/reports/2023-05-juicebox#g-06-use-assembly-to-validate-msgsender)


Gas saved per Instance: ~12 *(Total: ~144)*
<details>
<summary><i>There are 12 instances of this issue:</i></summary>

```solidity
📁 File: contracts/L1/libs/LibProposing.sol

310:             if (proposerOne != address(0) && msg.sender != proposerOne) { 
```
[310](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProposing.sol#L310)

```solidity
📁 File: contracts/L2/TaikoL2.sol

123:         if (msg.sender != GOLDEN_TOUCH_ADDRESS) revert L2_INVALID_SENDER(); 
```
[123](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/TaikoL2.sol#L123)

```solidity
📁 File: contracts/bridge/Bridge.sol

250:         if (invocationDelay != 0 && msg.sender != proofReceipt[msgHash].preferredExecutor) { 

260:             if (_message.gasLimit == 0 && msg.sender != _message.destOwner) { 

294:             if (msg.sender == refundTo) { 

322:             if (msg.sender != _message.destOwner) revert B_PERMISSION_DENIED(); 
```
[250](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/Bridge.sol#L250), [260](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/Bridge.sol#L260), [294](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/Bridge.sol#L294), [322](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/Bridge.sol#L322)

```solidity
📁 File: contracts/signal/SignalService.sol

77:         if (!isAuthorized[msg.sender]) revert SS_UNAUTHORIZED(); 
```
[77](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/signal/SignalService.sol#L77)

```solidity
📁 File: contracts/tokenvault/BaseVault.sol

65:         if (ctx_.from != msg.sender) revert VAULT_PERMISSION_DENIED(); 
```
[65](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BaseVault.sol#L65)

```solidity
📁 File: contracts/tokenvault/BridgedERC20Base.sol

61:         if (msg.sender == migratingAddress) { 

64:         } else if (msg.sender != resolve("erc20_vault", true)) { 

78:             if (msg.sender != _account) revert BB_PERMISSION_DENIED(); 

83:         } else if (msg.sender != resolve("erc20_vault", true)) { 
```
[61](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC20Base.sol#L61), [64](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC20Base.sol#L64), [78](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC20Base.sol#L78), [83](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC20Base.sol#L83)

</details>


---
### [GAS&#x2011;85] Use `assembly` to write address/contract storage values
Using `assembly { sstore(state.slot, addr) }` instead of `state = addr` can save gas.


Gas saved per Instance: ~50 *(Total: ~2,800)*
<details>
<summary><i>There are 56 instances of this issue:</i></summary>

```solidity
📁 File: contracts/L1/libs/LibProposing.sol

86:             params.coinbase = msg.sender; 

257:                 prevHook = params.hookCalls[i].hook; 
```
[86](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProposing.sol#L86), [257](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProposing.sol#L257)

```solidity
📁 File: contracts/L1/libs/LibProving.sol

226:                 ts.prover = msg.sender; 

251:                 ts.contester = msg.sender; 

303:             ts_.contester = address(0); 

327:                 ts_.prover = _blk.assignedProver; 

332:                 ts_.prover = address(0); 

390:         _ts.contester = address(0); 
391:         _ts.prover = msg.sender;
```
[226](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProving.sol#L226), [251](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProving.sol#L251), [303](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProving.sol#L303), [327](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProving.sol#L327), [332](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProving.sol#L332), [390](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProving.sol#L390-L391)

```solidity
📁 File: contracts/L1/libs/LibVerifying.sol

70:         ts.prover = address(0); 

149:                         tierProvider = _resolver.resolve("tier_provider", false); 
```
[70](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibVerifying.sol#L70), [149](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibVerifying.sol#L149)

```solidity
📁 File: contracts/automata-attestation/AutomataDcapV3Attestation.sol

57:         owner = msg.sender; 
```
[57](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/AutomataDcapV3Attestation.sol#L57)

```solidity
📁 File: contracts/automata-attestation/utils/SigVerifyLib.sol

21:         ES256VERIFIER = es256Verifier; 
```
[21](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/SigVerifyLib.sol#L21)

```solidity
📁 File: contracts/bridge/Bridge.sol

145:         message_.from = msg.sender; 

397:         destBridge_ = resolve(_chainId, "bridge", true); 
```
[145](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/Bridge.sol#L145), [397](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/Bridge.sol#L397)

```solidity
📁 File: contracts/common/AddressManager.sol

49:         __addresses[_chainId][_name] = _newAddress; 
```
[49](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/common/AddressManager.sol#L49)

```solidity
📁 File: contracts/common/AddressResolver.sol

62:         addressManager = _addressManager; 
```
[62](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/common/AddressResolver.sol#L62)

```solidity
📁 File: contracts/signal/SignalService.sol

112:                 signalService = address(this); 

117:                 signalService = resolve(hop.chainId, "signal_service", false); 

128:             app = signalService; 
```
[112](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/signal/SignalService.sol#L112), [117](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/signal/SignalService.sol#L117), [128](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/signal/SignalService.sol#L128)

```solidity
📁 File: contracts/team/TimelockTokenPool.sol

122:         taikoToken = _taikoToken; 

125:         costToken = _costToken; 

128:         sharedVault = _sharedVault; 
```
[122](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/TimelockTokenPool.sol#L122), [125](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/TimelockTokenPool.sol#L125), [128](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/TimelockTokenPool.sol#L128)

```solidity
📁 File: contracts/team/airdrop/ERC20Airdrop.sol

41:         token = _token; 
42:         vault = _vault;
```
[41](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/airdrop/ERC20Airdrop.sol#L41-L42)

```solidity
📁 File: contracts/team/airdrop/ERC20Airdrop2.sol

69:         token = _token; 
70:         vault = _vault;
```
[69](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/airdrop/ERC20Airdrop2.sol#L69-L70)

```solidity
📁 File: contracts/team/airdrop/ERC721Airdrop.sol

39:         token = _token; 
40:         vault = _vault;
```
[39](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/airdrop/ERC721Airdrop.sol#L39-L40)

```solidity
📁 File: contracts/tokenvault/BridgedERC1155.sol

56:         srcToken = _srcToken; 
```
[56](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC1155.sol#L56)

```solidity
📁 File: contracts/tokenvault/BridgedERC20.sol

73:         srcToken = _srcToken; 

81:         snapshooter = _snapshooter; 
```
[73](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC20.sol#L73), [81](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC20.sol#L81)

```solidity
📁 File: contracts/tokenvault/BridgedERC20Base.sol

49:         migratingAddress = _migratingAddress; 
```
[49](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC20Base.sol#L49)

```solidity
📁 File: contracts/tokenvault/BridgedERC721.sol

47:         srcToken = _srcToken; 
```
[47](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC721.sol#L47)

```solidity
📁 File: contracts/tokenvault/ERC1155Vault.sol

225:             token = ctoken.addr; 

229:             token = _getOrDeployBridgedToken(ctoken); 

292:         btoken_ = canonicalToBridged[_ctoken.chainId][_ctoken.addr]; 

294:             btoken_ = _deployBridgedToken(_ctoken); 

309:         btoken_ = address(new ERC1967Proxy(resolve("bridged_erc1155", false), data)); 

312:         canonicalToBridged[_ctoken.chainId][_ctoken.addr] = btoken_; 
```
[225](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC1155Vault.sol#L225), [229](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC1155Vault.sol#L229), [292](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC1155Vault.sol#L292), [294](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC1155Vault.sol#L294), [309](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC1155Vault.sol#L309), [312](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC1155Vault.sol#L312)

```solidity
📁 File: contracts/tokenvault/ERC20Vault.sol

168:         btokenOld_ = canonicalToBridged[_ctoken.chainId][_ctoken.addr]; 

189:         canonicalToBridged[_ctoken.chainId][_ctoken.addr] = _btokenNew; 

329:             token_ = _ctoken.addr; 

332:             token_ = _getOrDeployBridgedToken(_ctoken); 

395:         btoken = canonicalToBridged[ctoken.chainId][ctoken.addr]; 

398:             btoken = _deployBridgedToken(ctoken); 

421:         btoken = address(new ERC1967Proxy(resolve("bridged_erc20", false), data)); 

423:         canonicalToBridged[ctoken.chainId][ctoken.addr] = btoken; 
```
[168](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC20Vault.sol#L168), [189](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC20Vault.sol#L189), [329](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC20Vault.sol#L329), [332](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC20Vault.sol#L332), [395](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC20Vault.sol#L395), [398](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC20Vault.sol#L398), [421](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC20Vault.sol#L421), [423](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC20Vault.sol#L423)

```solidity
📁 File: contracts/tokenvault/ERC721Vault.sol

169:             token_ = _ctoken.addr; 

174:             token_ = _getOrDeployBridgedToken(_ctoken); 

228:         btoken_ = canonicalToBridged[_ctoken.chainId][_ctoken.addr]; 

231:             btoken_ = _deployBridgedToken(_ctoken); 

246:         btoken_ = address(new ERC1967Proxy(resolve("bridged_erc721", false), data)); 

248:         canonicalToBridged[_ctoken.chainId][_ctoken.addr] = btoken_; 
```
[169](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC721Vault.sol#L169), [174](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC721Vault.sol#L174), [228](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC721Vault.sol#L228), [231](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC721Vault.sol#L231), [246](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC721Vault.sol#L246), [248](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC721Vault.sol#L248)

```solidity
📁 File: contracts/tokenvault/adapters/USDCAdapter.sol

40:         usdc = _usdc; 
```
[40](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/adapters/USDCAdapter.sol#L40)

```solidity
📁 File: contracts/verifiers/SgxVerifier.sol

133:         _address[0] = address(bytes20(_attestation.localEnclaveReport.reportData)); 
```
[133](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/verifiers/SgxVerifier.sol#L133)

</details>


---
### [GAS&#x2011;86] Use `calldata` instead of `memory` for function arguments that do not get mutated
Mark data types as `calldata` instead of `memory` where possible. This makes it so that the data is not automatically loaded into memory. If the data passed into the function does not need to be changed (like updating values in an array), it can be passed in as `calldata`. The one exception to this is if the argument must later be passed into another function that takes an argument that specifies `memory` storage.


Gas saved per Instance: ~300 *(Total: ~21,000)*
<details>
<summary><i>There are 70 instances of this issue:</i></summary>

```solidity
📁 File: contracts/L1/gov/TaikoGovernor.sol

/// @audit _targets
/// @audit _values
/// @audit _calldatas
/// @audit _description
48:     function propose( 
49:         address[] memory _targets,
50:         uint256[] memory _values,
51:         bytes[] memory _calldatas,
52:         string memory _description
53:     )
54:         public
55:         override(IGovernorUpgradeable, GovernorUpgradeable, GovernorCompatibilityBravoUpgradeable)
56:         returns (uint256)
57:     {

/// @audit _targets
/// @audit _values
/// @audit _signatures
/// @audit _calldatas
/// @audit _description
69:     function propose( 
70:         address[] memory _targets,
71:         uint256[] memory _values,
72:         string[] memory _signatures,
73:         bytes[] memory _calldatas,
74:         string memory _description
75:     )
76:         public
77:         virtual
78:         override(GovernorCompatibilityBravoUpgradeable)
79:         returns (uint256)
80:     {
```
[48](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/gov/TaikoGovernor.sol#L48-L57), [69](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/gov/TaikoGovernor.sol#L69-L80)

```solidity
📁 File: contracts/L1/hooks/AssignmentHook.sol

/// @audit _blk
/// @audit _meta
/// @audit _data
62:     function onBlockProposed( 
63:         TaikoData.Block memory _blk,
64:         TaikoData.BlockMetadata memory _meta,
65:         bytes memory _data
66:     )
67:         external
68:         payable
69:         nonReentrant
70:         onlyFromNamed("taiko")
71:     {

/// @audit _assignment
137:     function hashAssignment( 
138:         ProverAssignment memory _assignment,
139:         address _taikoL1Address,
140:         bytes32 _blobHash
141:     )
142:         public
143:         view
144:         returns (bytes32)
145:     {
```
[62](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/hooks/AssignmentHook.sol#L62-L71), [137](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/hooks/AssignmentHook.sol#L137-L145)

```solidity
📁 File: contracts/L1/hooks/IHook.sol

/// @audit _blk
/// @audit _meta
/// @audit _data
13:     function onBlockProposed( 
```
[13](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/hooks/IHook.sol#L13)

```solidity
📁 File: contracts/L1/libs/LibUtils.sol

/// @audit _config
23:     function getTransition( 
24:         TaikoData.State storage _state,
25:         TaikoData.Config memory _config,
26:         uint64 _blockId,
27:         bytes32 _parentHash
28:     )
29:         external
30:         view
31:         returns (TaikoData.TransitionState storage)
32:     {

/// @audit _config
52:     function getBlock( 
53:         TaikoData.State storage _state,
54:         TaikoData.Config memory _config,
55:         uint64 _blockId
56:     )
57:         external
58:         view
59:         returns (TaikoData.Block storage blk_, uint64 slot_)
60:     {
```
[23](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibUtils.sol#L23-L32), [52](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibUtils.sol#L52-L60)

```solidity
📁 File: contracts/L1/libs/LibVerifying.sol

/// @audit _config
47:     function init( 
48:         TaikoData.State storage _state,
49:         TaikoData.Config memory _config,
50:         bytes32 _genesisBlockHash
51:     )
52:         external
53:     {
```
[47](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibVerifying.sol#L47-L53)

```solidity
📁 File: contracts/L1/provers/Guardians.sol

/// @audit _newGuardians
53:     function setGuardians( 
54:         address[] memory _newGuardians,
55:         uint8 _minGuardians
56:     )
57:         external
58:         onlyOwner
59:         nonReentrant
60:     {
```
[53](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/provers/Guardians.sol#L53-L60)

```solidity
📁 File: contracts/L2/TaikoL2EIP1559Configurable.sol

/// @audit _newConfig
25:     function setConfigAndExcess( 
26:         Config memory _newConfig,
27:         uint64 _newGasExcess
28:     )
29:         external
30:         virtual
31:         onlyOwner
32:     {
```
[25](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/TaikoL2EIP1559Configurable.sol#L25-L32)

```solidity
📁 File: contracts/automata-attestation/interfaces/ISigVerifyLib.sol

/// @audit tbs
/// @audit signature
/// @audit publicKey
38:     function verifyAttStmtSignature( 

/// @audit tbs
/// @audit signature
/// @audit publicKey
48:     function verifyCertificateSignature( 

/// @audit tbs
/// @audit signature
/// @audit publicKey
58:     function verifyRS256Signature( 

/// @audit tbs
/// @audit signature
/// @audit publicKey
67:     function verifyRS1Signature( 

/// @audit tbs
/// @audit signature
/// @audit publicKey
76:     function verifyES256Signature( 
```
[38](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/interfaces/ISigVerifyLib.sol#L38), [48](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/interfaces/ISigVerifyLib.sol#L48), [58](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/interfaces/ISigVerifyLib.sol#L58), [67](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/interfaces/ISigVerifyLib.sol#L67), [76](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/interfaces/ISigVerifyLib.sol#L76)

```solidity
📁 File: contracts/automata-attestation/lib/PEMCertChainLib.sol

/// @audit pemChain
40:     function splitCertificateChain( 
41:         bytes memory pemChain,
42:         uint256 size
43:     )
44:         external
45:         pure
46:         returns (bool success, bytes[] memory certs)
47:     {

/// @audit der
74:     function decodeCert( 
75:         bytes memory der,
76:         bool isPckCert
77:     )
78:         external
79:         pure
80:         returns (bool success, ECSha256Certificate memory cert)
81:     {
```
[40](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/PEMCertChainLib.sol#L40-L47), [74](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/PEMCertChainLib.sol#L74-L81)

```solidity
📁 File: contracts/automata-attestation/lib/interfaces/IPEMCertChainLib.sol

/// @audit pemChain
36:     function splitCertificateChain( 

/// @audit der
44:     function decodeCert( 
```
[36](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/interfaces/IPEMCertChainLib.sol#L36), [44](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/interfaces/IPEMCertChainLib.sol#L44)

```solidity
📁 File: contracts/automata-attestation/utils/SigVerifyLib.sol

/// @audit tbs
/// @audit signature
/// @audit publicKey
24:     function verifyAttStmtSignature( 
25:         bytes memory tbs,
26:         bytes memory signature,
27:         PublicKey memory publicKey,
28:         Algorithm alg
29:     )
30:         public
31:         view
32:         returns (bool)
33:     {

/// @audit tbs
/// @audit signature
/// @audit publicKey
54:     function verifyCertificateSignature( 
55:         bytes memory tbs,
56:         bytes memory signature,
57:         PublicKey memory publicKey,
58:         CertSigAlgorithm alg
59:     )
60:         public
61:         view
62:         returns (bool)
63:     {

/// @audit tbs
/// @audit signature
/// @audit publicKey
79:     function verifyRS256Signature( 
80:         bytes memory tbs,
81:         bytes memory signature,
82:         bytes memory publicKey
83:     )
84:         public
85:         view
86:         returns (bool sigValid)
87:     {

/// @audit tbs
/// @audit signature
/// @audit publicKey
96:     function verifyRS1Signature( 
97:         bytes memory tbs,
98:         bytes memory signature,
99:         bytes memory publicKey
100:     )
101:         public
102:         view
103:         returns (bool sigValid)
104:     {

/// @audit tbs
/// @audit signature
/// @audit publicKey
113:     function verifyES256Signature( 
114:         bytes memory tbs,
115:         bytes memory signature,
116:         bytes memory publicKey
117:     )
118:         public
119:         view
120:         returns (bool sigValid)
121:     {
```
[24](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/SigVerifyLib.sol#L24-L33), [54](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/SigVerifyLib.sol#L54-L63), [79](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/SigVerifyLib.sol#L79-L87), [96](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/SigVerifyLib.sol#L96-L104), [113](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/SigVerifyLib.sol#L113-L121)

```solidity
📁 File: contracts/bridge/Bridge.sol

/// @audit _message
449:     function hashMessage(Message memory _message) public pure returns (bytes32) { 
```
[449](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/Bridge.sol#L449)

```solidity
📁 File: contracts/bridge/IBridge.sol

/// @audit _message
155:     function hashMessage(Message memory _message) external pure returns (bytes32); 
```
[155](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/IBridge.sol#L155)

```solidity
📁 File: contracts/team/TimelockTokenPool.sol

/// @audit _grant
135:     function grant(address _recipient, Grant memory _grant) external onlyOwner { 

/// @audit _sig
168:     function withdraw(address _to, bytes memory _sig) external { 
```
[135](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/TimelockTokenPool.sol#L135), [168](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/TimelockTokenPool.sol#L168)

```solidity
📁 File: contracts/tokenvault/BridgedERC1155.sol

/// @audit _symbol
/// @audit _name
38:     function init( 
39:         address _owner,
40:         address _addressManager,
41:         address _srcToken,
42:         uint256 _srcChainId,
43:         string memory _symbol,
44:         string memory _name
45:     )
46:         external
47:         initializer
48:     {

/// @audit _tokenIds
/// @audit _amounts
83:     function mintBatch( 
84:         address _to,
85:         uint256[] memory _tokenIds,
86:         uint256[] memory _amounts
87:     )
88:         public
89:         nonReentrant
90:         whenNotPaused
91:         onlyFromNamed("erc1155_vault")
92:     {
```
[38](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC1155.sol#L38-L48), [83](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC1155.sol#L83-L92)

```solidity
📁 File: contracts/tokenvault/BridgedERC20.sol

/// @audit _symbol
/// @audit _name
52:     function init( 
53:         address _owner,
54:         address _addressManager,
55:         address _srcToken,
56:         uint256 _srcChainId,
57:         uint8 _decimals,
58:         string memory _symbol,
59:         string memory _name
60:     )
61:         external
62:         initializer
63:     {
```
[52](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC20.sol#L52-L63)

```solidity
📁 File: contracts/tokenvault/BridgedERC721.sol

/// @audit _symbol
/// @audit _name
31:     function init( 
32:         address _owner,
33:         address _addressManager,
34:         address _srcToken,
35:         uint256 _srcChainId,
36:         string memory _symbol,
37:         string memory _name
38:     )
39:         external
40:         initializer
41:     {
```
[31](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC721.sol#L31-L41)

```solidity
📁 File: contracts/tokenvault/ERC1155Vault.sol

/// @audit _op
39:     function sendToken(BridgeTransferOp memory _op) 
40:         external
41:         payable
42:         nonReentrant
43:         whenNotPaused
44:         withValidOperation(_op)
45:         returns (IBridge.Message memory message_)
46:     {
```
[39](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC1155Vault.sol#L39-L46)

```solidity
📁 File: contracts/tokenvault/ERC721Vault.sol

/// @audit _op
26:     function sendToken(BridgeTransferOp memory _op) 
27:         external
28:         payable
29:         nonReentrant
30:         whenNotPaused
31:         withValidOperation(_op)
32:         returns (IBridge.Message memory message_)
33:     {
```
[26](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC721Vault.sol#L26-L33)

```solidity
📁 File: contracts/verifiers/SgxVerifier.sol

/// @audit _tran
171:     function getSignedHash( 
172:         TaikoData.Transition memory _tran,
173:         address _newInstance,
174:         address _prover,
175:         bytes32 _metaHash
176:     )
177:         public
178:         view
179:         returns (bytes32)
180:     {
```
[171](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/verifiers/SgxVerifier.sol#L171-L180)

</details>


---
### [GAS&#x2011;87] Use constants instead of `type(uint<n>).max` / `.min`

Gas saved per Instance: ~4 *(Total: ~40)*
<details>
<summary><i>There are 10 instances of this issue:</i></summary>

```solidity
📁 File: contracts/L1/libs/LibDepositing.sol

/// @audit 0xFFFFFFFFFFFFFFFFFFFFFFFF
150:         if (_amount > type(uint96).max) revert L1_INVALID_ETH_DEPOSIT(); 
```
[150](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibDepositing.sol#L150)

```solidity
📁 File: contracts/L1/libs/LibVerifying.sol

/// @audit 0xFFFFFFFFFFFFFFFFFFFFFFFF
260:                 || _config.ethDepositMaxAmount > type(uint96).max || _config.ethDepositGas == 0 

/// @audit 0xFFFFFFFFFFFFFFFFFFFFFFFF
262:                 || _config.ethDepositMaxFee > type(uint96).max / _config.ethDepositMaxCountPerBlock 
```
[260](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibVerifying.sol#L260), [262](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibVerifying.sol#L262)

```solidity
📁 File: contracts/L1/provers/Guardians.sol

/// @audit 0xFF
63:         if (_newGuardians.length < MIN_NUM_GUARDIANS || _newGuardians.length > type(uint8).max) { 
```
[63](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/provers/Guardians.sol#L63)

```solidity
📁 File: contracts/L2/TaikoL2.sol

/// @audit 0xFFFFFFFFFFFFFFFF
82:         if (block.chainid <= 1 || block.chainid > type(uint64).max) { 

/// @audit 0xFFFFFFFFFFFFFFFF
284:             gasExcess_ = uint64(excess.min(type(uint64).max)); 
```
[82](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/TaikoL2.sol#L82), [284](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/TaikoL2.sol#L284)

```solidity
📁 File: contracts/automata-attestation/utils/BytesUtils.sol

/// @audit 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
91:                     mask = type(uint256).max; // aka 0xffffff.... 
```
[91](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/BytesUtils.sol#L91)

```solidity
📁 File: contracts/bridge/Bridge.sol

/// @audit 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
27:     uint256 internal constant PLACEHOLDER = type(uint256).max; 

/// @audit 0xFFFFFFFFFFFFFFFF
89:         uint64 _timestamp = _suspend ? type(uint64).max : uint64(block.timestamp); 
```
[27](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/Bridge.sol#L27), [89](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/Bridge.sol#L89)

```solidity
📁 File: contracts/common/AddressResolver.sol

/// @audit 0xFFFFFFFFFFFFFFFF
59:         if (block.chainid > type(uint64).max) { 
```
[59](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/common/AddressResolver.sol#L59)

</details>


---
### [GAS&#x2011;88] Use custom errors rather than `revert()`/`require()` strings to save gas
[Source](https://blog.soliditylang.org/2021/04/21/custom-errors/)
Instead of using error strings, to reduce deployment and runtime cost, you should use Custom Errors. This would save both deployment and runtime cost.


Gas saved per Instance: ~29 *(Total: ~1,914)*
<details>
<summary><i>There are 66 instances of this issue:</i></summary>

```solidity
📁 File: contracts/automata-attestation/AutomataDcapV3Attestation.sol

61:         require(msg.sender == owner, "onlyOwner"); 
```
[61](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/AutomataDcapV3Attestation.sol#L61)

```solidity
📁 File: contracts/automata-attestation/lib/QuoteV3Auth/V3Parser.sol

77:         require( 
78:             localEnclaveReport.reserved3.length == 96 && localEnclaveReport.reserved4.length == 60
79:                 && localEnclaveReport.reportData.length == 64,
80:             "local QE report has wrong length"
81:         );
82:         require(
83:             pckSignedQeReport.reserved3.length == 96 && pckSignedQeReport.reserved4.length == 60
84:                 && pckSignedQeReport.reportData.length == 64,
85:             "QE report has wrong length"
86:         );
87:         require(
88:             v3Quote.v3AuthData.certification.certType == 5,
89:             "certType must be 5: Concatenated PCK Cert Chain (PEM formatted)"
90:         );
91:         require(
92:             v3Quote.v3AuthData.certification.decodedCertDataArray.length == 3, "3 certs in chain"
93:         );
94:         require(
95:             v3Quote.v3AuthData.ecdsa256BitSignature.length == 64
96:                 && v3Quote.v3AuthData.ecdsaAttestationKey.length == 64
97:                 && v3Quote.v3AuthData.qeReportSignature.length == 64,
98:             "Invalid ECDSA signature format"
99:         );
100:         require(
101:             v3Quote.v3AuthData.qeAuthData.parsedDataSize
102:                 == v3Quote.v3AuthData.qeAuthData.data.length,
103:             "Invalid QEAuthData size"
104:         );

116:         require(totalQuoteSize >= MINIMUM_QUOTE_LENGTH, "Invalid quote size"); 

279:         require(certParsedSuccessfully, "splitCertificateChain failed"); 
```
[77](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/QuoteV3Auth/V3Parser.sol#L77-L104), [116](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/QuoteV3Auth/V3Parser.sol#L116), [279](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/QuoteV3Auth/V3Parser.sol#L279)

```solidity
📁 File: contracts/automata-attestation/utils/Asn1Decode.sol

57:         require(der[ptr.ixs()] == 0x03, "Not type BIT STRING"); 

67:         require(der[ptr.ixs()] == 0x04, "Not type OCTET STRING"); 

88:         require(der[ptr.ixs()] & 0x20 == 0x20, "Not a constructed type"); 

142:         require(der[ptr.ixs()] == 0x02, "Not type INTEGER"); 
143:         require(der[ptr.ixf()] & 0x80 == 0, "Not positive");

155:         require(der[ptr.ixs()] == 0x02, "Not type INTEGER"); 
156:         require(der[ptr.ixf()] & 0x80 == 0, "Not positive");

180:         require(der[ptr.ixs()] == 0x03, "ixs Not type BIT STRING 0x03"); 

182:         require(der[ptr.ixf()] == 0x00, "ixf Not 0"); 
```
[57](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/Asn1Decode.sol#L57), [67](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/Asn1Decode.sol#L67), [88](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/Asn1Decode.sol#L88), [142](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/Asn1Decode.sol#L142-L143), [155](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/Asn1Decode.sol#L155-L156), [180](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/Asn1Decode.sol#L180), [182](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/Asn1Decode.sol#L182)

```solidity
📁 File: contracts/automata-attestation/utils/BytesUtils.sol

25:         require(offset + len <= self.length, "invalid offset"); 

199:         require(idx + 2 <= self.length, "invalid idx"); 

212:         require(idx + 4 <= self.length, "unexpected idx"); 

225:         require(idx + 32 <= self.length, "unexpected idx"); 

238:         require(idx + 20 <= self.length, "unexpected idx"); 

264:         require(len <= 32, "unexpected len"); 
265:         require(idx + len <= self.length, "unexpected idx");

293:         require(offset + len <= self.length, "unexpected offset"); 

329:         require(len <= 52, "unexpected len"); 

335:             require(char >= 0x30 && char <= 0x7A, "invalid char"); 

337:             require(decoded <= 0x20, "invalid decoded"); 

365:             revert("unexpected len"); 
```
[25](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/BytesUtils.sol#L25), [199](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/BytesUtils.sol#L199), [212](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/BytesUtils.sol#L212), [225](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/BytesUtils.sol#L225), [238](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/BytesUtils.sol#L238), [264](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/BytesUtils.sol#L264-L265), [293](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/BytesUtils.sol#L293), [329](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/BytesUtils.sol#L329), [335](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/BytesUtils.sol#L335), [337](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/BytesUtils.sol#L337), [365](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/BytesUtils.sol#L365)

```solidity
📁 File: contracts/automata-attestation/utils/SigVerifyLib.sol

50:             revert("Unsupported algorithm"); 

75:             revert("Unsupported algorithm"); 
```
[50](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/SigVerifyLib.sol#L50), [75](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/SigVerifyLib.sol#L75)

```solidity
📁 File: contracts/thirdparty/optimism/Bytes.sol

25:             require(_length + 31 >= _length, "slice_overflow"); 
26:             require(_start + _length >= _start, "slice_overflow");
27:             require(_bytes.length >= _start + _length, "slice_outOfBounds");
```
[25](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/Bytes.sol#L25-L27)

```solidity
📁 File: contracts/thirdparty/optimism/rlp/RLPReader.sol

37:         require( 
38:             _in.length > 0,
39:             "RLPReader: length of an RLP item must be greater than zero to be decodable"
40:         );

56:         require( 
57:             itemType == RLPItemType.LIST_ITEM,
58:             "RLPReader: decoded item type for list is not a list item"
59:         );

61:         require( 
62:             listOffset + listLength == _in.length,
63:             "RLPReader: list item has an invalid data remainder"
64:         );

112:         require( 
113:             itemType == RLPItemType.DATA_ITEM,
114:             "RLPReader: decoded item type for bytes is not a data item"
115:         );

117:         require( 
118:             _in.length == itemOffset + itemLength,
119:             "RLPReader: bytes value contains an invalid remainder"
120:         );

152:         require( 
153:             _in.length > 0,
154:             "RLPReader: length of an RLP item must be greater than zero to be decodable"
155:         );

172:             require( 
173:                 _in.length > strLen,
174:                 "RLPReader: length of content must be greater than string length (short string)"
175:             );

182:             require( 
183:                 strLen != 1 || firstByteOfContent >= 0x80,
184:                 "RLPReader: invalid prefix, single byte < 0x80 are not prefixed (short string)"
185:             );

192:             require( 
193:                 _in.length > lenOfStrLen,
194:                 "RLPReader: length of content must be > than length of string length (long string)"
195:             );

202:             require( 
203:                 firstByteOfContent != 0x00,
204:                 "RLPReader: length of content must not have any leading zeros (long string)"
205:             );

212:             require( 
213:                 strLen > 55,
214:                 "RLPReader: length of content must be greater than 55 bytes (long string)"
215:             );

217:             require( 
218:                 _in.length > lenOfStrLen + strLen,
219:                 "RLPReader: length of content must be greater than total length (long string)"
220:             );

228:             require( 
229:                 _in.length > listLen,
230:                 "RLPReader: length of content must be greater than list length (short list)"
231:             );

238:             require( 
239:                 _in.length > lenOfListLen,
240:                 "RLPReader: length of content must be > than length of list length (long list)"
241:             );

248:             require( 
249:                 firstByteOfContent != 0x00,
250:                 "RLPReader: length of content must not have any leading zeros (long list)"
251:             );

258:             require( 
259:                 listLen > 55,
260:                 "RLPReader: length of content must be greater than 55 bytes (long list)"
261:             );

263:             require( 
264:                 _in.length > lenOfListLen + listLen,
265:                 "RLPReader: length of content must be greater than total length (long list)"
266:             );
```
[37](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/rlp/RLPReader.sol#L37-L40), [56](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/rlp/RLPReader.sol#L56-L59), [61](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/rlp/RLPReader.sol#L61-L64), [112](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/rlp/RLPReader.sol#L112-L115), [117](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/rlp/RLPReader.sol#L117-L120), [152](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/rlp/RLPReader.sol#L152-L155), [172](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/rlp/RLPReader.sol#L172-L175), [182](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/rlp/RLPReader.sol#L182-L185), [192](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/rlp/RLPReader.sol#L192-L195), [202](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/rlp/RLPReader.sol#L202-L205), [212](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/rlp/RLPReader.sol#L212-L215), [217](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/rlp/RLPReader.sol#L217-L220), [228](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/rlp/RLPReader.sol#L228-L231), [238](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/rlp/RLPReader.sol#L238-L241), [248](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/rlp/RLPReader.sol#L248-L251), [258](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/rlp/RLPReader.sol#L258-L261), [263](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/rlp/RLPReader.sol#L263-L266)

```solidity
📁 File: contracts/thirdparty/optimism/trie/MerkleTrie.sol

77:         require(_key.length > 0, "MerkleTrie: empty key"); 

89:             require(currentKeyIndex <= key.length, "MerkleTrie: key index exceeds total key length"); 

93:                 require( 
94:                     Bytes.equal(abi.encodePacked(keccak256(currentNode.encoded)), currentNodeID),
95:                     "MerkleTrie: invalid root hash"
96:                 );

99:                 require( 
100:                     Bytes.equal(abi.encodePacked(keccak256(currentNode.encoded)), currentNodeID),
101:                     "MerkleTrie: invalid large internal hash"
102:                 );

105:                 require( 
106:                     Bytes.equal(currentNode.encoded, currentNodeID),
107:                     "MerkleTrie: invalid internal node hash"
108:                 );

119:                     require( 
120:                         value_.length > 0,
121:                         "MerkleTrie: value length must be greater than zero (branch)"
122:                     );

125:                     require( 
126:                         i == proof.length - 1,
127:                         "MerkleTrie: value node must be last node in proof (branch)"
128:                     );

150:                 require( 
151:                     pathRemainder.length == sharedNibbleLength,
152:                     "MerkleTrie: path remainder must share all nibbles with key"
153:                 );

162:                     require( 
163:                         keyRemainder.length == sharedNibbleLength,
164:                         "MerkleTrie: key remainder must be identical to path remainder"
165:                     );

172:                     require( 
173:                         value_.length > 0,
174:                         "MerkleTrie: value length must be greater than zero (leaf)"
175:                     );

178:                     require( 
179:                         i == proof.length - 1,
180:                         "MerkleTrie: value node must be last node in proof (leaf)"
181:                     );

191:                     revert("MerkleTrie: received a node with an unknown prefix"); 

194:                 revert("MerkleTrie: received an unparseable node"); 

198:         revert("MerkleTrie: ran out of proof elements"); 
```
[77](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/trie/MerkleTrie.sol#L77), [89](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/trie/MerkleTrie.sol#L89), [93](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/trie/MerkleTrie.sol#L93-L96), [99](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/trie/MerkleTrie.sol#L99-L102), [105](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/trie/MerkleTrie.sol#L105-L108), [119](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/trie/MerkleTrie.sol#L119-L122), [125](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/trie/MerkleTrie.sol#L125-L128), [150](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/trie/MerkleTrie.sol#L150-L153), [162](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/trie/MerkleTrie.sol#L162-L165), [172](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/trie/MerkleTrie.sol#L172-L175), [178](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/trie/MerkleTrie.sol#L178-L181), [191](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/trie/MerkleTrie.sol#L191), [194](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/trie/MerkleTrie.sol#L194), [198](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/trie/MerkleTrie.sol#L198)

</details>


---
### [GAS&#x2011;89] Use `if` statements instead of ternary operators
https://gist.github.com/notbozho/0d9f4dbc0026f8e7771a4fa39244f57e

<details>
<summary><i>There are 14 instances of this issue:</i></summary>

```solidity
📁 File: contracts/L1/libs/LibDepositing.sol

44:         address recipient_ = _recipient == address(0) ? msg.sender : _recipient; 

93:                 uint96 _fee = deposits_[i].amount > fee ? fee : deposits_[i].amount; 
```
[44](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibDepositing.sol#L44), [93](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibDepositing.sol#L93)

```solidity
📁 File: contracts/L2/TaikoL2.sol

281:                 excess = excess > issuance ? excess - issuance : 1; 
```
[281](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/TaikoL2.sol#L281)

```solidity
📁 File: contracts/automata-attestation/lib/PEMCertChainLib.sol

358:             uint16 svnValue = svnValueBytes.length < 2 
359:                 ? uint16(bytes2(svnValueBytes)) / 256
360:                 : uint16(bytes2(svnValueBytes));
```
[358](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/PEMCertChainLib.sol#L358-L360)

```solidity
📁 File: contracts/bridge/Bridge.sol

89:         uint64 _timestamp = _suspend ? type(uint64).max : uint64(block.timestamp); 

280:                 uint256 gasLimit = msg.sender == _message.destOwner ? gasleft() : _message.gasLimit; 

290:             address refundTo = 
291:                 _message.refundTo == address(0) ? _message.destOwner : _message.refundTo;
```
[89](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/Bridge.sol#L89), [280](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/Bridge.sol#L280), [290](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/Bridge.sol#L290-L291)

```solidity
📁 File: contracts/signal/SignalService.sol

124:             bytes32 kind = isFullProof ? LibSignals.STATE_ROOT : LibSignals.SIGNAL_ROOT; 

167:         blockId_ = _blockId != 0 ? _blockId : topBlockId[_chainId][_kind]; 
```
[124](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/signal/SignalService.sol#L124), [167](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/signal/SignalService.sol#L167)

```solidity
📁 File: contracts/thirdparty/optimism/trie/MerkleTrie.sol

221:         id_ = _node.length < 32 ? RLPReader.readRawBytes(_node) : RLPReader.readBytes(_node); 

243:         uint256 max = (_a.length < _b.length) ? _a.length : _b.length; 
```
[221](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/trie/MerkleTrie.sol#L221), [243](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/trie/MerkleTrie.sol#L243)

```solidity
📁 File: contracts/tokenvault/ERC1155Vault.sol

58:         IBridge.Message memory message = IBridge.Message({ 
59:             id: 0, // will receive a new value
60:             from: address(0), // will receive a new value
61:             srcChainId: 0, // will receive a new value
62:             destChainId: _op.destChainId,
63:             srcOwner: msg.sender,
64:             destOwner: _op.destOwner != address(0) ? _op.destOwner : msg.sender,
65:             to: resolve(_op.destChainId, name(), false),
66:             refundTo: _op.refundTo,
67:             value: msg.value - _op.fee,
68:             fee: _op.fee,
69:             gasLimit: _op.gasLimit,
70:             data: data,
71:             memo: _op.memo
72:         });
```
[58](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC1155Vault.sol#L58-L72)

```solidity
📁 File: contracts/tokenvault/ERC20Vault.sol

221:         IBridge.Message memory message = IBridge.Message({ 
222:             id: 0, // will receive a new value
223:             from: address(0), // will receive a new value
224:             srcChainId: 0, // will receive a new value
225:             destChainId: _op.destChainId,
226:             srcOwner: msg.sender,
227:             destOwner: _op.destOwner != address(0) ? _op.destOwner : msg.sender,
228:             to: resolve(_op.destChainId, name(), false),
229:             refundTo: _op.refundTo,
230:             value: msg.value - _op.fee,
231:             fee: _op.fee,
232:             gasLimit: _op.gasLimit,
233:             data: data,
234:             memo: _op.memo
235:         });
```
[221](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC20Vault.sol#L221-L235)

```solidity
📁 File: contracts/tokenvault/ERC721Vault.sol

44:         IBridge.Message memory message = IBridge.Message({ 
45:             id: 0, // will receive a new value
46:             from: address(0), // will receive a new value
47:             srcChainId: 0, // will receive a new value
48:             destChainId: _op.destChainId,
49:             srcOwner: msg.sender,
50:             destOwner: _op.destOwner != address(0) ? _op.destOwner : msg.sender,
51:             to: resolve(_op.destChainId, name(), false),
52:             refundTo: _op.refundTo,
53:             value: msg.value - _op.fee,
54:             fee: _op.fee,
55:             gasLimit: _op.gasLimit,
56:             data: data,
57:             memo: _op.memo
58:         });
```
[44](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC721Vault.sol#L44-L58)

</details>


---
### [GAS&#x2011;90] Use immutable when you have storage variable that is not going to change
<details>
<summary><i>There are 5 instances of this issue:</i></summary>

```solidity
📁 File: contracts/team/TimelockTokenPool.sol

68:     uint128 public totalAmountGranted; 

71:     uint128 public totalAmountVoided; 

74:     uint128 public totalAmountWithdrawn; 

77:     uint128 public totalCostPaid; 
```
[68](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/TimelockTokenPool.sol#L68), [71](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/TimelockTokenPool.sol#L71), [74](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/TimelockTokenPool.sol#L74), [77](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/TimelockTokenPool.sol#L77)

```solidity
📁 File: contracts/tokenvault/BridgedERC1155.sol

16:     address public srcToken; 
```
[16](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC1155.sol#L16)

</details>


---
### [GAS&#x2011;91] Use local variables for emitting
Emitted values should not be read from storage again. Instead, the existing values from memory should be used.


Gas saved per Instance: ~100 *(Total: ~700)*
<details>
<summary><i>There are 7 instances of this issue:</i></summary>

```solidity
📁 File: contracts/L1/provers/Guardians.sol

/// @audit version
95:         emit GuardiansUpdated(version, _newGuardians); 
```
[95](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/provers/Guardians.sol#L95)

```solidity
📁 File: contracts/L2/CrossChainOwned.sol

/// @audit nextTxId
53:         emit TransactionExecuted(nextTxId++, bytes4(txdata)); 
```
[53](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/CrossChainOwned.sol#L53)

```solidity
📁 File: contracts/L2/TaikoL2.sol

/// @audit gasExcess
157:         emit Anchored(blockhash(parentId), gasExcess); 
```
[157](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/TaikoL2.sol#L157)

```solidity
📁 File: contracts/tokenvault/BridgedERC20Base.sol

/// @audit migratingAddress
63:             emit MigratedTo(migratingAddress, _account, _amount); 

/// @audit migratingAddress
80:             emit MigratedTo(migratingAddress, _account, _amount); 
```
[63](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC20Base.sol#L63), [80](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC20Base.sol#L80)

```solidity
📁 File: contracts/verifiers/SgxVerifier.sol

/// @audit instances
109:             emit InstanceDeleted(idx, instances[idx].addr); 

/// @audit nextInstanceId
220:             emit InstanceAdded(nextInstanceId, _instances[i], address(0), validSince); 
```
[109](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/verifiers/SgxVerifier.sol#L109), [220](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/verifiers/SgxVerifier.sol#L220)

</details>


---
### [GAS&#x2011;92] Use modifiers rather than invoking functions to perform checks
In using modifiers, the solidity compiler would inline the operations of the modifier in the called function. Using functions to perform checks would incur two `JUMPI` instructions, plus the stack setup, which could cost up to **40 gas units**.

Implementing this change would increase deployment cost, but would reduce the gas cost of the called functions. In the long run, using modifiers would be cheaper.


Gas saved per Instance: ~40 *(Total: ~160)*
<details>
<summary><i>There are 4 instances of this issue:</i></summary>

```solidity
📁 File: contracts/libs/LibAddress.sol

/// @audit sendEther
42:     function sendEther(address _to, uint256 _amount) internal { 
43:         sendEther(_to, _amount, gasleft());
```
[42](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/libs/LibAddress.sol#L42-L43)

```solidity
📁 File: contracts/tokenvault/BridgedERC1155.sol

/// @audit validateInputs
38:     function init( 
39:         address _owner,
40:         address _addressManager,
41:         address _srcToken,
42:         uint256 _srcChainId,
43:         string memory _symbol,
44:         string memory _name
45:     )
46:         external
47:         initializer
48:     {
49:         // Check if provided parameters are valid.
50:         // The symbol and the name can be empty for ERC1155 tokens so we use some placeholder data
51:         // for them instead.
52:         LibBridgedToken.validateInputs(_srcToken, _srcChainId, "foo", "foo");
```
[38](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC1155.sol#L38-L52)

```solidity
📁 File: contracts/tokenvault/BridgedERC20.sol

/// @audit validateInputs
52:     function init( 
53:         address _owner,
54:         address _addressManager,
55:         address _srcToken,
56:         uint256 _srcChainId,
57:         uint8 _decimals,
58:         string memory _symbol,
59:         string memory _name
60:     )
61:         external
62:         initializer
63:     {
64:         // Check if provided parameters are valid
65:         LibBridgedToken.validateInputs(_srcToken, _srcChainId, _symbol, _name);
```
[52](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC20.sol#L52-L65)

```solidity
📁 File: contracts/tokenvault/BridgedERC721.sol

/// @audit validateInputs
31:     function init( 
32:         address _owner,
33:         address _addressManager,
34:         address _srcToken,
35:         uint256 _srcChainId,
36:         string memory _symbol,
37:         string memory _name
38:     )
39:         external
40:         initializer
41:     {
42:         // Check if provided parameters are valid
43:         LibBridgedToken.validateInputs(_srcToken, _srcChainId, _symbol, _name);
```
[31](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC721.sol#L31-L43)

</details>


---
### [GAS&#x2011;93] Use of `emit` inside a loop
Emitting an event inside a loop performs a LOG op N times, where N is the loop length. Consider refactoring the code to emit the event only once at the end of loop. **Gas savings should be multiplied by the average loop length.**


Gas saved per Instance: ~375 *(Total: ~1,125)*
<details>
<summary><i>There are 3 instances of this issue:</i></summary>

```solidity
📁 File: contracts/bridge/Bridge.sol

93:             emit MessageSuspended(msgHash, _suspend); 
```
[93](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/Bridge.sol#L93)

```solidity
📁 File: contracts/verifiers/SgxVerifier.sol

109:             emit InstanceDeleted(idx, instances[idx].addr); 

220:             emit InstanceAdded(nextInstanceId, _instances[i], address(0), validSince); 
```
[109](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/verifiers/SgxVerifier.sol#L109), [220](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/verifiers/SgxVerifier.sol#L220)

</details>


---
### [GAS&#x2011;94] Use `revert()` to gain maximum gas savings
If you dont need Error messages, or you want gain maximum gas savings - `revert()` is the cheapest way to revert a transaction in terms of gas.

```solidity
	revert(); // 117 gas
	require(false); // 132 gas
	revert CustomError(); // 157 gas
	assert(false); // 164 gas
	revert("Custom Error"); // 406 gas
	require(false, "Custom Error"); // 421 gas
```
The gas savings are calculated based on the average gas cost of the total instances of these functions in the contract, minus the gas cost of `revert()` which is 117 gas.


Gas saved per Instance: ~282.598 *(Total: ~68,954)*
<details>
<summary><i>There are 244 instances of this issue:</i></summary>

```solidity
📁 File: contracts/L1/TaikoL1.sol

29:         if (state.slotB.provingPaused) revert L1_PROVING_PAUSED(); 

35:         if (!_inNonReentrant()) revert L1_RECEIVE_DISABLED(); 

90:         if (_blockId != meta.id) revert L1_INVALID_BLOCK_ID(); 
```
[29](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/TaikoL1.sol#L29), [35](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/TaikoL1.sol#L35), [90](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/TaikoL1.sol#L90)

```solidity
📁 File: contracts/L1/TaikoToken.sol

61:         if (_to == address(this)) revert TKO_INVALID_ADDR(); 

79:         if (_to == address(this)) revert TKO_INVALID_ADDR(); 
```
[61](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/TaikoToken.sol#L61), [79](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/TaikoToken.sol#L79)

```solidity
📁 File: contracts/L1/gov/TaikoGovernor.sol

81:         if (_signatures.length != _calldatas.length) revert TG_INVALID_SIGNATURES_LENGTH(); 
```
[81](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/gov/TaikoGovernor.sol#L81)

```solidity
📁 File: contracts/L1/hooks/AssignmentHook.sol

88:             revert HOOK_ASSIGNMENT_EXPIRED(); 

97:             revert HOOK_ASSIGNMENT_INVALID_SIG(); 

175:         revert HOOK_TIER_NOT_FOUND(); 
```
[88](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/hooks/AssignmentHook.sol#L88), [97](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/hooks/AssignmentHook.sol#L97), [175](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/hooks/AssignmentHook.sol#L175)

```solidity
📁 File: contracts/L1/libs/LibDepositing.sol

38:             revert L1_INVALID_ETH_DEPOSIT(); 

150:         if (_amount > type(uint96).max) revert L1_INVALID_ETH_DEPOSIT(); 
```
[38](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibDepositing.sol#L38), [150](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibDepositing.sol#L150)

```solidity
📁 File: contracts/L1/libs/LibProposing.sol

82:             revert L1_INVALID_PROVER(); 

94:         if (!_isProposerPermitted(b, _resolver)) revert L1_UNAUTHORIZED(); 

99:             revert L1_TOO_MANY_BLOCKS(); 

109:             revert L1_UNEXPECTED_PARENT(); 

142:             if (!_config.blobAllowedForDA) revert L1_BLOB_FOR_DA_DISABLED(); 

145:                 if (!_config.blobReuseEnabled) revert L1_BLOB_REUSE_DISABLED(); 

149:                     revert L1_BLOB_NOT_REUSABLE(); 

159:                 if (meta_.blobHash == 0) revert L1_BLOB_NOT_FOUND(); 

172:                 revert L1_TXLIST_OFFSET(); 

182:             if (!LibAddress.isSenderEOA()) revert L1_PROPOSER_NOT_EOA(); 

186:                 revert L1_INVALID_PARAM(); 

196:             revert L1_TXLIST_SIZE(); 

246:                     revert L1_INVALID_HOOK(); 

269:                 revert L1_LIVENESS_BOND_NOT_RECEIVED(); 
```
[82](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProposing.sol#L82), [94](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProposing.sol#L94), [99](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProposing.sol#L99), [109](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProposing.sol#L109), [142](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProposing.sol#L142), [145](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProposing.sol#L145), [149](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProposing.sol#L149), [159](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProposing.sol#L159), [172](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProposing.sol#L172), [182](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProposing.sol#L182), [186](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProposing.sol#L186), [196](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProposing.sol#L196), [246](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProposing.sol#L246), [269](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProposing.sol#L269)

```solidity
📁 File: contracts/L1/libs/LibProving.sol

74:         if (_state.slotB.provingPaused == _pause) revert L1_INVALID_PAUSE_STATUS(); 

106:             revert L1_INVALID_TRANSITION(); 

112:             revert L1_INVALID_BLOCK_ID(); 

122:             revert L1_BLOCK_MISMATCH(); 

135:             revert L1_INVALID_TIER(); 

182:                 revert L1_MISSING_VERIFIER(); 

219:             if (sameTransition) revert L1_ALREADY_PROVED(); 

223:                 assert(tier.validityBond == 0); 
224:                 assert(ts.validityBond == 0 && ts.contestBond == 0 && ts.contester == address(0));

239:                 if (ts.contester != address(0)) revert L1_ALREADY_CONTESTED(); 

374:             if (_sameTransition) revert L1_ALREADY_PROVED(); 

420:             if (!isAssignedPover) revert L1_NOT_ASSIGNED_PROVER(); 

424:             if (isAssignedPover) revert L1_ASSIGNED_PROVER_NOT_ALLOWED(); 
```
[74](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProving.sol#L74), [106](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProving.sol#L106), [112](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProving.sol#L112), [122](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProving.sol#L122), [135](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProving.sol#L135), [182](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProving.sol#L182), [219](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProving.sol#L219), [223](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProving.sol#L223-L224), [239](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProving.sol#L239), [374](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProving.sol#L374), [420](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProving.sol#L420), [424](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProving.sol#L424)

```solidity
📁 File: contracts/L1/libs/LibUtils.sol

35:             revert L1_INVALID_BLOCK_ID(); 

40:         if (blk.blockId != _blockId) revert L1_BLOCK_MISMATCH(); 

43:         if (tid == 0) revert L1_TRANSITION_NOT_FOUND(); 

64:             revert L1_INVALID_BLOCK_ID(); 

86:         if (tid_ >= _blk.nextTransitionId) revert L1_UNEXPECTED_TRANSITION_ID(); 
```
[35](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibUtils.sol#L35), [40](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibUtils.sol#L40), [43](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibUtils.sol#L43), [64](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibUtils.sol#L64), [86](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibUtils.sol#L86)

```solidity
📁 File: contracts/L1/libs/LibVerifying.sol

54:         if (!_isConfigValid(_config)) revert L1_INVALID_CONFIG(); 

105:         if (blk.blockId != blockId) revert L1_BLOCK_MISMATCH(); 

111:         if (tid == 0) revert L1_TRANSITION_ID_ZERO(); 

131:                 if (blk.blockId != blockId) revert L1_BLOCK_MISMATCH(); 
```
[54](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibVerifying.sol#L54), [105](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibVerifying.sol#L105), [111](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibVerifying.sol#L111), [131](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibVerifying.sol#L131)

```solidity
📁 File: contracts/L1/provers/GuardianProver.sol

45:         if (_proof.tier != LibTiers.TIER_GUARDIAN) revert INVALID_PROOF(); 
```
[45](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/provers/GuardianProver.sol#L45)

```solidity
📁 File: contracts/L1/provers/Guardians.sol

64:             revert INVALID_GUARDIAN_SET(); 

70:             revert INVALID_MIN_GUARDIANS(); 

82:             if (guardian == address(0)) revert INVALID_GUARDIAN(); 

84:             if (guardianIds[guardian] != 0) revert INVALID_GUARDIAN_SET(); 

113:         if (id == 0) revert INVALID_GUARDIAN(); 
```
[64](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/provers/Guardians.sol#L64), [70](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/provers/Guardians.sol#L70), [82](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/provers/Guardians.sol#L82), [84](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/provers/Guardians.sol#L84), [113](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/provers/Guardians.sol#L113)

```solidity
📁 File: contracts/L1/tiers/DevnetTierProvider.sol

43:         revert TIER_NOT_FOUND(); 
```
[43](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/tiers/DevnetTierProvider.sol#L43)

```solidity
📁 File: contracts/L1/tiers/MainnetTierProvider.sol

54:         revert TIER_NOT_FOUND(); 
```
[54](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/tiers/MainnetTierProvider.sol#L54)

```solidity
📁 File: contracts/L1/tiers/TestnetTierProvider.sol

54:         revert TIER_NOT_FOUND(); 
```
[54](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/tiers/TestnetTierProvider.sol#L54)

```solidity
📁 File: contracts/L2/CrossChainOwned.sol

43:         if (txId != nextTxId) revert XCO_INVALID_TX_ID(); 

47:             revert XCO_PERMISSION_DENIED(); 

51:         if (!success) revert XCO_TX_REVERTED(); 

71:             revert XCO_INVALID_OWNER_CHAINID(); 
```
[43](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/CrossChainOwned.sol#L43), [47](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/CrossChainOwned.sol#L47), [51](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/CrossChainOwned.sol#L51), [71](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/CrossChainOwned.sol#L71)

```solidity
📁 File: contracts/L2/Lib1559Math.sol

25:             revert EIP1559_INVALID_PARAMS(); 
```
[25](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/Lib1559Math.sol#L25)

```solidity
📁 File: contracts/L2/TaikoL2.sol

83:             revert L2_INVALID_CHAIN_ID(); 

93:             revert L2_TOO_LATE(); 

120:             revert L2_INVALID_PARAM(); 

123:         if (msg.sender != GOLDEN_TOUCH_ADDRESS) revert L2_INVALID_SENDER(); 

133:             revert L2_PUBLIC_INPUT_HASH_MISMATCH(); 

142:             revert L2_BASEFEE_MISMATCH(); 

172:         if (_to == address(0)) revert L2_INVALID_PARAM(); 
```
[83](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/TaikoL2.sol#L83), [93](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/TaikoL2.sol#L93), [120](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/TaikoL2.sol#L120), [123](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/TaikoL2.sol#L123), [133](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/TaikoL2.sol#L133), [142](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/TaikoL2.sol#L142), [172](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/TaikoL2.sol#L172)

```solidity
📁 File: contracts/L2/TaikoL2EIP1559Configurable.sol

33:         if (_newConfig.gasTargetPerL1Block == 0) revert L2_INVALID_CONFIG(); 
34:         if (_newConfig.basefeeAdjustmentQuotient == 0) revert L2_INVALID_CONFIG();
```
[33](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/TaikoL2EIP1559Configurable.sol#L33-L34)

```solidity
📁 File: contracts/automata-attestation/AutomataDcapV3Attestation.sol

61:         require(msg.sender == owner, "onlyOwner"); 
```
[61](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/AutomataDcapV3Attestation.sol#L61)

```solidity
📁 File: contracts/automata-attestation/lib/QuoteV3Auth/V3Parser.sol

77:         require( 
78:             localEnclaveReport.reserved3.length == 96 && localEnclaveReport.reserved4.length == 60
79:                 && localEnclaveReport.reportData.length == 64,
80:             "local QE report has wrong length"
81:         );
82:         require(
83:             pckSignedQeReport.reserved3.length == 96 && pckSignedQeReport.reserved4.length == 60
84:                 && pckSignedQeReport.reportData.length == 64,
85:             "QE report has wrong length"
86:         );
87:         require(
88:             v3Quote.v3AuthData.certification.certType == 5,
89:             "certType must be 5: Concatenated PCK Cert Chain (PEM formatted)"
90:         );
91:         require(
92:             v3Quote.v3AuthData.certification.decodedCertDataArray.length == 3, "3 certs in chain"
93:         );
94:         require(
95:             v3Quote.v3AuthData.ecdsa256BitSignature.length == 64
96:                 && v3Quote.v3AuthData.ecdsaAttestationKey.length == 64
97:                 && v3Quote.v3AuthData.qeReportSignature.length == 64,
98:             "Invalid ECDSA signature format"
99:         );
100:         require(
101:             v3Quote.v3AuthData.qeAuthData.parsedDataSize
102:                 == v3Quote.v3AuthData.qeAuthData.data.length,
103:             "Invalid QEAuthData size"
104:         );

116:         require(totalQuoteSize >= MINIMUM_QUOTE_LENGTH, "Invalid quote size"); 

279:         require(certParsedSuccessfully, "splitCertificateChain failed"); 
```
[77](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/QuoteV3Auth/V3Parser.sol#L77-L104), [116](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/QuoteV3Auth/V3Parser.sol#L116), [279](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/QuoteV3Auth/V3Parser.sol#L279)

```solidity
📁 File: contracts/automata-attestation/utils/Asn1Decode.sol

57:         require(der[ptr.ixs()] == 0x03, "Not type BIT STRING"); 

67:         require(der[ptr.ixs()] == 0x04, "Not type OCTET STRING"); 

88:         require(der[ptr.ixs()] & 0x20 == 0x20, "Not a constructed type"); 

142:         require(der[ptr.ixs()] == 0x02, "Not type INTEGER"); 
143:         require(der[ptr.ixf()] & 0x80 == 0, "Not positive");

155:         require(der[ptr.ixs()] == 0x02, "Not type INTEGER"); 
156:         require(der[ptr.ixf()] & 0x80 == 0, "Not positive");

180:         require(der[ptr.ixs()] == 0x03, "ixs Not type BIT STRING 0x03"); 

182:         require(der[ptr.ixf()] == 0x00, "ixf Not 0"); 
```
[57](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/Asn1Decode.sol#L57), [67](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/Asn1Decode.sol#L67), [88](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/Asn1Decode.sol#L88), [142](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/Asn1Decode.sol#L142-L143), [155](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/Asn1Decode.sol#L155-L156), [180](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/Asn1Decode.sol#L180), [182](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/Asn1Decode.sol#L182)

```solidity
📁 File: contracts/automata-attestation/utils/BytesUtils.sol

25:         require(offset + len <= self.length, "invalid offset"); 

199:         require(idx + 2 <= self.length, "invalid idx"); 

212:         require(idx + 4 <= self.length, "unexpected idx"); 

225:         require(idx + 32 <= self.length, "unexpected idx"); 

238:         require(idx + 20 <= self.length, "unexpected idx"); 

264:         require(len <= 32, "unexpected len"); 
265:         require(idx + len <= self.length, "unexpected idx");

293:         require(offset + len <= self.length, "unexpected offset"); 

329:         require(len <= 52, "unexpected len"); 

335:             require(char >= 0x30 && char <= 0x7A, "invalid char"); 

337:             require(decoded <= 0x20, "invalid decoded"); 

365:             revert("unexpected len"); 
```
[25](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/BytesUtils.sol#L25), [199](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/BytesUtils.sol#L199), [212](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/BytesUtils.sol#L212), [225](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/BytesUtils.sol#L225), [238](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/BytesUtils.sol#L238), [264](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/BytesUtils.sol#L264-L265), [293](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/BytesUtils.sol#L293), [329](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/BytesUtils.sol#L329), [335](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/BytesUtils.sol#L335), [337](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/BytesUtils.sol#L337), [365](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/BytesUtils.sol#L365)

```solidity
📁 File: contracts/automata-attestation/utils/SigVerifyLib.sol

50:             revert("Unsupported algorithm"); 

75:             revert("Unsupported algorithm"); 

138:         assert(success); // never reverts, always returns 0 or 1 
```
[50](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/SigVerifyLib.sol#L50), [75](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/SigVerifyLib.sol#L75), [138](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/SigVerifyLib.sol#L138)

```solidity
📁 File: contracts/bridge/Bridge.sol

65:         if (_chainId != block.chainid) revert B_INVALID_CHAINID(); 

109:         if (addressBanned[_addr] == _ban) revert B_INVALID_STATUS(); 

125:             revert B_INVALID_USER(); 

132:         if (!destChainEnabled) revert B_INVALID_CHAINID(); 

134:             revert B_INVALID_CHAINID(); 

139:         if (expectedAmount != msg.value) revert B_INVALID_VALUE(); 

166:         if (messageStatus[msgHash] != Status.NEW) revert B_STATUS_MISMATCH(); 

175:                 revert B_MESSAGE_NOT_SENT(); 

180:                 revert B_NOT_FAILED(); 

212:             revert B_INVOCATION_TOO_EARLY(); 

227:         if (messageStatus[msgHash] != Status.NEW) revert B_STATUS_MISMATCH(); 

237:                 revert B_NOT_RECEIVED(); 

261:                 revert B_PERMISSION_DENIED(); 

305:             revert B_INVOCATION_TOO_EARLY(); 

322:             if (msg.sender != _message.destOwner) revert B_PERMISSION_DENIED(); 

327:             revert B_NON_RETRIABLE(); 

406:             revert B_INVALID_CONTEXT(); 

485:         if (_gasLimit == 0) revert B_INVALID_GAS_LIMIT(); 
486:         assert(_message.from != address(this));
```
[65](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/Bridge.sol#L65), [109](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/Bridge.sol#L109), [125](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/Bridge.sol#L125), [132](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/Bridge.sol#L132), [134](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/Bridge.sol#L134), [139](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/Bridge.sol#L139), [166](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/Bridge.sol#L166), [175](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/Bridge.sol#L175), [180](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/Bridge.sol#L180), [212](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/Bridge.sol#L212), [227](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/Bridge.sol#L227), [237](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/Bridge.sol#L237), [261](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/Bridge.sol#L261), [305](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/Bridge.sol#L305), [322](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/Bridge.sol#L322), [327](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/Bridge.sol#L327), [406](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/Bridge.sol#L406), [485](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/Bridge.sol#L485-L486)

```solidity
📁 File: contracts/common/AddressManager.sol

48:         if (_newAddress == oldAddress) revert AM_INVALID_PARAMS(); 

59:         revert AM_UNSUPPORTED(); 
```
[48](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/common/AddressManager.sol#L48), [59](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/common/AddressManager.sol#L59)

```solidity
📁 File: contracts/common/AddressResolver.sol

25:         if (msg.sender != resolve(_name, true)) revert RESOLVER_DENIED(); 

60:             revert RESOLVER_UNEXPECTED_CHAINID(); 

81:         if (addressManager == address(0)) revert RESOLVER_INVALID_MANAGER(); 

86:             revert RESOLVER_ZERO_ADDR(_chainId, _name); 
```
[25](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/common/AddressResolver.sol#L25), [60](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/common/AddressResolver.sol#L60), [81](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/common/AddressResolver.sol#L81), [86](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/common/AddressResolver.sol#L86)

```solidity
📁 File: contracts/common/EssentialContract.sol

42:         if (msg.sender != owner() && msg.sender != resolve(_name, true)) revert RESOLVER_DENIED(); 

47:         if (_loadReentryLock() == _TRUE) revert REENTRANT_CALL(); 

54:         if (!paused()) revert INVALID_PAUSE_STATUS(); 

59:         if (paused()) revert INVALID_PAUSE_STATUS(); 

105:         if (_addressManager == address(0)) revert ZERO_ADDR_MANAGER(); 
```
[42](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/common/EssentialContract.sol#L42), [47](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/common/EssentialContract.sol#L47), [54](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/common/EssentialContract.sol#L54), [59](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/common/EssentialContract.sol#L59), [105](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/common/EssentialContract.sol#L105)

```solidity
📁 File: contracts/libs/Lib4844.sol

40:         if (_x >= BLS_MODULUS) revert POINT_X_TOO_LARGE(); 
41:         if (_y >= BLS_MODULUS) revert POINT_Y_TOO_LARGE();

47:         if (!ok) revert EVAL_FAILED_1(); 

49:         if (ret.length != 64) revert EVAL_FAILED_2(); 

58:             revert EVAL_FAILED_2(); 
```
[40](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/libs/Lib4844.sol#L40-L41), [47](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/libs/Lib4844.sol#L47), [49](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/libs/Lib4844.sol#L49), [58](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/libs/Lib4844.sol#L58)

```solidity
📁 File: contracts/libs/LibAddress.sol

24:         if (_to == address(0)) revert ETH_TRANSFER_FAILED(); 

36:         if (!success) revert ETH_TRANSFER_FAILED(); 
```
[24](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/libs/LibAddress.sol#L24), [36](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/libs/LibAddress.sol#L36)

```solidity
📁 File: contracts/libs/LibTrieProof.sol

50:             if (rlpAccount.length == 0) revert LTP_INVALID_ACCOUNT_PROOF(); 

64:         if (!verified) revert LTP_INVALID_INCLUSION_PROOF(); 
```
[50](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/libs/LibTrieProof.sol#L50), [64](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/libs/LibTrieProof.sol#L64)

```solidity
📁 File: contracts/signal/SignalService.sol

36:         if (_app == address(0)) revert SS_INVALID_SENDER(); 

41:         if (_input == 0) revert SS_INVALID_VALUE(); 

57:         if (isAuthorized[_addr] == _authorize) revert SS_INVALID_STATE(); 

77:         if (!isAuthorized[msg.sender]) revert SS_UNAUTHORIZED(); 

95:         if (hopProofs.length == 0) revert SS_EMPTY_PROOF(); 

111:                 if (hop.chainId != block.chainid) revert SS_INVALID_LAST_HOP_CHAINID(); 

115:                     revert SS_INVALID_MID_HOP_CHAINID(); 

132:             revert SS_SIGNAL_NOT_FOUND(); 

172:             if (chainData_ == 0) revert SS_SIGNAL_NOT_FOUND(); 

232:         revert SS_UNSUPPORTED(); 
```
[36](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/signal/SignalService.sol#L36), [41](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/signal/SignalService.sol#L41), [57](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/signal/SignalService.sol#L57), [77](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/signal/SignalService.sol#L77), [95](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/signal/SignalService.sol#L95), [111](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/signal/SignalService.sol#L111), [115](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/signal/SignalService.sol#L115), [132](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/signal/SignalService.sol#L132), [172](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/signal/SignalService.sol#L172), [232](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/signal/SignalService.sol#L232)

```solidity
📁 File: contracts/team/TimelockTokenPool.sol

121:         if (_taikoToken == address(0)) revert INVALID_PARAM(); 

124:         if (_costToken == address(0)) revert INVALID_PARAM(); 

127:         if (_sharedVault == address(0)) revert INVALID_PARAM(); 

136:         if (_recipient == address(0)) revert INVALID_PARAM(); 
137:         if (recipients[_recipient].grant.amount != 0) revert ALREADY_GRANTED();

154:         if (amountVoided == 0) revert NOTHING_TO_VOID(); 

169:         if (_to == address(0)) revert INVALID_PARAM(); 

268:         if (_grant.amount == 0) revert INVALID_GRANT(); 

275:             if (_cliff > 0) revert INVALID_GRANT(); 

277:             if (_cliff > 0 && _cliff <= _start) revert INVALID_GRANT(); 
278:             if (_cliff >= _start + _period) revert INVALID_GRANT();
```
[121](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/TimelockTokenPool.sol#L121), [124](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/TimelockTokenPool.sol#L124), [127](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/TimelockTokenPool.sol#L127), [136](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/TimelockTokenPool.sol#L136-L137), [154](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/TimelockTokenPool.sol#L154), [169](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/TimelockTokenPool.sol#L169), [268](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/TimelockTokenPool.sol#L268), [275](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/TimelockTokenPool.sol#L275), [277](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/TimelockTokenPool.sol#L277-L278)

```solidity
📁 File: contracts/team/airdrop/ERC20Airdrop2.sol

41:             revert WITHDRAWALS_NOT_ONGOING(); 
```
[41](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/airdrop/ERC20Airdrop2.sol#L41)

```solidity
📁 File: contracts/team/airdrop/MerkleClaimable.sol

37:         ) revert CLAIM_NOT_ONGOING(); 

70:         if (isClaimed[hash]) revert CLAIMED_ALREADY(); 
71:         if (!_verifyMerkleProof(proof, merkleRoot, hash)) revert INVALID_PROOF();
```
[37](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/airdrop/MerkleClaimable.sol#L37), [70](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/airdrop/MerkleClaimable.sol#L70-L71)

```solidity
📁 File: contracts/thirdparty/optimism/Bytes.sol

25:             require(_length + 31 >= _length, "slice_overflow"); 
26:             require(_start + _length >= _start, "slice_overflow");
27:             require(_bytes.length >= _start + _length, "slice_outOfBounds");
```
[25](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/Bytes.sol#L25-L27)

```solidity
📁 File: contracts/thirdparty/optimism/rlp/RLPReader.sol

37:         require( 
38:             _in.length > 0,
39:             "RLPReader: length of an RLP item must be greater than zero to be decodable"
40:         );

56:         require( 
57:             itemType == RLPItemType.LIST_ITEM,
58:             "RLPReader: decoded item type for list is not a list item"
59:         );

61:         require( 
62:             listOffset + listLength == _in.length,
63:             "RLPReader: list item has an invalid data remainder"
64:         );

112:         require( 
113:             itemType == RLPItemType.DATA_ITEM,
114:             "RLPReader: decoded item type for bytes is not a data item"
115:         );

117:         require( 
118:             _in.length == itemOffset + itemLength,
119:             "RLPReader: bytes value contains an invalid remainder"
120:         );

152:         require( 
153:             _in.length > 0,
154:             "RLPReader: length of an RLP item must be greater than zero to be decodable"
155:         );

172:             require( 
173:                 _in.length > strLen,
174:                 "RLPReader: length of content must be greater than string length (short string)"
175:             );

182:             require( 
183:                 strLen != 1 || firstByteOfContent >= 0x80,
184:                 "RLPReader: invalid prefix, single byte < 0x80 are not prefixed (short string)"
185:             );

192:             require( 
193:                 _in.length > lenOfStrLen,
194:                 "RLPReader: length of content must be > than length of string length (long string)"
195:             );

202:             require( 
203:                 firstByteOfContent != 0x00,
204:                 "RLPReader: length of content must not have any leading zeros (long string)"
205:             );

212:             require( 
213:                 strLen > 55,
214:                 "RLPReader: length of content must be greater than 55 bytes (long string)"
215:             );

217:             require( 
218:                 _in.length > lenOfStrLen + strLen,
219:                 "RLPReader: length of content must be greater than total length (long string)"
220:             );

228:             require( 
229:                 _in.length > listLen,
230:                 "RLPReader: length of content must be greater than list length (short list)"
231:             );

238:             require( 
239:                 _in.length > lenOfListLen,
240:                 "RLPReader: length of content must be > than length of list length (long list)"
241:             );

248:             require( 
249:                 firstByteOfContent != 0x00,
250:                 "RLPReader: length of content must not have any leading zeros (long list)"
251:             );

258:             require( 
259:                 listLen > 55,
260:                 "RLPReader: length of content must be greater than 55 bytes (long list)"
261:             );

263:             require( 
264:                 _in.length > lenOfListLen + listLen,
265:                 "RLPReader: length of content must be greater than total length (long list)"
266:             );
```
[37](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/rlp/RLPReader.sol#L37-L40), [56](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/rlp/RLPReader.sol#L56-L59), [61](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/rlp/RLPReader.sol#L61-L64), [112](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/rlp/RLPReader.sol#L112-L115), [117](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/rlp/RLPReader.sol#L117-L120), [152](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/rlp/RLPReader.sol#L152-L155), [172](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/rlp/RLPReader.sol#L172-L175), [182](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/rlp/RLPReader.sol#L182-L185), [192](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/rlp/RLPReader.sol#L192-L195), [202](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/rlp/RLPReader.sol#L202-L205), [212](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/rlp/RLPReader.sol#L212-L215), [217](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/rlp/RLPReader.sol#L217-L220), [228](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/rlp/RLPReader.sol#L228-L231), [238](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/rlp/RLPReader.sol#L238-L241), [248](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/rlp/RLPReader.sol#L248-L251), [258](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/rlp/RLPReader.sol#L258-L261), [263](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/rlp/RLPReader.sol#L263-L266)

```solidity
📁 File: contracts/thirdparty/optimism/trie/MerkleTrie.sol

77:         require(_key.length > 0, "MerkleTrie: empty key"); 

89:             require(currentKeyIndex <= key.length, "MerkleTrie: key index exceeds total key length"); 

93:                 require( 
94:                     Bytes.equal(abi.encodePacked(keccak256(currentNode.encoded)), currentNodeID),
95:                     "MerkleTrie: invalid root hash"
96:                 );

99:                 require( 
100:                     Bytes.equal(abi.encodePacked(keccak256(currentNode.encoded)), currentNodeID),
101:                     "MerkleTrie: invalid large internal hash"
102:                 );

105:                 require( 
106:                     Bytes.equal(currentNode.encoded, currentNodeID),
107:                     "MerkleTrie: invalid internal node hash"
108:                 );

119:                     require( 
120:                         value_.length > 0,
121:                         "MerkleTrie: value length must be greater than zero (branch)"
122:                     );

125:                     require( 
126:                         i == proof.length - 1,
127:                         "MerkleTrie: value node must be last node in proof (branch)"
128:                     );

150:                 require( 
151:                     pathRemainder.length == sharedNibbleLength,
152:                     "MerkleTrie: path remainder must share all nibbles with key"
153:                 );

162:                     require( 
163:                         keyRemainder.length == sharedNibbleLength,
164:                         "MerkleTrie: key remainder must be identical to path remainder"
165:                     );

172:                     require( 
173:                         value_.length > 0,
174:                         "MerkleTrie: value length must be greater than zero (leaf)"
175:                     );

178:                     require( 
179:                         i == proof.length - 1,
180:                         "MerkleTrie: value node must be last node in proof (leaf)"
181:                     );

191:                     revert("MerkleTrie: received a node with an unknown prefix"); 

194:                 revert("MerkleTrie: received an unparseable node"); 

198:         revert("MerkleTrie: ran out of proof elements"); 
```
[77](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/trie/MerkleTrie.sol#L77), [89](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/trie/MerkleTrie.sol#L89), [93](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/trie/MerkleTrie.sol#L93-L96), [99](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/trie/MerkleTrie.sol#L99-L102), [105](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/trie/MerkleTrie.sol#L105-L108), [119](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/trie/MerkleTrie.sol#L119-L122), [125](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/trie/MerkleTrie.sol#L125-L128), [150](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/trie/MerkleTrie.sol#L150-L153), [162](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/trie/MerkleTrie.sol#L162-L165), [172](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/trie/MerkleTrie.sol#L172-L175), [178](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/trie/MerkleTrie.sol#L178-L181), [191](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/trie/MerkleTrie.sol#L191), [194](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/trie/MerkleTrie.sol#L194), [198](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/trie/MerkleTrie.sol#L198)

```solidity
📁 File: contracts/thirdparty/solmate/LibFixedPointMath.sol

26:             if (x >= 135_305_999_368_893_231_589) revert Overflow(); 
```
[26](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/solmate/LibFixedPointMath.sol#L26)

```solidity
📁 File: contracts/tokenvault/BaseNFTVault.sol

142:             revert VAULT_TOKEN_ARRAY_MISMATCH(); 

146:             revert VAULT_MAX_TOKEN_PER_TXN_EXCEEDED(); 

149:         if (_op.token == address(0)) revert VAULT_INVALID_TOKEN(); 
```
[142](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BaseNFTVault.sol#L142), [146](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BaseNFTVault.sol#L146), [149](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BaseNFTVault.sol#L149)

```solidity
📁 File: contracts/tokenvault/BaseVault.sol

24:             revert VAULT_PERMISSION_DENIED(); 

55:         if (ctx_.from != selfOnSourceChain) revert VAULT_PERMISSION_DENIED(); 

65:         if (ctx_.from != msg.sender) revert VAULT_PERMISSION_DENIED(); 
```
[24](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BaseVault.sol#L24), [55](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BaseVault.sol#L55), [65](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BaseVault.sol#L65)

```solidity
📁 File: contracts/tokenvault/BridgedERC1155.sol

137:         if (_to == address(this)) revert BTOKEN_CANNOT_RECEIVE(); 
138:         if (paused()) revert INVALID_PAUSE_STATUS();
```
[137](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC1155.sol#L137-L138)

```solidity
📁 File: contracts/tokenvault/BridgedERC20.sol

39:             revert BTOKEN_UNAUTHORIZED(); 

147:         if (_to == address(this)) revert BTOKEN_CANNOT_RECEIVE(); 
148:         if (paused()) revert INVALID_PAUSE_STATUS();
```
[39](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC20.sol#L39), [147](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC20.sol#L147-L148)

```solidity
📁 File: contracts/tokenvault/BridgedERC20Base.sol

46:             revert BB_INVALID_PARAMS(); 

59:         if (_isMigratingOut()) revert BB_MINT_DISALLOWED(); 

66:             revert BB_PERMISSION_DENIED(); 

78:             if (msg.sender != _account) revert BB_PERMISSION_DENIED(); 

85:             revert RESOLVER_DENIED(); 
```
[46](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC20Base.sol#L46), [59](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC20Base.sol#L59), [66](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC20Base.sol#L66), [78](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC20Base.sol#L78), [85](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC20Base.sol#L85)

```solidity
📁 File: contracts/tokenvault/BridgedERC721.sol

80:             revert BTOKEN_INVALID_BURN(); 

125:         if (_to == address(this)) revert BTOKEN_CANNOT_RECEIVE(); 
126:         if (paused()) revert INVALID_PAUSE_STATUS();
```
[80](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC721.sol#L80), [125](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC721.sol#L125-L126)

```solidity
📁 File: contracts/tokenvault/ERC1155Vault.sol

48:             if (_op.amounts[i] == 0) revert VAULT_INVALID_AMOUNT(); 

52:             revert VAULT_INTERFACE_NOT_SUPPORTED(); 

108:         if (to == address(0) || to == address(this)) revert VAULT_INVALID_TO(); 
```
[48](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC1155Vault.sol#L48), [52](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC1155Vault.sol#L52), [108](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC1155Vault.sol#L108)

```solidity
📁 File: contracts/tokenvault/ERC20Vault.sol

159:             revert VAULT_INVALID_NEW_BTOKEN(); 

162:         if (btokenBlacklist[_btokenNew]) revert VAULT_BTOKEN_BLACKLISTED(); 

165:             revert VAULT_NOT_SAME_OWNER(); 

178:             ) revert VAULT_CTOKEN_MISMATCH(); 

214:         if (_op.amount == 0) revert VAULT_INVALID_AMOUNT(); 
215:         if (_op.token == address(0)) revert VAULT_INVALID_TOKEN();
216:         if (btokenBlacklist[_op.token]) revert VAULT_BTOKEN_BLACKLISTED();

267:         if (to == address(0) || to == address(this)) revert VAULT_INVALID_TO(); 
```
[159](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC20Vault.sol#L159), [162](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC20Vault.sol#L162), [165](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC20Vault.sol#L165), [178](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC20Vault.sol#L178), [214](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC20Vault.sol#L214-L216), [267](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC20Vault.sol#L267)

```solidity
📁 File: contracts/tokenvault/ERC721Vault.sol

35:             if (_op.amounts[i] != 0) revert VAULT_INVALID_AMOUNT(); 

39:             revert VAULT_INTERFACE_NOT_SUPPORTED(); 

91:         if (to == address(0) || to == address(this)) revert VAULT_INVALID_TO(); 
```
[35](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC721Vault.sol#L35), [39](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC721Vault.sol#L39), [91](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC721Vault.sol#L91)

```solidity
📁 File: contracts/tokenvault/LibBridgedToken.sol

24:             revert BTOKEN_INVALID_PARAMS(); 
```
[24](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/LibBridgedToken.sol#L24)

```solidity
📁 File: contracts/verifiers/GuardianVerifier.sol

32:             revert PERMISSION_DENIED(); 
```
[32](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/verifiers/GuardianVerifier.sol#L32)

```solidity
📁 File: contracts/verifiers/SgxVerifier.sol

107:             if (instances[idx].addr == address(0)) revert SGX_INVALID_INSTANCE(); 

125:             revert SGX_RA_NOT_SUPPORTED(); 

130:         if (!verified) revert SGX_INVALID_ATTESTATION(); 

152:         if (_proof.data.length != 89) revert SGX_INVALID_PROOF(); 

161:         if (!_isInstanceValid(id, oldInstance)) revert SGX_INVALID_INSTANCE(); 

211:             if (addressRegistered[_instances[i]]) revert SGX_ALREADY_ATTESTED(); 

215:             if (_instances[i] == address(0)) revert SGX_INVALID_INSTANCE(); 
```
[107](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/verifiers/SgxVerifier.sol#L107), [125](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/verifiers/SgxVerifier.sol#L125), [130](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/verifiers/SgxVerifier.sol#L130), [152](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/verifiers/SgxVerifier.sol#L152), [161](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/verifiers/SgxVerifier.sol#L161), [211](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/verifiers/SgxVerifier.sol#L211), [215](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/verifiers/SgxVerifier.sol#L215)

</details>


---
### [GAS&#x2011;95] Use `s.x = s.x + y` instead of `s.x += y` for structs
Using the `s.x = s.x + y` instead of `s.x += y` for structs can save **100 gas**. The same applies to `-=`, `*=`, etc.


Gas saved per Instance: ~100 *(Total: ~600)*
<details>
<summary><i>There are 6 instances of this issue:</i></summary>

```solidity
📁 File: contracts/L1/libs/LibDepositing.sol

101:                     deposits_[i].amount -= _fee; 
```
[101](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibDepositing.sol#L101)

```solidity
📁 File: contracts/L1/libs/LibProving.sol

252:                 ts.contestations += 1; 

377:             _ts.contestations += 1; 
```
[252](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProving.sol#L252), [377](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProving.sol#L377)

```solidity
📁 File: contracts/team/TimelockTokenPool.sol

213:         r.amountWithdrawn += amountToWithdraw; 
214:         r.costPaid += costToWithdraw;
```
[213](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/TimelockTokenPool.sol#L213-L214)

</details>


---
### [GAS&#x2011;96] Use scratch space when building emitted events with two data arguments
We can use assembly to emit events efficiently by utilizing `scratch space` and the `free memory pointer`. This will allow us to potentially avoid memory expansion costs.
Note: In order to do this optimization safely, we will need to cache and restore the free memory pointer.

For example, for a generic `emit` event for `eventSentAmountExample`: 
```solidity
// uint256 id, uint256 value, uint256 amount
emit eventSentAmountExample(id, value, amount);
```



Gas saved per Instance: ~38 *(Total: ~912)*
<details>
<summary><i>There are 24 instances of this issue:</i></summary>

```solidity
📁 File: contracts/L1/libs/LibDepositing.sol

50:         emit EthDeposited( 
```
[50](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibDepositing.sol#L50)

```solidity
📁 File: contracts/L1/libs/LibProposing.sol

166:                     emit BlobCached(meta_.blobHash); 
```
[166](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProposing.sol#L166)

```solidity
📁 File: contracts/L1/libs/LibProving.sol

80:         emit ProvingPaused(_pause); 
```
[80](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProving.sol#L80)

```solidity
📁 File: contracts/L1/provers/GuardianProver.sol

54:         emit GuardianApproval(msg.sender, _meta.id, _tran.blockHash, approved_); 
```
[54](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/provers/GuardianProver.sol#L54)

```solidity
📁 File: contracts/L1/provers/Guardians.sol

95:         emit GuardiansUpdated(version, _newGuardians); 
```
[95](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/provers/Guardians.sol#L95)

```solidity
📁 File: contracts/L2/CrossChainOwned.sol

53:         emit TransactionExecuted(nextTxId++, bytes4(txdata)); 
```
[53](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/CrossChainOwned.sol#L53)

```solidity
📁 File: contracts/L2/TaikoL2.sol

157:         emit Anchored(blockhash(parentId), gasExcess); 
```
[157](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/TaikoL2.sol#L157)

```solidity
📁 File: contracts/L2/TaikoL2EIP1559Configurable.sol

39:         emit ConfigAndExcessChanged(_newConfig, _newGasExcess); 
```
[39](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/TaikoL2EIP1559Configurable.sol#L39)

```solidity
📁 File: contracts/bridge/Bridge.sol

93:             emit MessageSuspended(msgHash, _suspend); 

111:         emit AddressBanned(_addr, _ban); 

151:         emit MessageSent(msgHash_, message_); 

208:             emit MessageRecalled(msgHash); 

301:             emit MessageExecuted(msgHash); 

336:         emit MessageRetried(msgHash); 

519:         emit MessageStatusChanged(_msgHash, _status); 
```
[93](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/Bridge.sol#L93), [111](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/Bridge.sol#L111), [151](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/Bridge.sol#L151), [208](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/Bridge.sol#L208), [301](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/Bridge.sol#L301), [336](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/Bridge.sol#L336), [519](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/Bridge.sol#L519)

```solidity
📁 File: contracts/common/EssentialContract.sol

71:         emit Paused(msg.sender); 

80:         emit Unpaused(msg.sender); 
```
[71](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/common/EssentialContract.sol#L71), [80](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/common/EssentialContract.sol#L80)

```solidity
📁 File: contracts/signal/SignalService.sol

59:         emit Authorized(_addr, _authorize); 
```
[59](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/signal/SignalService.sol#L59)

```solidity
📁 File: contracts/team/TimelockTokenPool.sol

143:         emit Granted(_recipient, _grant); 

157:         emit Voided(_recipient, amountVoided); 
```
[143](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/TimelockTokenPool.sol#L143), [157](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/TimelockTokenPool.sol#L157)

```solidity
📁 File: contracts/team/airdrop/ERC20Airdrop2.sol

93:         emit Withdrawn(user, amount); 
```
[93](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/airdrop/ERC20Airdrop2.sol#L93)

```solidity
📁 File: contracts/team/airdrop/MerkleClaimable.sol

74:         emit Claimed(hash); 
```
[74](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/airdrop/MerkleClaimable.sol#L74)

```solidity
📁 File: contracts/tokenvault/BridgedERC20Base.sol

51:         emit MigrationStatusChanged(_migratingAddress, _migratingInbound); 
```
[51](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC20Base.sol#L51)

```solidity
📁 File: contracts/verifiers/SgxVerifier.sol

109:             emit InstanceDeleted(idx, instances[idx].addr); 
```
[109](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/verifiers/SgxVerifier.sol#L109)

</details>


---
### [GAS&#x2011;97] Use `selfbalance()` instead of `address(this).balance`
Use assembly when getting a contract's balance of ETH.

You can use `selfbalance()` instead of `address(this).balance` when getting your contract's balance of ETH to save gas.
Additionally, you can use `balance(address)` instead of `address().balance` when getting an external contract's balance of ETH.

*Saves 15 gas when checking internal balance, 6 for external*

<details>
<summary><i>There are 6 instances of this issue:</i></summary>

```solidity
📁 File: contracts/L1/hooks/AssignmentHook.sol

125:         if (address(this).balance > 0) { 
126:             taikoL1Address.sendEther(address(this).balance);
```
[125](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/hooks/AssignmentHook.sol#L125-L126)

```solidity
📁 File: contracts/L1/libs/LibProposing.sol

253:                 IHook(params.hookCalls[i].hook).onBlockProposed{ value: address(this).balance }( 

260:             if (address(this).balance != 0) { 
261:                 msg.sender.sendEther(address(this).balance);
```
[253](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProposing.sol#L253), [260](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProposing.sol#L260-L261)

```solidity
📁 File: contracts/L2/TaikoL2.sol

174:             _to.sendEther(address(this).balance); 
```
[174](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/TaikoL2.sol#L174)

</details>


---
### [GAS&#x2011;98] Use shift right/left instead of division/multiplication if possible
`<x> * 2` is the same as `<x> << 1`. While the compiler uses the `SHL` opcode to accomplish both, the version that uses multiplication incurs an overhead of **20 gas** due to `JUMP`s to and from a compiler utility function that introduces checks which can be avoided by using `unchecked {}` around the division by two.


Gas saved per Instance: ~20 *(Total: ~40)*

<i>There are 2 instaces of this issue:</i>

```solidity
📁 File: contracts/automata-attestation/lib/QuoteV3Auth/V3Parser.sol

158:             uint256 acc = lowerDigit * (16 ** (2 * i)); 
159:             acc += upperDigit * (16 ** ((2 * i) + 1));
```
[158](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/QuoteV3Auth/V3Parser.sol#L158-L159)


---
### [GAS&#x2011;99] Use the inputs/results of assignments rather than re-reading state variables
When a state variable is assigned, it saves gas to use the value being assigned, later in the function, rather than re-reading the state variable itself. If needed, it can also be stored to a local variable, and be used in that way. Both options avoid a Gwarmaccess (**100 gas**). Note that if the operation is, say `+=`, the assignment also results in a value which can be used. The instances below point to the first reference after the assignment, since later references are already covered by issues describing the caching of state variable values.


Gas saved per Instance: ~97 *(Total: ~970)*
<details>
<summary><i>There are 10 instances of this issue:</i></summary>

```solidity
📁 File: contracts/bridge/Bridge.sol

/// @audit use result of assignment of receivedAt, here
184:             proofReceipt[msgHash].receivedAt = receivedAt; 

/// @audit use result of assignment of receivedAt, here
189:         if (block.timestamp >= invocationDelay + receivedAt) { 

/// @audit use result of assignment of receivedAt, here
244:                     receivedAt: receivedAt, 

/// @audit use result of assignment of receivedAt, here
258:         if (block.timestamp >= invocationDelay + receivedAt) { 
```
[184](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/Bridge.sol#L184), [189](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/Bridge.sol#L189), [244](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/Bridge.sol#L244), [258](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/Bridge.sol#L258)

```solidity
📁 File: contracts/team/TimelockTokenPool.sol

/// @audit use result of assignment of amountWithdrawn, here
193:         amountToWithdraw = amountUnlocked - amountWithdrawn; 
```
[193](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/TimelockTokenPool.sol#L193)

```solidity
📁 File: contracts/tokenvault/ERC1155Vault.sol

/// @audit use result of assignment of token, here
226:             IERC1155(token).safeBatchTransferFrom(address(this), to, tokenIds, amounts, ""); 

/// @audit use result of assignment of token, here
229:             token = _getOrDeployBridgedToken(ctoken); 
/// @audit use result of assignment of token, here
230:             BridgedERC1155(token).mintBatch(to, tokenIds, amounts);
```
[226](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC1155Vault.sol#L226), [229](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC1155Vault.sol#L229-L230)

```solidity
📁 File: contracts/verifiers/SgxVerifier.sol

/// @audit use result of assignment of validSince, here
217:             instances[nextInstanceId] = Instance(_instances[i], validSince); 

/// @audit use result of assignment of validSince, here
220:             emit InstanceAdded(nextInstanceId, _instances[i], address(0), validSince); 
```
[217](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/verifiers/SgxVerifier.sol#L217), [220](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/verifiers/SgxVerifier.sol#L220)

</details>


---
### [GAS&#x2011;100] Use `uint256(1)`/`uint256(2)` instead of `true`/`false` to save gas for changes
Use uint256(1) and uint256(2) for true/false to avoid a Gwarmaccess (100 gas), and to avoid Gsset (20000 gas) when changing from ‘false’ to ‘true’, after having been ‘true’ in the past. Refer to the [source](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/5ae630684a0f57de400ef69499addab4c32ac8fb/contracts/security/ReentrancyGuard.sol#L23-L27).


Gas saved per Instance: ~17,100 *(Total: ~171,000)*
<details>
<summary><i>There are 10 instances of this issue:</i></summary>

```solidity
📁 File: contracts/automata-attestation/AutomataDcapV3Attestation.sol

38:     bool private _checkLocalEnclaveReport; 
39:     mapping(bytes32 enclave => bool trusted) private _trustedUserMrEnclave;
40:     mapping(bytes32 signer => bool trusted) private _trustedUserMrSigner;

47:     mapping(uint256 idx => mapping(bytes serialNum => bool revoked)) private _serialNumIsRevoked; 
```
[38](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/AutomataDcapV3Attestation.sol#L38-L40), [47](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/AutomataDcapV3Attestation.sol#L47)

```solidity
📁 File: contracts/bridge/Bridge.sol

42:     mapping(address addr => bool banned) public addressBanned; 
```
[42](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/Bridge.sol#L42)

```solidity
📁 File: contracts/signal/SignalService.sol

21:     mapping(address addr => bool authorized) public isAuthorized; 
```
[21](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/signal/SignalService.sol#L21)

```solidity
📁 File: contracts/team/airdrop/MerkleClaimable.sol

12:     mapping(bytes32 hash => bool claimed) public isClaimed; 
```
[12](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/airdrop/MerkleClaimable.sol#L12)

```solidity
📁 File: contracts/tokenvault/BridgedERC20Base.sol

14:     bool public migratingInbound; 
```
[14](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC20Base.sol#L14)

```solidity
📁 File: contracts/tokenvault/ERC20Vault.sol

52:     mapping(address btoken => bool blacklisted) public btokenBlacklist; 
```
[52](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC20Vault.sol#L52)

```solidity
📁 File: contracts/verifiers/SgxVerifier.sol

55:     mapping(address instanceAddress => bool alreadyAttested) public addressRegistered; 
```
[55](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/verifiers/SgxVerifier.sol#L55)

</details>


---
### [GAS&#x2011;101] Using `> 0` costs more gas than `!= 0` when used on a `uint` in a `require()` statement
This change saves **[6 gas](https://aws1.discourse-cdn.com/business6/uploads/zeppelin/original/2X/3/363a367d6d68851f27d2679d10706cd16d788b96.png)** per instance. The optimization works until solidity version [0.8.13](https://gist.github.com/IllIllI000/bf2c3120f24a69e489f12b3213c06c94) where there is a regression in gas costs.


Gas saved per Instance: ~6 *(Total: ~30)*
<details>
<summary><i>There are 5 instances of this issue:</i></summary>

```solidity
📁 File: contracts/thirdparty/optimism/rlp/RLPReader.sol

/// @audit _in.length != 0
38:             _in.length > 0, 

/// @audit _in.length != 0
153:             _in.length > 0, 
```
[38](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/rlp/RLPReader.sol#L38), [153](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/rlp/RLPReader.sol#L153)

```solidity
📁 File: contracts/thirdparty/optimism/trie/MerkleTrie.sol

/// @audit _key.length != 0
77:         require(_key.length > 0, "MerkleTrie: empty key"); 

/// @audit value_.length != 0
120:                         value_.length > 0, 

/// @audit value_.length != 0
173:                         value_.length > 0, 
```
[77](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/trie/MerkleTrie.sol#L77), [120](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/trie/MerkleTrie.sol#L120), [173](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/trie/MerkleTrie.sol#L173)

</details>


---
### [GAS&#x2011;102] Using `bool`s for storage incurs overhead
Use uint256(1) and uint256(2) for true/false to avoid a Gwarmaccess (100 gas), and to avoid Gsset (20000 gas) when changing from ‘false’ to ‘true’, after having been ‘true’ in the past. See [source](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/58f635312aa21f947cae5f8578638a85aa2519f5/contracts/security/ReentrancyGuard.sol#L23-L27).


Gas saved per Instance: ~17,100 *(Total: ~410,400)*
<details>
<summary><i>There are 24 instances of this issue:</i></summary>

```solidity
📁 File: contracts/L1/TaikoData.sol

32:         bool blobAllowedForDA; 

34:         bool blobReuseEnabled; 

85:         bool cacheBlobForReuse; 

108:         bool blobUsed; 

171:         bool provingPaused; 
```
[32](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/TaikoData.sol#L32), [34](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/TaikoData.sol#L34), [85](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/TaikoData.sol#L85), [108](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/TaikoData.sol#L108), [171](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/TaikoData.sol#L171)

```solidity
📁 File: contracts/automata-attestation/AutomataDcapV3Attestation.sol

38:     bool private _checkLocalEnclaveReport; 
```
[38](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/AutomataDcapV3Attestation.sol#L38)

```solidity
📁 File: contracts/automata-attestation/lib/PEMCertChainLib.sol

35:         bool fmspcFound; 
36:         bool pceidFound;
37:         bool tcbFound;
```
[35](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/PEMCertChainLib.sol#L35-L37)

```solidity
📁 File: contracts/automata-attestation/lib/interfaces/IPEMCertChainLib.sol

14:         bool isPck; 
```
[14](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/interfaces/IPEMCertChainLib.sol#L14)

```solidity
📁 File: contracts/tokenvault/BridgedERC20Base.sol

14:     bool public migratingInbound; 
```
[14](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC20Base.sol#L14)

```solidity
📁 File: contracts/verifiers/IVerifier.sol

15:         bool isContesting; 
16:         bool blobUsed;
```
[15](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/verifiers/IVerifier.sol#L15-L16)

</details>


---
### [GAS&#x2011;103] Using `constant`s instead of `enum` can save gas
`Enum` is expensive and it is [more efficient to use constants](https://www.codehawks.com/finding/clm84992q02j9w9ruebun36d9) instead. An illustrative example of this approach can be found in the [ReentrancyGuard.sol](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/181d518609a9f006fcb97af63e6952e603cf100e/contracts/utils/ReentrancyGuard.sol#L34-L35).

<details>
<summary><i>There are 9 instances of this issue:</i></summary>

```solidity
📁 File: contracts/automata-attestation/interfaces/ISigVerifyLib.sol

7:     enum KeyType { 
8:         RSA,
9:         ECDSA
10:     }

19:     enum CertSigAlgorithm { 
20:         Sha256WithRSAEncryption,
21:         Sha1WithRSAEncryption
22:     }

32:     enum Algorithm { 
33:         RS256,
34:         ES256,
35:         RS1
36:     }
```
[7](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/interfaces/ISigVerifyLib.sol#L7-L10), [19](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/interfaces/ISigVerifyLib.sol#L19-L22), [32](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/interfaces/ISigVerifyLib.sol#L32-L36)

```solidity
📁 File: contracts/automata-attestation/lib/EnclaveIdStruct.sol

26:     enum EnclaveIdStatus { 
27:         OK,
28:         SGX_ENCLAVE_REPORT_ISVSVN_REVOKED
29:     }
```
[26](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/EnclaveIdStruct.sol#L26-L29)

```solidity
📁 File: contracts/automata-attestation/lib/TCBInfoStruct.sol

19:     enum TCBStatus { 
20:         OK,
21:         TCB_SW_HARDENING_NEEDED,
22:         TCB_CONFIGURATION_AND_SW_HARDENING_NEEDED,
23:         TCB_CONFIGURATION_NEEDED,
24:         TCB_OUT_OF_DATE,
25:         TCB_OUT_OF_DATE_CONFIGURATION_NEEDED,
26:         TCB_REVOKED,
27:         TCB_UNRECOGNIZED
28:     }
```
[19](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/TCBInfoStruct.sol#L19-L28)

```solidity
📁 File: contracts/automata-attestation/lib/interfaces/IPEMCertChainLib.sol

31:     enum CRL { 
32:         PCK,
33:         ROOT
34:     }
```
[31](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/interfaces/IPEMCertChainLib.sol#L31-L34)

```solidity
📁 File: contracts/bridge/IBridge.sol

9:     enum Status { 
10:         NEW,
11:         RETRIABLE,
12:         DONE,
13:         FAILED,
14:         RECALLED
15:     }
```
[9](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/IBridge.sol#L9-L15)

```solidity
📁 File: contracts/signal/ISignalService.sol

13:     enum CacheOption { 
14:         CACHE_NOTHING,
15:         CACHE_SIGNAL_ROOT,
16:         CACHE_STATE_ROOT,
17:         CACHE_BOTH
18:     }
```
[13](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/signal/ISignalService.sol#L13-L18)

```solidity
📁 File: contracts/thirdparty/optimism/rlp/RLPReader.sol

16:     enum RLPItemType { 
17:         DATA_ITEM,
18:         LIST_ITEM
19:     }
```
[16](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/rlp/RLPReader.sol#L16-L19)

</details>


---
### [GAS&#x2011;104] Using globals directly is cheaper than assigning them to variables
Using the [global](https://docs.soliditylang.org/en/v0.8.14/cheatsheet.html#global-variables) directly saves **5 [gas](https://gist.github.com/IllIllI000/0a38d74d0af20412471a43f1e4fcf8be)**


Gas saved per Instance: ~5 

<i>There is one instance of this issue:</i>

```solidity
📁 File: contracts/L1/hooks/AssignmentHook.sol

93:         address taikoL1Address = msg.sender; 
```
[93](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/hooks/AssignmentHook.sol#L93)


---
### [GAS&#x2011;105] Using `msg` globals directly, rather than caching the value, saves gas
For example, use `msg.sender` directly rather than storing it to a local variable


<i>There are 3 instaces of this issue:</i>

```solidity
📁 File: contracts/L1/hooks/AssignmentHook.sol

/// @audit taikoL1Address
94:         bytes32 hash = hashAssignment(assignment, taikoL1Address, _meta.blobHash); 

/// @audit taikoL1Address
102:         tko.transferFrom(_blk.assignedProver, taikoL1Address, _blk.livenessBond); 

/// @audit taikoL1Address
126:             taikoL1Address.sendEther(address(this).balance); 
```
[94](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/hooks/AssignmentHook.sol#L94), [102](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/hooks/AssignmentHook.sol#L102), [126](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/hooks/AssignmentHook.sol#L126)


---
### [GAS&#x2011;106] Using `private` rather than `public`, saves gas
For constants, the values can be read from the verified contract source code, or if there are multiple values there can be a single getter function that returns a tuple of the values of all currently-public constants. Saves 3406-3606 gas in deployment gas due to the compiler not having to create non-payable getter functions for deployment calldata, not having to store the bytes of the value outside of where it's used, and not adding another entry to the method ID table


Gas saved per Instance: ~3,606 *(Total: ~310,116)*
<details>
<summary><i>There are 86 instances of this issue:</i></summary>

```solidity
📁 File: contracts/L1/TaikoL1.sol

24:     TaikoData.State public state; 
```
[24](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/TaikoL1.sol#L24)

```solidity
📁 File: contracts/L1/hooks/AssignmentHook.sol

38:     uint256 public constant MAX_GAS_PAYING_PROVER = 50_000; 
```
[38](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/hooks/AssignmentHook.sol#L38)

```solidity
📁 File: contracts/L1/libs/LibProposing.sol

21:     uint256 public constant MAX_BYTES_PER_BLOB = 4096 * 32; 
```
[21](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProposing.sol#L21)

```solidity
📁 File: contracts/L1/libs/LibProving.sol

20:     bytes32 public constant RETURN_LIVENESS_BOND = keccak256("RETURN_LIVENESS_BOND"); 

23:     bytes32 public constant TIER_OP = bytes32("tier_optimistic"); 
```
[20](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProving.sol#L20), [23](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProving.sol#L23)

```solidity
📁 File: contracts/L1/provers/Guardians.sol

11:     uint256 public constant MIN_NUM_GUARDIANS = 5; 

16:     mapping(address guardian => uint256 id) public guardianIds; 

23:     address[] public guardians; 

27:     uint32 public version; 

30:     uint32 public minGuardians; 
```
[11](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/provers/Guardians.sol#L11), [16](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/provers/Guardians.sol#L16), [23](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/provers/Guardians.sol#L23), [27](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/provers/Guardians.sol#L27), [30](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/provers/Guardians.sol#L30)

```solidity
📁 File: contracts/L1/tiers/ITierProvider.sol

39:     uint16 public constant TIER_OPTIMISTIC = 100; 

42:     uint16 public constant TIER_SGX = 200; 

45:     uint16 public constant TIER_SGX_ZKVM = 300; 

48:     uint16 public constant TIER_GUARDIAN = 1000; 
```
[39](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/tiers/ITierProvider.sol#L39), [42](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/tiers/ITierProvider.sol#L42), [45](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/tiers/ITierProvider.sol#L45), [48](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/tiers/ITierProvider.sol#L48)

```solidity
📁 File: contracts/L2/CrossChainOwned.sol

16:     uint64 public ownerChainId; 

19:     uint64 public nextTxId; 
```
[16](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/CrossChainOwned.sol#L16), [19](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/CrossChainOwned.sol#L19)

```solidity
📁 File: contracts/L2/TaikoL2.sol

32:     address public constant GOLDEN_TOUCH_ADDRESS = 0x0000777735367b36bC9B61C50022d9D0700dB4Ec; 

35:     uint8 public constant BLOCK_SYNC_THRESHOLD = 5; 

39:     mapping(uint256 blockId => bytes32 blockHash) public l2Hashes; 

43:     bytes32 public publicInputHash; 

47:     uint64 public gasExcess; 

50:     uint64 public lastSyncedBlock; 
```
[32](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/TaikoL2.sol#L32), [35](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/TaikoL2.sol#L35), [39](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/TaikoL2.sol#L39), [43](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/TaikoL2.sol#L43), [47](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/TaikoL2.sol#L47), [50](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/TaikoL2.sol#L50)

```solidity
📁 File: contracts/L2/TaikoL2EIP1559Configurable.sol

11:     Config public customConfig; 
```
[11](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/TaikoL2EIP1559Configurable.sol#L11)

```solidity
📁 File: contracts/automata-attestation/AutomataDcapV3Attestation.sol

25:     ISigVerifyLib public immutable sigVerifyLib; 
26:     IPEMCertChainLib public immutable pemCertLib;

49:     mapping(string fmspc => TCBInfoStruct.TCBInfo tcbInfo) public tcbInfo; 
50:     EnclaveIdStruct.EnclaveId public qeIdentity;

52:     address public owner; 
```
[25](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/AutomataDcapV3Attestation.sol#L25-L26), [49](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/AutomataDcapV3Attestation.sol#L49-L50), [52](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/AutomataDcapV3Attestation.sol#L52)

```solidity
📁 File: contracts/bridge/Bridge.sol

31:     uint128 public nextMessageId; 

35:     mapping(bytes32 msgHash => Status status) public messageStatus; 

42:     mapping(address addr => bool banned) public addressBanned; 

46:     mapping(bytes32 msgHash => ProofReceipt receipt) public proofReceipt; 
```
[31](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/Bridge.sol#L31), [35](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/Bridge.sol#L35), [42](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/Bridge.sol#L42), [46](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/Bridge.sol#L46)

```solidity
📁 File: contracts/common/AddressResolver.sol

13:     address public addressManager; 
```
[13](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/common/AddressResolver.sol#L13)

```solidity
📁 File: contracts/libs/Lib4844.sol

10:     address public constant POINT_EVALUATION_PRECOMPILE_ADDRESS = address(0x0A); 

13:     uint32 public constant FIELD_ELEMENTS_PER_BLOB = 4096; 

16:     uint256 public constant BLS_MODULUS = 
17:         52_435_875_175_126_190_479_447_740_508_185_965_837_690_552_500_527_637_822_603_658_699_938_581_184_513;
```
[10](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/libs/Lib4844.sol#L10), [13](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/libs/Lib4844.sol#L13), [16](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/libs/Lib4844.sol#L16-L17)

```solidity
📁 File: contracts/signal/LibSignals.sol

8:     bytes32 public constant STATE_ROOT = keccak256("STATE_ROOT"); 

11:     bytes32 public constant SIGNAL_ROOT = keccak256("SIGNAL_ROOT"); 
```
[8](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/signal/LibSignals.sol#L8), [11](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/signal/LibSignals.sol#L11)

```solidity
📁 File: contracts/signal/SignalService.sol

17:     mapping(uint64 chainId => mapping(bytes32 kind => uint64 blockId)) public topBlockId; 

21:     mapping(address addr => bool authorized) public isAuthorized; 
```
[17](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/signal/SignalService.sol#L17), [21](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/signal/SignalService.sol#L21)

```solidity
📁 File: contracts/team/TimelockTokenPool.sol

59:     address public taikoToken; 

62:     address public costToken; 

65:     address public sharedVault; 

68:     uint128 public totalAmountGranted; 

71:     uint128 public totalAmountVoided; 

74:     uint128 public totalAmountWithdrawn; 

77:     uint128 public totalCostPaid; 

80:     mapping(address recipient => Recipient receipt) public recipients; 
```
[59](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/TimelockTokenPool.sol#L59), [62](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/TimelockTokenPool.sol#L62), [65](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/TimelockTokenPool.sol#L65), [68](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/TimelockTokenPool.sol#L68), [71](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/TimelockTokenPool.sol#L71), [74](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/TimelockTokenPool.sol#L74), [77](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/TimelockTokenPool.sol#L77), [80](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/TimelockTokenPool.sol#L80)

```solidity
📁 File: contracts/team/airdrop/ERC20Airdrop.sol

13:     address public token; 

16:     address public vault; 
```
[13](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/airdrop/ERC20Airdrop.sol#L13), [16](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/airdrop/ERC20Airdrop.sol#L16)

```solidity
📁 File: contracts/team/airdrop/ERC20Airdrop2.sol

16:     address public token; 

19:     address public vault; 

22:     mapping(address addr => uint256 amountClaimed) public claimedAmount; 

25:     mapping(address addr => uint256 amountWithdrawn) public withdrawnAmount; 

28:     uint64 public withdrawalWindow; 
```
[16](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/airdrop/ERC20Airdrop2.sol#L16), [19](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/airdrop/ERC20Airdrop2.sol#L19), [22](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/airdrop/ERC20Airdrop2.sol#L22), [25](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/airdrop/ERC20Airdrop2.sol#L25), [28](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/airdrop/ERC20Airdrop2.sol#L28)

```solidity
📁 File: contracts/team/airdrop/ERC721Airdrop.sol

11:     address public token; 

14:     address public vault; 
```
[11](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/airdrop/ERC721Airdrop.sol#L11), [14](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/airdrop/ERC721Airdrop.sol#L14)

```solidity
📁 File: contracts/team/airdrop/MerkleClaimable.sol

12:     mapping(bytes32 hash => bool claimed) public isClaimed; 

15:     bytes32 public merkleRoot; 

18:     uint64 public claimStart; 

21:     uint64 public claimEnd; 
```
[12](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/airdrop/MerkleClaimable.sol#L12), [15](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/airdrop/MerkleClaimable.sol#L15), [18](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/airdrop/MerkleClaimable.sol#L18), [21](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/airdrop/MerkleClaimable.sol#L21)

```solidity
📁 File: contracts/thirdparty/solmate/LibFixedPointMath.sol

7:     uint128 public constant MAX_EXP_INPUT = 135_305_999_368_893_231_588; 
8:     uint256 public constant SCALING_FACTOR = 1e18; // For fixed point representation factor
```
[7](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/solmate/LibFixedPointMath.sol#L7-L8)

```solidity
📁 File: contracts/tokenvault/BaseNFTVault.sol

47:     bytes4 public constant ERC1155_INTERFACE_ID = 0xd9b67a26; 

50:     bytes4 public constant ERC721_INTERFACE_ID = 0x80ac58cd; 

53:     uint256 public constant MAX_TOKEN_PER_TXN = 10; 

56:     mapping(address btoken => CanonicalNFT canonical) public bridgedToCanonical; 

59:     mapping(uint256 chainId => mapping(address ctoken => address btoken)) public canonicalToBridged; 
```
[47](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BaseNFTVault.sol#L47), [50](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BaseNFTVault.sol#L50), [53](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BaseNFTVault.sol#L53), [56](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BaseNFTVault.sol#L56), [59](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BaseNFTVault.sol#L59)

```solidity
📁 File: contracts/tokenvault/BridgedERC1155.sol

16:     address public srcToken; 

19:     uint256 public srcChainId; 
```
[16](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC1155.sol#L16), [19](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC1155.sol#L19)

```solidity
📁 File: contracts/tokenvault/BridgedERC20.sol

22:     address public srcToken; 

27:     uint256 public srcChainId; 

30:     address public snapshooter; 
```
[22](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC20.sol#L22), [27](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC20.sol#L27), [30](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC20.sol#L30)

```solidity
📁 File: contracts/tokenvault/BridgedERC20Base.sol

11:     address public migratingAddress; 

14:     bool public migratingInbound; 
```
[11](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC20Base.sol#L11), [14](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC20Base.sol#L14)

```solidity
📁 File: contracts/tokenvault/BridgedERC721.sol

14:     address public srcToken; 

17:     uint256 public srcChainId; 
```
[14](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC721.sol#L14), [17](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC721.sol#L17)

```solidity
📁 File: contracts/tokenvault/ERC20Vault.sol

45:     mapping(address btoken => CanonicalERC20 canonical) public bridgedToCanonical; 

49:     mapping(uint256 chainId => mapping(address ctoken => address btoken)) public canonicalToBridged; 

52:     mapping(address btoken => bool blacklisted) public btokenBlacklist; 
```
[45](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC20Vault.sol#L45), [49](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC20Vault.sol#L49), [52](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC20Vault.sol#L52)

```solidity
📁 File: contracts/tokenvault/adapters/USDCAdapter.sol

31:     IUSDC public usdc; 
```
[31](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/adapters/USDCAdapter.sol#L31)

```solidity
📁 File: contracts/verifiers/SgxVerifier.sol

30:     uint64 public constant INSTANCE_EXPIRY = 180 days; 

34:     uint64 public constant INSTANCE_VALIDITY_DELAY = 1 days; 

39:     uint256 public nextInstanceId; 

47:     mapping(uint256 instanceId => Instance instance) public instances; 

55:     mapping(address instanceAddress => bool alreadyAttested) public addressRegistered; 
```
[30](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/verifiers/SgxVerifier.sol#L30), [34](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/verifiers/SgxVerifier.sol#L34), [39](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/verifiers/SgxVerifier.sol#L39), [47](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/verifiers/SgxVerifier.sol#L47), [55](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/verifiers/SgxVerifier.sol#L55)

</details>


---
### [GAS&#x2011;107] Using `storage` instead of `memory` for structs/arrays saves gas
When fetching data from a storage location, assigning the data to a `memory` variable causes all fields of the struct/array to be read from storage, which incurs a Gcoldsload (**2100 gas**) for *each* field of the struct/array. If the fields are read from the new memory variable, they incur an additional `MLOAD` rather than a cheap stack read. Instead of declearing the variable with the `memory` keyword, declaring the variable with the `storage` keyword and caching any fields that need to be re-read in stack variables, will be much cheaper, only incuring the Gcoldsload for the fields actually read. The only time it makes sense to read the whole struct/array into a `memory` variable, is if the full struct/array is being returned by the function, is being passed to a function that requires `memory`, or if the array/struct is being read from another `memory` array/struct


Gas saved per Instance: ~2,100 *(Total: ~92,400)*
<details>
<summary><i>There are 44 instances of this issue:</i></summary>

```solidity
📁 File: contracts/L1/TaikoL1.sol

65:         TaikoData.Config memory config = getConfig(); 

92:         TaikoData.Config memory config = getConfig(); 
```
[65](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/TaikoL1.sol#L65), [92](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/TaikoL1.sol#L92)

```solidity
📁 File: contracts/L1/gov/TaikoTimelockController.sol

17:         address[] memory nil = new address[](0); 
```
[17](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/gov/TaikoTimelockController.sol#L17)

```solidity
📁 File: contracts/L1/hooks/AssignmentHook.sol

77:         Input memory input = abi.decode(_data, (Input)); 
78:         ProverAssignment memory assignment = input.assignment;
```
[77](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/hooks/AssignmentHook.sol#L77-L78)

```solidity
📁 File: contracts/L1/libs/LibProposing.sol

78:         TaikoData.BlockParams memory params = abi.decode(_data, (TaikoData.BlockParams)); 

93:         TaikoData.SlotB memory b = _state.slotB; 

212:         TaikoData.Block memory blk = TaikoData.Block({ 
213:             metaHash: keccak256(abi.encode(meta_)),
214:             // Safeguard the liveness bond to ensure its preservation,
215:             // particularly in scenarios where it might be altered after the
216:             // block's proposal but before it has been proven or verified.
217:             livenessBond: _config.livenessBond,
218:             blockId: b.numBlocks,
219:             proposedAt: meta_.timestamp,
220:             proposedIn: uint64(block.number),
221:             // For a new block, the next transition ID is always 1, not 0.
222:             nextTransitionId: 1,
223:             // For unverified block, its verifiedTransitionId is always 0.
224:             verifiedTransitionId: 0,
225:             assignedProver: params.assignedProver
226:         });
```
[78](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProposing.sol#L78), [93](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProposing.sol#L93), [212](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProposing.sol#L212-L226)

```solidity
📁 File: contracts/L1/libs/LibProving.sol

110:         TaikoData.SlotB memory b = _state.slotB; 

140:         ITierProvider.Tier memory tier = 
141:             ITierProvider(_resolver.resolve("tier_provider", false)).getTier(_proof.tier);

166:                 IVerifier.Context memory ctx = IVerifier.Context({ 
167:                     metaHash: blk.metaHash,
168:                     blobHash: _meta.blobHash,
169:                     // Separate msgSender to allow the prover to be any address in the future.
170:                     prover: msg.sender,
171:                     msgSender: msg.sender,
172:                     blockId: blk.blockId,
173:                     isContesting: isContesting,
174:                     blobUsed: _meta.blobUsed
175:                 });
```
[110](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProving.sol#L110), [140](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProving.sol#L140-L141), [166](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProving.sol#L166-L175)

```solidity
📁 File: contracts/L1/libs/LibUtils.sol

33:         TaikoData.SlotB memory b = _state.slotB; 
```
[33](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibUtils.sol#L33)

```solidity
📁 File: contracts/L1/libs/LibVerifying.sol

99:         TaikoData.SlotB memory b = _state.slotB; 
```
[99](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibVerifying.sol#L99)

```solidity
📁 File: contracts/L2/CrossChainOwned.sol

45:         IBridge.Context memory ctx = IBridge(msg.sender).context(); 
```
[45](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/CrossChainOwned.sol#L45)

```solidity
📁 File: contracts/L2/TaikoL2.sol

136:         Config memory config = getConfig(); 
```
[136](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/TaikoL2.sol#L136)

```solidity
📁 File: contracts/automata-attestation/AutomataDcapV3Attestation.sol

180:         EnclaveIdStruct.EnclaveId memory enclaveId = qeIdentity; 

192:             EnclaveIdStruct.TcbLevel memory tcb = enclaveId.tcbLevels[i]; 

215:             TCBInfoStruct.TCBLevelObj memory current = tcb.tcbLevels[i]; 

260:             IPEMCertChainLib.ECSha256Certificate memory issuer; 

415:         IPEMCertChainLib.ECSha256Certificate[] memory parsedQuoteCerts; 
416:         TCBInfoStruct.TCBInfo memory fetchedTcbInfo;

442:             IPEMCertChainLib.ECSha256Certificate memory pckCert = parsedQuoteCerts[0]; 
```
[180](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/AutomataDcapV3Attestation.sol#L180), [192](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/AutomataDcapV3Attestation.sol#L192), [215](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/AutomataDcapV3Attestation.sol#L215), [260](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/AutomataDcapV3Attestation.sol#L260), [415](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/AutomataDcapV3Attestation.sol#L415-L416), [442](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/AutomataDcapV3Attestation.sol#L442)

```solidity
📁 File: contracts/automata-attestation/lib/PEMCertChainLib.sol

198:             uint256[] memory cpuSvns; 

241:         string[] memory split = LibString.split(contentSlice, string(delimiter)); 

299:                 PCKTCBFlags memory flags; 
```
[198](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/PEMCertChainLib.sol#L198), [241](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/PEMCertChainLib.sol#L241), [299](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/PEMCertChainLib.sol#L299)

```solidity
📁 File: contracts/automata-attestation/lib/QuoteV3Auth/V3Parser.sol

52:         V3Struct.EnclaveReport memory localEnclaveReport = parseEnclaveReport(rawLocalEnclaveReport); 

75:         V3Struct.EnclaveReport memory pckSignedQeReport = v3Quote.v3AuthData.pckSignedQeReport; 

211:         V3Struct.QEAuthData memory qeAuthData; 

216:         V3Struct.CertificationData memory cert; 

276:         IPEMCertChainLib.ECSha256Certificate[] memory parsedQuoteCerts; 
```
[52](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/QuoteV3Auth/V3Parser.sol#L52), [75](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/QuoteV3Auth/V3Parser.sol#L75), [211](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/QuoteV3Auth/V3Parser.sol#L211), [216](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/QuoteV3Auth/V3Parser.sol#L216), [276](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/QuoteV3Auth/V3Parser.sol#L276)

```solidity
📁 File: contracts/libs/LibTrieProof.sol

52:             RLPReader.RLPItem[] memory accountState = RLPReader.readList(rlpAccount); 
```
[52](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/libs/LibTrieProof.sol#L52)

```solidity
📁 File: contracts/signal/SignalService.sol

94:         HopProof[] memory hopProofs = abi.decode(_proof, (HopProof[])); 

103:         HopProof memory hop; 
```
[94](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/signal/SignalService.sol#L94), [103](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/signal/SignalService.sol#L103)

```solidity
📁 File: contracts/thirdparty/optimism/trie/MerkleTrie.sol

79:         TrieNode[] memory proof = _parseProof(_proof); 

86:             TrieNode memory currentNode = proof[i]; 

135:                     RLPReader.RLPItem memory nextNode = currentNode.decoded[branchKey]; 
```
[79](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/trie/MerkleTrie.sol#L79), [86](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/trie/MerkleTrie.sol#L86), [135](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/trie/MerkleTrie.sol#L135)

```solidity
📁 File: contracts/tokenvault/ERC1155Vault.sol

58:         IBridge.Message memory message = IBridge.Message({ 
59:             id: 0, // will receive a new value
60:             from: address(0), // will receive a new value
61:             srcChainId: 0, // will receive a new value
62:             destChainId: _op.destChainId,
63:             srcOwner: msg.sender,
64:             destOwner: _op.destOwner != address(0) ? _op.destOwner : msg.sender,
65:             to: resolve(_op.destChainId, name(), false),
66:             refundTo: _op.refundTo,
67:             value: msg.value - _op.fee,
68:             fee: _op.fee,
69:             gasLimit: _op.gasLimit,
70:             data: data,
71:             memo: _op.memo
72:         });

104:         IBridge.Context memory ctx = checkProcessMessageContext(); 
```
[58](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC1155Vault.sol#L58-L72), [104](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC1155Vault.sol#L104)

```solidity
📁 File: contracts/tokenvault/ERC20Vault.sol

171:             CanonicalERC20 memory ctoken = bridgedToCanonical[btokenOld_]; 

221:         IBridge.Message memory message = IBridge.Message({ 
222:             id: 0, // will receive a new value
223:             from: address(0), // will receive a new value
224:             srcChainId: 0, // will receive a new value
225:             destChainId: _op.destChainId,
226:             srcOwner: msg.sender,
227:             destOwner: _op.destOwner != address(0) ? _op.destOwner : msg.sender,
228:             to: resolve(_op.destChainId, name(), false),
229:             refundTo: _op.refundTo,
230:             value: msg.value - _op.fee,
231:             fee: _op.fee,
232:             gasLimit: _op.gasLimit,
233:             data: data,
234:             memo: _op.memo
235:         });

263:         IBridge.Context memory ctx = checkProcessMessageContext(); 
```
[171](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC20Vault.sol#L171), [221](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC20Vault.sol#L221-L235), [263](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC20Vault.sol#L263)

```solidity
📁 File: contracts/tokenvault/ERC721Vault.sol

44:         IBridge.Message memory message = IBridge.Message({ 
45:             id: 0, // will receive a new value
46:             from: address(0), // will receive a new value
47:             srcChainId: 0, // will receive a new value
48:             destChainId: _op.destChainId,
49:             srcOwner: msg.sender,
50:             destOwner: _op.destOwner != address(0) ? _op.destOwner : msg.sender,
51:             to: resolve(_op.destChainId, name(), false),
52:             refundTo: _op.refundTo,
53:             value: msg.value - _op.fee,
54:             fee: _op.fee,
55:             gasLimit: _op.gasLimit,
56:             data: data,
57:             memo: _op.memo
58:         });

87:         IBridge.Context memory ctx = checkProcessMessageContext(); 
```
[44](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC721Vault.sol#L44-L58), [87](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC721Vault.sol#L87)

```solidity
📁 File: contracts/verifiers/SgxVerifier.sol

132:         address[] memory _address = new address[](1); 
```
[132](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/verifiers/SgxVerifier.sol#L132)

</details>


---
### [GAS&#x2011;108] Using `this.<fn>()` wastes gas
Calling an `external` function internally, through the use of `this` wastes the gas overhead of calling an `external` function (100 gas). Instead, change the function from `external` to `public`, and remove the `this`


Gas saved per Instance: ~100 

<i>There is one instance of this issue:</i>

```solidity
📁 File: contracts/L2/CrossChainOwned.sol

50:         (bool success,) = address(this).call(txdata); 
```
[50](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/CrossChainOwned.sol#L50)


---
### [GAS&#x2011;109] Using variable directly is cheaper
Variables can be accessed directly without the need of accessing them through a function. This can save an extra function call.

<details>
<summary><i>There are 3 instances of this issue:</i></summary>

```solidity
📁 File: contracts/tokenvault/ERC1155Vault.sol

/// @audit Use 'canonicalToBridged' directly instead of '_getOrDeployBridgedToken()'
229:             token = _getOrDeployBridgedToken(ctoken); 
```
[229](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC1155Vault.sol#L229)

```solidity
📁 File: contracts/tokenvault/ERC20Vault.sol

/// @audit Use 'canonicalToBridged' directly instead of '_getOrDeployBridgedToken()'
332:             token_ = _getOrDeployBridgedToken(_ctoken); 
```
[332](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC20Vault.sol#L332)

```solidity
📁 File: contracts/tokenvault/ERC721Vault.sol

/// @audit Use 'canonicalToBridged' directly instead of '_getOrDeployBridgedToken()'
174:             token_ = _getOrDeployBridgedToken(_ctoken); 
```
[174](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC721Vault.sol#L174)

</details>


---
### [GAS&#x2011;110] `x + y` is more efficient than using `+=` for state variables (likewise for `-=`)
In instances found where either `+=` or -= are used against state variables use `x = x + y` instead


Gas saved per Instance: ~248 *(Total: ~1,240)*
<details>
<summary><i>There are 5 instances of this issue:</i></summary>

```solidity
📁 File: contracts/team/TimelockTokenPool.sol

141:         totalAmountGranted += _grant.amount; 

156:         totalAmountVoided += amountVoided; 

216:         totalAmountWithdrawn += amountToWithdraw; 
217:         totalCostPaid += costToWithdraw;
```
[141](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/TimelockTokenPool.sol#L141), [156](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/TimelockTokenPool.sol#L156), [216](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/TimelockTokenPool.sol#L216-L217)

```solidity
📁 File: contracts/verifiers/SgxVerifier.sol

207:             validSince += INSTANCE_VALIDITY_DELAY; 
```
[207](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/verifiers/SgxVerifier.sol#L207)

</details>
