Quality Assurance Report Low And None Critical


# SUMMARY
|      |  issue  |  instance  |
|------|---------|------------|
|[L-01]|No limits when setting state variable amounts|29|
|[L-02]|External calls in an unbounded for-loop may result in a DoS|16|
|[L-03]|The additions/multiplications may silently overflow.|32|
|[L-04]|Unbounded state array which is iterated upon|24|
|[L-05]|Unsafe downcast|29|
|[L-06]|`name()` is not a part of the ERC-20 standard|9|
|[L-07]|Governance functions should be controlled by time locks|6|
|[L-08]|`abi.encodePacked()` should not be used with dynamic types when passing the result to a hash function such as `keccak256()`|3|
|[L-09]|Array lengths not checked|11|
|[L-10]|`require()` should be used instead of `assert()`|4|
|[L-11]|Missing checks for `address(0x0)` when assigning values to address state variables|13|
|[L-12]|Array does not have a `pop` function|1|
|[L-13]|External call recipient may consume all transaction gas|1|
|[L-14]|NFT doesn't handle hard forks|1|
|[L-15]|Setters should have initial value check|1|
|[L-16]|Empty `receive()`/`payable fallback()` function does not authorize requests|1|
|[L-17]|Contracts are designed to receive ETH but do not implement function for withdrawal|1|
|[L-18]|`tokenURI()` does not follow EIP-721|1|
|[L-19]|Int casting `block.timestamp` can reduce the lifespan of a contract|12|
|[L-20]|Constant decimal values|1|
|[L-21]|Pausing withdrawals is unfair to the users|1|
|[L-22]|Double type casts create complexity within the code|16|
|[L-23]|Constructor contains no validation|2|
|[L-24]|For loops in `public` or `external` functions should be avoided due to high gas costs and possible DOS|10|
|[L-25]| Function calls within for loops|5|
|[L-26]|Contracts are not using their OZ Upgradeable counterparts|54|
|[L-27]|Consider implementing two-step procedure for updating protocol addresses|2|
|[L-28]|Missing checks for address(0x0) in the constructor|1|
|[L-29]| Code does not follow the best practice of check-effects-interaction|5|
|[L-30]|issing checks for address(0x0) when updating address state variables|18|
|[L-31]|The setter does not set a state variable or call a fuction|2|
|[L-32]|Prefer continue over revert model in iteration|8|
|[L-33]|Subtraction may underflow if multiplication is too large|1|


## [L-01] No limits when setting state variable amounts

It is important to ensure state variables numbers are set to a reasonable value.


There are 29 instance(s) of this issue:

```solidity
File: contracts/L1/TaikoL1.sol
126             state.slotB.lastUnpausedAt = uint64(block.timestamp);
```
https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/TaikoL1.sol#L126:126

```solidity
File: contracts/L1/libs/LibDepositing.sol
107                 _state.slotA.nextEthDepositToProcess = j;
```
https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibDepositing.sol#L107:107

```solidity
File: contracts/L1/libs/LibProving.sol
78                  _state.slotB.lastUnpausedAt = uint64(block.timestamp);
```
https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProving.sol#L78:78

```solidity
File: contracts/L1/libs/LibVerifying.sol


57              _state.slotA.genesisHeight = uint64(block.number);


58              _state.slotA.genesisTimestamp = uint64(block.timestamp);


216                     _state.slotB.lastVerifiedBlockId = lastVerifiedBlockId;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibVerifying.sol#L216:216

```solidity
File: contracts/L2/TaikoL2.sol


96              gasExcess = _gasExcess;


284                 gasExcess_ = uint64(excess.min(type(uint64).max));


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/TaikoL2.sol#L284:284

```solidity
File: contracts/L2/TaikoL2EIP1559Configurable.sol


37              gasExcess = _newGasExcess;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/TaikoL2EIP1559Configurable.sol#L37:37

```solidity
File: contracts/automata-attestation/lib/PEMCertChainLib.sol


206                 cert.pck.sgxExtension.pcesvn = pcesvn;


363                     pcesvn = uint256(svnValue);


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/PEMCertChainLib.sol#L363:363

```solidity
File: contracts/automata-attestation/lib/QuoteV3Auth/V3Parser.sol


146             enclaveReport.isvProdId = uint16(littleEndianDecode(rawEnclaveReport.substring(256, 2)));


147             enclaveReport.isvSvn = uint16(littleEndianDecode(rawEnclaveReport.substring(258, 2)));


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/QuoteV3Auth/V3Parser.sol#L147:147

```solidity
File: contracts/bridge/Bridge.sol


92                  proofReceipt[msgHash].receivedAt = _timestamp;


146             message_.srcChainId = uint64(block.chainid);


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/Bridge.sol#L146:146

```solidity
File: contracts/common/EssentialContract.sol


70              __paused = _TRUE;


79              __paused = _FALSE;


111             __paused = _FALSE;


125                 __reentry = _reentry;


136                 reentry_ = __reentry;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/common/EssentialContract.sol#L136:136

```solidity
File: contracts/team/airdrop/ERC20Airdrop2.sol


71              withdrawalWindow = _withdrawalWindow;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/airdrop/ERC20Airdrop2.sol#L71:71

```solidity
File: contracts/team/airdrop/MerkleClaimable.sol


91              claimStart = _claimStart;


92              claimEnd = _claimEnd;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/airdrop/MerkleClaimable.sol#L92:92

```solidity
File: contracts/thirdparty/solmate/LibFixedPointMath.sol


76                  r = int256(


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/solmate/LibFixedPointMath.sol#L76:76

```solidity
File: contracts/tokenvault/BridgedERC1155.sol


57              srcChainId = _srcChainId;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC1155.sol#L57:57

```solidity
File: contracts/tokenvault/BridgedERC20.sol
74              srcChainId = _srcChainId;

75              __srcDecimals = _decimals;
```
https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC20.sol#L75:75

```solidity
File: contracts/tokenvault/BridgedERC721.sol
48              srcChainId = _srcChainId;
```
https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC721.sol#L48:48

```solidity
File: contracts/tokenvault/ERC20Vault.sol
361                 balanceChange_ = _amount;
```
https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC20Vault.sol#L361:361


## [L-02] External calls in an unbounded for-loop may result in a DoS

Consider limiting the number of iterations in for-loops that make external calls.


There are 16 instance(s) of this issue:

```solidity
File: contracts/L1/libs/LibProposing.sol
244     for (uint256 i; i < params.hookCalls.length; ++i) {
```
https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProposing.sol#L244:244

```solidity
File: contracts/L1/provers/Guardians.sol
80        for (uint256 i = 0; i < _newGuardians.length; ++i) {
```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/provers/Guardians.sol#L80:80

```solidity
File: contracts/L2/TaikoL2.sol
234   for (uint256 i; i < 255 && _blockId >= i + 1; ++i) {
```
https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/TaikoL2.sol#L234:234

```solidity
File: contracts/bridge/Bridge.sol
90              for (uint256 i; i < _msgHashes.length; ++i) {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/Bridge.sol#L90:90

```solidity
File: contracts/signal/SignalService.sol
104             for (uint256 i; i < hopProofs.length; ++i) {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/signal/SignalService.sol#L104:104

```solidity
File: contracts/team/airdrop/ERC721Airdrop.sol
59              for (uint256 i; i < tokenIds.length; ++i) {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/airdrop/ERC721Airdrop.sol#L59:59

```solidity
File: contracts/thirdparty/optimism/trie/MerkleTrie.sol
85              for (uint256 i = 0; i < proof.length; i++) {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/trie/MerkleTrie.sol#L85:85

```solidity
File: contracts/tokenvault/ERC1155Vault.sol


47              for (uint256 i; i < _op.amounts.length; ++i) {


251                     for (uint256 i; i < _op.tokenIds.length; ++i) {


269                     for (uint256 i; i < _op.tokenIds.length; ++i) {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC1155Vault.sol#L269:269

```solidity
File: contracts/tokenvault/ERC721Vault.sol


34              for (uint256 i; i < _op.tokenIds.length; ++i) {


170                 for (uint256 i; i < _tokenIds.length; ++i) {


175                 for (uint256 i; i < _tokenIds.length; ++i) {


197                     for (uint256 i; i < _op.tokenIds.length; ++i) {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC721Vault.sol#L197:197

```solidity
File: contracts/verifiers/SgxVerifier.sol


104             for (uint256 i; i < _ids.length; ++i) {


210             for (uint256 i; i < _instances.length; ++i) {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/verifiers/SgxVerifier.sol#L210:210

## [L-03] The additions/multiplications may silently overflow.
The additions/multiplications may silently overflow because they're in unchecked blocks with no preceding value checks, which may lead to unexpected results.

There are 32 instance(s) of this issue:

```solidity
File: contracts/L1/libs/LibDepositing.sol
140                     && _state.slotA.numEthDeposits - _state.slotA.nextEthDepositToProcess

141                         < _config.ethDepositRingBufferSize - 1;
```
https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibDepositing.sol#L141:141

```solidity
File: contracts/L1/libs/LibProposing.sol
122                     l1Hash: blockhash(block.number - 1),

131                     l1Height: uint64(block.number - 1),
```
https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProposing.sol#L131:131

```solidity
File: contracts/L1/libs/LibProving.sol
382                     _tko.transfer(msg.sender, reward - _tier.validityBond);

384                     _tko.transferFrom(msg.sender, address(this), _tier.validityBond - reward);
```
https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProving.sol#L384:384

```solidity
File: contracts/L1/libs/LibVerifying.sol
152                             uint256(ITierProvider(tierProvider).getTier(ts.tier).cooldownWindow) * 60
153                                 + uint256(ts.timestamp).max(_state.slotB.lastUnpausedAt) > block.timestamp

178                     uint256 bondToReturn = uint256(ts.validityBond) + blk.livenessBond;

213                     uint64 lastVerifiedBlockId = b.lastVerifiedBlockId + numBlocksVerified;
```
https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibVerifying.sol#L213:213

```solidity
File: contracts/L1/provers/Guardians.sol
116                 _approvals[version][_hash] |= 1 << (id - 1);
```
https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/provers/Guardians.sol#L116:116

```solidity
File: contracts/L2/TaikoL2.sol
127                 parentId = block.number - 1;

234                 for (uint256 i; i < 255 && _blockId >= i + 1; ++i) {

235                     uint256 j = _blockId - i - 1;
```
https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/TaikoL2.sol#L235:235

```solidity
File: contracts/thirdparty/optimism/Bytes.sol
25                  require(_length + 31 >= _length, "slice_overflow");

26                  require(_start + _length >= _start, "slice_overflow");

27                  require(_bytes.length >= _start + _length, "slice_outOfBounds");
```
https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/Bytes.sol#L27:27

```solidity
File: contracts/thirdparty/solmate/LibFixedPointMath.sol
33                  x = (x << 78) / 5 ** 18;


39                  int256 k = ((x << 96) / 54_916_777_467_707_473_351_141_471_128 + 2 ** 95) >> 96;


40                  x = x - k * 54_916_777_467_707_473_351_141_471_128;


45                  int256 y = x + 1_346_386_616_545_796_478_920_950_773_328;


46                  y = ((y * x) >> 96) + 57_155_421_227_552_351_082_224_309_758_442;


47                  int256 p = y + x - 94_201_549_194_550_492_254_356_042_504_812;


48                  p = ((p * y) >> 96) + 28_719_021_644_029_726_153_956_944_680_412_240;


49                  p = p * x + (4_385_272_521_454_847_904_659_076_985_693_276 << 96);


53                  int256 q = x - 2_855_989_394_907_223_263_936_484_059_900;


54                  q = ((q * x) >> 96) + 50_020_603_652_535_783_019_961_831_881_945;


55                  q = ((q * x) >> 96) - 533_845_033_583_426_703_283_633_433_725_380;


56                  q = ((q * x) >> 96) + 3_604_857_256_930_695_427_073_651_918_091_429;


57                  q = ((q * x) >> 96) - 14_423_608_567_350_463_180_887_372_962_807_573;


58                  q = ((q * x) >> 96) + 26_449_188_498_355_588_339_934_803_723_976_023;


77                      (uint256(r) * 3_822_833_074_963_236_453_042_738_258_902_158_003_155_416_615_667)


78                          >> uint256(195 - k)


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/solmate/LibFixedPointMath.sol#L78:78


## [L-04] Unbounded state array which is iterated upon

Iterating over an unbounded state array in Solidity can result in excessive gas consumption, especially if the array size exceeds the block gas limit. This issue commonly arises in tasks like token distribution. To address this, it is recommended to limit array sizes for iteration, consider alternative data structures like linked lists, adopt paginated processing for smaller batches over multiple transactions, or use a 'state array' with a separate index-tracking array to manage large datasets and avoid gas-related problems.


There are 24 instance(s) of this issue:

```solidity
File: contracts/L1/provers/Guardians.sol


75                  delete guardianIds[guardians[i]];


75                  delete guardianIds[guardians[i]];


84                  if (guardianIds[guardian] != 0) revert INVALID_GUARDIAN_SET();


88                  guardianIds[guardian] = guardians.length;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/provers/Guardians.sol#L88:88

```solidity
File: contracts/automata-attestation/AutomataDcapV3Attestation.sol


81                  if (_serialNumIsRevoked[index][serialNumBatch[i]]) {


81                  if (_serialNumIsRevoked[index][serialNumBatch[i]]) {


84                  _serialNumIsRevoked[index][serialNumBatch[i]] = true;


84                  _serialNumIsRevoked[index][serialNumBatch[i]] = true;


96                  if (!_serialNumIsRevoked[index][serialNumBatch[i]]) {


96                  if (!_serialNumIsRevoked[index][serialNumBatch[i]]) {


99                  delete _serialNumIsRevoked[index][serialNumBatch[i]];


99                  delete _serialNumIsRevoked[index][serialNumBatch[i]];


268                         certRevoked = _serialNumIsRevoked[uint256(IPEMCertChainLib.CRL.ROOT)][certs[i]
269                             .serialNumber];


268                         certRevoked = _serialNumIsRevoked[uint256(IPEMCertChainLib.CRL.ROOT)][certs[i]


271                         certRevoked = _serialNumIsRevoked[uint256(IPEMCertChainLib.CRL.PCK)][certs[i]
272                             .serialNumber];


271                         certRevoked = _serialNumIsRevoked[uint256(IPEMCertChainLib.CRL.PCK)][certs[i]


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/AutomataDcapV3Attestation.sol#L271:271

```solidity
File: contracts/automata-attestation/utils/BytesUtils.sol


336                 decoded = uint8(BASE32_HEX_TABLE[uint256(uint8(char)) - 0x30]);


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/BytesUtils.sol#L336:336

```solidity
File: contracts/bridge/Bridge.sol


92                  proofReceipt[msgHash].receivedAt = _timestamp;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/Bridge.sol#L92:92

```solidity
File: contracts/verifiers/SgxVerifier.sol
107                 if (instances[idx].addr == address(0)) revert SGX_INVALID_INSTANCE();

109                 emit InstanceDeleted(idx, instances[idx].addr);

111                 delete instances[idx];

211                 if (addressRegistered[_instances[i]]) revert SGX_ALREADY_ATTESTED();

213                 addressRegistered[_instances[i]] = true;

217                 instances[nextInstanceId] = Instance(_instances[i], validSince);
```
https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/verifiers/SgxVerifier.sol#L217:217



## [L-05] Unsafe downcast

When a type is downcast to a smaller type, the higher order bits are truncated, effectively applying a modulo to the original value. Without any other checks, this wrapping will lead to unexpected behavior and bugs.


There are 29 instance(s) of this issue:

```solidity
File: contracts/L1/TaikoL1.sol


126             state.slotB.lastUnpausedAt = uint64(block.timestamp);


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/TaikoL1.sol#L126:126

```solidity
File: contracts/L1/libs/LibProposing.sol


191                 meta_.txListByteSize = uint24(_txList.length);


130                     timestamp: uint64(block.timestamp),


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProposing.sol#L130:130

```solidity
File: contracts/L1/libs/LibProving.sol


414             bool inProvingWindow = uint256(_ts.timestamp).max(_state.slotB.lastUnpausedAt)


78                  _state.slotB.lastUnpausedAt = uint64(block.timestamp);


264             ts.timestamp = uint64(block.timestamp);


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProving.sol#L264:264

```solidity
File: contracts/L1/libs/LibVerifying.sol


153                                 + uint256(ts.timestamp).max(_state.slotB.lastUnpausedAt) > block.timestamp


71              ts.timestamp = uint64(block.timestamp);


58              _state.slotA.genesisTimestamp = uint64(block.timestamp);


64              blk.proposedAt = uint64(block.timestamp);


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibVerifying.sol#L64:64

```solidity
File: contracts/automata-attestation/utils/Asn1Decode.sol


207                 ixLastContentByte = uint80(ixFirstContentByte + length - 1);


196                 uint8 lengthbytesLength = uint8(der[ix + 1] & 0x7F);


206                 ixFirstContentByte = uint80(ix + 2 + lengthbytesLength);


25              return uint80(self >> 160);


20              return uint80(self >> 80);


192                 length = uint8(der[ix + 1]);


193                 ixFirstContentByte = uint80(ix + 2);


194                 ixLastContentByte = uint80(ixFirstContentByte + length - 1);


15              return uint80(self);


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/Asn1Decode.sol#L15:15

```solidity
File: contracts/automata-attestation/utils/BytesUtils.sol


189             return uint8(self[idx]);


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/BytesUtils.sol#L189:189

```solidity
File: contracts/bridge/Bridge.sol


89              uint64 _timestamp = _suspend ? type(uint64).max : uint64(block.timestamp);


533                 _storeContext(bytes32(PLACEHOLDER), address(uint160(PLACEHOLDER)), uint64(PLACEHOLDER));


183                 receivedAt = uint64(block.timestamp);


240                 receivedAt = uint64(block.timestamp);


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/Bridge.sol#L240:240

```solidity
File: contracts/thirdparty/optimism/rlp/RLPWriter.sol


45                  out_[0] = bytes1(uint8(lenLen) + uint8(_offset) + 55);


47                      out_[i] = bytes1(uint8((_len / (256 ** (lenLen - i))) % 256));


35                  out_[0] = bytes1(uint8(_len) + uint8(_offset));


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/rlp/RLPWriter.sol#L35:35

```solidity
File: contracts/verifiers/SgxVerifier.sol
204             uint64 validSince = uint64(block.timestamp);

229             instances[id] = Instance(newInstance, uint64(block.timestamp));
```
https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/verifiers/SgxVerifier.sol#L229:229


## [L-06] `name()` is not a part of the ERC-20 standard

The `name()` function is not a part of the [ERC-20 standard](https://eips.ethereum.org/EIPS/eip-20), and was added later as an [optional extension](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/extensions/IERC20Metadata.sol). As such, some valid ERC20 tokens do not support this interface, so it is unsafe to blindly cast all tokens to this interface, and then call this function.

There are 9 instance(s) of this issue:

```solidity
File: contracts/tokenvault/ERC1155Vault.sol


306                 (owner(), addressManager, _ctoken.addr, _ctoken.chainId, _ctoken.symbol, _ctoken.name)


264                         ctoken_.name = _name;


319                 ctokenName: _ctoken.name


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC1155Vault.sol#L319:319

```solidity
File: contracts/tokenvault/ERC20Vault.sol


197                 ctokenName: _ctoken.name,


177                         || keccak256(bytes(ctoken.name)) != keccak256(bytes(_ctoken.name))


417                     ctoken.name


430                 ctokenName: ctoken.name,


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC20Vault.sol#L430:430

```solidity
File: contracts/tokenvault/ERC721Vault.sol


255                 ctokenName: _ctoken.name


243                 (owner(), addressManager, _ctoken.addr, _ctoken.chainId, _ctoken.symbol, _ctoken.name)


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC721Vault.sol#L243:243



## [L-07] Governance functions should be controlled by time locks

Governance functions (such as upgrading contracts, setting critical parameters) should be controlled using time locks to introduce a delay between a proposal and its execution. This gives users time to exit before a potentially dangerous or malicious operation is applied.

There are 6 instance(s) of this issue:

```solidity
File: contracts/L1/TaikoToken.sol


47          function burn(address _from, uint256 _amount) public onlyOwner {

```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/TaikoToken.sol#L47:49

```solidity
File: contracts/L2/TaikoL2EIP1559Configurable.sol


25          function setConfigAndExcess(
26              Config memory _newConfig,
27              uint64 _newGasExcess
28          )
29              external
30              virtual
31              onlyOwner
32          {

```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/TaikoL2EIP1559Configurable.sol#L25:40

```solidity
File: contracts/automata-attestation/AutomataDcapV3Attestation.sol


69          function setMrEnclave(bytes32 _mrEnclave, bool _trusted) external onlyOwner {

73          function addRevokedCertSerialNum(
74              uint256 index,
75              bytes[] calldata serialNumBatch
76          )
77              external
78              onlyOwner
79          {

65          function setMrSigner(bytes32 _mrSigner, bool _trusted) external onlyOwner {

88          function removeRevokedCertSerialNum(
89              uint256 index,
90              bytes[] calldata serialNumBatch
91          )
92              external
93              onlyOwner
94          {

122         function toggleLocalReportCheck() external onlyOwner {

114         function configureQeIdentityJson(EnclaveIdStruct.EnclaveId calldata qeIdentityInput)
115             external
116             onlyOwner
117         {

103         function configureTcbInfoJson(
104             string calldata fmspc,
105             TCBInfoStruct.TCBInfo calldata tcbInfoInput
106         )
107             public
108             onlyOwner
109         {

```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/AutomataDcapV3Attestation.sol#L103:112

```solidity
File: contracts/common/AddressManager.sol


38          function setAddress(
39              uint64 _chainId,
40              bytes32 _name,
41              address _newAddress
42          )
43              external
44              virtual
45              onlyOwner
46          {

```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/common/AddressManager.sol#L38:51

```solidity
File: contracts/signal/SignalService.sol


56          function authorize(address _addr, bool _authorize) external onlyOwner {

```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/signal/SignalService.sol#L56:60

```solidity
File: contracts/team/TimelockTokenPool.sol


150         function void(address _recipient) external onlyOwner {

135         function grant(address _recipient, Grant memory _grant) external onlyOwner {

```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/TimelockTokenPool.sol#L135:144

```solidity
File: contracts/tokenvault/BridgedERC20.sol


80          function setSnapshoter(address _snapshooter) external onlyOwner {

```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC20.sol#L80:82

```solidity
File: contracts/tokenvault/ERC20Vault.sol


148         function changeBridgedToken(
149             CanonicalERC20 calldata _ctoken,
150             address _btokenNew
151         )
152             external
153             nonReentrant
154             whenNotPaused
155             onlyOwner
156             returns (address btokenOld_)
157         {

```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC20Vault.sol#L148:200

```solidity
File: contracts/verifiers/SgxVerifier.sol
90         function addInstances(address[] calldata _instances)
91              external
92              onlyOwner
93              returns (uint256[] memory)
94          {
```
https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/verifiers/SgxVerifier.sol#L90:96




## [L-08] `abi.encodePacked()` should not be used with dynamic types when passing the result to a hash function such as `keccak256()`

Use `abi.encode()` instead which will pad items to 32 bytes, which will [prevent hash collisions](https://docs.soliditylang.org/en/v0.8.13/abi-spec.html#non-standard-packed-mode) (e.g. `abi.encodePacked(0x123,0x456)` => `0x123456` => `abi.encodePacked(0x1,0x23456)`, but `abi.encode(0x123,0x456)` => `0x0...1230...456`). Unless there is a compelling reason, `abi.encode` should be preferred. If there is only one argument to `abi.encodePacked()` it can often be cast to `bytes()` or `bytes32()` [instead](https://ethereum.stackexchange.com/questions/30912/how-to-compare-strings-in-solidity#answer-82739). If all arguments are strings and or bytes, `bytes.concat()` should be used instead.

There are 3 instance(s) of this issue:
```solidity
File: contracts/L1/libs/LibProposing.sol


meta_.difficulty = keccak256(abi.encodePacked(block.prevrandao, b.numBlocks, block.number));

```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProposing.sol#L204:204

```solidity
File: contracts/signal/SignalService.sol


return keccak256(abi.encodePacked("SIGNAL", _chainId, _app, _signal));

```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/signal/SignalService.sol#L203:203

```solidity
File: contracts/team/TimelockTokenPool.sol


bytes32 hash = keccak256(abi.encodePacked("Withdraw unlocked Taiko token to: ", _to));

```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/TimelockTokenPool.sol#L170:170


## [L-09] Array lengths not checked

If the length of the arrays are not required to be of the same length, user operations may not be fully executed due to a mismatch in the number of items iterated over, versus the number of items provided in the second array.


There are 11 instance(s) of this issue:

```solidity
File: contracts/L1/gov/TaikoGovernor.sol


48          function propose(
49              address[] memory _targets,
50              uint256[] memory _values,
51              bytes[] memory _calldatas,
52              string memory _description
53          )
54              public
55              override(IGovernorUpgradeable, GovernorUpgradeable, GovernorCompatibilityBravoUpgradeable)
56              returns (uint256)
57          {
58              return super.propose(_targets, _values, _calldatas, _description);
59          }


69          function propose(
70              address[] memory _targets,
71              uint256[] memory _values,
72              string[] memory _signatures,
73              bytes[] memory _calldatas,
74              string memory _description
75          )
76              public
77              virtual
78              override(GovernorCompatibilityBravoUpgradeable)
79              returns (uint256)
80          {
81              if (_signatures.length != _calldatas.length) revert TG_INVALID_SIGNATURES_LENGTH();
82      
83              return GovernorCompatibilityBravoUpgradeable.propose(
84                  _targets, _values, _signatures, _calldatas, _description
85              );
86          }


127         function _execute(
128             uint256 _proposalId,
129             address[] memory _targets,
130             uint256[] memory _values,
131             bytes[] memory _calldatas,
132             bytes32 _descriptionHash
133         )
134             internal
135             override(GovernorUpgradeable, GovernorTimelockControlUpgradeable)
136         {
137             super._execute(_proposalId, _targets, _values, _calldatas, _descriptionHash);
138         }


140         function _cancel(
141             address[] memory _targets,
142             uint256[] memory _values,
143             bytes[] memory _calldatas,
144             bytes32 _descriptionHash
145         )
146             internal
147             override(GovernorUpgradeable, GovernorTimelockControlUpgradeable)
148             returns (uint256)
149         {
150             return super._cancel(_targets, _values, _calldatas, _descriptionHash);
151         }


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/gov/TaikoGovernor.sol#L140:151

```solidity
File: contracts/libs/Lib4844.sol


30          function evaluatePoint(
31              bytes32 _blobHash,
32              uint256 _x,
33              uint256 _y,
34              bytes1[48] memory _commitment,
35              bytes1[48] memory _pointProof
36          )
37              internal
38              view
39          {
40              if (_x >= BLS_MODULUS) revert POINT_X_TOO_LARGE();
41              if (_y >= BLS_MODULUS) revert POINT_Y_TOO_LARGE();
42      
43              (bool ok, bytes memory ret) = POINT_EVALUATION_PRECOMPILE_ADDRESS.staticcall(
44                  abi.encodePacked(_blobHash, _x, _y, _commitment, _pointProof)
45              );
46      
47              if (!ok) revert EVAL_FAILED_1();
48      
49              if (ret.length != 64) revert EVAL_FAILED_2();
50      
51              bytes32 first;
52              bytes32 second;
53              assembly {
54                  first := mload(add(ret, 32))
55                  second := mload(add(ret, 64))
56              }
57              if (uint256(first) != FIELD_ELEMENTS_PER_BLOB || uint256(second) != BLS_MODULUS) {
58                  revert EVAL_FAILED_2();
59              }
60          }


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/libs/Lib4844.sol#L30:60

```solidity
File: contracts/libs/LibTrieProof.sol


34          function verifyMerkleProof(
35              bytes32 _rootHash,
36              address _addr,
37              bytes32 _slot,
38              bytes32 _value,
39              bytes[] memory _accountProof,
40              bytes[] memory _storageProof
41          )
42              internal
43              pure
44              returns (bytes32 storageRoot_)
45          {
46              if (_accountProof.length != 0) {
47                  bytes memory rlpAccount =
48                      SecureMerkleTrie.get(abi.encodePacked(_addr), _accountProof, _rootHash);
49      
50                  if (rlpAccount.length == 0) revert LTP_INVALID_ACCOUNT_PROOF();
51      
52                  RLPReader.RLPItem[] memory accountState = RLPReader.readList(rlpAccount);
53      
54                  storageRoot_ =
55                      bytes32(RLPReader.readBytes(accountState[_ACCOUNT_FIELD_INDEX_STORAGE_HASH]));
56              } else {
57                  storageRoot_ = _rootHash;
58              }
59      
60              bool verified = SecureMerkleTrie.verifyInclusionProof(
61                  bytes.concat(_slot), RLPWriter.writeUint(uint256(_value)), _storageProof, storageRoot_
62              );
63      
64              if (!verified) revert LTP_INVALID_INCLUSION_PROOF();
65          }


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/libs/LibTrieProof.sol#L34:65

```solidity
File: contracts/team/airdrop/ERC721Airdrop.sol


47          function claim(
48              address user,
49              uint256[] calldata tokenIds,
50              bytes32[] calldata proof
51          )
52              external
53              nonReentrant
54          {
55              // Check if this can be claimed
56              _verifyClaim(abi.encode(user, tokenIds), proof);
57      
58              // Transfer the tokens
59              for (uint256 i; i < tokenIds.length; ++i) {
60                  IERC721(token).safeTransferFrom(vault, user, tokenIds[i]);
61              }
62          }


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/airdrop/ERC721Airdrop.sol#L47:62

```solidity
File: contracts/tokenvault/BridgedERC1155.sol


83          function mintBatch(
84              address _to,
85              uint256[] memory _tokenIds,
86              uint256[] memory _amounts
87          )
88              public
89              nonReentrant
90              whenNotPaused
91              onlyFromNamed("erc1155_vault")
92          {
93              _mintBatch(_to, _tokenIds, _amounts, "");
94          }


125         function _beforeTokenTransfer(
126             address, /*_operator*/
127             address, /*_from*/
128             address _to,
129             uint256[] memory, /*_ids*/
130             uint256[] memory, /*_amounts*/
131             bytes memory /*_data*/
132         )
133             internal
134             virtual
135             override
136         {
137             if (_to == address(this)) revert BTOKEN_CANNOT_RECEIVE();
138             if (paused()) revert INVALID_PAUSE_STATUS();
139         }


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC1155.sol#L125:139

```solidity
File: contracts/tokenvault/ERC1155Vault.sol


160         function onERC1155BatchReceived(
161             address,
162             address,
163             uint256[] calldata,
164             uint256[] calldata,
165             bytes calldata
166         )
167             external
168             pure
169             returns (bytes4)
170         {
171             return IERC1155ReceiverUpgradeable.onERC1155BatchReceived.selector;
172         }


214         function _transferTokens(
215             CanonicalNFT memory ctoken,
216             address to,
217             uint256[] memory tokenIds,
218             uint256[] memory amounts
219         )
220             private
221             returns (address token)
222         {
223             if (ctoken.chainId == block.chainid) {
224                 // Token lives on this chain
225                 token = ctoken.addr;
226                 IERC1155(token).safeBatchTransferFrom(address(this), to, tokenIds, amounts, "");
227             } else {
228                 // Token does not live on this chain
229                 token = _getOrDeployBridgedToken(ctoken);
230                 BridgedERC1155(token).mintBatch(to, tokenIds, amounts);
231             }
232         }


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC1155Vault.sol#L214:232




## [L-10] `require()` should be used instead of `assert()`

Prior to solidity version 0.8.0, hitting an assert consumes the remainder of the transaction's available gas rather than returning it, as require()/revert() do. assert() should be avoided even past solidity version 0.8.0 as its documentation states that 'The assert function creates an error of type Panic(uint256). ... Properly functioning code should never create a Panic, not even on invalid external input. If this happens, then there is a bug in your contract which you should fix'.


There are 4 instance(s) of this issue:

```solidity
File: contracts/L1/libs/LibProving.sol


223                     assert(tier.validityBond == 0);


224                     assert(ts.validityBond == 0 && ts.contestBond == 0 && ts.contester == address(0));


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProving.sol#L224:224

```solidity
File: contracts/automata-attestation/utils/SigVerifyLib.sol


138             assert(success); // never reverts, always returns 0 or 1


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/SigVerifyLib.sol#L138:138

```solidity
File: contracts/bridge/Bridge.sol


486             assert(_message.from != address(this));


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/Bridge.sol#L486:486



## [L-11] Missing checks for `address(0x0)` when assigning values to address state variables

This issue arises when an address state variable is assigned a value without a preceding check to ensure it isn't address(0x0). This can lead to unexpected behavior as address(0x0) often represents an uninitialized address.


There are 13 instance(s) of this issue:

```solidity
File: contracts/bridge/Bridge.sol


549                 __ctx = Context(_msgHash, _from, _srcChainId);


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/Bridge.sol#L549:549

```solidity
File: contracts/common/AddressResolver.sol


62              addressManager = _addressManager;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/common/AddressResolver.sol#L62:62

```solidity
File: contracts/team/airdrop/ERC20Airdrop.sol


41              token = _token;


42              vault = _vault;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/airdrop/ERC20Airdrop.sol#L42:42

```solidity
File: contracts/team/airdrop/ERC20Airdrop2.sol


69              token = _token;


70              vault = _vault;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/airdrop/ERC20Airdrop2.sol#L70:70

```solidity
File: contracts/team/airdrop/ERC721Airdrop.sol


39              token = _token;


40              vault = _vault;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/airdrop/ERC721Airdrop.sol#L40:40

```solidity
File: contracts/tokenvault/BridgedERC1155.sol


56              srcToken = _srcToken;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC1155.sol#L56:56

```solidity
File: contracts/tokenvault/BridgedERC20.sol


73              srcToken = _srcToken;


81              snapshooter = _snapshooter;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC20.sol#L81:81

```solidity
File: contracts/tokenvault/BridgedERC20Base.sol


49              migratingAddress = _migratingAddress;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC20Base.sol#L49:49

```solidity
File: contracts/tokenvault/BridgedERC721.sol


47              srcToken = _srcToken;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC721.sol#L47:47






## [L-12] Array does not have a `pop` function

Arrays without the pop operation in Solidity can lead to inefficient memory management and increase the likelihood of out-of-gas errors.


```solidity
File: contracts/L1/provers/Guardians.sol


87                  guardians.push(guardian);


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/provers/Guardians.sol#L87:87



## [L-13] External call recipient may consume all transaction gas

There is no limit specified on the amount of gas used, so the recipient can use up all of the transaction's gas, causing it to revert. Use `addr.call{gas: <amount>}()` or [this](https://github.com/nomad-xyz/ExcessivelySafeCall) library instead.


```solidity
File: contracts/L2/CrossChainOwned.sol


50              (bool success,) = address(this).call(txdata);


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/CrossChainOwned.sol#L50:50

## [L-14] NFT doesn't handle hard forks

When there are hard forks, users often have to go through [many hoops](https://twitter.com/elerium115/status/1558471934924431363) to ensure that they control ownership on every fork. Consider adding `require(1 == chain.chainId)`, or the chain ID of whichever chain you prefer, to the functions below, or at least include the chain ID in the URI, so that there is no confusion about which chain is the owner of the NFT.


```solidity
File: contracts/tokenvault/BridgedERC721.sol


107         function tokenURI(uint256 _tokenId) public view virtual override returns (string memory) {
108             return string(
109                 abi.encodePacked(
110                     LibBridgedToken.buildURI(srcToken, srcChainId), Strings.toString(_tokenId)
111                 )
112             );
113         }


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC721.sol#L107:113

## [L-15] Setters should have initial value check

Setters should have initial value check to prevent assigning wrong value to the variable. Assginment of wrong value can lead to unexpected behavior of the contract.


There are 5 instance(s) of this issue:

```solidity
File: contracts/L2/TaikoL2EIP1559Configurable.sol


25          function setConfigAndExcess(
26              Config memory _newConfig,
27              uint64 _newGasExcess
28          )
29              external
30              virtual
31              onlyOwner
32          {
33              if (_newConfig.gasTargetPerL1Block == 0) revert L2_INVALID_CONFIG();
34              if (_newConfig.basefeeAdjustmentQuotient == 0) revert L2_INVALID_CONFIG();
35      
36              customConfig = _newConfig;
37              gasExcess = _newGasExcess;
38      
39              emit ConfigAndExcessChanged(_newConfig, _newGasExcess);
40          }


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/TaikoL2EIP1559Configurable.sol#L25:40

```solidity
File: contracts/automata-attestation/AutomataDcapV3Attestation.sol


65          function setMrSigner(bytes32 _mrSigner, bool _trusted) external onlyOwner {
66              _trustedUserMrSigner[_mrSigner] = _trusted;
67          }


69          function setMrEnclave(bytes32 _mrEnclave, bool _trusted) external onlyOwner {
70              _trustedUserMrEnclave[_mrEnclave] = _trusted;
71          }


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/AutomataDcapV3Attestation.sol#L69:71

```solidity
File: contracts/common/AddressManager.sol


38          function setAddress(
39              uint64 _chainId,
40              bytes32 _name,
41              address _newAddress
42          )
43              external
44              virtual
45              onlyOwner
46          {
47              address oldAddress = __addresses[_chainId][_name];
48              if (_newAddress == oldAddress) revert AM_INVALID_PARAMS();
49              __addresses[_chainId][_name] = _newAddress;
50              emit AddressSet(_chainId, _name, _newAddress, oldAddress);
51          }


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/common/AddressManager.sol#L38:51

```solidity
File: contracts/tokenvault/BridgedERC20.sol


80          function setSnapshoter(address _snapshooter) external onlyOwner {
81              snapshooter = _snapshooter;
82          }


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC20.sol#L80:82



## [L-16] Empty `receive()`/`payable fallback()` function does not authorize requests

If the intention is for the Ether to be used, the function should call another function, otherwise it should revert (e.g. `require(msg.sender == address(weth))`). Having no access control on the function means that someone may send Ether to the contract, and have no way to get anything back out, which is a loss of funds. If the concern is having to spend a small amount of gas to check the sender against an immutable address, the code should at least have a function to rescue unused Ether.


```solidity
File: contracts/bridge/Bridge.sol


70          receive() external payable { }


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/Bridge.sol#L70:70

## [L-17] Contracts are designed to receive ETH but do not implement function for withdrawal

The following contracts can receive ETH but can not withdraw, ETH is occasionally sent by users will be stuck in those contracts. This functionality also applies to baseTokens resulting in locked tokens and loss of funds.


```solidity
File: contracts/bridge/Bridge.sol


70          receive() external payable { }


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/Bridge.sol#L70:70

## [L-18] `tokenURI()` does not follow EIP-721

The [EIP](https://eips.ethereum.org/EIPS/eip-721) states that `tokenURI()` "Throws if `_tokenId` is not a valid NFT", which the code below does not do. If the NFT has not yet been minted, `tokenURI()` should revert.


```solidity
File: contracts/tokenvault/BridgedERC721.sol


107         function tokenURI(uint256 _tokenId) public view virtual override returns (string memory) {
108             return string(
109                 abi.encodePacked(
110                     LibBridgedToken.buildURI(srcToken, srcChainId), Strings.toString(_tokenId)
111                 )
112             );
113         }


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC721.sol#L107:113

## [L-19] Int casting `block.timestamp` can reduce the lifespan of a contract

Consider removing casting to ensure future functionality.


There are 12 instance(s) of this issue:

```solidity
File: contracts/L1/TaikoL1.sol


126             state.slotB.lastUnpausedAt = uint64(block.timestamp);


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/TaikoL1.sol#L126:126

```solidity
File: contracts/L1/libs/LibProposing.sol


130                     timestamp: uint64(block.timestamp),


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProposing.sol#L130:130

```solidity
File: contracts/L1/libs/LibProving.sol


78                  _state.slotB.lastUnpausedAt = uint64(block.timestamp);


264             ts.timestamp = uint64(block.timestamp);


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProving.sol#L264:264

```solidity
File: contracts/L1/libs/LibVerifying.sol


58              _state.slotA.genesisTimestamp = uint64(block.timestamp);


64              blk.proposedAt = uint64(block.timestamp);


71              ts.timestamp = uint64(block.timestamp);


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibVerifying.sol#L71:71

```solidity
File: contracts/bridge/Bridge.sol


89              uint64 _timestamp = _suspend ? type(uint64).max : uint64(block.timestamp);


183                 receivedAt = uint64(block.timestamp);


240                 receivedAt = uint64(block.timestamp);


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/Bridge.sol#L240:240

```solidity
File: contracts/verifiers/SgxVerifier.sol


204             uint64 validSince = uint64(block.timestamp);


229             instances[id] = Instance(newInstance, uint64(block.timestamp));


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/verifiers/SgxVerifier.sol#L229:229



## [L-20] Constant decimal values

The use of fixed decimal values such as 1e18 or 1e8 in Solidity contracts can lead to inaccuracies, bugs, and vulnerabilities, particularly when interacting with tokens having different decimal configurations. Not all ERC20 tokens follow the standard 18 decimal places, and assumptions about decimal places can lead to miscalculations. Always retrieve and use the decimals() function from the token contract itself when performing calculations involving token amounts.


```solidity
File: contracts/team/TimelockTokenPool.sol


197             uint128 _amountUnlocked = amountUnlocked / 1e18; // divide first


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/TimelockTokenPool.sol#L197:197





## [L-21] Pausing withdrawals is unfair to the users

Users should always have the possibility of accessing their own funds, but when these functions are paused, their funds will be locked until the contracts are unpaused.


```solidity
File: contracts/L2/TaikoL2.sol


163         function withdraw(


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/TaikoL2.sol#L163:163

## [L-22]  Double type casts create complexity within the code

Double type casting should be avoided in Solidity contracts to prevent unintended consequences and ensure accurate data representation. Performing multiple type casts in succession can lead to unexpected truncation, rounding errors, or loss of precision, potentially compromising the contract's functionality and reliability. Furthermore, double type casting can make the code less readable and harder to maintain, increasing the likelihood of errors and misunderstandings during development and debugging. To ensure precise and consistent data handling, developers should use appropriate data types and avoid unnecessary or excessive type casting, promoting a more robust and dependable contract execution.


There are 16 instance(s) of this issue:

```solidity
File: contracts/L1/libs/LibDepositing.sol


recipient: address(uint160(data >> 96)),

return (uint256(uint160(_addr)) << 96) | _amount;

```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibDepositing.sol#L151:151

```solidity
File: contracts/automata-attestation/lib/PEMCertChainLib.sol


? uint16(bytes2(svnValueBytes)) / 256

: uint16(bytes2(svnValueBytes));

```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/PEMCertChainLib.sol#L360:360

```solidity
File: contracts/automata-attestation/lib/QuoteV3Auth/V3Parser.sol


uint256 digits = uint256(uint8(bytes1(encoded[i])));

```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/QuoteV3Auth/V3Parser.sol#L154:154

```solidity
File: contracts/automata-attestation/utils/BytesUtils.sol


decoded = uint8(BASE32_HEX_TABLE[uint256(uint8(char)) - 0x30]);

```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/BytesUtils.sol#L336:336

```solidity
File: contracts/automata-attestation/utils/SigVerifyLib.sol


uint256 r = uint256(bytes32(signature.substring(0, 32)));

uint256 s = uint256(bytes32(signature.substring(32, 32)));

uint256 gx = uint256(bytes32(publicKey.substring(0, 32)));

uint256 gy = uint256(bytes32(publicKey.substring(32, 32)));

```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/SigVerifyLib.sol#L133:133

```solidity
File: contracts/bridge/Bridge.sol


return _msgHash ^ bytes32(uint256(Status.FAILED));

_storeContext(bytes32(PLACEHOLDER), address(uint160(PLACEHOLDER)), uint64(PLACEHOLDER));

```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/Bridge.sol#L533:533

```solidity
File: contracts/thirdparty/optimism/rlp/RLPWriter.sol


out_[i] = bytes1(uint8((_len / (256 ** (lenLen - i))) % 256));

```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/rlp/RLPWriter.sol#L47:47

```solidity
File: contracts/verifiers/SgxVerifier.sol


_address[0] = address(bytes20(_attestation.localEnclaveReport.reportData));

uint32 id = uint32(bytes4(Bytes.slice(_proof.data, 0, 4)));

address newInstance = address(bytes20(Bytes.slice(_proof.data, 4, 20)));

```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/verifiers/SgxVerifier.sol#L155:155



## [L-23]  Constructor contains no validation

In Solidity, when values are being assigned in constructors to unsigned or integer variables, it's crucial to ensure the provided values adhere to the protocol's specific operational boundaries as laid out in the project specifications and documentation. If the constructors lack appropriate validation checks, there's a risk of setting state variables with values that could cause unexpected and potentially detrimental behavior within the contract's operations, violating the intended logic of the protocol. This can compromise the contract's security and impact the maintainability and reliability of the system. In order to avoid such issues, it is recommended to incorporate rigorous validation checks in constructors. These checks should align with the project's defined rules and constraints, making use of Solidity's built-in require function to enforce these conditions. If the validation checks fail, the require function will cause the transaction to revert, ensuring the integrity and adherence to the protocol's expected behavior.


```solidity
File: contracts/automata-attestation/AutomataDcapV3Attestation.sol


54          constructor(address sigVerifyLibAddr, address pemCertLibAddr) {
55              sigVerifyLib = ISigVerifyLib(sigVerifyLibAddr);
56              pemCertLib = PEMCertChainLib(pemCertLibAddr);
57              owner = msg.sender;
58          }


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/AutomataDcapV3Attestation.sol#L54:58

```solidity
File: contracts/automata-attestation/utils/SigVerifyLib.sol


20          constructor(address es256Verifier) {
21              ES256VERIFIER = es256Verifier;
22          }


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/SigVerifyLib.sol#L20:22

## [L-24] For loops in `public` or `external` functions should be avoided due to high gas costs and possible DOS

In Solidity, for loops can potentially cause Denial of Service (DoS) attacks if not handled carefully. DoS attacks can occur when an attacker intentionally exploits the gas cost of a function, causing it to run out of gas or making it too expensive for other users to call. Below are some scenarios where for loops can lead to DoS attacks: Nested for loops can become exceptionally gas expensive and should be used sparingly.


There are 10 instance(s) of this issue:

```solidity
File: contracts/L1/provers/Guardians.sol


53          function setGuardians(
54              address[] memory _newGuardians,
55              uint8 _minGuardians
56          )
57              external
58              onlyOwner
59              nonReentrant
60          {
61              // We need at least MIN_NUM_GUARDIANS and at most 255 guardians (so the approval bits fit in
62              // a uint256)
63              if (_newGuardians.length < MIN_NUM_GUARDIANS || _newGuardians.length > type(uint8).max) {
64                  revert INVALID_GUARDIAN_SET();
65              }
66              // Minimum number of guardians to approve is at least equal or greater than half the
67              // guardians (rounded up) and less or equal than the total number of guardians
68              if (_minGuardians < (_newGuardians.length + 1) >> 1 || _minGuardians > _newGuardians.length)
69              {
70                  revert INVALID_MIN_GUARDIANS();
71              }
72      
73              // Delete the current guardians
74              for (uint256 i; i < guardians.length; ++i) {
75                  delete guardianIds[guardians[i]];
76              }
77              delete guardians;
78      
79              // Set the new guardians
80              for (uint256 i = 0; i < _newGuardians.length; ++i) {
81                  address guardian = _newGuardians[i];
82                  if (guardian == address(0)) revert INVALID_GUARDIAN();
83                  // This makes sure there are not duplicate addresses
84                  if (guardianIds[guardian] != 0) revert INVALID_GUARDIAN_SET();
85      
86                  // Save and index the guardian
87                  guardians.push(guardian);
88                  guardianIds[guardian] = guardians.length;
89              }
90      
91              // Bump the version so previous approvals get invalidated
92              ++version;
93      
94              minGuardians = _minGuardians;
95              emit GuardiansUpdated(version, _newGuardians);
96          }


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/provers/Guardians.sol#L53:96

```solidity
File: contracts/automata-attestation/AutomataDcapV3Attestation.sol


73          function addRevokedCertSerialNum(
74              uint256 index,
75              bytes[] calldata serialNumBatch
76          )
77              external
78              onlyOwner
79          {
80              for (uint256 i; i < serialNumBatch.length; ++i) {
81                  if (_serialNumIsRevoked[index][serialNumBatch[i]]) {
82                      continue;
83                  }
84                  _serialNumIsRevoked[index][serialNumBatch[i]] = true;
85              }
86          }


88          function removeRevokedCertSerialNum(
89              uint256 index,
90              bytes[] calldata serialNumBatch
91          )
92              external
93              onlyOwner
94          {
95              for (uint256 i; i < serialNumBatch.length; ++i) {
96                  if (!_serialNumIsRevoked[index][serialNumBatch[i]]) {
97                      continue;
98                  }
99                  delete _serialNumIsRevoked[index][serialNumBatch[i]];
100             }
101         }


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/AutomataDcapV3Attestation.sol#L88:101

```solidity
File: contracts/automata-attestation/lib/PEMCertChainLib.sol


40          function splitCertificateChain(
41              bytes memory pemChain,
42              uint256 size
43          )
44              external
45              pure
46              returns (bool success, bytes[] memory certs)
47          {
48              certs = new bytes[](size);
49              string memory pemChainStr = string(pemChain);
50      
51              uint256 index = 0;
52              uint256 len = pemChain.length;
53      
54              for (uint256 i; i < size; ++i) {
55                  string memory input;
56                  if (i > 0) {
57                      input = LibString.slice(pemChainStr, index, index + len);
58                  } else {
59                      input = pemChainStr;
60                  }
61                  uint256 increment;
62                  (success, certs[i], increment) = _removeHeadersAndFooters(input);
63      
64                  if (!success) {
65                      return (false, certs);
66                  }
67      
68                  index += increment;
69              }
70      
71              success = true;
72          }


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/PEMCertChainLib.sol#L40:72

```solidity
File: contracts/bridge/Bridge.sol


82          function suspendMessages(
83              bytes32[] calldata _msgHashes,
84              bool _suspend
85          )
86              external
87              onlyFromOwnerOrNamed("bridge_watchdog")
88          {
89              uint64 _timestamp = _suspend ? type(uint64).max : uint64(block.timestamp);
90              for (uint256 i; i < _msgHashes.length; ++i) {
91                  bytes32 msgHash = _msgHashes[i];
92                  proofReceipt[msgHash].receivedAt = _timestamp;
93                  emit MessageSuspended(msgHash, _suspend);
94              }
95          }


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/Bridge.sol#L82:95

```solidity
File: contracts/signal/SignalService.sol


83          function proveSignalReceived(
84              uint64 _chainId,
85              address _app,
86              bytes32 _signal,
87              bytes calldata _proof
88          )
89              public
90              virtual
91              validSender(_app)
92              nonZeroValue(_signal)
93          {
94              HopProof[] memory hopProofs = abi.decode(_proof, (HopProof[]));
95              if (hopProofs.length == 0) revert SS_EMPTY_PROOF();
96      
97              uint64 chainId = _chainId;
98              address app = _app;
99              bytes32 signal = _signal;
100             bytes32 value = _signal;
101             address signalService = resolve(chainId, "signal_service", false);
102     
103             HopProof memory hop;
104             for (uint256 i; i < hopProofs.length; ++i) {
105                 hop = hopProofs[i];
106     
107                 bytes32 signalRoot = _verifyHopProof(chainId, app, signal, value, hop, signalService);
108                 bool isLastHop = i == hopProofs.length - 1;
109     
110                 if (isLastHop) {
111                     if (hop.chainId != block.chainid) revert SS_INVALID_LAST_HOP_CHAINID();
112                     signalService = address(this);
113                 } else {
114                     if (hop.chainId == 0 || hop.chainId == block.chainid) {
115                         revert SS_INVALID_MID_HOP_CHAINID();
116                     }
117                     signalService = resolve(hop.chainId, "signal_service", false);
118                 }
119     
120                 bool isFullProof = hop.accountProof.length > 0;
121     
122                 _cacheChainData(hop, chainId, hop.blockId, signalRoot, isFullProof, isLastHop);
123     
124                 bytes32 kind = isFullProof ? LibSignals.STATE_ROOT : LibSignals.SIGNAL_ROOT;
125                 signal = signalForChainData(chainId, kind, hop.blockId);
126                 value = hop.rootHash;
127                 chainId = hop.chainId;
128                 app = signalService;
129             }
130     
131             if (value == 0 || value != _loadSignalValue(address(this), signal)) {
132                 revert SS_SIGNAL_NOT_FOUND();
133             }
134         }


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/signal/SignalService.sol#L83:134

```solidity
File: contracts/team/airdrop/ERC721Airdrop.sol


47          function claim(
48              address user,
49              uint256[] calldata tokenIds,
50              bytes32[] calldata proof
51          )
52              external
53              nonReentrant
54          {
55              // Check if this can be claimed
56              _verifyClaim(abi.encode(user, tokenIds), proof);
57      
58              // Transfer the tokens
59              for (uint256 i; i < tokenIds.length; ++i) {
60                  IERC721(token).safeTransferFrom(vault, user, tokenIds[i]);
61              }
62          }


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/airdrop/ERC721Airdrop.sol#L47:62

```solidity
File: contracts/tokenvault/ERC1155Vault.sol


39          function sendToken(BridgeTransferOp memory _op)
40              external
41              payable
42              nonReentrant
43              whenNotPaused
44              withValidOperation(_op)
45              returns (IBridge.Message memory message_)
46          {
47              for (uint256 i; i < _op.amounts.length; ++i) {
48                  if (_op.amounts[i] == 0) revert VAULT_INVALID_AMOUNT();
49              }
50              // Check token interface support
51              if (!_op.token.supportsInterface(ERC1155_INTERFACE_ID)) {
52                  revert VAULT_INTERFACE_NOT_SUPPORTED();
53              }
54      
55              (bytes memory data, CanonicalNFT memory ctoken) = _handleMessage(msg.sender, _op);
56      
57              // Create a message to send to the destination chain
58              IBridge.Message memory message = IBridge.Message({
59                  id: 0, // will receive a new value
60                  from: address(0), // will receive a new value
61                  srcChainId: 0, // will receive a new value
62                  destChainId: _op.destChainId,
63                  srcOwner: msg.sender,
64                  destOwner: _op.destOwner != address(0) ? _op.destOwner : msg.sender,
65                  to: resolve(_op.destChainId, name(), false),
66                  refundTo: _op.refundTo,
67                  value: msg.value - _op.fee,
68                  fee: _op.fee,
69                  gasLimit: _op.gasLimit,
70                  data: data,
71                  memo: _op.memo
72              });
73      
74              // Send the message and obtain the message hash
75              bytes32 msgHash;
76              (msgHash, message_) =
77                  IBridge(resolve("bridge", false)).sendMessage{ value: msg.value }(message);
78      
79              // Emit TokenSent event
80              emit TokenSent({
81                  msgHash: msgHash,
82                  from: message_.srcOwner,
83                  to: _op.to,
84                  destChainId: message_.destChainId,
85                  ctoken: ctoken.addr,
86                  token: _op.token,
87                  tokenIds: _op.tokenIds,
88                  amounts: _op.amounts
89              });
90          }


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC1155Vault.sol#L39:90

```solidity
File: contracts/tokenvault/ERC721Vault.sol


26          function sendToken(BridgeTransferOp memory _op)
27              external
28              payable
29              nonReentrant
30              whenNotPaused
31              withValidOperation(_op)
32              returns (IBridge.Message memory message_)
33          {
34              for (uint256 i; i < _op.tokenIds.length; ++i) {
35                  if (_op.amounts[i] != 0) revert VAULT_INVALID_AMOUNT();
36              }
37      
38              if (!_op.token.supportsInterface(ERC721_INTERFACE_ID)) {
39                  revert VAULT_INTERFACE_NOT_SUPPORTED();
40              }
41      
42              (bytes memory data, CanonicalNFT memory ctoken) = _handleMessage(msg.sender, _op);
43      
44              IBridge.Message memory message = IBridge.Message({
45                  id: 0, // will receive a new value
46                  from: address(0), // will receive a new value
47                  srcChainId: 0, // will receive a new value
48                  destChainId: _op.destChainId,
49                  srcOwner: msg.sender,
50                  destOwner: _op.destOwner != address(0) ? _op.destOwner : msg.sender,
51                  to: resolve(_op.destChainId, name(), false),
52                  refundTo: _op.refundTo,
53                  value: msg.value - _op.fee,
54                  fee: _op.fee,
55                  gasLimit: _op.gasLimit,
56                  data: data,
57                  memo: _op.memo
58              });
59      
60              bytes32 msgHash;
61              (msgHash, message_) =
62                  IBridge(resolve("bridge", false)).sendMessage{ value: msg.value }(message);
63      
64              emit TokenSent({
65                  msgHash: msgHash,
66                  from: message_.srcOwner,
67                  to: _op.to,
68                  destChainId: message_.destChainId,
69                  ctoken: ctoken.addr,
70                  token: _op.token,
71                  tokenIds: _op.tokenIds,
72                  amounts: _op.amounts
73              });
74          }


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC721Vault.sol#L26:74

```solidity
File: contracts/verifiers/SgxVerifier.sol


100         function deleteInstances(uint256[] calldata _ids)
101             external
102             onlyFromOwnerOrNamed("rollup_watchdog")
103         {
104             for (uint256 i; i < _ids.length; ++i) {
105                 uint256 idx = _ids[i];
106     
107                 if (instances[idx].addr == address(0)) revert SGX_INVALID_INSTANCE();
108     
109                 emit InstanceDeleted(idx, instances[idx].addr);
110     
111                 delete instances[idx];
112             }
113         }


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/verifiers/SgxVerifier.sol#L100:113



## [L-25]  Function calls within for loops

Making function calls within loops in Solidity can lead to inefficient gas usage, potential bottlenecks, and increased vulnerability to attacks. Each function call or external call consumes gas, and when executed within a loop, the gas cost multiplies, potentially causing the transaction to run out of gas or exceed block gas limits. This can result in transaction failure or unpredictable behavior.


There are 5 instance(s) of this issue:

```solidity
File: contracts/automata-attestation/AutomataDcapV3Attestation.sol


214             for (uint256 i; i < tcb.tcbLevels.length; ++i) {
215                 TCBInfoStruct.TCBLevelObj memory current = tcb.tcbLevels[i];
216                 bool pceSvnIsHigherOrGreater = pck.sgxExtension.pcesvn >= current.pcesvn;
217                 bool cpuSvnsAreHigherOrGreater = _isCpuSvnHigherOrGreater(
218                     pck.sgxExtension.sgxTcbCompSvnArr, current.sgxTcbCompSvnArr
219                 );
220                 if (pceSvnIsHigherOrGreater && cpuSvnsAreHigherOrGreater) {
221                     status = current.status;
222                     bool tcbIsRevoked = status == TCBInfoStruct.TCBStatus.TCB_REVOKED;
223                     return (!tcbIsRevoked, status);
224                 }
225             }


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/AutomataDcapV3Attestation.sol#L214:225

```solidity
File: contracts/automata-attestation/lib/PEMCertChainLib.sol


54              for (uint256 i; i < size; ++i) {
55                  string memory input;
56                  if (i > 0) {
57                      input = LibString.slice(pemChainStr, index, index + len);
58                  } else {
59                      input = pemChainStr;
60                  }
61                  uint256 increment;
62                  (success, certs[i], increment) = _removeHeadersAndFooters(input);
63      
64                  if (!success) {
65                      return (false, certs);
66                  }
67      
68                  index += increment;
69              }


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/PEMCertChainLib.sol#L54:69

```solidity
File: contracts/automata-attestation/utils/X509DateUtils.sol


48              for (uint16 i = 1970; i < year; ++i) {
49                  if (isLeapYear(i)) {
50                      timestamp += 31_622_400; // Leap year in seconds
51                  } else {
52                      timestamp += 31_536_000; // Normal year in seconds
53                  }
54              }


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/X509DateUtils.sol#L48:54

```solidity
File: contracts/signal/SignalService.sol


104             for (uint256 i; i < hopProofs.length; ++i) {
105                 hop = hopProofs[i];
106     
107                 bytes32 signalRoot = _verifyHopProof(chainId, app, signal, value, hop, signalService);
108                 bool isLastHop = i == hopProofs.length - 1;
109     
110                 if (isLastHop) {
111                     if (hop.chainId != block.chainid) revert SS_INVALID_LAST_HOP_CHAINID();
112                     signalService = address(this);
113                 } else {
114                     if (hop.chainId == 0 || hop.chainId == block.chainid) {
115                         revert SS_INVALID_MID_HOP_CHAINID();
116                     }
117                     signalService = resolve(hop.chainId, "signal_service", false);
118                 }
119     
120                 bool isFullProof = hop.accountProof.length > 0;
121     
122                 _cacheChainData(hop, chainId, hop.blockId, signalRoot, isFullProof, isLastHop);
123     
124                 bytes32 kind = isFullProof ? LibSignals.STATE_ROOT : LibSignals.SIGNAL_ROOT;
125                 signal = signalForChainData(chainId, kind, hop.blockId);
126                 value = hop.rootHash;
127                 chainId = hop.chainId;
128                 app = signalService;
129             }


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/signal/SignalService.sol#L104:129

```solidity
File: contracts/thirdparty/optimism/trie/MerkleTrie.sol


85              for (uint256 i = 0; i < proof.length; i++) {
86                  TrieNode memory currentNode = proof[i];
87      
88                  // Key index should never exceed total key length or we'll be out of bounds.
89                  require(currentKeyIndex <= key.length, "MerkleTrie: key index exceeds total key length");
90      
91                  if (currentKeyIndex == 0) {
92                      // First proof element is always the root node.
93                      require(
94                          Bytes.equal(abi.encodePacked(keccak256(currentNode.encoded)), currentNodeID),
95                          "MerkleTrie: invalid root hash"
96                      );
97                  } else if (currentNode.encoded.length >= 32) {
98                      // Nodes 32 bytes or larger are hashed inside branch nodes.
99                      require(
100                         Bytes.equal(abi.encodePacked(keccak256(currentNode.encoded)), currentNodeID),
101                         "MerkleTrie: invalid large internal hash"
102                     );
103                 } else {
104                     // Nodes smaller than 32 bytes aren't hashed.
105                     require(
106                         Bytes.equal(currentNode.encoded, currentNodeID),
107                         "MerkleTrie: invalid internal node hash"
108                     );
109                 }
110     
111                 if (currentNode.decoded.length == BRANCH_NODE_LENGTH) {
112                     if (currentKeyIndex == key.length) {
113                         // Value is the last element of the decoded list (for branch nodes). There's
114                         // some ambiguity in the Merkle trie specification because bytes(0) is a
115                         // valid value to place into the trie, but for branch nodes bytes(0) can exist
116                         // even when the value wasn't explicitly placed there. Geth treats a value of
117                         // bytes(0) as "key does not exist" and so we do the same.
118                         value_ = RLPReader.readBytes(currentNode.decoded[TREE_RADIX]);
119                         require(
120                             value_.length > 0,
121                             "MerkleTrie: value length must be greater than zero (branch)"
122                         );
123     
124                         // Extra proof elements are not allowed.
125                         require(
126                             i == proof.length - 1,
127                             "MerkleTrie: value node must be last node in proof (branch)"
128                         );
129     
130                         return value_;
131                     } else {
132                         // We're not at the end of the key yet.
133                         // Figure out what the next node ID should be and continue.
134                         uint8 branchKey = uint8(key[currentKeyIndex]);
135                         RLPReader.RLPItem memory nextNode = currentNode.decoded[branchKey];
136                         currentNodeID = _getNodeID(nextNode);
137                         currentKeyIndex += 1;
138                     }
139                 } else if (currentNode.decoded.length == LEAF_OR_EXTENSION_NODE_LENGTH) {
140                     bytes memory path = _getNodePath(currentNode);
141                     uint8 prefix = uint8(path[0]);
142                     uint8 offset = 2 - (prefix % 2);
143                     bytes memory pathRemainder = Bytes.slice(path, offset);
144                     bytes memory keyRemainder = Bytes.slice(key, currentKeyIndex);
145                     uint256 sharedNibbleLength = _getSharedNibbleLength(pathRemainder, keyRemainder);
146     
147                     // Whether this is a leaf node or an extension node, the path remainder MUST be a
148                     // prefix of the key remainder (or be equal to the key remainder) or the proof is
149                     // considered invalid.
150                     require(
151                         pathRemainder.length == sharedNibbleLength,
152                         "MerkleTrie: path remainder must share all nibbles with key"
153                     );
154     
155                     if (prefix == PREFIX_LEAF_EVEN || prefix == PREFIX_LEAF_ODD) {
156                         // Prefix of 2 or 3 means this is a leaf node. For the leaf node to be valid,
157                         // the key remainder must be exactly equal to the path remainder. We already
158                         // did the necessary byte comparison, so it's more efficient here to check that
159                         // the key remainder length equals the shared nibble length, which implies
160                         // equality with the path remainder (since we already did the same check with
161                         // the path remainder and the shared nibble length).
162                         require(
163                             keyRemainder.length == sharedNibbleLength,
164                             "MerkleTrie: key remainder must be identical to path remainder"
165                         );
166     
167                         // Our Merkle Trie is designed specifically for the purposes of the Ethereum
168                         // state trie. Empty values are not allowed in the state trie, so we can safely
169                         // say that if the value is empty, the key should not exist and the proof is
170                         // invalid.
171                         value_ = RLPReader.readBytes(currentNode.decoded[1]);
172                         require(
173                             value_.length > 0,
174                             "MerkleTrie: value length must be greater than zero (leaf)"
175                         );
176     
177                         // Extra proof elements are not allowed.
178                         require(
179                             i == proof.length - 1,
180                             "MerkleTrie: value node must be last node in proof (leaf)"
181                         );
182     
183                         return value_;
184                     } else if (prefix == PREFIX_EXTENSION_EVEN || prefix == PREFIX_EXTENSION_ODD) {
185                         // Prefix of 0 or 1 means this is an extension node. We move onto the next node
186                         // in the proof and increment the key index by the length of the path remainder
187                         // which is equal to the shared nibble length.
188                         currentNodeID = _getNodeID(currentNode.decoded[1]);
189                         currentKeyIndex += sharedNibbleLength;
190                     } else {
191                         revert("MerkleTrie: received a node with an unknown prefix");
192                     }
193                 } else {
194                     revert("MerkleTrie: received an unparseable node");
195                 }
196             }


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/trie/MerkleTrie.sol#L85:196





## [L-26]  Contracts are not using their OZ Upgradeable counterparts

The non-upgradeable standard version of OpenZeppelin’s library is inherited/used by the contracts. It would be safer to use the upgradeable versions of the library contracts to avoid unexpected behavior.

Use the contracts from `@openzeppelin/contracts-upgradeable` instead of `@openzeppelin/contracts` where applicable. See https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/tree/master/contracts for a list of available upgradeable contracts


There are 54 instance(s) of this issue:

```solidity
File: contracts/L1/TaikoToken.sol


4       import "@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol";


5       import "@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20SnapshotUpgradeable.sol";


6       import "@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20VotesUpgradeable.sol";


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/TaikoToken.sol#L6:6

```solidity
File: contracts/L1/gov/TaikoGovernor.sol


4       import "@openzeppelin/contracts-upgradeable/governance/GovernorUpgradeable.sol";


8       import


5       import


7       import "@openzeppelin/contracts-upgradeable/governance/extensions/GovernorVotesUpgradeable.sol";


10      import


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/gov/TaikoGovernor.sol#L10:10

```solidity
File: contracts/L1/gov/TaikoTimelockController.sol


4       import "@openzeppelin/contracts-upgradeable/governance/TimelockControllerUpgradeable.sol";


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/gov/TaikoTimelockController.sol#L4:4

```solidity
File: contracts/L1/hooks/AssignmentHook.sol


4       import "@openzeppelin/contracts/token/ERC20/IERC20.sol";


5       import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/hooks/AssignmentHook.sol#L5:5

```solidity
File: contracts/L1/libs/LibProposing.sol


4       import "@openzeppelin/contracts/token/ERC20/IERC20.sol";


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProposing.sol#L4:4

```solidity
File: contracts/L1/libs/LibProving.sol


4       import "@openzeppelin/contracts/token/ERC20/IERC20.sol";


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProving.sol#L4:4

```solidity
File: contracts/L1/libs/LibVerifying.sol


4       import "@openzeppelin/contracts/token/ERC20/IERC20.sol";


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibVerifying.sol#L4:4

```solidity
File: contracts/L2/CrossChainOwned.sol


4       import "@openzeppelin/contracts/token/ERC20/IERC20.sol";


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/CrossChainOwned.sol#L4:4

```solidity
File: contracts/L2/TaikoL2.sol


4       import "@openzeppelin/contracts/token/ERC20/IERC20.sol";


5       import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/TaikoL2.sol#L5:5

```solidity
File: contracts/bridge/Bridge.sol


4       import "@openzeppelin/contracts/utils/Address.sol";


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/Bridge.sol#L4:4

```solidity
File: contracts/common/AddressResolver.sol


4       import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/common/AddressResolver.sol#L4:4

```solidity
File: contracts/common/EssentialContract.sol


4       import "@openzeppelin/contracts/proxy/utils/UUPSUpgradeable.sol";


5       import "@openzeppelin/contracts-upgradeable/access/Ownable2StepUpgradeable.sol";


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/common/EssentialContract.sol#L5:5

```solidity
File: contracts/libs/LibAddress.sol


4       import "@openzeppelin/contracts/utils/Address.sol";


5       import "@openzeppelin/contracts/utils/cryptography/ECDSA.sol";


6       import "@openzeppelin/contracts/utils/introspection/IERC165.sol";


7       import "@openzeppelin/contracts/interfaces/IERC1271.sol";


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/libs/LibAddress.sol#L7:7

```solidity
File: contracts/signal/SignalService.sol


4       import "@openzeppelin/contracts/utils/math/SafeCast.sol";


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/signal/SignalService.sol#L4:4

```solidity
File: contracts/team/TimelockTokenPool.sol


4       import "@openzeppelin/contracts/utils/cryptography/ECDSA.sol";


5       import "@openzeppelin/contracts/token/ERC20/IERC20.sol";


6       import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/TimelockTokenPool.sol#L6:6

```solidity
File: contracts/team/airdrop/ERC20Airdrop.sol


4       import "@openzeppelin/contracts/token/ERC20/IERC20.sol";


5       import "@openzeppelin/contracts/governance/utils/IVotes.sol";


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/airdrop/ERC20Airdrop.sol#L5:5

```solidity
File: contracts/team/airdrop/ERC20Airdrop2.sol


4       import "@openzeppelin/contracts/token/ERC20/IERC20.sol";


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/airdrop/ERC20Airdrop2.sol#L4:4

```solidity
File: contracts/team/airdrop/ERC721Airdrop.sol


4       import "@openzeppelin/contracts/token/ERC721/IERC721.sol";


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/airdrop/ERC721Airdrop.sol#L4:4

```solidity
File: contracts/team/airdrop/MerkleClaimable.sol


4       import "@openzeppelin/contracts/utils/cryptography/MerkleProof.sol";


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/airdrop/MerkleClaimable.sol#L4:4

```solidity
File: contracts/tokenvault/BaseVault.sol


4       import "@openzeppelin/contracts-upgradeable/utils/introspection/IERC165Upgradeable.sol";


5       import "@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol";


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BaseVault.sol#L5:5

```solidity
File: contracts/tokenvault/BridgedERC1155.sol


4       import "@openzeppelin/contracts/utils/Strings.sol";


5       import "@openzeppelin/contracts-upgradeable/token/ERC1155/ERC1155Upgradeable.sol";


6       import


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC1155.sol#L6:6

```solidity
File: contracts/tokenvault/BridgedERC20.sol


4       import "@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol";


5       import "@openzeppelin/contracts/utils/Strings.sol";


6       import "@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20SnapshotUpgradeable.sol";


7       import "@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20VotesUpgradeable.sol";


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC20.sol#L7:7

```solidity
File: contracts/tokenvault/BridgedERC721.sol


4       import "@openzeppelin/contracts-upgradeable/token/ERC721/ERC721Upgradeable.sol";


5       import "@openzeppelin/contracts/utils/Strings.sol";


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC721.sol#L5:5

```solidity
File: contracts/tokenvault/ERC1155Vault.sol


4       import "@openzeppelin/contracts/token/ERC1155/IERC1155.sol";


5       import "@openzeppelin/contracts-upgradeable/token/ERC1155/utils/ERC1155ReceiverUpgradeable.sol";


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC1155Vault.sol#L5:5

```solidity
File: contracts/tokenvault/ERC20Vault.sol


4       import "@openzeppelin/contracts/token/ERC20/IERC20.sol";


5       import "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol";


6       import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC20Vault.sol#L6:6

```solidity
File: contracts/tokenvault/ERC721Vault.sol


4       import "@openzeppelin/contracts/token/ERC721/IERC721.sol";


5       import "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol";


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC721Vault.sol#L5:5

```solidity
File: contracts/tokenvault/LibBridgedToken.sol


4       import "@openzeppelin/contracts/utils/Strings.sol";


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/LibBridgedToken.sol#L4:4

```solidity
File: contracts/verifiers/SgxVerifier.sol


4       import "@openzeppelin/contracts/utils/cryptography/ECDSA.sol";


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/verifiers/SgxVerifier.sol#L4:4



## [L-27]  Consider implementing two-step procedure for updating protocol addresses

Lack of two-step procedure for critical operations leaves them error-prone. Consider adding two step procedure on the critical functions. See similar findings in previous Code4rena contests for reference: https://code4rena.com/reports/2022-06-illuminate/#2-critical-changes-should-use-two-step-procedure


```solidity
File: contracts/common/AddressManager.sol


38          function setAddress(


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/common/AddressManager.sol#L38:38

```solidity
File: contracts/tokenvault/BridgedERC20.sol


80          function setSnapshoter(address _snapshooter) external onlyOwner {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC20.sol#L80:80




## [L-28]  Missing checks for address(0x0) in the constructor




```solidity
File: contracts/automata-attestation/utils/SigVerifyLib.sol


21              ES256VERIFIER = es256Verifier;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/SigVerifyLib.sol#L21:21



## [L-29]  Code does not follow the best practice of check-effects-interaction

Code should follow the best-practice of [check-effects-interaction](https://blockchain-academy.hs-mittweida.de/courses/solidity-coding-beginners-to-intermediate/lessons/solidity-11-coding-patterns/topic/checks-effects-interactions/), where state variables are updated before any external calls are made. Doing so prevents a large class of reentrancy bugs.


There are 5 instance(s) of this issue:

```solidity
File: contracts/tokenvault/ERC1155Vault.sol


/// @audit _deployBridgedToken() called prior to this assignment
/// @audit contains nested function call IAddressManager.getAddress() 
/// @audit located in file Good/contracts/tokenvault/ERC1155Vault.sol  
312             canonicalToBridged[_ctoken.chainId][_ctoken.addr] = btoken_;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC1155Vault.sol#L312:312

```solidity
File: contracts/tokenvault/ERC20Vault.sol


/// @audit _deployBridgedToken() called prior to this assignment
/// @audit contains nested function call IAddressManager.getAddress() 
/// @audit located in file Good/contracts/tokenvault/ERC20Vault.sol  
423             canonicalToBridged[ctoken.chainId][ctoken.addr] = btoken;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC20Vault.sol#L423:423

```solidity
File: contracts/tokenvault/ERC721Vault.sol


/// @audit _deployBridgedToken() called prior to this assignment
/// @audit contains nested function call IAddressManager.getAddress() 
/// @audit located in file Good/contracts/tokenvault/ERC721Vault.sol  
248             canonicalToBridged[_ctoken.chainId][_ctoken.addr] = btoken_;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC721Vault.sol#L248:248

```solidity
File: contracts/verifiers/SgxVerifier.sol


/// @audit IAttestation.verifyParsedQuote() called prior to this assignment
217                 instances[nextInstanceId] = Instance(_instances[i], validSince);


/// @audit getSignedHash() called prior to this assignment
/// @audit contains nested function call ITaikoL1.getConfig() 
/// @audit located in file Good/contracts/verifiers/SgxVerifier.sol  
229             instances[id] = Instance(newInstance, uint64(block.timestamp));


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/verifiers/SgxVerifier.sol#L229:229



## [L-30]  Missing checks for address(0x0) when updating address state variables

issing checks for address(0x0) when updating address state variables

There are 18 instance(s) of this issue:

```solidity
File: contracts/L1/libs/LibProving.sol


303                 ts_.contester = address(0);


332                     ts_.prover = address(0);


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProving.sol#L332:332

```solidity
File: contracts/automata-attestation/utils/SigVerifyLib.sol


21              ES256VERIFIER = es256Verifier;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/SigVerifyLib.sol#L21:21

```solidity
File: contracts/common/AddressResolver.sol


62              addressManager = _addressManager;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/common/AddressResolver.sol#L62:62

```solidity
File: contracts/team/airdrop/ERC20Airdrop.sol


41              token = _token;


42              vault = _vault;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/airdrop/ERC20Airdrop.sol#L42:42

```solidity
File: contracts/team/airdrop/ERC20Airdrop2.sol


69              token = _token;


70              vault = _vault;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/airdrop/ERC20Airdrop2.sol#L70:70

```solidity
File: contracts/team/airdrop/ERC721Airdrop.sol


39              token = _token;


40              vault = _vault;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/airdrop/ERC721Airdrop.sol#L40:40

```solidity
File: contracts/tokenvault/BridgedERC1155.sol


56              srcToken = _srcToken;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC1155.sol#L56:56

```solidity
File: contracts/tokenvault/BridgedERC20.sol


73              srcToken = _srcToken;


81              snapshooter = _snapshooter;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC20.sol#L81:81

```solidity
File: contracts/tokenvault/BridgedERC20Base.sol


49              migratingAddress = _migratingAddress;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC20Base.sol#L49:49

```solidity
File: contracts/tokenvault/BridgedERC721.sol


47              srcToken = _srcToken;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC721.sol#L47:47

```solidity
File: contracts/tokenvault/ERC1155Vault.sol


309             btoken_ = address(new ERC1967Proxy(resolve("bridged_erc1155", false), data));


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC1155Vault.sol#L309:309

```solidity
File: contracts/tokenvault/ERC20Vault.sol


421             btoken = address(new ERC1967Proxy(resolve("bridged_erc20", false), data));


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC20Vault.sol#L421:421

```solidity
File: contracts/tokenvault/ERC721Vault.sol


246             btoken_ = address(new ERC1967Proxy(resolve("bridged_erc721", false), data));


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC721Vault.sol#L246:246




## [L-31]  The setter does not set a state variable or call a fuction




```solidity
File: contracts/automata-attestation/AutomataDcapV3Attestation.sol


65          function setMrSigner(bytes32 _mrSigner, bool _trusted) external onlyOwner {
66              _trustedUserMrSigner[_mrSigner] = _trusted;
67          }


69          function setMrEnclave(bytes32 _mrEnclave, bool _trusted) external onlyOwner {
70              _trustedUserMrEnclave[_mrEnclave] = _trusted;
71          }


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/AutomataDcapV3Attestation.sol#L69:71


## [L-32] Prefer continue over revert model in iteration

Preferably, it's better to skip operations on array indices when a condition is not met instead of reverting the entire transaction. Reverting could be exploited by malicious actors who might intentionally introduce array objects failing conditional checks, disrupting group operations. It's advisable to skip array indices rather than revert, unless there are valid security or logic reasons for doing otherwise


There are 8 instance(s) of this issue:

```solidity
File: contracts/L1/libs/LibProposing.sol


244                 for (uint256 i; i < params.hookCalls.length; ++i) {
245                     if (uint160(prevHook) >= uint160(params.hookCalls[i].hook)) {
246                         revert L1_INVALID_HOOK();
247                     }
248     
249                     // When a hook is called, all ether in this contract will be send to the hook.
250                     // If the ether sent to the hook is not used entirely, the hook shall send the Ether
251                     // back to this contract for the next hook to use.
252                     // Proposers shall choose use extra hooks wisely.
253                     IHook(params.hookCalls[i].hook).onBlockProposed{ value: address(this).balance }(
254                         blk, meta_, params.hookCalls[i].data
255                     );
256     
257                     prevHook = params.hookCalls[i].hook;
258                 }


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProposing.sol#L244:258

```solidity
File: contracts/L1/provers/Guardians.sol


80              for (uint256 i = 0; i < _newGuardians.length; ++i) {
81                  address guardian = _newGuardians[i];
82                  if (guardian == address(0)) revert INVALID_GUARDIAN();
83                  // This makes sure there are not duplicate addresses
84                  if (guardianIds[guardian] != 0) revert INVALID_GUARDIAN_SET();
85      
86                  // Save and index the guardian
87                  guardians.push(guardian);
88                  guardianIds[guardian] = guardians.length;
89              }


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/provers/Guardians.sol#L80:89

```solidity
File: contracts/signal/SignalService.sol


104             for (uint256 i; i < hopProofs.length; ++i) {
105                 hop = hopProofs[i];
106     
107                 bytes32 signalRoot = _verifyHopProof(chainId, app, signal, value, hop, signalService);
108                 bool isLastHop = i == hopProofs.length - 1;
109     
110                 if (isLastHop) {
111                     if (hop.chainId != block.chainid) revert SS_INVALID_LAST_HOP_CHAINID();
112                     signalService = address(this);
113                 } else {
114                     if (hop.chainId == 0 || hop.chainId == block.chainid) {
115                         revert SS_INVALID_MID_HOP_CHAINID();
116                     }
117                     signalService = resolve(hop.chainId, "signal_service", false);
118                 }
119     
120                 bool isFullProof = hop.accountProof.length > 0;
121     
122                 _cacheChainData(hop, chainId, hop.blockId, signalRoot, isFullProof, isLastHop);
123     
124                 bytes32 kind = isFullProof ? LibSignals.STATE_ROOT : LibSignals.SIGNAL_ROOT;
125                 signal = signalForChainData(chainId, kind, hop.blockId);
126                 value = hop.rootHash;
127                 chainId = hop.chainId;
128                 app = signalService;
129             }


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/signal/SignalService.sol#L104:129

```solidity
File: contracts/thirdparty/optimism/trie/MerkleTrie.sol


85              for (uint256 i = 0; i < proof.length; i++) {
86                  TrieNode memory currentNode = proof[i];
87      
88                  // Key index should never exceed total key length or we'll be out of bounds.
89                  require(currentKeyIndex <= key.length, "MerkleTrie: key index exceeds total key length");
90      
91                  if (currentKeyIndex == 0) {
92                      // First proof element is always the root node.
93                      require(
94                          Bytes.equal(abi.encodePacked(keccak256(currentNode.encoded)), currentNodeID),
95                          "MerkleTrie: invalid root hash"
96                      );
97                  } else if (currentNode.encoded.length >= 32) {
98                      // Nodes 32 bytes or larger are hashed inside branch nodes.
99                      require(
100                         Bytes.equal(abi.encodePacked(keccak256(currentNode.encoded)), currentNodeID),
101                         "MerkleTrie: invalid large internal hash"
102                     );
103                 } else {
104                     // Nodes smaller than 32 bytes aren't hashed.
105                     require(
106                         Bytes.equal(currentNode.encoded, currentNodeID),
107                         "MerkleTrie: invalid internal node hash"
108                     );
109                 }
110     
111                 if (currentNode.decoded.length == BRANCH_NODE_LENGTH) {
112                     if (currentKeyIndex == key.length) {
113                         // Value is the last element of the decoded list (for branch nodes). There's
114                         // some ambiguity in the Merkle trie specification because bytes(0) is a
115                         // valid value to place into the trie, but for branch nodes bytes(0) can exist
116                         // even when the value wasn't explicitly placed there. Geth treats a value of
117                         // bytes(0) as "key does not exist" and so we do the same.
118                         value_ = RLPReader.readBytes(currentNode.decoded[TREE_RADIX]);
119                         require(
120                             value_.length > 0,
121                             "MerkleTrie: value length must be greater than zero (branch)"
122                         );
123     
124                         // Extra proof elements are not allowed.
125                         require(
126                             i == proof.length - 1,
127                             "MerkleTrie: value node must be last node in proof (branch)"
128                         );
129     
130                         return value_;
131                     } else {
132                         // We're not at the end of the key yet.
133                         // Figure out what the next node ID should be and continue.
134                         uint8 branchKey = uint8(key[currentKeyIndex]);
135                         RLPReader.RLPItem memory nextNode = currentNode.decoded[branchKey];
136                         currentNodeID = _getNodeID(nextNode);
137                         currentKeyIndex += 1;
138                     }
139                 } else if (currentNode.decoded.length == LEAF_OR_EXTENSION_NODE_LENGTH) {
140                     bytes memory path = _getNodePath(currentNode);
141                     uint8 prefix = uint8(path[0]);
142                     uint8 offset = 2 - (prefix % 2);
143                     bytes memory pathRemainder = Bytes.slice(path, offset);
144                     bytes memory keyRemainder = Bytes.slice(key, currentKeyIndex);
145                     uint256 sharedNibbleLength = _getSharedNibbleLength(pathRemainder, keyRemainder);
146     
147                     // Whether this is a leaf node or an extension node, the path remainder MUST be a
148                     // prefix of the key remainder (or be equal to the key remainder) or the proof is
149                     // considered invalid.
150                     require(
151                         pathRemainder.length == sharedNibbleLength,
152                         "MerkleTrie: path remainder must share all nibbles with key"
153                     );
154     
155                     if (prefix == PREFIX_LEAF_EVEN || prefix == PREFIX_LEAF_ODD) {
156                         // Prefix of 2 or 3 means this is a leaf node. For the leaf node to be valid,
157                         // the key remainder must be exactly equal to the path remainder. We already
158                         // did the necessary byte comparison, so it's more efficient here to check that
159                         // the key remainder length equals the shared nibble length, which implies
160                         // equality with the path remainder (since we already did the same check with
161                         // the path remainder and the shared nibble length).
162                         require(
163                             keyRemainder.length == sharedNibbleLength,
164                             "MerkleTrie: key remainder must be identical to path remainder"
165                         );
166     
167                         // Our Merkle Trie is designed specifically for the purposes of the Ethereum
168                         // state trie. Empty values are not allowed in the state trie, so we can safely
169                         // say that if the value is empty, the key should not exist and the proof is
170                         // invalid.
171                         value_ = RLPReader.readBytes(currentNode.decoded[1]);
172                         require(
173                             value_.length > 0,
174                             "MerkleTrie: value length must be greater than zero (leaf)"
175                         );
176     
177                         // Extra proof elements are not allowed.
178                         require(
179                             i == proof.length - 1,
180                             "MerkleTrie: value node must be last node in proof (leaf)"
181                         );
182     
183                         return value_;
184                     } else if (prefix == PREFIX_EXTENSION_EVEN || prefix == PREFIX_EXTENSION_ODD) {
185                         // Prefix of 0 or 1 means this is an extension node. We move onto the next node
186                         // in the proof and increment the key index by the length of the path remainder
187                         // which is equal to the shared nibble length.
188                         currentNodeID = _getNodeID(currentNode.decoded[1]);
189                         currentKeyIndex += sharedNibbleLength;
190                     } else {
191                         revert("MerkleTrie: received a node with an unknown prefix");
192                     }
193                 } else {
194                     revert("MerkleTrie: received an unparseable node");
195                 }
196             }


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/trie/MerkleTrie.sol#L85:196

```solidity
File: contracts/tokenvault/ERC1155Vault.sol


47              for (uint256 i; i < _op.amounts.length; ++i) {
48                  if (_op.amounts[i] == 0) revert VAULT_INVALID_AMOUNT();
49              }


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC1155Vault.sol#L47:49

```solidity
File: contracts/tokenvault/ERC721Vault.sol


34              for (uint256 i; i < _op.tokenIds.length; ++i) {
35                  if (_op.amounts[i] != 0) revert VAULT_INVALID_AMOUNT();
36              }


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC721Vault.sol#L34:36

```solidity
File: contracts/verifiers/SgxVerifier.sol


104             for (uint256 i; i < _ids.length; ++i) {
105                 uint256 idx = _ids[i];
106     
107                 if (instances[idx].addr == address(0)) revert SGX_INVALID_INSTANCE();
108     
109                 emit InstanceDeleted(idx, instances[idx].addr);
110     
111                 delete instances[idx];
112             }


210             for (uint256 i; i < _instances.length; ++i) {
211                 if (addressRegistered[_instances[i]]) revert SGX_ALREADY_ATTESTED();
212     
213                 addressRegistered[_instances[i]] = true;
214     
215                 if (_instances[i] == address(0)) revert SGX_INVALID_INSTANCE();
216     
217                 instances[nextInstanceId] = Instance(_instances[i], validSince);
218                 ids[i] = nextInstanceId;
219     
220                 emit InstanceAdded(nextInstanceId, _instances[i], address(0), validSince);
221     
222                 nextInstanceId++;
223             }


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/verifiers/SgxVerifier.sol#L210:223



## [L-34]  Subtraction may underflow if multiplication is too large

```solidity
File: contracts/thirdparty/solmate/LibFixedPointMath.sol
40                  x = x - k * 54_916_777_467_707_473_351_141_471_128;
```
https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/solmate/LibFixedPointMath.sol#L40:40



# Non-critical Issues

| |Issue|Instances|
|-|:-|:-:|
| [[NC001](#nc001---the-nonreentrant-modifier-should-occur-before-all-other-modifiers)] | The `nonReentrant` `modifier` should occur before all other modifiers | 4 |
| [[NC002](#nc002---constants-should-be-defined-rather-than-using-magic-numbers)] | Constants should be defined rather than using magic numbers | 385 |
| [[NC003](#nc003---event-is-not-properly-indexed)] | Event is not properly indexed | 5 |
| [[NC004](#nc004---function-ordering-does-not-follow-the-solidity-style-guide)] | Function ordering does not follow the Solidity style guide | 5 |
| [[NC005](#nc005---imports-could-be-organized-more-systematically)] | Imports could be organized more systematically | 17 |
| [[NC006](#nc006---constants-in-comparisons-should-appear-on-the-left-side)] | Constants in comparisons should appear on the left side | 198 |
| [[NC007](#nc007---else-block-not-required)] | else-block not required | 22 |
| [[NC008](#nc008---events-may-be-emitted-out-of-order-due-to-reentrancy)] | Events may be emitted out of order due to reentrancy | 7 |
| [[NC009](#nc009---if-statement-can-be-converted-to-a-ternary)] | If-statement can be converted to a ternary | 5 |
| [[NC010](#nc010---import-declarations-should-import-specific-identifiers-rather-than-the-whole-file)] | Import declarations should import specific identifiers, rather than the whole file | 54 |
| [[NC011](#nc011---adding-a-return-statement-when-the-function-defines-a-named-return-variable-is-redundant)] | Adding a return statement when the function defines a named return variable, is redundant | 1 |
| [[NC012](#nc012---public-functions-not-called-by-the-contract-should-be-declared-external-instead)] | Public functions not called by the contract should be declared external instead | 43 |
| [[NC013](#nc013---multiple-addressid-mappings-can-be-combined-into-a-single-mapping-of-an-addressid-to-a-struct-for-readability)] | Multiple `address`/ID mappings can be combined into a single `mapping` of an `address`/ID to a `struct`, for readability | 3 |
| [[NC014](#nc014---duplicated-requirerevert-checks-should-be-refactored-to-a-modifier-or-function)] | Duplicated `require()`/`revert()` checks should be refactored to a modifier or function | 3 |
| [[NC015](#nc015---variables-need-not-be-initialized-to-zero)] | Variables need not be initialized to zero | 7 |
| [[NC016](#nc016---variable-names-that-consist-of-all-capital-letters-should-be-reserved-for-constantimmutable-variables)] | Variable names that consist of all capital letters should be reserved for constant/immutable variables | 1 |
| [[NC017](#nc017---consider-using-delete-rather-than-assigning-falsezero-to-clear-values)] | Consider using delete rather than assigning false/zero to clear values | 9 |
| [[NC018](#nc018---variable-names-for-immutables-should-use-constant_case)] | Variable names for `immutable`s should use CONSTANT_CASE | 2 |
| [[NC019](#nc019---lines-are-too-long)] | Lines are too long | 6 |
| [[NC020](#nc020---file-is-missing-natspec-comments)] | File is missing NatSpec comments | 13 |
| [[NC021](#nc021---function-declarations-should-have-natspec-descriptions)] | Function declarations should have NatSpec descriptions | 58 |
| [[NC022](#nc022---contract-declarations-should-have-notice-tags)] | Contract declarations should have `@notice` tags | 39 |
| [[NC023](#nc023---error-declarations-should-have-natspec-descriptions)] | Error declarations should have NatSpec descriptions | 160 |
| [[NC024](#nc024---inconsistent-spacing-in-comments)] | Inconsistent spacing in comments | 12 |
| [[NC025](#nc025---contract-does-not-follow-the-solidity-style-guides-suggested-layout-ordering)] | Contract does not follow the Solidity style guide's suggested layout ordering | 1 |
| [[NC026](#nc026---non-externalpublic-variable-names-should-begin-with-an-underscore)] | Non-external/public variable names should begin with an underscore | 1 |
| [[NC027](#nc027---consider-disabling-renounceownership)] | Consider disabling `renounceOwnership()` | 1 |
| [[NC028](#nc028---not-using-the-named-return-variables-anywhere-in-the-function-is-confusing)] | Not using the named return variables anywhere in the function is confusing | 10 |
| [[NC029](#nc029---expressions-for-constant-values-such-as-a-call-to-keccak256-should-use-immutable-rather-than-constant)] | Expressions for constant values such as a call to `keccak256()`, should use `immutable` rather than `constant` | 3 |
| [[NC030](#nc030---empty-function-body---consider-commenting-why)] | Empty Function Body - Consider commenting why | 4 |
| [[NC031](#nc031---contracts-should-have-full-test-coverage)] | Contracts should have full test coverage | 1 |
| [[NC032](#nc032---large-or-complicated-code-bases-should-implement-invariant-tests)] | Large or complicated code bases should implement invariant tests | 1 |
| [[NC033](#nc033---long-functions-should-be-refactored-into-multiple-smaller-functions)] | Long functions should be refactored into multiple, smaller, functions | 24 |
| [[NC034](#nc034---address-shouldnt-be-hard-coded)] | `address` shouldn't be hard-coded | 1 |
| [[NC035](#nc035---consider-using-blocknumber-instead-of-blocktimestamp)] | Consider using `block.number` instead of `block.timestamp` | 34 |
| [[NC036](#nc036---consider-bounding-input-array-length)] | Consider bounding input array length | 10 |
| [[NC037](#nc037---large-numeric-literals-should-use-underscores-for-readability)] | Large numeric literals should use underscores for readability | 23 |
| [[NC038](#nc038---cast-to-bytes-or-bytes32-for-clearer-semantic-meaning)] | Cast to `bytes` or `bytes32` for clearer semantic meaning | 4 |
| [[NC039](#nc039---variables-should-be-named-in-mixedcase-style)] | Variables should be named in mixedCase style | 57 |
| [[NC040](#nc040---use-allowlistdenylist-rather-than-whitelistblacklist)] | Use allowlist/denylist rather than whitelist/blacklist | 9 |
| [[NC041](#nc041---contracts-containing-only-utility-functions-should-be-made-into-libraries)] | Contracts containing only utility functions should be made into libraries | 4 |
| [[NC042](#nc042---function-names-should-use-lowercamelcase)] | Function names should use lowerCamelCase | 18 |
| [[NC043](#nc043---consider-adding-a-deny-list)] | Consider adding a deny-list | 29 |
| [[NC044](#nc044---custom-errors-should-be-used-rather-than-revertrequire)] | Custom errors should be used rather than `revert()`/`require()` | 7 |
| [[NC045](#nc045---interfaces-should-be-defined-in-separate-files-from-their-usage)] | Interfaces should be defined in separate files from their usage | 2 |
| [[NC046](#nc046---custom-error-has-no-error-details)] | Custom error has no error details | 160 |
| [[NC047](#nc047---contract-uses-both-requirerevert-as-well-as-custom-errors)] | Contract uses both `require()`/`revert()` as well as custom errors | 16 |
| [[NC048](#nc048---overridden-function-has-no-body)] | Overridden function has no body | 3 |
| [[NC049](#nc049---unused-struct-definition)] | Unused `struct` definition | 5 |
| [[NC050](#nc050---unused-error-definition)] | Unused `error` definition | 1 |
| [[NC051](#nc051---events-are-missing-sender-information)] | Events are missing sender information | 32 |
| [[NC052](#nc052---enum-values-should-be-used-in-place-of-constant-array-indexes)] | Enum values should be used in place of constant array indexes | 37 |
| [[NC053](#nc053---zero-as-a-function-argument-should-have-a-descriptive-meaning)] | Zero as a function argument should have a descriptive meaning | 87 |
| [[NC054](#nc054---function-names-should-differ-to-make-the-code-more-readable)] | Function names should differ to make the code more readable | 237 |
| [[NC055](#nc055---it-is-standard-for-all-external-and-public-functions-to-be-override-from-an-interface)] | It is standard for all external and public functions to be override from an interface | 161 |
| [[NC056](#nc056---consider-adding-formal-verification-proofs)] | Consider adding formal verification proofs | 1 |
| [[NC057](#nc057---assembly-code-blocks-should-be-thoroughly-commented)] | Assembly code blocks should be thoroughly commented | 65 |
| [[NC058](#nc058---large-multiples-of-ten-should-use-scientific-notation-eg-1e6-rather-than-decimal-literals-eg-1000000-for-readability)] | Large multiples of ten should use scientific notation (e.g. 1e6) rather than decimal literals (e.g. 1000000), for readability | 3 |
| [[NC059](#nc059---common-functions-should-be-refactored-to-a-common-base-contract)] | Common functions should be refactored to a common base contract | 13 |
| [[NC060](#nc060---polymorphic-functions-make-security-audits-more-time-consuming-and-error-prone)] | Polymorphic functions make security audits more time-consuming and error-prone | 13 |
| [[NC061](#nc061---error-messages-should-descriptive-rather-that-cryptic)] | Error messages should descriptive, rather that cryptic | 1 |
| [[NC062](#nc062---missing-timelock-for-critical-parameter-change)] | Missing timelock for critical parameter change | 3 |
| [[NC063](#nc063---setters-should-prevent-re-setting-of-the-same-value)] | Setters should prevent re-setting of the same value | 6 |
| [[NC064](#nc064---consider-splitting-long-calculations)] | Consider splitting long calculations | 5 |
| [[NC065](#nc065---high-cyclomatic-complexity)] | High cyclomatic complexity | 14 |
| [[NC066](#nc066---use-of-override-is-unnecessary)] | Use of override is unnecessary | 63 |
| [[NC067](#nc067---unused-import)] | Unused import | 3 |
| [[NC068](#nc068---use-stringconcat-on-strings-instead-of-abiencodepacked-for-clearer-semantic-meaning)] | Use `string.concat()` on strings instead of `abi.encodePacked()` for clearer semantic meaning | 8 |
| [[NC069](#nc069---unsafe-conversion-from-unsigned-to-signed-values)] | Unsafe conversion from unsigned to signed values | 3 |
| [[NC070](#nc070---put-all-system-wide-constants-in-one-file)] | Put all system-wide constants in one file | 23 |
| [[NC071](#nc071---add-inline-comments-for-unnamed-variables)] | Add inline comments for unnamed variables | 10 |
| [[NC072](#nc072---consider-adding-emergency-stop-functionality)] | Consider adding emergency-stop functionality | 9 |
| [[NC073](#nc073---named-imports-of-parent-contracts-are-missing)] | Named imports of parent contracts are missing | 46 |
| [[NC074](#nc074---contract-doesnt-handle-all-nft-types)] | Contract doesn't handle all NFT types | 2 |
| [[NC075](#nc075---use-bytesconcat-on-bytes-instead-of-abiencodepacked-for-clearer-semantic-meaning)] | Use `bytes.concat()` on bytes instead of `abi.encodePacked()` for clearer semantic meaning | 4 |
| [[NC076](#nc076---style-guide-state-and-local-variables-should-be-named-using-lowercamelcase)] | Style guide: State and local variables should be named using lowerCamelCase | 43 |
| [[NC077](#nc077---unusual-loop-variable)] | Unusual loop variable | 1 |
| [[NC078](#nc078---visibility-should-be-set-explicitly-rather-than-defaulting-to-internal)] | Visibility should be set explicitly rather than defaulting to internal | 3 |
| [[NC079](#nc079---event-declarations-should-have-natspec-param-annotations)] | Event declarations should have NatSpec @param annotations | 1 |
| [[NC080](#nc080---event-declarations-should-have-natspec-dev-annotations)] | Event declarations should have NatSpec @dev annotations | 45 |
| [[NC081](#nc081---function-definitions-should-have-natspec-dev-annotations)] | Function definitions should have NatSpec @dev annotations | 338 |
| [[NC082](#nc082---function-definitions-should-have-natspec-notice-annotations)] | Function definitions should have NatSpec @notice annotations | 252 |
| [[NC083](#nc083---interface-declarations-should-have-natspec-author-annotations)] | Interface declarations should have NatSpec @author annotations | 16 |
| [[NC084](#nc084---interface-declarations-should-have-natspec-notice-annotations)] | Interface declarations should have NatSpec @notice annotations | 6 |
| [[NC085](#nc085---interface-declarations-should-have-natspec-dev-annotations)] | Interface declarations should have NatSpec @dev annotations | 13 |
| [[NC086](#nc086---abstract-contract-declarations-should-have-natspec-author-annotations)] | Abstract contract declarations should have NatSpec @author annotations | 10 |
| [[NC087](#nc087---abstract-contract-declarations-should-have-natspec-notice-annotations)] | Abstract contract declarations should have NatSpec @notice annotations | 2 |
| [[NC088](#nc088---abstract-contract-declarations-should-have-natspec-dev-annotations)] | Abstract contract declarations should have Natspec @dev annotations | 7 |
| [[NC089](#nc089---library-declarations-should-have-natspec-title-annotations)] | Library declarations should have Natspec @title annotations | 3 |
| [[NC090](#nc090---library-declarations-should-have-natspec-author-annotations)] | Library declarations should have Natspec @author annotations | 30 |
| [[NC091](#nc091---library-declarations-should-have-natspec-notice-annotations)] | Library declarations should have Natspec @notice annotations | 19 |
| [[NC092](#nc092---library-declarations-should-have-natspec-dev-annotations)] | Library declarations should have Natspec @dev annotations | 26 |
| [[NC093](#nc093---modifier-definitions-should-have-natspec-notice-annotations)] | Modifier definitions should have Natspec @notice annotations | 15 |
| [[NC094](#nc094---modifier-definitions-should-have-natspec-dev-annotations)] | Modifier definitions should have Natspec @dev annotations | 13 |
| [[NC095](#nc095---contract-definitions-should-have-natspec-author-annotations)] | Contract definitions should have Natspec @author annotations | 30 |
| [[NC096](#nc096---contract-definitions-should-have-natspec-notice-annotations)] | Contract definitions should have Natspec @notice annotations | 12 |
| [[NC097](#nc097---contract-definitions-should-have-natspec-dev-annotations)] | Contract definitions should have Natspec @dev annotations | 19 |
| [[NC098](#nc098---event-definitions-should-have-natspec-notice-annotations)] | Event definitions should have Natspec @notice annotations | 7 |
| [[NC099](#nc099---state-variable-declarations-should-have-natspec-notice-annotations)] | State variable declarations should have Natspec @notice annotations | 90 |
| [[NC100](#nc100---state-variable-declarations-should-have-natspec-dev-annotations)] | State variable declarations should have Natspec @dev annotations | 144 |
| [[NC101](#nc101---functions-should-have-natspec-return-annotations)] | Functions should have Natspec @return annotations | 131 |
| [[NC102](#nc102---functions-should-have-natspec-param-annotations)] | Functions should have Natspec @param annotations | 210 |
| [[NC103](#nc103---missing-events-in-sensitive-functions)] | Missing events in sensitive functions | 3 |
| [[NC104](#nc104---if-statement-control-structures-do-not-comply-with-best-practices)] | If statement control structures do not comply with best practices | 135 |
| [[NC105](#nc105---a-event-should-be-emitted-if-a-non-immutable-state-variable-is-set-in-a-constructor)] | A event should be emitted if a non immutable state variable is set in a constructor | 2 |
| [[NC106](#nc106---unused-file)] | Unused file | 1 |
| [[NC107](#nc107---public-state-arrays-should-have-a-getter-to-return-all-elements)] | Public state arrays should have a getter to return all elements | 1 |
| [[NC108](#nc108---it-is-best-practice-to-use-linear-inheritance)] | It is best practice to use linear inheritance | 18 |
| [[NC109](#nc109---consider-only-defining-one-libraryinterfacecontract-per-sol-file)] | Consider only defining one library/interface/contract per sol file | 5 |
| [[NC110](#nc110---use-a-struct-to-encapsulate-multiple-function-parameters)] | Use a struct to encapsulate multiple function parameters | 23 |
| [[NC111](#nc111---avoid-defining-a-function-in-a-single-line-including-its-contents)] | Avoid defining a function in a single line including it's contents | 3 |
| [[NC112](#nc112---empty-bytes-check-is-missing)] | Empty bytes check is missing | 88 |
| [[NC113](#nc113---defining-all-externalpublic-functions-in-contract-interfaces)] | Defining All External/Public Functions in Contract Interfaces | 51 |
| [[NC114](#nc114---avoid-mutating-function-parameters)] | Avoid mutating function parameters | 1 |

Total: 4154 instances over 114 issues







## NC001 - The `nonReentrant` `modifier` should occur before all other modifiers:

This is a best-practice to protect against reentrancy in other modifiers.


<details>
<summary>Click to show 4 findings</summary>

```solidity
File: contracts/L1/provers/GuardianProver.sol


35          function approve(
36              TaikoData.BlockMetadata calldata _meta,
37              TaikoData.Transition calldata _tran,
38              TaikoData.TierProof calldata _proof
39          )
40              external
41              whenNotPaused
42              nonReentrant
43              returns (bool approved_)
44          {
45              if (_proof.tier != LibTiers.TIER_GUARDIAN) revert INVALID_PROOF();
46              bytes32 hash = keccak256(abi.encode(_meta, _tran));
47              approved_ = approve(_meta.id, hash);
48      
49              if (approved_) {
50                  deleteApproval(hash);
51                  ITaikoL1(resolve("taiko", false)).proveBlock(_meta.id, abi.encode(_meta, _tran, _proof));
52              }
53      
54              emit GuardianApproval(msg.sender, _meta.id, _tran.blockHash, approved_);
55          }


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/provers/GuardianProver.sol#L35:55

```solidity
File: contracts/L1/provers/Guardians.sol


53          function setGuardians(
54              address[] memory _newGuardians,
55              uint8 _minGuardians
56          )
57              external
58              onlyOwner
59              nonReentrant
60          {
61              // We need at least MIN_NUM_GUARDIANS and at most 255 guardians (so the approval bits fit in
62              // a uint256)
63              if (_newGuardians.length < MIN_NUM_GUARDIANS || _newGuardians.length > type(uint8).max) {
64                  revert INVALID_GUARDIAN_SET();
65              }
66              // Minimum number of guardians to approve is at least equal or greater than half the
67              // guardians (rounded up) and less or equal than the total number of guardians
68              if (_minGuardians < (_newGuardians.length + 1) >> 1 || _minGuardians > _newGuardians.length)
69              {
70                  revert INVALID_MIN_GUARDIANS();
71              }
72      
73              // Delete the current guardians
74              for (uint256 i; i < guardians.length; ++i) {
75                  delete guardianIds[guardians[i]];
76              }
77              delete guardians;
78      
79              // Set the new guardians
80              for (uint256 i = 0; i < _newGuardians.length; ++i) {
81                  address guardian = _newGuardians[i];
82                  if (guardian == address(0)) revert INVALID_GUARDIAN();
83                  // This makes sure there are not duplicate addresses
84                  if (guardianIds[guardian] != 0) revert INVALID_GUARDIAN_SET();
85      
86                  // Save and index the guardian
87                  guardians.push(guardian);
88                  guardianIds[guardian] = guardians.length;
89              }
90      
91              // Bump the version so previous approvals get invalidated
92              ++version;
93      
94              minGuardians = _minGuardians;
95              emit GuardiansUpdated(version, _newGuardians);
96          }


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/provers/Guardians.sol#L53:96

```solidity
File: contracts/L2/TaikoL2.sol


163         function withdraw(
164             address _token,
165             address _to
166         )
167             external
168             onlyFromOwnerOrNamed("withdrawer")
169             nonReentrant
170             whenNotPaused
171         {
172             if (_to == address(0)) revert L2_INVALID_PARAM();
173             if (_token == address(0)) {
174                 _to.sendEther(address(this).balance);
175             } else {
176                 IERC20(_token).safeTransfer(_to, IERC20(_token).balanceOf(address(this)));
177             }
178         }


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/TaikoL2.sol#L163:178

```solidity
File: contracts/bridge/Bridge.sol


101         function banAddress(
102             address _addr,
103             bool _ban
104         )
105             external
106             onlyFromOwnerOrNamed("bridge_watchdog")
107             nonReentrant
108         {
109             if (addressBanned[_addr] == _ban) revert B_INVALID_STATUS();
110             addressBanned[_addr] = _ban;
111             emit AddressBanned(_addr, _ban);
112         }


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/Bridge.sol#L101:112

</details>

## NC002 - Constants should be defined rather than using magic numbers:

Even assembly can benefit from using readable constants instead of hex/numeric literals.


<details>
<summary>Click to show 385 findings</summary>

```solidity
File: contracts/L1/TaikoData.sol


195             uint256[43] __gap;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/TaikoData.sol#L195:195

```solidity
File: contracts/L1/TaikoL1.sol


26          uint256[50] private __gap;


192                 chainId: 167_008,


195                 blockMaxProposals: 864_000,


196                 blockRingBufferSize: 864_100,


199                 blockMaxGasLimit: 15_000_000,


203                 blockMaxTxListBytes: 120_000,


204                 blobExpiry: 24 hours,


207                 livenessBond: 250e18, // 250 Taiko token


209                 ethDepositRingBufferSize: 1024,


210                 ethDepositMinCountPerBlock: 8,


211                 ethDepositMaxCountPerBlock: 32,


213                 ethDepositMaxAmount: 10_000 ether,


214                 ethDepositGas: 21_000,


216                 blockSyncThreshold: 16


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/TaikoL1.sol#L216:216

```solidity
File: contracts/L1/TaikoToken.sol


16          uint256[50] private __gap;


41              _mint(_recipient, 1_000_000_000 ether);


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/TaikoToken.sol#L41:41

```solidity
File: contracts/L1/gov/TaikoGovernor.sol


23          uint256[50] private __gap;


43              __GovernorVotesQuorumFraction_init(4);


112             return 7200; // 1 day


118             return 50_400; // 1 week


124             return 1_000_000_000 ether / 10_000; // 0.01% of Taiko Token


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/gov/TaikoGovernor.sol#L124:124

```solidity
File: contracts/L1/gov/TaikoTimelockController.sol


10          uint256[50] private __gap;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/gov/TaikoTimelockController.sol#L10:10

```solidity
File: contracts/L1/hooks/AssignmentHook.sol


40          uint256[50] private __gap;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/hooks/AssignmentHook.sol#L40:40

```solidity
File: contracts/L1/libs/LibDepositing.sol


89                          recipient: address(uint160(data >> 96)),


151             return (uint256(uint160(_addr)) << 96) | _amount;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibDepositing.sol#L151:151

```solidity
File: contracts/L1/libs/LibProving.sol


192                 bool returnLivenessBond = blk.livenessBond > 0 && _proof.data.length == 32


415                 + _tier.provingWindow * 60 >= block.timestamp;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProving.sol#L415:415

```solidity
File: contracts/L1/libs/LibVerifying.sol


152                             uint256(ITierProvider(tierProvider).getTier(ts.tier).cooldownWindow) * 60


251                     || _config.blockMaxTxListBytes > 128 * 1024 // calldata up to 128K


256                 || _config.ethDepositMaxCountPerBlock > 32


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibVerifying.sol#L256:256

```solidity
File: contracts/L1/provers/GuardianProver.sol


11          uint256[50] private __gap;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/provers/GuardianProver.sol#L11:11

```solidity
File: contracts/L1/provers/Guardians.sol


32          uint256[46] private __gap;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/provers/Guardians.sol#L32:32

```solidity
File: contracts/L1/tiers/DevnetTierProvider.sol


11          uint256[50] private __gap;


24                      validityBond: 250 ether, // TKO


25                      contestBond: 500 ether, // TKO


26                      cooldownWindow: 1440, //24 hours


27                      provingWindow: 120, // 2 hours


28                      maxBlocksToVerifyPerProof: 16


37                      cooldownWindow: 60, //1 hours


38                      provingWindow: 2880, // 48 hours


39                      maxBlocksToVerifyPerProof: 16


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/tiers/DevnetTierProvider.sol#L39:39

```solidity
File: contracts/L1/tiers/MainnetTierProvider.sol


11          uint256[50] private __gap;


24                      validityBond: 250 ether, // TKO


25                      contestBond: 500 ether, // TKO


26                      cooldownWindow: 1440, //24 hours


27                      provingWindow: 60, // 1 hours


28                      maxBlocksToVerifyPerProof: 8


35                      validityBond: 500 ether, // TKO


36                      contestBond: 1000 ether, // TKO


37                      cooldownWindow: 1440, //24 hours


38                      provingWindow: 240, // 4 hours


39                      maxBlocksToVerifyPerProof: 4


48                      cooldownWindow: 60, //1 hours


49                      provingWindow: 2880, // 48 hours


50                      maxBlocksToVerifyPerProof: 16


59              tiers_ = new uint16[](3);


68              if (_rand % 1000 == 0) return LibTiers.TIER_SGX_ZKVM;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/tiers/MainnetTierProvider.sol#L68:68

```solidity
File: contracts/L1/tiers/TestnetTierProvider.sol


11          uint256[50] private __gap;


24                      validityBond: 250 ether, // TKO


25                      contestBond: 500 ether, // TKO


26                      cooldownWindow: 1440, //24 hours


27                      provingWindow: 30, // 0.5 hours


28                      maxBlocksToVerifyPerProof: 12


35                      validityBond: 500 ether, // TKO


36                      contestBond: 1000 ether, // TKO


37                      cooldownWindow: 1440, //24 hours


38                      provingWindow: 60, // 1 hours


39                      maxBlocksToVerifyPerProof: 8


48                      cooldownWindow: 60, //1 hours


49                      provingWindow: 2880, // 48 hours


50                      maxBlocksToVerifyPerProof: 16


59              tiers_ = new uint16[](3);


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/tiers/TestnetTierProvider.sol#L59:59

```solidity
File: contracts/L2/CrossChainOwned.sol


21          uint256[49] private __gap;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/CrossChainOwned.sol#L21:21

```solidity
File: contracts/L2/TaikoL2.sol


52          uint256[47] private __gap;


202             if (_blockId + 256 >= block.number) return blockhash(_blockId);


213             config_.gasTargetPerL1Block = 15 * 1e6 * 4;


214             config_.basefeeAdjustmentQuotient = 8;


228             bytes32[256] memory inputs;


234                 for (uint256 i; i < 255 && _blockId >= i + 1; ++i) {


236                     inputs[j % 255] = blockhash(j);


240             inputs[255] = bytes32(block.chainid);


246             inputs[_blockId % 255] = blockhash(_blockId);


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/TaikoL2.sol#L246:246

```solidity
File: contracts/L2/TaikoL2EIP1559Configurable.sol


13          uint256[49] private __gap;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/TaikoL2EIP1559Configurable.sol#L13:13

```solidity
File: contracts/automata-attestation/AutomataDcapV3Attestation.sol


313             bytes32 expectedAuthDataHash = bytes32(qeEnclaveReport.reportData.substring(0, 32));


419                 parsedQuoteCerts = new IPEMCertChainLib.ECSha256Certificate[](3);


420                 for (uint256 i; i < 3; ++i) {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/AutomataDcapV3Attestation.sol#L420:420

```solidity
File: contracts/automata-attestation/lib/PEMCertChainLib.sol


135                     (notBeforeTag != 0x17 && notBeforeTag == 0x18)


136                         || (notAfterTag != 0x17 && notAfterTag != 0x18)


171                 sigPtr = NodePtr.getPtr(sigPtr.ixs() + 3, sigPtr.ixf() + 3, sigPtr.ixl());


174                 bytes memory sigX = _trimBytes(der.bytesAt(sigPtr), 32);


177                 bytes memory sigY = _trimBytes(der.bytesAt(sigPtr), 32);


180                 cert.pubKey = _trimBytes(der.bytesAt(subjectPublicKeyInfoPtr), 64);


189                 if (der[tbsPtr.ixs()] != 0xA3) {


288                 if (der[internalPtr.ixs()] != 0x06) {


303                         if (der[extnValueOidPtr.ixs()] != 0x06) {


359                     ? uint16(bytes2(svnValueBytes)) / 256


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/PEMCertChainLib.sol#L359:359

```solidity
File: contracts/automata-attestation/lib/QuoteV3Auth/V3Parser.sol


33              uint256 localAuthDataSize = littleEndianDecode(quote.substring(432, 4));


34              if (quote.length - 436 != localAuthDataSize) {


38              bytes memory rawHeader = quote.substring(0, 48);


46                  parseAuthDataAndVerifyCertType(quote.substring(436, localAuthDataSize), pemCertLibAddr);


51              bytes memory rawLocalEnclaveReport = quote.substring(48, 384);


78                  localEnclaveReport.reserved3.length == 96 && localEnclaveReport.reserved4.length == 60


79                      && localEnclaveReport.reportData.length == 64,


83                  pckSignedQeReport.reserved3.length == 96 && pckSignedQeReport.reserved4.length == 60


84                      && pckSignedQeReport.reportData.length == 64,


88                  v3Quote.v3AuthData.certification.certType == 5,


92                  v3Quote.v3AuthData.certification.decodedCertDataArray.length == 3, "3 certs in chain"


95                  v3Quote.v3AuthData.ecdsa256BitSignature.length == 64


96                      && v3Quote.v3AuthData.ecdsaAttestationKey.length == 64


97                      && v3Quote.v3AuthData.qeReportSignature.length == 64,


106             uint32 totalQuoteSize = 48 // header


107                 + 384 // local QE report


108                 + 64 // ecdsa256BitSignature


109                 + 64 // ecdsaAttestationKey


110                 + 384 // QE report


111                 + 64 // qeReportSignature


114                 + 4 // sizeof(v3Quote.v3AuthData.certification.certDataSize)


138             enclaveReport.cpuSvn = bytes16(rawEnclaveReport.substring(0, 16));


139             enclaveReport.miscSelect = bytes4(rawEnclaveReport.substring(16, 4));


140             enclaveReport.reserved1 = bytes28(rawEnclaveReport.substring(20, 28));


141             enclaveReport.attributes = bytes16(rawEnclaveReport.substring(48, 16));


142             enclaveReport.mrEnclave = bytes32(rawEnclaveReport.substring(64, 32));


143             enclaveReport.reserved2 = bytes32(rawEnclaveReport.substring(96, 32));


144             enclaveReport.mrSigner = bytes32(rawEnclaveReport.substring(128, 32));


145             enclaveReport.reserved3 = rawEnclaveReport.substring(160, 96);


146             enclaveReport.isvProdId = uint16(littleEndianDecode(rawEnclaveReport.substring(256, 2)));


147             enclaveReport.isvSvn = uint16(littleEndianDecode(rawEnclaveReport.substring(258, 2)));


148             enclaveReport.reserved4 = rawEnclaveReport.substring(260, 60);


149             enclaveReport.reportData = rawEnclaveReport.substring(320, 64);


155                 uint256 upperDigit = digits / 16;


156                 uint256 lowerDigit = digits % 16;


158                 uint256 acc = lowerDigit * (16 ** (2 * i));


159                 acc += upperDigit * (16 ** ((2 * i) + 1));


180             bytes4 teeType = bytes4(rawHeader.substring(4, 4));


185             bytes16 qeVendorId = bytes16(rawHeader.substring(12, 16));


194                 qeSvn: bytes2(rawHeader.substring(8, 2)),


197                 userData: bytes20(rawHeader.substring(28, 20))


212             qeAuthData.parsedDataSize = uint16(littleEndianDecode(rawAuthData.substring(576, 2)));


213             qeAuthData.data = rawAuthData.substring(578, qeAuthData.parsedDataSize);


215             uint256 offset = 578 + qeAuthData.parsedDataSize;


218             if (cert.certType < 1 || cert.certType > 5) {


222             cert.certDataSize = uint32(littleEndianDecode(rawAuthData.substring(offset, 4)));


223             offset += 4;


227             authDataV3.ecdsa256BitSignature = rawAuthData.substring(0, 64);


228             authDataV3.ecdsaAttestationKey = rawAuthData.substring(64, 64);


229             bytes memory rawQeReport = rawAuthData.substring(128, 384);


231             authDataV3.qeReportSignature = rawAuthData.substring(512, 64);


249             uint16 isvProdIdPackBE = (enclaveReport.isvProdId >> 8) | (enclaveReport.isvProdId << 8);


250             uint16 isvSvnPackBE = (enclaveReport.isvSvn >> 8) | (enclaveReport.isvSvn << 8);


273             returns (bytes[3] memory certChainData)


278                 pemCertLib.splitCertificateChain(certBytes, 3);


280             parsedQuoteCerts = new IPEMCertChainLib.ECSha256Certificate[](3);


281             for (uint256 i; i < 3; ++i) {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/QuoteV3Auth/V3Parser.sol#L281:281

```solidity
File: contracts/automata-attestation/lib/QuoteV3Auth/V3Struct.sol


44              bytes[3] decodedCertDataArray; // base64 decoded cert bytes array


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/QuoteV3Auth/V3Struct.sol#L44:44

```solidity
File: contracts/automata-attestation/utils/Asn1Decode.sol


20              return uint80(self >> 80);


25              return uint80(self >> 160);


30              _ixs |= _ixf << 80;


31              _ixs |= _ixl << 160;


57              require(der[ptr.ixs()] == 0x03, "Not type BIT STRING");


67              require(der[ptr.ixs()] == 0x04, "Not type OCTET STRING");


142             require(der[ptr.ixs()] == 0x02, "Not type INTEGER");


143             require(der[ptr.ixf()] & 0x80 == 0, "Not positive");


145             return uint256(der.readBytesN(ptr.ixf(), len) >> (32 - len) * 8);


155             require(der[ptr.ixs()] == 0x02, "Not type INTEGER");


156             require(der[ptr.ixf()] & 0x80 == 0, "Not positive");


180             require(der[ptr.ixs()] == 0x03, "ixs Not type BIT STRING 0x03");


182             require(der[ptr.ixf()] == 0x00, "ixf Not 0");


191             if ((der[ix + 1] & 0x80) == 0) {


196                 uint8 lengthbytesLength = uint8(der[ix + 1] & 0x7F);


203                         der.readBytesN(ix + 2, lengthbytesLength) >> (32 - lengthbytesLength) * 8


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/Asn1Decode.sol#L203:203

```solidity
File: contracts/automata-attestation/utils/BytesUtils.sol


80              for (uint256 idx = 0; idx < shortest; idx += 32) {


90                      if (shortest > 32) {


93                          mask = ~(2 ** (8 * (32 - shortest + idx)) - 1);


100                 selfptr += 32;


101                 otherptr += 32;


212             require(idx + 4 <= self.length, "unexpected idx");


225             require(idx + 32 <= self.length, "unexpected idx");


238             require(idx + 20 <= self.length, "unexpected idx");


264             require(len <= 32, "unexpected len");


329             require(len <= 52, "unexpected len");


335                 require(char >= 0x30 && char <= 0x7A, "invalid char");


336                 decoded = uint8(BASE32_HEX_TABLE[uint256(uint8(char)) - 0x30]);


337                 require(decoded <= 0x20, "invalid decoded");


341                 ret = (ret << 5) | decoded;


344             uint256 bitlen = len * 5;


345             if (len % 8 == 0) {


347                 ret = (ret << 5) | decoded;


348             } else if (len % 8 == 2) {


350                 ret = (ret << 3) | (decoded >> 2);


352             } else if (len % 8 == 4) {


354                 ret = (ret << 1) | (decoded >> 4);


355                 bitlen -= 4;


356             } else if (len % 8 == 5) {


358                 ret = (ret << 4) | (decoded >> 1);


360             } else if (len % 8 == 7) {


362                 ret = (ret << 2) | (decoded >> 3);


363                 bitlen -= 3;


368             return bytes32(ret << (256 - bitlen));


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/BytesUtils.sol#L368:368

```solidity
File: contracts/automata-attestation/utils/RsaVerify.sol


53              uint8[17] memory sha256ExplicitNullParam = [


54                  0x30,


55                  0x31,


56                  0x30,


57                  0x0d,


58                  0x06,


59                  0x09,


60                  0x60,


61                  0x86,


62                  0x48,


63                  0x01,


64                  0x65,


65                  0x03,


66                  0x04,


67                  0x02,


68                  0x01,


69                  0x05,


70                  0x00


73              uint8[15] memory sha256ImplicitNullParam = [


74                  0x30,


75                  0x2f,


76                  0x30,


77                  0x0b,


78                  0x06,


79                  0x09,


80                  0x60,


81                  0x86,


82                  0x48,


83                  0x01,


84                  0x65,


85                  0x03,


86                  0x04,


87                  0x02,


88                  0x01


125             if (uint8(decipher[decipherlen - 50]) == 0x31) {


128             } else if (uint8(decipher[decipherlen - 48]) == 0x2f) {


135             uint256 paddingLen = decipherlen - 5 - digestAlgoWithParamLen - 32;


137             if (decipher[0] != 0 || decipher[1] != 0x01) {


141                 if (decipher[i] != 0xff) {


153                     if (decipher[3 + paddingLen + i] != bytes1(sha256ExplicitNullParam[i])) {


159                     if (decipher[3 + paddingLen + i] != bytes1(sha256ImplicitNullParam[i])) {


168                 decipher[3 + paddingLen + digestAlgoWithParamLen] != 0x04


169                     || decipher[4 + paddingLen + digestAlgoWithParamLen] != 0x20


175                 if (decipher[5 + paddingLen + digestAlgoWithParamLen + i] != _sha256[i]) {


222             uint8[15] memory sha1Prefix = [


223                 0x30,


224                 0x21,


225                 0x30,


226                 0x09,


227                 0x06,


228                 0x05,


229                 0x2b,


230                 0x0e,


231                 0x03,


232                 0x02,


233                 0x1a,


234                 0x05,


235                 0x00,


236                 0x04,


237                 0x14


268             uint256 paddingLen = decipherlen - 3 - sha1Prefix.length - 20;


270             if (decipher[0] != 0 || decipher[1] != 0x01) {


274                 if (decipher[i] != 0xff) {


284                 if (decipher[3 + paddingLen + i] != bytes1(sha1Prefix[i])) {


291                 if (decipher[3 + paddingLen + sha1Prefix.length + i] != _sha1[i]) {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/RsaVerify.sol#L291:291

```solidity
File: contracts/automata-attestation/utils/SigVerifyLib.sol


89              bytes memory exponent = publicKey.substring(0, 3);


90              bytes memory modulus = publicKey.substring(3, publicKey.length - 3);


106             bytes memory exponent = publicKey.substring(0, 3);


107             bytes memory modulus = publicKey.substring(3, publicKey.length - 3);


123             if (signature.length != 64) {


126             uint256 r = uint256(bytes32(signature.substring(0, 32)));


127             uint256 s = uint256(bytes32(signature.substring(32, 32)));


129             if (publicKey.length != 64) {


132             uint256 gx = uint256(bytes32(publicKey.substring(0, 32)));


133             uint256 gy = uint256(bytes32(publicKey.substring(32, 32)));


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/SigVerifyLib.sol#L133:133

```solidity
File: contracts/automata-attestation/utils/X509DateUtils.sol


17              if (x509Time.length == 13) {


18                  if (uint8(x509Time[0]) - 48 < 5) yrs += 2000;


19                  else yrs += 1900;


21                  yrs += (uint8(x509Time[0]) - 48) * 1000 + (uint8(x509Time[1]) - 48) * 100;


24              yrs += (uint8(x509Time[offset + 0]) - 48) * 10 + uint8(x509Time[offset + 1]) - 48;


25              mnths = (uint8(x509Time[offset + 2]) - 48) * 10 + uint8(x509Time[offset + 3]) - 48;


26              dys += (uint8(x509Time[offset + 4]) - 48) * 10 + uint8(x509Time[offset + 5]) - 48;


27              hrs += (uint8(x509Time[offset + 6]) - 48) * 10 + uint8(x509Time[offset + 7]) - 48;


28              mins += (uint8(x509Time[offset + 8]) - 48) * 10 + uint8(x509Time[offset + 9]) - 48;


29              secs += (uint8(x509Time[offset + 10]) - 48) * 10 + uint8(x509Time[offset + 11]) - 48;


48              for (uint16 i = 1970; i < year; ++i) {


50                      timestamp += 31_622_400; // Leap year in seconds


52                      timestamp += 31_536_000; // Normal year in seconds


56              uint8[12] memory monthDays = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];


57              if (isLeapYear(year)) monthDays[1] = 29;


60                  timestamp += uint256(monthDays[i - 1]) * 86_400; // Days in seconds


63              timestamp += uint256(day - 1) * 86_400; // Days in seconds


64              timestamp += uint256(hour) * 3600; // Hours in seconds


65              timestamp += uint256(minute) * 60; // Minutes in seconds


72              if (year % 4 != 0) return false;


73              if (year % 100 != 0) return true;


74              if (year % 400 != 0) return false;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/X509DateUtils.sol#L74:74

```solidity
File: contracts/bridge/Bridge.sol


48          uint256[43] private __gap;


428                 return (1 hours, 384 seconds);


431                     || block.chainid == 4 // Rinkeby


432                     || block.chainid == 5 // Goerli


433                     || block.chainid == 42 // Kovan


434                     || block.chainid == 17_000 // Holesky


435                     || block.chainid == 11_155_111 // Sepolia


438                 return (30 minutes, 384 seconds);


439             } else if (block.chainid >= 32_300 && block.chainid <= 32_400) {


441                 return (5 minutes, 384 seconds);


491                 _message.data.length >= 4 // msg can be empty


501                     64, // return max 64 bytes


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/Bridge.sol#L501:501

```solidity
File: contracts/common/AddressManager.sol


14          uint256[49] private __gap;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/common/AddressManager.sol#L14:14

```solidity
File: contracts/common/AddressResolver.sol


14          uint256[49] private __gap;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/common/AddressResolver.sol#L14:14

```solidity
File: contracts/common/EssentialContract.sol


25          uint256[49] private __gap;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/common/EssentialContract.sol#L25:25

```solidity
File: contracts/libs/Lib4844.sol


34              bytes1[48] memory _commitment,


35              bytes1[48] memory _pointProof


49              if (ret.length != 64) revert EVAL_FAILED_2();


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/libs/Lib4844.sol#L49:49

```solidity
File: contracts/libs/LibAddress.sol


31                  64, // return max 64 bytes


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/libs/LibAddress.sol#L31:31

```solidity
File: contracts/signal/SignalService.sol


23          uint256[48] private __gap;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/signal/SignalService.sol#L23:23

```solidity
File: contracts/team/TimelockTokenPool.sol


82          uint128[44] private __gap;


197             uint128 _amountUnlocked = amountUnlocked / 1e18; // divide first


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/TimelockTokenPool.sol#L197:197

```solidity
File: contracts/team/airdrop/ERC20Airdrop.sol


18          uint256[48] private __gap;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/airdrop/ERC20Airdrop.sol#L18:18

```solidity
File: contracts/team/airdrop/ERC20Airdrop2.sol


30          uint256[45] private __gap;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/airdrop/ERC20Airdrop2.sol#L30:30

```solidity
File: contracts/team/airdrop/ERC721Airdrop.sol


16          uint256[48] private __gap;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/airdrop/ERC721Airdrop.sol#L16:16

```solidity
File: contracts/team/airdrop/MerkleClaimable.sol


23          uint256[47] private __gap;


35                  merkleRoot == 0x0 || claimStart == 0 || claimEnd == 0 || claimStart > block.timestamp


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/airdrop/MerkleClaimable.sol#L35:35

```solidity
File: contracts/thirdparty/optimism/Bytes.sol


25                  require(_length + 31 >= _length, "slice_overflow");


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/Bytes.sol#L25:25

```solidity
File: contracts/thirdparty/optimism/rlp/RLPReader.sol


163             if (prefix <= 0x7f) {


166             } else if (prefix <= 0xb7) {


170                 uint256 strLen = prefix - 0x80;


183                     strLen != 1 || firstByteOfContent >= 0x80,


188             } else if (prefix <= 0xbf) {


190                 uint256 lenOfStrLen = prefix - 0xb7;


203                     firstByteOfContent != 0x00,


213                     strLen > 55,


223             } else if (prefix <= 0xf7) {


226                 uint256 listLen = prefix - 0xc0;


236                 uint256 lenOfListLen = prefix - 0xf7;


249                     firstByteOfContent != 0x00,


259                     listLen > 55,


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/rlp/RLPReader.sol#L259:259

```solidity
File: contracts/thirdparty/optimism/rlp/RLPWriter.sol


14              if (_in.length == 1 && uint8(_in[0]) < 128) {


17                  out_ = abi.encodePacked(_writeLength(_in.length, 128), _in);


33              if (_len < 56) {


41                      i *= 256;


45                  out_[0] = bytes1(uint8(lenLen) + uint8(_offset) + 55);


47                      out_[i] = bytes1(uint8((_len / (256 ** (lenLen - i))) % 256));


59              for (; i < 32; i++) {


65              out_ = new bytes(32 - i);


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/rlp/RLPWriter.sol#L65:65

```solidity
File: contracts/thirdparty/optimism/trie/MerkleTrie.sol


97                  } else if (currentNode.encoded.length >= 32) {


221             id_ = _node.length < 32 ? RLPReader.readRawBytes(_node) : RLPReader.readBytes(_node);


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/trie/MerkleTrie.sol#L221:221

```solidity
File: contracts/thirdparty/solmate/LibFixedPointMath.sol


19                  if (x <= -42_139_678_854_452_767_551) {


26                  if (x >= 135_305_999_368_893_231_589) revert Overflow();


33                  x = (x << 78) / 5 ** 18;


39                  int256 k = ((x << 96) / 54_916_777_467_707_473_351_141_471_128 + 2 ** 95) >> 96;


40                  x = x - k * 54_916_777_467_707_473_351_141_471_128;


45                  int256 y = x + 1_346_386_616_545_796_478_920_950_773_328;


46                  y = ((y * x) >> 96) + 57_155_421_227_552_351_082_224_309_758_442;


47                  int256 p = y + x - 94_201_549_194_550_492_254_356_042_504_812;


48                  p = ((p * y) >> 96) + 28_719_021_644_029_726_153_956_944_680_412_240;


49                  p = p * x + (4_385_272_521_454_847_904_659_076_985_693_276 << 96);


53                  int256 q = x - 2_855_989_394_907_223_263_936_484_059_900;


54                  q = ((q * x) >> 96) + 50_020_603_652_535_783_019_961_831_881_945;


55                  q = ((q * x) >> 96) - 533_845_033_583_426_703_283_633_433_725_380;


56                  q = ((q * x) >> 96) + 3_604_857_256_930_695_427_073_651_918_091_429;


57                  q = ((q * x) >> 96) - 14_423_608_567_350_463_180_887_372_962_807_573;


58                  q = ((q * x) >> 96) + 26_449_188_498_355_588_339_934_803_723_976_023;


77                      (uint256(r) * 3_822_833_074_963_236_453_042_738_258_902_158_003_155_416_615_667)


78                          >> uint256(195 - k)


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/solmate/LibFixedPointMath.sol#L78:78

```solidity
File: contracts/tokenvault/BaseNFTVault.sol


61          uint256[48] private __gap;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BaseNFTVault.sol#L61:61

```solidity
File: contracts/tokenvault/BaseVault.sol


18          uint256[50] private __gap;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BaseVault.sol#L18:18

```solidity
File: contracts/tokenvault/BridgedERC1155.sol


27          uint256[46] private __gap;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC1155.sol#L27:27

```solidity
File: contracts/tokenvault/BridgedERC20.sol


32          uint256[47] private __gap;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC20.sol#L32:32

```solidity
File: contracts/tokenvault/BridgedERC20Base.sol


16          uint256[49] private __gap;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC20Base.sol#L16:16

```solidity
File: contracts/tokenvault/BridgedERC721.sol


19          uint256[48] private __gap;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC721.sol#L19:19

```solidity
File: contracts/tokenvault/ERC1155Vault.sol


32          uint256[50] private __gap;


140             (bytes memory data) = abi.decode(message.data[4:], (bytes));


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC1155Vault.sol#L140:140

```solidity
File: contracts/tokenvault/ERC20Vault.sol


54          uint256[47] private __gap;


298             (bytes memory data) = abi.decode(_message.data[4:], (bytes));


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC20Vault.sol#L298:298

```solidity
File: contracts/tokenvault/ERC721Vault.sol


19          uint256[50] private __gap;


123             (bytes memory data) = abi.decode(_message.data[4:], (bytes));


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC721Vault.sol#L123:123

```solidity
File: contracts/tokenvault/LibBridgedToken.sol


56                      Strings.toHexString(uint160(_srcToken), 20),


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/LibBridgedToken.sol#L56:56

```solidity
File: contracts/tokenvault/adapters/USDCAdapter.sol


32          uint256[49] private __gap;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/adapters/USDCAdapter.sol#L32:32

```solidity
File: contracts/verifiers/GuardianVerifier.sol


11          uint256[50] private __gap;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/verifiers/GuardianVerifier.sol#L11:11

```solidity
File: contracts/verifiers/SgxVerifier.sol


57          uint256[47] private __gap;


152             if (_proof.data.length != 89) revert SGX_INVALID_PROOF();


154             uint32 id = uint32(bytes4(Bytes.slice(_proof.data, 0, 4)));


155             address newInstance = address(bytes20(Bytes.slice(_proof.data, 4, 20)));


156             bytes memory signature = Bytes.slice(_proof.data, 24);


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/verifiers/SgxVerifier.sol#L156:156

</details>

## NC003 - Event is not properly indexed:

Index event fields make the field more quickly accessible to off-chain tools that parse events. This is especially useful when it comes to filtering based on an address. However, note that each index field costs extra gas during emission, so it's not necessarily best to index the maximum allowed per event (three fields). Where applicable, each event should use three indexed fields if there are three or more fields, and gas usage is not particularly of concern for the events in question. If there are fewer than three applicable fields, all of the applicable fields should be indexed.


<details>
<summary>Click to show 5 findings</summary>

```solidity
File: contracts/common/EssentialContract.sol


29          event Paused(address account);


33          event Unpaused(address account);


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/common/EssentialContract.sol#L33:33

```solidity
File: contracts/signal/ISignalService.sol


49          event SignalSent(address app, bytes32 signal, bytes32 slot, bytes32 value);


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/signal/ISignalService.sol#L49:49

```solidity
File: contracts/team/airdrop/ERC20Airdrop2.sol


35          event Withdrawn(address user, uint256 amount);


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/airdrop/ERC20Airdrop2.sol#L35:35

```solidity
File: contracts/tokenvault/BridgedERC20Base.sol


21          event MigrationStatusChanged(address addr, bool inbound);


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC20Base.sol#L21:21

</details>

## NC004 - Function ordering does not follow the Solidity style guide:

According to the [Solidity style guide](https://docs.soliditylang.org/en/v0.8.17/style-guide.html#order-of-functions), functions should be laid out in the following order :`constructor()`, `receive()`, `fallback()`, `external`, `public`, `internal`, `private`, but the cases below do not follow this pattern.


<details>
<summary>Click to show 5 findings</summary>

```solidity
File: contracts/automata-attestation/AutomataDcapV3Attestation.sol


114         function configureQeIdentityJson(EnclaveIdStruct.EnclaveId calldata qeIdentityInput)


138         function verifyAttestation(bytes calldata data) external view override returns (bool) {


355         function verifyParsedQuote(V3Struct.ParsedV3QuoteStruct calldata v3quote)


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/AutomataDcapV3Attestation.sol#L355:355

```solidity
File: contracts/automata-attestation/lib/QuoteV3Auth/V3Parser.sol


244         function packQEReport(V3Struct.EnclaveReport memory enclaveReport)


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/QuoteV3Auth/V3Parser.sol#L244:244

```solidity
File: contracts/automata-attestation/utils/BytesUtils.sol


284         function substring(


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/BytesUtils.sol#L284:284

</details>

## NC005 - Imports could be organized more systematically:

This issue arises when the contract's interface is not imported first, followed by each of the interfaces it uses, followed by all other files.


<details>
<summary>Click to show 17 findings</summary>

```solidity
File: contracts/L1/TaikoL1.sol


9       import "./ITaikoL1.sol";


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/TaikoL1.sol#L9:9

```solidity
File: contracts/L1/hooks/AssignmentHook.sol


8       import "../ITaikoL1.sol";


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/hooks/AssignmentHook.sol#L8:8

```solidity
File: contracts/L1/libs/LibProposing.sol


7       import "../hooks/IHook.sol";


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProposing.sol#L7:7

```solidity
File: contracts/L1/libs/LibProving.sol


7       import "../../verifiers/IVerifier.sol";


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProving.sol#L7:7

```solidity
File: contracts/L1/libs/LibVerifying.sol


7       import "../../signal/ISignalService.sol";


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibVerifying.sol#L7:7

```solidity
File: contracts/L1/tiers/DevnetTierProvider.sol


5       import "./ITierProvider.sol";


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/tiers/DevnetTierProvider.sol#L5:5

```solidity
File: contracts/L1/tiers/MainnetTierProvider.sol


5       import "./ITierProvider.sol";


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/tiers/MainnetTierProvider.sol#L5:5

```solidity
File: contracts/L1/tiers/TestnetTierProvider.sol


5       import "./ITierProvider.sol";


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/tiers/TestnetTierProvider.sol#L5:5

```solidity
File: contracts/L2/CrossChainOwned.sol


6       import "../bridge/IBridge.sol";


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/CrossChainOwned.sol#L6:6

```solidity
File: contracts/L2/TaikoL2.sol


9       import "../signal/ISignalService.sol";


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/TaikoL2.sol#L9:9

```solidity
File: contracts/automata-attestation/AutomataDcapV3Attestation.sol


6       import { IPEMCertChainLib } from "./lib/interfaces/IPEMCertChainLib.sol";


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/AutomataDcapV3Attestation.sol#L6:6

```solidity
File: contracts/automata-attestation/lib/PEMCertChainLib.sol


8       import { IPEMCertChainLib } from "./interfaces/IPEMCertChainLib.sol";


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/PEMCertChainLib.sol#L8:8

```solidity
File: contracts/bridge/Bridge.sol


7       import "../signal/ISignalService.sol";


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/Bridge.sol#L7:7

```solidity
File: contracts/signal/SignalService.sol


7       import "./ISignalService.sol";


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/signal/SignalService.sol#L7:7

```solidity
File: contracts/tokenvault/BridgedERC20Base.sol


5       import "./IBridgedERC20.sol";


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC20Base.sol#L5:5

```solidity
File: contracts/verifiers/GuardianVerifier.sol


6       import "./IVerifier.sol";


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/verifiers/GuardianVerifier.sol#L6:6

```solidity
File: contracts/verifiers/SgxVerifier.sol


8       import "../automata-attestation/interfaces/IAttestation.sol";


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/verifiers/SgxVerifier.sol#L8:8

</details>

## NC006 - Constants in comparisons should appear on the left side:

This issue arises when constants in comparisons appear on the right side, which can lead to typo bugs.


<details>
<summary>Click to show 198 findings</summary>

```solidity
File: contracts/L1/TaikoL1.sol


153             if (blk_.verifiedTransitionId != 0) {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/TaikoL1.sol#L153:153

```solidity
File: contracts/L1/hooks/AssignmentHook.sol


83                      || assignment.metaHash != 0 && _blk.metaHash != assignment.metaHash


84                      || assignment.parentMetaHash != 0 && _meta.parentMetaHash != assignment.parentMetaHash


85                      || assignment.maxBlockId != 0 && _meta.id > assignment.maxBlockId


86                      || assignment.maxProposedIn != 0 && block.number > assignment.maxProposedIn


120             if (input.tip != 0 && block.coinbase != address(0)) {


125             if (address(this).balance > 0) {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/hooks/AssignmentHook.sol#L125:125

```solidity
File: contracts/L1/libs/LibProposing.sol


108             if (params.parentMetaHash != 0 && parentMetaHash != params.parentMetaHash) {


135                     blobUsed: _txList.length == 0,


144                 if (params.blobHash != 0) {


159                     if (meta_.blobHash == 0) revert L1_BLOB_NOT_FOUND();


185                 if (params.txListByteOffset != 0) {


195             if (meta_.txListByteSize == 0 || meta_.txListByteSize > _config.blockMaxTxListBytes) {


260                 if (address(this).balance != 0) {


307             if (_slotB.numBlocks == 1) {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProposing.sol#L307:307

```solidity
File: contracts/L1/libs/LibProving.sol


105             if (_tran.parentHash == 0 || _tran.blockHash == 0 || _tran.stateRoot == 0) {


134             if (_proof.tier == 0 || _proof.tier < _meta.minTier || _proof.tier < ts.tier) {


164                     bool isContesting = _proof.tier == ts.tier && tier.contestBond != 0;


186             bool isTopTier = tier.contestBond == 0;


192                 bool returnLivenessBond = blk.livenessBond > 0 && _proof.data.length == 32


223                     assert(tier.validityBond == 0);


224                     assert(ts.validityBond == 0 && ts.contestBond == 0 && ts.contester == address(0));


280             if (tid_ == 0) {


309                 if (tid_ == 1) {


412             if (_tier.contestBond == 0) return;


419             if (_tid == 1 && _ts.tier == 0 && inProvingWindow) {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProving.sol#L419:419

```solidity
File: contracts/L1/libs/LibUtils.sol


43              if (tid == 0) revert L1_TRANSITION_NOT_FOUND();


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibUtils.sol#L43:43

```solidity
File: contracts/L1/libs/LibVerifying.sol


93              if (_maxBlocksToVerify == 0) {


111             if (tid == 0) revert L1_TRANSITION_ID_ZERO();


137                     if (tid == 0) break;


212                 if (numBlocksVerified > 0) {


247                 _config.chainId <= 1 || _config.chainId == block.chainid //


248                     || _config.blockMaxProposals == 1


250                     || _config.blockMaxGasLimit == 0 || _config.blockMaxTxListBytes == 0


252                     || _config.livenessBond == 0 || _config.ethDepositRingBufferSize <= 1


253                     || _config.ethDepositMinCountPerBlock == 0


256                 || _config.ethDepositMaxCountPerBlock > 32


258                     || _config.ethDepositMinAmount == 0


260                     || _config.ethDepositMaxAmount > type(uint96).max || _config.ethDepositGas == 0


261                     || _config.ethDepositMaxFee == 0


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibVerifying.sol#L261:261

```solidity
File: contracts/L1/provers/Guardians.sol


84                  if (guardianIds[guardian] != 0) revert INVALID_GUARDIAN_SET();


113             if (id == 0) revert INVALID_GUARDIAN();


134                     if (bits & 1 == 1) ++count;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/provers/Guardians.sol#L134:134

```solidity
File: contracts/L1/tiers/MainnetTierProvider.sol


68              if (_rand % 1000 == 0) return LibTiers.TIER_SGX_ZKVM;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/tiers/MainnetTierProvider.sol#L68:68

```solidity
File: contracts/L1/tiers/TestnetTierProvider.sol


68              if (_rand % 10 == 0) return LibTiers.TIER_SGX;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/tiers/TestnetTierProvider.sol#L68:68

```solidity
File: contracts/L2/CrossChainOwned.sol


70              if (_ownerChainId == 0 || _ownerChainId == block.chainid) {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/CrossChainOwned.sol#L70:70

```solidity
File: contracts/L2/Lib1559Math.sol


24              if (_adjustmentFactor == 0) {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/Lib1559Math.sol#L24:24

```solidity
File: contracts/L2/TaikoL2.sol


82              if (block.chainid <= 1 || block.chainid > type(uint64).max) {


86              if (block.number == 0) {


88              } else if (block.number == 1) {


117                 _l1BlockHash == 0 || _l1StateRoot == 0 || _l1BlockId == 0


118                     || (block.number != 1 && _parentGasUsed == 0)


234                 for (uint256 i; i < 255 && _blockId >= i + 1; ++i) {


262             if (gasExcess > 0) {


275                 if (lastSyncedBlock > 0 && _l1BlockId > lastSyncedBlock) {


279                 if (numL1Blocks > 0) {


296             if (basefee_ == 0) basefee_ = 1;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/TaikoL2.sol#L296:296

```solidity
File: contracts/L2/TaikoL2EIP1559Configurable.sol


33              if (_newConfig.gasTargetPerL1Block == 0) revert L2_INVALID_CONFIG();


34              if (_newConfig.basefeeAdjustmentQuotient == 0) revert L2_INVALID_CONFIG();


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/TaikoL2EIP1559Configurable.sol#L34:34

```solidity
File: contracts/automata-attestation/AutomataDcapV3Attestation.sol


420                 for (uint256 i; i < 3; ++i) {


421                     bool isPckCert = i == 0; // additional parsing for PCKCert


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/AutomataDcapV3Attestation.sol#L421:421

```solidity
File: contracts/automata-attestation/lib/PEMCertChainLib.sol


56                  if (i > 0) {


135                     (notBeforeTag != 0x17 && notBeforeTag == 0x18)


136                         || (notAfterTag != 0x17 && notAfterTag != 0x18)


189                 if (der[tbsPtr.ixs()] != 0xA3) {


286             while (tbsPtr != 0) {


288                 if (der[internalPtr.ixs()] != 0x06) {


303                         if (der[extnValueOidPtr.ixs()] != 0x06) {


358                 uint16 svnValue = svnValueBytes.length < 2


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/PEMCertChainLib.sol#L358:358

```solidity
File: contracts/automata-attestation/lib/QuoteV3Auth/V3Parser.sol


78                  localEnclaveReport.reserved3.length == 96 && localEnclaveReport.reserved4.length == 60


79                      && localEnclaveReport.reportData.length == 64,


83                  pckSignedQeReport.reserved3.length == 96 && pckSignedQeReport.reserved4.length == 60


84                      && pckSignedQeReport.reportData.length == 64,


88                  v3Quote.v3AuthData.certification.certType == 5,


92                  v3Quote.v3AuthData.certification.decodedCertDataArray.length == 3, "3 certs in chain"


95                  v3Quote.v3AuthData.ecdsa256BitSignature.length == 64


96                      && v3Quote.v3AuthData.ecdsaAttestationKey.length == 64


97                      && v3Quote.v3AuthData.qeReportSignature.length == 64,


218             if (cert.certType < 1 || cert.certType > 5) {


281             for (uint256 i; i < 3; ++i) {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/QuoteV3Auth/V3Parser.sol#L281:281

```solidity
File: contracts/automata-attestation/utils/Asn1Decode.sol


57              require(der[ptr.ixs()] == 0x03, "Not type BIT STRING");


67              require(der[ptr.ixs()] == 0x04, "Not type OCTET STRING");


88              require(der[ptr.ixs()] & 0x20 == 0x20, "Not a constructed type");


142             require(der[ptr.ixs()] == 0x02, "Not type INTEGER");


143             require(der[ptr.ixf()] & 0x80 == 0, "Not positive");


155             require(der[ptr.ixs()] == 0x02, "Not type INTEGER");


156             require(der[ptr.ixf()] & 0x80 == 0, "Not positive");


158             if (der[ptr.ixf()] == 0) {


180             require(der[ptr.ixs()] == 0x03, "ixs Not type BIT STRING 0x03");


182             require(der[ptr.ixf()] == 0x00, "ixf Not 0");


191             if ((der[ix + 1] & 0x80) == 0) {


197                 if (lengthbytesLength == 1) {


199                 } else if (lengthbytesLength == 2) {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/Asn1Decode.sol#L199:199

```solidity
File: contracts/automata-attestation/utils/BytesUtils.sol


90                      if (shortest > 32) {


96                      if (diff != 0) {


264             require(len <= 32, "unexpected len");


329             require(len <= 52, "unexpected len");


335                 require(char >= 0x30 && char <= 0x7A, "invalid char");


337                 require(decoded <= 0x20, "invalid decoded");


345             if (len % 8 == 0) {


348             } else if (len % 8 == 2) {


352             } else if (len % 8 == 4) {


356             } else if (len % 8 == 5) {


360             } else if (len % 8 == 7) {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/BytesUtils.sol#L360:360

```solidity
File: contracts/automata-attestation/utils/RsaVerify.sol


125             if (uint8(decipher[decipherlen - 50]) == 0x31) {


128             } else if (uint8(decipher[decipherlen - 48]) == 0x2f) {


137             if (decipher[0] != 0 || decipher[1] != 0x01) {


141                 if (decipher[i] != 0xff) {


145             if (decipher[2 + paddingLen] != 0) {


168                 decipher[3 + paddingLen + digestAlgoWithParamLen] != 0x04


169                     || decipher[4 + paddingLen + digestAlgoWithParamLen] != 0x20


270             if (decipher[0] != 0 || decipher[1] != 0x01) {


274                 if (decipher[i] != 0xff) {


278             if (decipher[2 + paddingLen] != 0) {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/RsaVerify.sol#L278:278

```solidity
File: contracts/automata-attestation/utils/SigVerifyLib.sol


123             if (signature.length != 64) {


129             if (publicKey.length != 64) {


140             return abi.decode(ret, (uint256)) == 1;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/SigVerifyLib.sol#L140:140

```solidity
File: contracts/automata-attestation/utils/X509DateUtils.sol


17              if (x509Time.length == 13) {


18                  if (uint8(x509Time[0]) - 48 < 5) yrs += 2000;


72              if (year % 4 != 0) return false;


73              if (year % 100 != 0) return true;


74              if (year % 400 != 0) return false;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/X509DateUtils.sol#L74:74

```solidity
File: contracts/bridge/Bridge.sol


169             bool isMessageProven = receivedAt != 0;


231             bool isMessageProven = receivedAt != 0;


242                 if (invocationDelay != 0) {


245                         preferredExecutor: _message.gasLimit == 0 ? _message.destOwner : msg.sender


250             if (invocationDelay != 0 && msg.sender != proofReceipt[msgHash].preferredExecutor) {


260                 if (_message.gasLimit == 0 && msg.sender != _message.destOwner) {


321             if (_message.gasLimit == 0 || _isLastAttempt) {


405             if (ctx_.msgHash == 0 || ctx_.msgHash == bytes32(PLACEHOLDER)) {


424                 block.chainid == 1 // Ethereum mainnet


430                 block.chainid == 2 // Ropsten


431                     || block.chainid == 4 // Rinkeby


432                     || block.chainid == 5 // Goerli


433                     || block.chainid == 42 // Kovan


434                     || block.chainid == 17_000 // Holesky


435                     || block.chainid == 11_155_111 // Sepolia


439             } else if (block.chainid >= 32_300 && block.chainid <= 32_400) {


485             if (_gasLimit == 0) revert B_INVALID_GAS_LIMIT();


491                 _message.data.length >= 4 // msg can be empty


530             if (block.chainid == 1) {


542             if (block.chainid == 1) {


556             if (block.chainid == 1) {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/Bridge.sol#L556:556

```solidity
File: contracts/common/EssentialContract.sol


120             if (block.chainid == 1) {


131             if (block.chainid == 1) {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/common/EssentialContract.sol#L131:131

```solidity
File: contracts/libs/Lib4844.sol


49              if (ret.length != 64) revert EVAL_FAILED_2();


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/libs/Lib4844.sol#L49:49

```solidity
File: contracts/libs/LibTrieProof.sol


46              if (_accountProof.length != 0) {


50                  if (rlpAccount.length == 0) revert LTP_INVALID_ACCOUNT_PROOF();


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/libs/LibTrieProof.sol#L50:50

```solidity
File: contracts/signal/SignalService.sol


41              if (_input == 0) revert SS_INVALID_VALUE();


95              if (hopProofs.length == 0) revert SS_EMPTY_PROOF();


114                     if (hop.chainId == 0 || hop.chainId == block.chainid) {


120                 bool isFullProof = hop.accountProof.length > 0;


131             if (value == 0 || value != _loadSignalValue(address(this), signal)) {


154             return _loadSignalValue(_app, _signal) != 0;


167             blockId_ = _blockId != 0 ? _blockId : topBlockId[_chainId][_kind];


169             if (blockId_ != 0) {


172                 if (chainData_ == 0) revert SS_SIGNAL_NOT_FOUND();


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/signal/SignalService.sol#L172:172

```solidity
File: contracts/team/TimelockTokenPool.sol


137             if (recipients[_recipient].grant.amount != 0) revert ALREADY_GRANTED();


154             if (amountVoided == 0) revert NOTHING_TO_VOID();


255             if (_amount == 0) return 0;


256             if (_start == 0) return _amount;


259             if (_period == 0) return _amount;


268             if (_grant.amount == 0) revert INVALID_GRANT();


274             if (_start == 0 || _period == 0) {


275                 if (_cliff > 0) revert INVALID_GRANT();


277                 if (_cliff > 0 && _cliff <= _start) revert INVALID_GRANT();


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/TimelockTokenPool.sol#L277:277

```solidity
File: contracts/team/airdrop/ERC20Airdrop2.sol


111             if (balance == 0) return (0, 0);


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/airdrop/ERC20Airdrop2.sol#L111:111

```solidity
File: contracts/team/airdrop/MerkleClaimable.sol


35                  merkleRoot == 0x0 || claimStart == 0 || claimEnd == 0 || claimStart > block.timestamp


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/airdrop/MerkleClaimable.sol#L35:35

```solidity
File: contracts/thirdparty/optimism/rlp/RLPReader.sol


38                  _in.length > 0,


153                 _in.length > 0,


163             if (prefix <= 0x7f) {


166             } else if (prefix <= 0xb7) {


183                     strLen != 1 || firstByteOfContent >= 0x80,


188             } else if (prefix <= 0xbf) {


203                     firstByteOfContent != 0x00,


213                     strLen > 55,


223             } else if (prefix <= 0xf7) {


249                     firstByteOfContent != 0x00,


259                     listLen > 55,


287             if (_length == 0) {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/rlp/RLPReader.sol#L287:287

```solidity
File: contracts/thirdparty/optimism/rlp/RLPWriter.sol


14              if (_in.length == 1 && uint8(_in[0]) < 128) {


33              if (_len < 56) {


39                  while (_len / i != 0) {


59              for (; i < 32; i++) {


60                  if (b[i] != 0) {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/rlp/RLPWriter.sol#L60:60

```solidity
File: contracts/thirdparty/optimism/trie/MerkleTrie.sol


77              require(_key.length > 0, "MerkleTrie: empty key");


91                  if (currentKeyIndex == 0) {


97                  } else if (currentNode.encoded.length >= 32) {


120                             value_.length > 0,


173                             value_.length > 0,


221             id_ = _node.length < 32 ? RLPReader.readRawBytes(_node) : RLPReader.readBytes(_node);


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/trie/MerkleTrie.sol#L221:221

```solidity
File: contracts/thirdparty/solmate/LibFixedPointMath.sol


26                  if (x >= 135_305_999_368_893_231_589) revert Overflow();


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/solmate/LibFixedPointMath.sol#L26:26

```solidity
File: contracts/tokenvault/ERC1155Vault.sol


48                  if (_op.amounts[i] == 0) revert VAULT_INVALID_AMOUNT();


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC1155Vault.sol#L48:48

```solidity
File: contracts/tokenvault/ERC20Vault.sol


214             if (_op.amount == 0) revert VAULT_INVALID_AMOUNT();


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC20Vault.sol#L214:214

```solidity
File: contracts/tokenvault/ERC721Vault.sol


35                  if (_op.amounts[i] != 0) revert VAULT_INVALID_AMOUNT();


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC721Vault.sol#L35:35

```solidity
File: contracts/tokenvault/LibBridgedToken.sol


21                  _srcToken == address(0) || _srcChainId == 0 || _srcChainId == block.chainid


22                      || bytes(_symbol).length == 0 || bytes(_name).length == 0


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/LibBridgedToken.sol#L22:22

```solidity
File: contracts/verifiers/SgxVerifier.sol


152             if (_proof.data.length != 89) revert SGX_INVALID_PROOF();


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/verifiers/SgxVerifier.sol#L152:152

</details>

## NC007 - else-block not required:

One level of nesting can be removed by not having an else block when the if-block returns


<details>
<summary>Click to show 22 findings</summary>

```solidity
File: contracts/L1/tiers/MainnetTierProvider.sol


68              if (_rand % 1000 == 0) return LibTiers.TIER_SGX_ZKVM;
69              else return LibTiers.TIER_SGX;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/tiers/MainnetTierProvider.sol#L68:69

```solidity
File: contracts/automata-attestation/AutomataDcapV3Attestation.sol


319             if (qeReportDataIsValid) {
320                 bytes memory pckSignedQeReportBytes =
321                     V3Parser.packQEReport(authDataV3.pckSignedQeReport);
322                 bool qeSigVerified = sigVerifyLib.verifyES256Signature(
323                     pckSignedQeReportBytes, authDataV3.qeReportSignature, pckCertPubKey
324                 );
325                 bool quoteSigVerified = sigVerifyLib.verifyES256Signature(
326                     signedQuoteData, authDataV3.ecdsa256BitSignature, authDataV3.ecdsaAttestationKey
327                 );
328                 return qeSigVerified && quoteSigVerified;
329             } else {
330                 return false;
331             }


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/AutomataDcapV3Attestation.sol#L319:331

```solidity
File: contracts/automata-attestation/utils/Asn1Decode.sol


158             if (der[ptr.ixf()] == 0) {
159                 return der.substring(ptr.ixf() + 1, valueLength - 1);
160             } else {
161                 return der.substring(ptr.ixf(), valueLength);
162             }


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/Asn1Decode.sol#L158:162

```solidity
File: contracts/automata-attestation/utils/RsaVerify.sol


151             if (digestAlgoWithParamLen == sha256ExplicitNullParam.length) {
152                 for (uint256 i; i < digestAlgoWithParamLen; ++i) {
153                     if (decipher[3 + paddingLen + i] != bytes1(sha256ExplicitNullParam[i])) {
154                         return false;
155                     }
156                 }
157             } else {
158                 for (uint256 i; i < digestAlgoWithParamLen; ++i) {
159                     if (decipher[3 + paddingLen + i] != bytes1(sha256ImplicitNullParam[i])) {
160                         return false;
161                     }
162                 }
163             }


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/RsaVerify.sol#L151:163

```solidity
File: contracts/automata-attestation/utils/SigVerifyLib.sol


34              if (alg == Algorithm.RS256) {
35                  if (publicKey.keyType != KeyType.RSA) {
36                      return false;
37                  }
38                  return verifyRS256Signature(tbs, signature, publicKey.pubKey);
39              } else if (alg == Algorithm.ES256) {
40                  if (publicKey.keyType != KeyType.ECDSA) {
41                      return false;
42                  }
43                  return verifyES256Signature(tbs, signature, publicKey.pubKey);
44              } else if (alg == Algorithm.RS1) {
45                  if (publicKey.keyType != KeyType.RSA) {
46                      return false;
47                  }
48                  return verifyRS1Signature(tbs, signature, publicKey.pubKey);
49              } else {
50                  revert("Unsupported algorithm");
51              }


39              } else if (alg == Algorithm.ES256) {
40                  if (publicKey.keyType != KeyType.ECDSA) {
41                      return false;
42                  }
43                  return verifyES256Signature(tbs, signature, publicKey.pubKey);
44              } else if (alg == Algorithm.RS1) {
45                  if (publicKey.keyType != KeyType.RSA) {
46                      return false;
47                  }
48                  return verifyRS1Signature(tbs, signature, publicKey.pubKey);
49              } else {
50                  revert("Unsupported algorithm");
51              }


44              } else if (alg == Algorithm.RS1) {
45                  if (publicKey.keyType != KeyType.RSA) {
46                      return false;
47                  }
48                  return verifyRS1Signature(tbs, signature, publicKey.pubKey);
49              } else {
50                  revert("Unsupported algorithm");
51              }


64              if (alg == CertSigAlgorithm.Sha256WithRSAEncryption) {
65                  if (publicKey.keyType != KeyType.RSA) {
66                      return false;
67                  }
68                  return verifyRS256Signature(tbs, signature, publicKey.pubKey);
69              } else if (alg == CertSigAlgorithm.Sha1WithRSAEncryption) {
70                  if (publicKey.keyType != KeyType.RSA) {
71                      return false;
72                  }
73                  return verifyRS1Signature(tbs, signature, publicKey.pubKey);
74              } else {
75                  revert("Unsupported algorithm");
76              }


69              } else if (alg == CertSigAlgorithm.Sha1WithRSAEncryption) {
70                  if (publicKey.keyType != KeyType.RSA) {
71                      return false;
72                  }
73                  return verifyRS1Signature(tbs, signature, publicKey.pubKey);
74              } else {
75                  revert("Unsupported algorithm");
76              }


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/SigVerifyLib.sol#L69:76

```solidity
File: contracts/bridge/Bridge.sol


423             if (
424                 block.chainid == 1 // Ethereum mainnet
425             ) {
426                 // For Taiko mainnet
427                 // 384 seconds = 6.4 minutes = one ethereum epoch
428                 return (1 hours, 384 seconds);
429             } else if (
430                 block.chainid == 2 // Ropsten
431                     || block.chainid == 4 // Rinkeby
432                     || block.chainid == 5 // Goerli
433                     || block.chainid == 42 // Kovan
434                     || block.chainid == 17_000 // Holesky
435                     || block.chainid == 11_155_111 // Sepolia
436             ) {
437                 // For all Taiko public testnets
438                 return (30 minutes, 384 seconds);
439             } else if (block.chainid >= 32_300 && block.chainid <= 32_400) {
440                 // For all Taiko internal devnets
441                 return (5 minutes, 384 seconds);
442             } else {
443                 // This is a Taiko L2 chain where no deleys are applied.
444                 return (0, 0);
445             }


429             } else if (
430                 block.chainid == 2 // Ropsten
431                     || block.chainid == 4 // Rinkeby
432                     || block.chainid == 5 // Goerli
433                     || block.chainid == 42 // Kovan
434                     || block.chainid == 17_000 // Holesky
435                     || block.chainid == 11_155_111 // Sepolia
436             ) {
437                 // For all Taiko public testnets
438                 return (30 minutes, 384 seconds);
439             } else if (block.chainid >= 32_300 && block.chainid <= 32_400) {
440                 // For all Taiko internal devnets
441                 return (5 minutes, 384 seconds);
442             } else {
443                 // This is a Taiko L2 chain where no deleys are applied.
444                 return (0, 0);
445             }


439             } else if (block.chainid >= 32_300 && block.chainid <= 32_400) {
440                 // For all Taiko internal devnets
441                 return (5 minutes, 384 seconds);
442             } else {
443                 // This is a Taiko L2 chain where no deleys are applied.
444                 return (0, 0);
445             }


556             if (block.chainid == 1) {
557                 bytes32 msgHash;
558                 address from;
559                 uint64 srcChainId;
560                 assembly {
561                     msgHash := tload(_CTX_SLOT)
562                     from := tload(add(_CTX_SLOT, 1))
563                     srcChainId := tload(add(_CTX_SLOT, 2))
564                 }
565                 return Context(msgHash, from, srcChainId);
566             } else {
567                 return __ctx;
568             }


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/Bridge.sol#L556:568

```solidity
File: contracts/libs/LibAddress.sol


70              if (Address.isContract(_addr)) {
71                  return IERC1271(_addr).isValidSignature(_hash, _sig) == _EIP1271_MAGICVALUE;
72              } else {
73                  return ECDSA.recover(_hash, _sig) == _addr;
74              }


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/libs/LibAddress.sol#L70:74

```solidity
File: contracts/thirdparty/optimism/rlp/RLPReader.sol


163             if (prefix <= 0x7f) {
164                 // Single byte.
165                 return (0, 1, RLPItemType.DATA_ITEM);
166             } else if (prefix <= 0xb7) {
167                 // Short string.
168     
169                 // slither-disable-next-line variable-scope
170                 uint256 strLen = prefix - 0x80;
171     
172                 require(
173                     _in.length > strLen,
174                     "RLPReader: length of content must be greater than string length (short string)"
175                 );
176     
177                 bytes1 firstByteOfContent;
178                 assembly {
179                     firstByteOfContent := and(mload(add(ptr, 1)), shl(248, 0xff))
180                 }
181     
182                 require(
183                     strLen != 1 || firstByteOfContent >= 0x80,
184                     "RLPReader: invalid prefix, single byte < 0x80 are not prefixed (short string)"
185                 );
186     
187                 return (1, strLen, RLPItemType.DATA_ITEM);
188             } else if (prefix <= 0xbf) {
189                 // Long string.
190                 uint256 lenOfStrLen = prefix - 0xb7;
191     
192                 require(
193                     _in.length > lenOfStrLen,
194                     "RLPReader: length of content must be > than length of string length (long string)"
195                 );
196     
197                 bytes1 firstByteOfContent;
198                 assembly {
199                     firstByteOfContent := and(mload(add(ptr, 1)), shl(248, 0xff))
200                 }
201     
202                 require(
203                     firstByteOfContent != 0x00,
204                     "RLPReader: length of content must not have any leading zeros (long string)"
205                 );
206     
207                 uint256 strLen;
208                 assembly {
209                     strLen := shr(sub(256, mul(8, lenOfStrLen)), mload(add(ptr, 1)))
210                 }
211     
212                 require(
213                     strLen > 55,
214                     "RLPReader: length of content must be greater than 55 bytes (long string)"
215                 );
216     
217                 require(
218                     _in.length > lenOfStrLen + strLen,
219                     "RLPReader: length of content must be greater than total length (long string)"
220                 );
221     
222                 return (1 + lenOfStrLen, strLen, RLPItemType.DATA_ITEM);
223             } else if (prefix <= 0xf7) {
224                 // Short list.
225                 // slither-disable-next-line variable-scope
226                 uint256 listLen = prefix - 0xc0;
227     
228                 require(
229                     _in.length > listLen,
230                     "RLPReader: length of content must be greater than list length (short list)"
231                 );
232     
233                 return (1, listLen, RLPItemType.LIST_ITEM);
234             } else {
235                 // Long list.
236                 uint256 lenOfListLen = prefix - 0xf7;
237     
238                 require(
239                     _in.length > lenOfListLen,
240                     "RLPReader: length of content must be > than length of list length (long list)"
241                 );
242     
243                 bytes1 firstByteOfContent;
244                 assembly {
245                     firstByteOfContent := and(mload(add(ptr, 1)), shl(248, 0xff))
246                 }
247     
248                 require(
249                     firstByteOfContent != 0x00,
250                     "RLPReader: length of content must not have any leading zeros (long list)"
251                 );
252     
253                 uint256 listLen;
254                 assembly {
255                     listLen := shr(sub(256, mul(8, lenOfListLen)), mload(add(ptr, 1)))
256                 }
257     
258                 require(
259                     listLen > 55,
260                     "RLPReader: length of content must be greater than 55 bytes (long list)"
261                 );
262     
263                 require(
264                     _in.length > lenOfListLen + listLen,
265                     "RLPReader: length of content must be greater than total length (long list)"
266                 );
267     
268                 return (1 + lenOfListLen, listLen, RLPItemType.LIST_ITEM);
269             }


166             } else if (prefix <= 0xb7) {
167                 // Short string.
168     
169                 // slither-disable-next-line variable-scope
170                 uint256 strLen = prefix - 0x80;
171     
172                 require(
173                     _in.length > strLen,
174                     "RLPReader: length of content must be greater than string length (short string)"
175                 );
176     
177                 bytes1 firstByteOfContent;
178                 assembly {
179                     firstByteOfContent := and(mload(add(ptr, 1)), shl(248, 0xff))
180                 }
181     
182                 require(
183                     strLen != 1 || firstByteOfContent >= 0x80,
184                     "RLPReader: invalid prefix, single byte < 0x80 are not prefixed (short string)"
185                 );
186     
187                 return (1, strLen, RLPItemType.DATA_ITEM);
188             } else if (prefix <= 0xbf) {
189                 // Long string.
190                 uint256 lenOfStrLen = prefix - 0xb7;
191     
192                 require(
193                     _in.length > lenOfStrLen,
194                     "RLPReader: length of content must be > than length of string length (long string)"
195                 );
196     
197                 bytes1 firstByteOfContent;
198                 assembly {
199                     firstByteOfContent := and(mload(add(ptr, 1)), shl(248, 0xff))
200                 }
201     
202                 require(
203                     firstByteOfContent != 0x00,
204                     "RLPReader: length of content must not have any leading zeros (long string)"
205                 );
206     
207                 uint256 strLen;
208                 assembly {
209                     strLen := shr(sub(256, mul(8, lenOfStrLen)), mload(add(ptr, 1)))
210                 }
211     
212                 require(
213                     strLen > 55,
214                     "RLPReader: length of content must be greater than 55 bytes (long string)"
215                 );
216     
217                 require(
218                     _in.length > lenOfStrLen + strLen,
219                     "RLPReader: length of content must be greater than total length (long string)"
220                 );
221     
222                 return (1 + lenOfStrLen, strLen, RLPItemType.DATA_ITEM);
223             } else if (prefix <= 0xf7) {
224                 // Short list.
225                 // slither-disable-next-line variable-scope
226                 uint256 listLen = prefix - 0xc0;
227     
228                 require(
229                     _in.length > listLen,
230                     "RLPReader: length of content must be greater than list length (short list)"
231                 );
232     
233                 return (1, listLen, RLPItemType.LIST_ITEM);
234             } else {
235                 // Long list.
236                 uint256 lenOfListLen = prefix - 0xf7;
237     
238                 require(
239                     _in.length > lenOfListLen,
240                     "RLPReader: length of content must be > than length of list length (long list)"
241                 );
242     
243                 bytes1 firstByteOfContent;
244                 assembly {
245                     firstByteOfContent := and(mload(add(ptr, 1)), shl(248, 0xff))
246                 }
247     
248                 require(
249                     firstByteOfContent != 0x00,
250                     "RLPReader: length of content must not have any leading zeros (long list)"
251                 );
252     
253                 uint256 listLen;
254                 assembly {
255                     listLen := shr(sub(256, mul(8, lenOfListLen)), mload(add(ptr, 1)))
256                 }
257     
258                 require(
259                     listLen > 55,
260                     "RLPReader: length of content must be greater than 55 bytes (long list)"
261                 );
262     
263                 require(
264                     _in.length > lenOfListLen + listLen,
265                     "RLPReader: length of content must be greater than total length (long list)"
266                 );
267     
268                 return (1 + lenOfListLen, listLen, RLPItemType.LIST_ITEM);
269             }


188             } else if (prefix <= 0xbf) {
189                 // Long string.
190                 uint256 lenOfStrLen = prefix - 0xb7;
191     
192                 require(
193                     _in.length > lenOfStrLen,
194                     "RLPReader: length of content must be > than length of string length (long string)"
195                 );
196     
197                 bytes1 firstByteOfContent;
198                 assembly {
199                     firstByteOfContent := and(mload(add(ptr, 1)), shl(248, 0xff))
200                 }
201     
202                 require(
203                     firstByteOfContent != 0x00,
204                     "RLPReader: length of content must not have any leading zeros (long string)"
205                 );
206     
207                 uint256 strLen;
208                 assembly {
209                     strLen := shr(sub(256, mul(8, lenOfStrLen)), mload(add(ptr, 1)))
210                 }
211     
212                 require(
213                     strLen > 55,
214                     "RLPReader: length of content must be greater than 55 bytes (long string)"
215                 );
216     
217                 require(
218                     _in.length > lenOfStrLen + strLen,
219                     "RLPReader: length of content must be greater than total length (long string)"
220                 );
221     
222                 return (1 + lenOfStrLen, strLen, RLPItemType.DATA_ITEM);
223             } else if (prefix <= 0xf7) {
224                 // Short list.
225                 // slither-disable-next-line variable-scope
226                 uint256 listLen = prefix - 0xc0;
227     
228                 require(
229                     _in.length > listLen,
230                     "RLPReader: length of content must be greater than list length (short list)"
231                 );
232     
233                 return (1, listLen, RLPItemType.LIST_ITEM);
234             } else {
235                 // Long list.
236                 uint256 lenOfListLen = prefix - 0xf7;
237     
238                 require(
239                     _in.length > lenOfListLen,
240                     "RLPReader: length of content must be > than length of list length (long list)"
241                 );
242     
243                 bytes1 firstByteOfContent;
244                 assembly {
245                     firstByteOfContent := and(mload(add(ptr, 1)), shl(248, 0xff))
246                 }
247     
248                 require(
249                     firstByteOfContent != 0x00,
250                     "RLPReader: length of content must not have any leading zeros (long list)"
251                 );
252     
253                 uint256 listLen;
254                 assembly {
255                     listLen := shr(sub(256, mul(8, lenOfListLen)), mload(add(ptr, 1)))
256                 }
257     
258                 require(
259                     listLen > 55,
260                     "RLPReader: length of content must be greater than 55 bytes (long list)"
261                 );
262     
263                 require(
264                     _in.length > lenOfListLen + listLen,
265                     "RLPReader: length of content must be greater than total length (long list)"
266                 );
267     
268                 return (1 + lenOfListLen, listLen, RLPItemType.LIST_ITEM);
269             }


223             } else if (prefix <= 0xf7) {
224                 // Short list.
225                 // slither-disable-next-line variable-scope
226                 uint256 listLen = prefix - 0xc0;
227     
228                 require(
229                     _in.length > listLen,
230                     "RLPReader: length of content must be greater than list length (short list)"
231                 );
232     
233                 return (1, listLen, RLPItemType.LIST_ITEM);
234             } else {
235                 // Long list.
236                 uint256 lenOfListLen = prefix - 0xf7;
237     
238                 require(
239                     _in.length > lenOfListLen,
240                     "RLPReader: length of content must be > than length of list length (long list)"
241                 );
242     
243                 bytes1 firstByteOfContent;
244                 assembly {
245                     firstByteOfContent := and(mload(add(ptr, 1)), shl(248, 0xff))
246                 }
247     
248                 require(
249                     firstByteOfContent != 0x00,
250                     "RLPReader: length of content must not have any leading zeros (long list)"
251                 );
252     
253                 uint256 listLen;
254                 assembly {
255                     listLen := shr(sub(256, mul(8, lenOfListLen)), mload(add(ptr, 1)))
256                 }
257     
258                 require(
259                     listLen > 55,
260                     "RLPReader: length of content must be greater than 55 bytes (long list)"
261                 );
262     
263                 require(
264                     _in.length > lenOfListLen + listLen,
265                     "RLPReader: length of content must be greater than total length (long list)"
266                 );
267     
268                 return (1 + lenOfListLen, listLen, RLPItemType.LIST_ITEM);
269             }


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/rlp/RLPReader.sol#L223:269

```solidity
File: contracts/thirdparty/optimism/trie/MerkleTrie.sol


111                 if (currentNode.decoded.length == BRANCH_NODE_LENGTH) {
112                     if (currentKeyIndex == key.length) {
113                         // Value is the last element of the decoded list (for branch nodes). There's
114                         // some ambiguity in the Merkle trie specification because bytes(0) is a
115                         // valid value to place into the trie, but for branch nodes bytes(0) can exist
116                         // even when the value wasn't explicitly placed there. Geth treats a value of
117                         // bytes(0) as "key does not exist" and so we do the same.
118                         value_ = RLPReader.readBytes(currentNode.decoded[TREE_RADIX]);
119                         require(
120                             value_.length > 0,
121                             "MerkleTrie: value length must be greater than zero (branch)"
122                         );
123     
124                         // Extra proof elements are not allowed.
125                         require(
126                             i == proof.length - 1,
127                             "MerkleTrie: value node must be last node in proof (branch)"
128                         );
129     
130                         return value_;
131                     } else {
132                         // We're not at the end of the key yet.
133                         // Figure out what the next node ID should be and continue.
134                         uint8 branchKey = uint8(key[currentKeyIndex]);
135                         RLPReader.RLPItem memory nextNode = currentNode.decoded[branchKey];
136                         currentNodeID = _getNodeID(nextNode);
137                         currentKeyIndex += 1;
138                     }
139                 } else if (currentNode.decoded.length == LEAF_OR_EXTENSION_NODE_LENGTH) {
140                     bytes memory path = _getNodePath(currentNode);
141                     uint8 prefix = uint8(path[0]);
142                     uint8 offset = 2 - (prefix % 2);
143                     bytes memory pathRemainder = Bytes.slice(path, offset);
144                     bytes memory keyRemainder = Bytes.slice(key, currentKeyIndex);
145                     uint256 sharedNibbleLength = _getSharedNibbleLength(pathRemainder, keyRemainder);
146     
147                     // Whether this is a leaf node or an extension node, the path remainder MUST be a
148                     // prefix of the key remainder (or be equal to the key remainder) or the proof is
149                     // considered invalid.
150                     require(
151                         pathRemainder.length == sharedNibbleLength,
152                         "MerkleTrie: path remainder must share all nibbles with key"
153                     );
154     
155                     if (prefix == PREFIX_LEAF_EVEN || prefix == PREFIX_LEAF_ODD) {
156                         // Prefix of 2 or 3 means this is a leaf node. For the leaf node to be valid,
157                         // the key remainder must be exactly equal to the path remainder. We already
158                         // did the necessary byte comparison, so it's more efficient here to check that
159                         // the key remainder length equals the shared nibble length, which implies
160                         // equality with the path remainder (since we already did the same check with
161                         // the path remainder and the shared nibble length).
162                         require(
163                             keyRemainder.length == sharedNibbleLength,
164                             "MerkleTrie: key remainder must be identical to path remainder"
165                         );
166     
167                         // Our Merkle Trie is designed specifically for the purposes of the Ethereum
168                         // state trie. Empty values are not allowed in the state trie, so we can safely
169                         // say that if the value is empty, the key should not exist and the proof is
170                         // invalid.
171                         value_ = RLPReader.readBytes(currentNode.decoded[1]);
172                         require(
173                             value_.length > 0,
174                             "MerkleTrie: value length must be greater than zero (leaf)"
175                         );
176     
177                         // Extra proof elements are not allowed.
178                         require(
179                             i == proof.length - 1,
180                             "MerkleTrie: value node must be last node in proof (leaf)"
181                         );
182     
183                         return value_;
184                     } else if (prefix == PREFIX_EXTENSION_EVEN || prefix == PREFIX_EXTENSION_ODD) {
185                         // Prefix of 0 or 1 means this is an extension node. We move onto the next node
186                         // in the proof and increment the key index by the length of the path remainder
187                         // which is equal to the shared nibble length.
188                         currentNodeID = _getNodeID(currentNode.decoded[1]);
189                         currentKeyIndex += sharedNibbleLength;
190                     } else {
191                         revert("MerkleTrie: received a node with an unknown prefix");
192                     }
193                 } else {
194                     revert("MerkleTrie: received an unparseable node");
195                 }


112                     if (currentKeyIndex == key.length) {
113                         // Value is the last element of the decoded list (for branch nodes). There's
114                         // some ambiguity in the Merkle trie specification because bytes(0) is a
115                         // valid value to place into the trie, but for branch nodes bytes(0) can exist
116                         // even when the value wasn't explicitly placed there. Geth treats a value of
117                         // bytes(0) as "key does not exist" and so we do the same.
118                         value_ = RLPReader.readBytes(currentNode.decoded[TREE_RADIX]);
119                         require(
120                             value_.length > 0,
121                             "MerkleTrie: value length must be greater than zero (branch)"
122                         );
123     
124                         // Extra proof elements are not allowed.
125                         require(
126                             i == proof.length - 1,
127                             "MerkleTrie: value node must be last node in proof (branch)"
128                         );
129     
130                         return value_;
131                     } else {
132                         // We're not at the end of the key yet.
133                         // Figure out what the next node ID should be and continue.
134                         uint8 branchKey = uint8(key[currentKeyIndex]);
135                         RLPReader.RLPItem memory nextNode = currentNode.decoded[branchKey];
136                         currentNodeID = _getNodeID(nextNode);
137                         currentKeyIndex += 1;
138                     }


139                 } else if (currentNode.decoded.length == LEAF_OR_EXTENSION_NODE_LENGTH) {
140                     bytes memory path = _getNodePath(currentNode);
141                     uint8 prefix = uint8(path[0]);
142                     uint8 offset = 2 - (prefix % 2);
143                     bytes memory pathRemainder = Bytes.slice(path, offset);
144                     bytes memory keyRemainder = Bytes.slice(key, currentKeyIndex);
145                     uint256 sharedNibbleLength = _getSharedNibbleLength(pathRemainder, keyRemainder);
146     
147                     // Whether this is a leaf node or an extension node, the path remainder MUST be a
148                     // prefix of the key remainder (or be equal to the key remainder) or the proof is
149                     // considered invalid.
150                     require(
151                         pathRemainder.length == sharedNibbleLength,
152                         "MerkleTrie: path remainder must share all nibbles with key"
153                     );
154     
155                     if (prefix == PREFIX_LEAF_EVEN || prefix == PREFIX_LEAF_ODD) {
156                         // Prefix of 2 or 3 means this is a leaf node. For the leaf node to be valid,
157                         // the key remainder must be exactly equal to the path remainder. We already
158                         // did the necessary byte comparison, so it's more efficient here to check that
159                         // the key remainder length equals the shared nibble length, which implies
160                         // equality with the path remainder (since we already did the same check with
161                         // the path remainder and the shared nibble length).
162                         require(
163                             keyRemainder.length == sharedNibbleLength,
164                             "MerkleTrie: key remainder must be identical to path remainder"
165                         );
166     
167                         // Our Merkle Trie is designed specifically for the purposes of the Ethereum
168                         // state trie. Empty values are not allowed in the state trie, so we can safely
169                         // say that if the value is empty, the key should not exist and the proof is
170                         // invalid.
171                         value_ = RLPReader.readBytes(currentNode.decoded[1]);
172                         require(
173                             value_.length > 0,
174                             "MerkleTrie: value length must be greater than zero (leaf)"
175                         );
176     
177                         // Extra proof elements are not allowed.
178                         require(
179                             i == proof.length - 1,
180                             "MerkleTrie: value node must be last node in proof (leaf)"
181                         );
182     
183                         return value_;
184                     } else if (prefix == PREFIX_EXTENSION_EVEN || prefix == PREFIX_EXTENSION_ODD) {
185                         // Prefix of 0 or 1 means this is an extension node. We move onto the next node
186                         // in the proof and increment the key index by the length of the path remainder
187                         // which is equal to the shared nibble length.
188                         currentNodeID = _getNodeID(currentNode.decoded[1]);
189                         currentKeyIndex += sharedNibbleLength;
190                     } else {
191                         revert("MerkleTrie: received a node with an unknown prefix");
192                     }
193                 } else {
194                     revert("MerkleTrie: received an unparseable node");
195                 }


155                     if (prefix == PREFIX_LEAF_EVEN || prefix == PREFIX_LEAF_ODD) {
156                         // Prefix of 2 or 3 means this is a leaf node. For the leaf node to be valid,
157                         // the key remainder must be exactly equal to the path remainder. We already
158                         // did the necessary byte comparison, so it's more efficient here to check that
159                         // the key remainder length equals the shared nibble length, which implies
160                         // equality with the path remainder (since we already did the same check with
161                         // the path remainder and the shared nibble length).
162                         require(
163                             keyRemainder.length == sharedNibbleLength,
164                             "MerkleTrie: key remainder must be identical to path remainder"
165                         );
166     
167                         // Our Merkle Trie is designed specifically for the purposes of the Ethereum
168                         // state trie. Empty values are not allowed in the state trie, so we can safely
169                         // say that if the value is empty, the key should not exist and the proof is
170                         // invalid.
171                         value_ = RLPReader.readBytes(currentNode.decoded[1]);
172                         require(
173                             value_.length > 0,
174                             "MerkleTrie: value length must be greater than zero (leaf)"
175                         );
176     
177                         // Extra proof elements are not allowed.
178                         require(
179                             i == proof.length - 1,
180                             "MerkleTrie: value node must be last node in proof (leaf)"
181                         );
182     
183                         return value_;
184                     } else if (prefix == PREFIX_EXTENSION_EVEN || prefix == PREFIX_EXTENSION_ODD) {
185                         // Prefix of 0 or 1 means this is an extension node. We move onto the next node
186                         // in the proof and increment the key index by the length of the path remainder
187                         // which is equal to the shared nibble length.
188                         currentNodeID = _getNodeID(currentNode.decoded[1]);
189                         currentKeyIndex += sharedNibbleLength;
190                     } else {
191                         revert("MerkleTrie: received a node with an unknown prefix");
192                     }


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/trie/MerkleTrie.sol#L155:192

</details>

## NC008 - Events may be emitted out of order due to reentrancy:

Ensure that events follow the best practice of check-effects-interaction, and are emitted before external calls


<details>
<summary>Click to show 7 findings</summary>

```solidity
File: contracts/L1/hooks/AssignmentHook.sol


/// @audit transferFrom() called before event
129             emit BlockAssigned(_blk.assignedProver, _meta, assignment);


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/hooks/AssignmentHook.sol#L129:129

```solidity
File: contracts/L1/libs/LibProving.sol


/// @audit transfer() called before event
254                     emit TransitionContested({
255                         blockId: blk.blockId,
256                         tran: _tran,
257                         contester: msg.sender,
258                         contestBond: tier.contestBond,
259                         tier: _proof.tier
260                     });


/// @audit transfer() called before event
230                     emit TransitionProved({
231                         blockId: blk.blockId,
232                         tran: _tran,
233                         prover: msg.sender,
234                         validityBond: 0,
235                         tier: _proof.tier
236                     });


/// @audit transfer() called before event
209                 emit TransitionProved({
210                     blockId: blk.blockId,
211                     tran: _tran,
212                     prover: msg.sender,
213                     validityBond: tier.validityBond,
214                     tier: _proof.tier
215                 });


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProving.sol#L209:215

```solidity
File: contracts/L1/libs/LibVerifying.sol


/// @audit transfer() called before event
198                     emit BlockVerified({
199                         blockId: blockId,
200                         assignedProver: blk.assignedProver,
201                         prover: ts.prover,
202                         blockHash: blockHash,
203                         stateRoot: stateRoot,
204                         tier: ts.tier,
205                         contestations: ts.contestations
206                     });


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibVerifying.sol#L198:206

```solidity
File: contracts/team/TimelockTokenPool.sol


/// @audit transferFrom() called before event
222             emit Withdrawn(_recipient, _to, amountToWithdraw, costToWithdraw);


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/TimelockTokenPool.sol#L222:222

```solidity
File: contracts/team/airdrop/ERC20Airdrop2.sol


/// @audit transferFrom() called before event
93              emit Withdrawn(user, amount);


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/airdrop/ERC20Airdrop2.sol#L93:93

</details>

## NC009 - If-statement can be converted to a ternary:

The code can be made more compact while also increasing readability by converting the following if-statements to ternaries (e.g. foo += (x > y) ? a : b)


<details>
<summary>Click to show 5 findings</summary>

```solidity
File: contracts/L1/libs/LibUtils.sol


80              if (_state.transitions[_slot][1].key == _parentHash) {
81                  tid_ = 1;
82              } else {
83                  tid_ = _state.transitionIds[_blk.blockId][_parentHash];
84              }


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibUtils.sol#L80:84

```solidity
File: contracts/automata-attestation/lib/PEMCertChainLib.sol


56                  if (i > 0) {
57                      input = LibString.slice(pemChainStr, index, index + len);
58                  } else {
59                      input = pemChainStr;
60                  }


333                 if (tbsPtr.ixl() < tbsParentPtr.ixl()) {
334                     tbsPtr = der.nextSiblingOf(tbsPtr);
335                 } else {
336                     tbsPtr = 0; // exit
337                 }


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/PEMCertChainLib.sol#L333:337

```solidity
File: contracts/automata-attestation/utils/X509DateUtils.sol


49                  if (isLeapYear(i)) {
50                      timestamp += 31_622_400; // Leap year in seconds
51                  } else {
52                      timestamp += 31_536_000; // Normal year in seconds
53                  }


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/X509DateUtils.sol#L49:53

```solidity
File: contracts/thirdparty/optimism/rlp/RLPWriter.sol


14              if (_in.length == 1 && uint8(_in[0]) < 128) {
15                  out_ = _in;
16              } else {
17                  out_ = abi.encodePacked(_writeLength(_in.length, 128), _in);
18              }


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/rlp/RLPWriter.sol#L14:18

</details>

## NC010 - Import declarations should import specific identifiers, rather than the whole file:

Using import declarations of the form import {<identifier_name>} from 'some/file.sol' avoids polluting the symbol namespace making flattened files smaller, and speeds up compilation


<details>
<summary>Click to show 54 findings</summary>

```solidity
File: contracts/L1/TaikoToken.sol


4       import "@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol";


5       import "@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20SnapshotUpgradeable.sol";


6       import "@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20VotesUpgradeable.sol";


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/TaikoToken.sol#L6:6

```solidity
File: contracts/L1/gov/TaikoGovernor.sol


4       import "@openzeppelin/contracts-upgradeable/governance/GovernorUpgradeable.sol";


5       import
6           "@openzeppelin/contracts-upgradeable/governance/compatibility/GovernorCompatibilityBravoUpgradeable.sol";


7       import "@openzeppelin/contracts-upgradeable/governance/extensions/GovernorVotesUpgradeable.sol";


8       import
9           "@openzeppelin/contracts-upgradeable/governance/extensions/GovernorVotesQuorumFractionUpgradeable.sol";


10      import
11          "@openzeppelin/contracts-upgradeable/governance/extensions/GovernorTimelockControlUpgradeable.sol";


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/gov/TaikoGovernor.sol#L10:11

```solidity
File: contracts/L1/gov/TaikoTimelockController.sol


4       import "@openzeppelin/contracts-upgradeable/governance/TimelockControllerUpgradeable.sol";


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/gov/TaikoTimelockController.sol#L4:4

```solidity
File: contracts/L1/hooks/AssignmentHook.sol


4       import "@openzeppelin/contracts/token/ERC20/IERC20.sol";


5       import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/hooks/AssignmentHook.sol#L5:5

```solidity
File: contracts/L1/libs/LibProposing.sol


4       import "@openzeppelin/contracts/token/ERC20/IERC20.sol";


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProposing.sol#L4:4

```solidity
File: contracts/L1/libs/LibProving.sol


4       import "@openzeppelin/contracts/token/ERC20/IERC20.sol";


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProving.sol#L4:4

```solidity
File: contracts/L1/libs/LibVerifying.sol


4       import "@openzeppelin/contracts/token/ERC20/IERC20.sol";


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibVerifying.sol#L4:4

```solidity
File: contracts/L2/CrossChainOwned.sol


4       import "@openzeppelin/contracts/token/ERC20/IERC20.sol";


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/CrossChainOwned.sol#L4:4

```solidity
File: contracts/L2/TaikoL2.sol


4       import "@openzeppelin/contracts/token/ERC20/IERC20.sol";


5       import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/TaikoL2.sol#L5:5

```solidity
File: contracts/bridge/Bridge.sol


4       import "@openzeppelin/contracts/utils/Address.sol";


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/Bridge.sol#L4:4

```solidity
File: contracts/common/AddressResolver.sol


4       import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/common/AddressResolver.sol#L4:4

```solidity
File: contracts/common/EssentialContract.sol


4       import "@openzeppelin/contracts/proxy/utils/UUPSUpgradeable.sol";


5       import "@openzeppelin/contracts-upgradeable/access/Ownable2StepUpgradeable.sol";


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/common/EssentialContract.sol#L5:5

```solidity
File: contracts/libs/LibAddress.sol


4       import "@openzeppelin/contracts/utils/Address.sol";


5       import "@openzeppelin/contracts/utils/cryptography/ECDSA.sol";


6       import "@openzeppelin/contracts/utils/introspection/IERC165.sol";


7       import "@openzeppelin/contracts/interfaces/IERC1271.sol";


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/libs/LibAddress.sol#L7:7

```solidity
File: contracts/signal/SignalService.sol


4       import "@openzeppelin/contracts/utils/math/SafeCast.sol";


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/signal/SignalService.sol#L4:4

```solidity
File: contracts/team/TimelockTokenPool.sol


4       import "@openzeppelin/contracts/utils/cryptography/ECDSA.sol";


5       import "@openzeppelin/contracts/token/ERC20/IERC20.sol";


6       import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/TimelockTokenPool.sol#L6:6

```solidity
File: contracts/team/airdrop/ERC20Airdrop.sol


4       import "@openzeppelin/contracts/token/ERC20/IERC20.sol";


5       import "@openzeppelin/contracts/governance/utils/IVotes.sol";


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/airdrop/ERC20Airdrop.sol#L5:5

```solidity
File: contracts/team/airdrop/ERC20Airdrop2.sol


4       import "@openzeppelin/contracts/token/ERC20/IERC20.sol";


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/airdrop/ERC20Airdrop2.sol#L4:4

```solidity
File: contracts/team/airdrop/ERC721Airdrop.sol


4       import "@openzeppelin/contracts/token/ERC721/IERC721.sol";


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/airdrop/ERC721Airdrop.sol#L4:4

```solidity
File: contracts/team/airdrop/MerkleClaimable.sol


4       import "@openzeppelin/contracts/utils/cryptography/MerkleProof.sol";


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/airdrop/MerkleClaimable.sol#L4:4

```solidity
File: contracts/tokenvault/BaseVault.sol


4       import "@openzeppelin/contracts-upgradeable/utils/introspection/IERC165Upgradeable.sol";


5       import "@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol";


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BaseVault.sol#L5:5

```solidity
File: contracts/tokenvault/BridgedERC1155.sol


4       import "@openzeppelin/contracts/utils/Strings.sol";


5       import "@openzeppelin/contracts-upgradeable/token/ERC1155/ERC1155Upgradeable.sol";


6       import
7           "@openzeppelin/contracts-upgradeable/token/ERC1155/extensions/IERC1155MetadataURIUpgradeable.sol";


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC1155.sol#L6:7

```solidity
File: contracts/tokenvault/BridgedERC20.sol


4       import "@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol";


5       import "@openzeppelin/contracts/utils/Strings.sol";


6       import "@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20SnapshotUpgradeable.sol";


7       import "@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20VotesUpgradeable.sol";


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC20.sol#L7:7

```solidity
File: contracts/tokenvault/BridgedERC721.sol


4       import "@openzeppelin/contracts-upgradeable/token/ERC721/ERC721Upgradeable.sol";


5       import "@openzeppelin/contracts/utils/Strings.sol";


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC721.sol#L5:5

```solidity
File: contracts/tokenvault/ERC1155Vault.sol


4       import "@openzeppelin/contracts/token/ERC1155/IERC1155.sol";


5       import "@openzeppelin/contracts-upgradeable/token/ERC1155/utils/ERC1155ReceiverUpgradeable.sol";


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC1155Vault.sol#L5:5

```solidity
File: contracts/tokenvault/ERC20Vault.sol


4       import "@openzeppelin/contracts/token/ERC20/IERC20.sol";


5       import "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol";


6       import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC20Vault.sol#L6:6

```solidity
File: contracts/tokenvault/ERC721Vault.sol


4       import "@openzeppelin/contracts/token/ERC721/IERC721.sol";


5       import "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol";


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC721Vault.sol#L5:5

```solidity
File: contracts/tokenvault/LibBridgedToken.sol


4       import "@openzeppelin/contracts/utils/Strings.sol";


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/LibBridgedToken.sol#L4:4

```solidity
File: contracts/verifiers/SgxVerifier.sol


4       import "@openzeppelin/contracts/utils/cryptography/ECDSA.sol";


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/verifiers/SgxVerifier.sol#L4:4

</details>

## NC011 - Adding a return statement when the function defines a named return variable, is redundant:

If a function defines a named return variable, it is not necessary to explicitly return it. It will automatically be returned at the end of the function.


```solidity
File: contracts/automata-attestation/AutomataDcapV3Attestation.sol


199             return (
200                 miscselectMatched && attributesMatched && mrsignerMatched && isvprodidMatched
201                     && tcbFound,
202                 status
203             );


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/AutomataDcapV3Attestation.sol#L199:203

## NC012 - Public functions not called by the contract should be declared external instead:

Contracts [are allowed](https://docs.soliditylang.org/en/latest/contracts.html#function-overriding) to override their parents' functions and change the visibility from `external` to `public`.


<details>
<summary>Click to show 43 findings</summary>

```solidity
File: contracts/L1/TaikoL1.sol


176         function getStateVariables()
177             public
178             view
179             returns (TaikoData.SlotA memory a_, TaikoData.SlotB memory b_)
180         {
181             a_ = state.slotA;
182             b_ = state.slotB;
183         }


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/TaikoL1.sol#L176:183

```solidity
File: contracts/L1/TaikoToken.sol


25          function init(
26              address _owner,
27              string calldata _name,
28              string calldata _symbol,
29              address _recipient
30          )
31              public
32              initializer
33          {
34              __Essential_init(_owner);
35              __ERC20_init(_name, _symbol);
36              __ERC20Snapshot_init();
37              __ERC20Votes_init();
38              __ERC20Permit_init(_name);
39      
40              // Mint 1 billion tokens
41              _mint(_recipient, 1_000_000_000 ether);
42          }


47          function burn(address _from, uint256 _amount) public onlyOwner {
48              _burn(_from, _amount);
49          }


52          function snapshot() public onlyFromOwnerOrNamed("snapshooter") {
53              _snapshot();
54          }


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/TaikoToken.sol#L52:54

```solidity
File: contracts/L1/gov/TaikoGovernor.sol


111         function votingDelay() public pure override returns (uint256) {
112             return 7200; // 1 day
113         }


117         function votingPeriod() public pure override returns (uint256) {
118             return 50_400; // 1 week
119         }


123         function proposalThreshold() public pure override returns (uint256) {
124             return 1_000_000_000 ether / 10_000; // 0.01% of Taiko Token
125         }


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/gov/TaikoGovernor.sol#L123:125

```solidity
File: contracts/L1/provers/Guardians.sol


107         function numGuardians() public view returns (uint256) {
108             return guardians.length;
109         }


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/provers/Guardians.sol#L107:109

```solidity
File: contracts/L1/tiers/DevnetTierProvider.sol


20          function getTier(uint16 _tierId) public pure override returns (ITierProvider.Tier memory) {
21              if (_tierId == LibTiers.TIER_OPTIMISTIC) {
22                  return ITierProvider.Tier({
23                      verifierName: "tier_optimistic",
24                      validityBond: 250 ether, // TKO
25                      contestBond: 500 ether, // TKO
26                      cooldownWindow: 1440, //24 hours
27                      provingWindow: 120, // 2 hours
28                      maxBlocksToVerifyPerProof: 16
29                  });
30              }
31      
32              if (_tierId == LibTiers.TIER_GUARDIAN) {
33                  return ITierProvider.Tier({
34                      verifierName: "tier_guardian",
35                      validityBond: 0, // must be 0 for top tier
36                      contestBond: 0, // must be 0 for top tier
37                      cooldownWindow: 60, //1 hours
38                      provingWindow: 2880, // 48 hours
39                      maxBlocksToVerifyPerProof: 16
40                  });
41              }
42      
43              revert TIER_NOT_FOUND();
44          }


47          function getTierIds() public pure override returns (uint16[] memory tiers_) {
48              tiers_ = new uint16[](2);
49              tiers_[0] = LibTiers.TIER_OPTIMISTIC;
50              tiers_[1] = LibTiers.TIER_GUARDIAN;
51          }


54          function getMinTier(uint256) public pure override returns (uint16) {
55              return LibTiers.TIER_OPTIMISTIC;
56          }


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/tiers/DevnetTierProvider.sol#L54:56

```solidity
File: contracts/L1/tiers/MainnetTierProvider.sol


20          function getTier(uint16 _tierId) public pure override returns (ITierProvider.Tier memory) {
21              if (_tierId == LibTiers.TIER_SGX) {
22                  return ITierProvider.Tier({
23                      verifierName: "tier_sgx",
24                      validityBond: 250 ether, // TKO
25                      contestBond: 500 ether, // TKO
26                      cooldownWindow: 1440, //24 hours
27                      provingWindow: 60, // 1 hours
28                      maxBlocksToVerifyPerProof: 8
29                  });
30              }
31      
32              if (_tierId == LibTiers.TIER_SGX_ZKVM) {
33                  return ITierProvider.Tier({
34                      verifierName: "tier_sgx_zkvm",
35                      validityBond: 500 ether, // TKO
36                      contestBond: 1000 ether, // TKO
37                      cooldownWindow: 1440, //24 hours
38                      provingWindow: 240, // 4 hours
39                      maxBlocksToVerifyPerProof: 4
40                  });
41              }
42      
43              if (_tierId == LibTiers.TIER_GUARDIAN) {
44                  return ITierProvider.Tier({
45                      verifierName: "tier_guardian",
46                      validityBond: 0, // must be 0 for top tier
47                      contestBond: 0, // must be 0 for top tier
48                      cooldownWindow: 60, //1 hours
49                      provingWindow: 2880, // 48 hours
50                      maxBlocksToVerifyPerProof: 16
51                  });
52              }
53      
54              revert TIER_NOT_FOUND();
55          }


58          function getTierIds() public pure override returns (uint16[] memory tiers_) {
59              tiers_ = new uint16[](3);
60              tiers_[0] = LibTiers.TIER_SGX;
61              tiers_[1] = LibTiers.TIER_SGX_ZKVM;
62              tiers_[2] = LibTiers.TIER_GUARDIAN;
63          }


66          function getMinTier(uint256 _rand) public pure override returns (uint16) {
67              // 0.1% require SGX + ZKVM; all others require SGX
68              if (_rand % 1000 == 0) return LibTiers.TIER_SGX_ZKVM;
69              else return LibTiers.TIER_SGX;
70          }


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/tiers/MainnetTierProvider.sol#L66:70

```solidity
File: contracts/L1/tiers/TestnetTierProvider.sol


20          function getTier(uint16 _tierId) public pure override returns (ITierProvider.Tier memory) {
21              if (_tierId == LibTiers.TIER_OPTIMISTIC) {
22                  return ITierProvider.Tier({
23                      verifierName: "tier_optimistic",
24                      validityBond: 250 ether, // TKO
25                      contestBond: 500 ether, // TKO
26                      cooldownWindow: 1440, //24 hours
27                      provingWindow: 30, // 0.5 hours
28                      maxBlocksToVerifyPerProof: 12
29                  });
30              }
31      
32              if (_tierId == LibTiers.TIER_SGX) {
33                  return ITierProvider.Tier({
34                      verifierName: "tier_sgx",
35                      validityBond: 500 ether, // TKO
36                      contestBond: 1000 ether, // TKO
37                      cooldownWindow: 1440, //24 hours
38                      provingWindow: 60, // 1 hours
39                      maxBlocksToVerifyPerProof: 8
40                  });
41              }
42      
43              if (_tierId == LibTiers.TIER_GUARDIAN) {
44                  return ITierProvider.Tier({
45                      verifierName: "tier_guardian",
46                      validityBond: 0, // must be 0 for top tier
47                      contestBond: 0, // must be 0 for top tier
48                      cooldownWindow: 60, //1 hours
49                      provingWindow: 2880, // 48 hours
50                      maxBlocksToVerifyPerProof: 16
51                  });
52              }
53      
54              revert TIER_NOT_FOUND();
55          }


58          function getTierIds() public pure override returns (uint16[] memory tiers_) {
59              tiers_ = new uint16[](3);
60              tiers_[0] = LibTiers.TIER_OPTIMISTIC;
61              tiers_[1] = LibTiers.TIER_SGX;
62              tiers_[2] = LibTiers.TIER_GUARDIAN;
63          }


66          function getMinTier(uint256 _rand) public pure override returns (uint16) {
67              // 10% will be selected to require SGX proofs.
68              if (_rand % 10 == 0) return LibTiers.TIER_SGX;
69              // Other blocks are optimistic, without validity proofs.
70              return LibTiers.TIER_OPTIMISTIC;
71          }


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/tiers/TestnetTierProvider.sol#L66:71

```solidity
File: contracts/L2/TaikoL2.sol


185         function getBasefee(
186             uint64 _l1BlockId,
187             uint32 _parentGasUsed
188         )
189             public
190             view
191             returns (uint256 basefee_)
192         {
193             (basefee_,) = _calc1559BaseFee(getConfig(), _l1BlockId, _parentGasUsed);
194         }


200         function getBlockHash(uint64 _blockId) public view returns (bytes32) {
201             if (_blockId >= block.number) return 0;
202             if (_blockId + 256 >= block.number) return blockhash(_blockId);
203             return l2Hashes[_blockId];
204         }


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/TaikoL2.sol#L200:204

```solidity
File: contracts/L2/TaikoL2EIP1559Configurable.sol


43          function getConfig() public view override returns (Config memory) {
44              return customConfig;
45          }


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/TaikoL2EIP1559Configurable.sol#L43:45

```solidity
File: contracts/automata-attestation/AutomataDcapV3Attestation.sol


103         function configureTcbInfoJson(
104             string calldata fmspc,
105             TCBInfoStruct.TCBInfo calldata tcbInfoInput
106         )
107             public
108             onlyOwner
109         {
110             // 2.2M gas
111             tcbInfo[fmspc] = tcbInfoInput;
112         }


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/AutomataDcapV3Attestation.sol#L103:112

```solidity
File: contracts/automata-attestation/utils/SigVerifyLib.sol


24          function verifyAttStmtSignature(
25              bytes memory tbs,
26              bytes memory signature,
27              PublicKey memory publicKey,
28              Algorithm alg
29          )
30              public
31              view
32              returns (bool)
33          {
34              if (alg == Algorithm.RS256) {
35                  if (publicKey.keyType != KeyType.RSA) {
36                      return false;
37                  }
38                  return verifyRS256Signature(tbs, signature, publicKey.pubKey);
39              } else if (alg == Algorithm.ES256) {
40                  if (publicKey.keyType != KeyType.ECDSA) {
41                      return false;
42                  }
43                  return verifyES256Signature(tbs, signature, publicKey.pubKey);
44              } else if (alg == Algorithm.RS1) {
45                  if (publicKey.keyType != KeyType.RSA) {
46                      return false;
47                  }
48                  return verifyRS1Signature(tbs, signature, publicKey.pubKey);
49              } else {
50                  revert("Unsupported algorithm");
51              }
52          }


54          function verifyCertificateSignature(
55              bytes memory tbs,
56              bytes memory signature,
57              PublicKey memory publicKey,
58              CertSigAlgorithm alg
59          )
60              public
61              view
62              returns (bool)
63          {
64              if (alg == CertSigAlgorithm.Sha256WithRSAEncryption) {
65                  if (publicKey.keyType != KeyType.RSA) {
66                      return false;
67                  }
68                  return verifyRS256Signature(tbs, signature, publicKey.pubKey);
69              } else if (alg == CertSigAlgorithm.Sha1WithRSAEncryption) {
70                  if (publicKey.keyType != KeyType.RSA) {
71                      return false;
72                  }
73                  return verifyRS1Signature(tbs, signature, publicKey.pubKey);
74              } else {
75                  revert("Unsupported algorithm");
76              }
77          }


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/SigVerifyLib.sol#L54:77

```solidity
File: contracts/bridge/Bridge.sol


340         function isMessageSent(Message calldata _message) public view returns (bool) {
341             if (_message.srcChainId != block.chainid) return false;
342             return ISignalService(resolve("signal_service", false)).isSignalSent({
343                 _app: address(this),
344                 _signal: hashMessage(_message)
345             });
346         }


352         function proveMessageFailed(
353             Message calldata _message,
354             bytes calldata _proof
355         )
356             public
357             view
358             returns (bool)
359         {
360             if (_message.srcChainId != block.chainid) return false;
361     
362             return _proveSignalReceived(
363                 resolve("signal_service", false),
364                 signalForFailedMessage(hashMessage(_message)),
365                 _message.destChainId,
366                 _proof
367             );
368         }


374         function proveMessageReceived(
375             Message calldata _message,
376             bytes calldata _proof
377         )
378             public
379             view
380             returns (bool)
381         {
382             if (_message.destChainId != block.chainid) return false;
383             return _proveSignalReceived(
384                 resolve("signal_service", false), hashMessage(_message), _message.srcChainId, _proof
385             );
386         }


403         function context() public view returns (Context memory ctx_) {
404             ctx_ = _loadContext();
405             if (ctx_.msgHash == 0 || ctx_.msgHash == bytes32(PLACEHOLDER)) {
406                 revert B_INVALID_CONTEXT();
407             }
408         }


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/Bridge.sol#L403:408

```solidity
File: contracts/common/AddressManager.sol


54          function getAddress(uint64 _chainId, bytes32 _name) public view override returns (address) {
55              return __addresses[_chainId][_name];
56          }


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/common/AddressManager.sol#L54:56

```solidity
File: contracts/signal/SignalService.sol


137         function isChainDataSynced(
138             uint64 _chainId,
139             bytes32 _kind,
140             uint64 _blockId,
141             bytes32 _chainData
142         )
143             public
144             view
145             nonZeroValue(_chainData)
146             returns (bool)
147         {
148             bytes32 signal = signalForChainData(_chainId, _kind, _blockId);
149             return _loadSignalValue(address(this), signal) == _chainData;
150         }


153         function isSignalSent(address _app, bytes32 _signal) public view returns (bool) {
154             return _loadSignalValue(_app, _signal) != 0;
155         }


158         function getSyncedChainData(
159             uint64 _chainId,
160             bytes32 _kind,
161             uint64 _blockId
162         )
163             public
164             view
165             returns (uint64 blockId_, bytes32 chainData_)
166         {
167             blockId_ = _blockId != 0 ? _blockId : topBlockId[_chainId][_kind];
168     
169             if (blockId_ != 0) {
170                 bytes32 signal = signalForChainData(_chainId, _kind, blockId_);
171                 chainData_ = _loadSignalValue(address(this), signal);
172                 if (chainData_ == 0) revert SS_SIGNAL_NOT_FOUND();
173             }
174         }


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/signal/SignalService.sol#L158:174

```solidity
File: contracts/team/TimelockTokenPool.sol


204         function getMyGrant(address _recipient) public view returns (Grant memory) {
205             return recipients[_recipient].grant;
206         }


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/TimelockTokenPool.sol#L204:206

```solidity
File: contracts/tokenvault/BridgedERC1155.sol


66          function mint(
67              address _to,
68              uint256 _tokenId,
69              uint256 _amount
70          )
71              public
72              nonReentrant
73              whenNotPaused
74              onlyFromNamed("erc1155_vault")
75          {
76              _mint(_to, _tokenId, _amount, "");
77          }


83          function mintBatch(
84              address _to,
85              uint256[] memory _tokenIds,
86              uint256[] memory _amounts
87          )
88              public
89              nonReentrant
90              whenNotPaused
91              onlyFromNamed("erc1155_vault")
92          {
93              _mintBatch(_to, _tokenIds, _amounts, "");
94          }


100         function burn(
101             address _account,
102             uint256 _tokenId,
103             uint256 _amount
104         )
105             public
106             nonReentrant
107             whenNotPaused
108             onlyFromNamed("erc1155_vault")
109         {
110             _burn(_account, _tokenId, _amount);
111         }


115         function name() public view returns (string memory) {
116             return LibBridgedToken.buildName(__name, srcChainId);
117         }


121         function symbol() public view returns (string memory) {
122             return LibBridgedToken.buildSymbol(__symbol);
123         }


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC1155.sol#L121:123

```solidity
File: contracts/tokenvault/BridgedERC20.sol


113         function decimals()
114             public
115             view
116             override(ERC20Upgradeable, IERC20MetadataUpgradeable)
117             returns (uint8)
118         {
119             return __srcDecimals;
120         }


125         function canonical() public view returns (address, uint256) {
126             return (srcToken, srcChainId);
127         }


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC20.sol#L125:127

```solidity
File: contracts/tokenvault/BridgedERC20Base.sol


75          function burn(address _account, uint256 _amount) public nonReentrant whenNotPaused {
76              if (_isMigratingOut()) {
77                  // Only the owner of the tokens himself can migrate out
78                  if (msg.sender != _account) revert BB_PERMISSION_DENIED();
79                  // Outbound migration
80                  emit MigratedTo(migratingAddress, _account, _amount);
81                  // Ask the new bridged token to mint token for the user.
82                  IBridgedERC20(migratingAddress).mint(_account, _amount);
83              } else if (msg.sender != resolve("erc20_vault", true)) {
84                  // Only the vault can burn tokens when not migrating out
85                  revert RESOLVER_DENIED();
86              }
87      
88              _burnToken(_account, _amount);
89          }


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC20Base.sol#L75:89

```solidity
File: contracts/tokenvault/BridgedERC721.sol


54          function mint(
55              address _account,
56              uint256 _tokenId
57          )
58              public
59              nonReentrant
60              whenNotPaused
61              onlyFromNamed("erc721_vault")
62          {
63              _safeMint(_account, _tokenId);
64          }


69          function burn(
70              address _account,
71              uint256 _tokenId
72          )
73              public
74              nonReentrant
75              whenNotPaused
76              onlyFromNamed("erc721_vault")
77          {
78              // Check if the caller is the owner of the token.
79              if (ownerOf(_tokenId) != _account) {
80                  revert BTOKEN_INVALID_BURN();
81              }
82              _burn(_tokenId);
83          }


100         function source() public view returns (address, uint256) {
101             return (srcToken, srcChainId);
102         }


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC721.sol#L100:102

</details>

## NC013 - Multiple `address`/ID mappings can be combined into a single `mapping` of an `address`/ID to a `struct`, for readability:

Well-organized data structures make code reviews easier, which may lead to fewer bugs. Consider combining related mappings into mappings to structs, so it's clear what data is related


```solidity
File: contracts/L1/TaikoData.sol


181             mapping(uint64 blockId_mod_blockRingBufferSize => Block blk) blocks;
182             // Indexing to transition ids (ring buffer not possible)
183             mapping(uint64 blockId => mapping(bytes32 parentHash => uint32 transitionId)) transitionIds;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/TaikoData.sol#L181:183

```solidity
File: contracts/bridge/Bridge.sol


35          mapping(bytes32 msgHash => Status status) public messageStatus;
36      
37          /// @dev Slots 3, 4, and 5.
38          Context private __ctx;
39      
40          /// @notice Mapping to store banned addresses.
41          /// @dev Slot 6.
42          mapping(address addr => bool banned) public addressBanned;
43      
44          /// @notice Mapping to store the proof receipt of a message from its hash.
45          /// @dev Slot 7.
46          mapping(bytes32 msgHash => ProofReceipt receipt) public proofReceipt;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/Bridge.sol#L35:46

```solidity
File: contracts/team/airdrop/ERC20Airdrop2.sol


22          mapping(address addr => uint256 amountClaimed) public claimedAmount;
23      
24          /// @notice Represents the already withdrawn amount.
25          mapping(address addr => uint256 amountWithdrawn) public withdrawnAmount;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/airdrop/ERC20Airdrop2.sol#L22:25

## NC014 - Duplicated `require()`/`revert()` checks should be refactored to a modifier or function:

The compiler will inline the function, which will avoid JUMP instructions usually associated with functions.


```solidity
File: contracts/automata-attestation/utils/Asn1Decode.sol


142             require(der[ptr.ixs()] == 0x02, "Not type INTEGER");


143             require(der[ptr.ixf()] & 0x80 == 0, "Not positive");


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/Asn1Decode.sol#L143:143

```solidity
File: contracts/automata-attestation/utils/SigVerifyLib.sol


50                  revert("Unsupported algorithm");


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/SigVerifyLib.sol#L50:50

## NC015 - Variables need not be initialized to zero:

The default value for variables is zero, so initializing them to zero is superfluous.


<details>
<summary>Click to show 7 findings</summary>

```solidity
File: contracts/L1/provers/Guardians.sol


80              for (uint256 i = 0; i < _newGuardians.length; ++i) {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/provers/Guardians.sol#L80:80

```solidity
File: contracts/automata-attestation/lib/QuoteV3Auth/V3Parser.sol


18          bytes4 internal constant SUPPORTED_TEE_TYPE = 0;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/QuoteV3Auth/V3Parser.sol#L18:18

```solidity
File: contracts/automata-attestation/utils/BytesUtils.sol


80              for (uint256 idx = 0; idx < shortest; idx += 32) {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/BytesUtils.sol#L80:80

```solidity
File: contracts/thirdparty/optimism/rlp/RLPWriter.sol


66              for (uint256 j = 0; j < out_.length; j++) {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/rlp/RLPWriter.sol#L66:66

```solidity
File: contracts/thirdparty/optimism/trie/MerkleTrie.sol


85              for (uint256 i = 0; i < proof.length; i++) {


208             for (uint256 i = 0; i < length;) {


30          uint8 internal constant PREFIX_EXTENSION_EVEN = 0;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/trie/MerkleTrie.sol#L30:30

</details>

## NC016 - Variable names that consist of all capital letters should be reserved for constant/immutable variables:

If the variable needs to be different based on which class it comes from, a view/pure function should be used instead.


```solidity
File: contracts/automata-attestation/utils/SigVerifyLib.sol


18          address private ES256VERIFIER;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/SigVerifyLib.sol#L18:18

## NC017 - Consider using delete rather than assigning false/zero to clear values:

The `delete` keyword more closely matches the semantics of what is being done, and draws more attention to the changing of state, which may lead to a more thorough audit of its associated logic.


<details>
<summary>Click to show 9 findings</summary>

```solidity
File: contracts/L1/libs/LibProposing.sol


190                 meta_.txListByteOffset = 0;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProposing.sol#L190:190

```solidity
File: contracts/L1/libs/LibProving.sol


197                     blk.livenessBond = 0;


300                 ts_.blockHash = 0;


301                 ts_.stateRoot = 0;


302                 ts_.validityBond = 0;


306                 ts_.tier = 0;


307                 ts_.contestations = 0;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProving.sol#L307:307

```solidity
File: contracts/team/TimelockTokenPool.sol


231             _grant.grantStart = 0;


232             _grant.grantPeriod = 0;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/TimelockTokenPool.sol#L232:232

</details>

## NC018 - Variable names for `immutable`s should use CONSTANT_CASE:

For `immutable` variable names, each word should use all capital letters, with underscores separating each word (CONSTANT_CASE).


```solidity
File: contracts/automata-attestation/AutomataDcapV3Attestation.sol


25          ISigVerifyLib public immutable sigVerifyLib;


26          IPEMCertChainLib public immutable pemCertLib;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/AutomataDcapV3Attestation.sol#L26:26

## NC019 - Lines are too long:

Usually lines in source code are limited to 80 characters. Today's screens are much larger so it's reasonable to stretch this in some cases. The solidity style guide recommends a maximumum line length of 120 characters, so the lines below should be split when they reach that length.


<details>
<summary>Click to show 6 findings</summary>

```solidity
File: contracts/automata-attestation/AutomataDcapV3Attestation.sol


// https://github.com/intel/SGXDataCenterAttestationPrimitives/blob/e7604e02331b3377f3766ed3653250e03af72d45/QuoteVerification/QVL/Src/AttestationLibrary/src/CertVerification/X509Constants.h#L64

// keccak256(hex"0ba9c4c0c0c86193a3fe23d6b02cda10a8bbd4e88e48b4458561a36e705525f567918e2edc88e40d860bd0cc4ee26aacc988e505a953558c453f6b0904ae7394")

```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/AutomataDcapV3Attestation.sol#L31:31

```solidity
File: contracts/automata-attestation/lib/PEMCertChainLib.sol


// https://github.com/intel/SGXDataCenterAttestationPrimitives/blob/e7604e02331b3377f3766ed3653250e03af72d45/QuoteVerification/QVL/Src/AttestationLibrary/src/CertVerification/X509Constants.h#L64

```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/PEMCertChainLib.sol#L31:31

```solidity
File: contracts/automata-attestation/utils/BytesUtils.sol


hex"00010203040506070809FFFFFFFFFFFFFF0A0B0C0D0E0F101112131415161718191A1B1C1D1E1FFFFFFFFFFFFFFFFFFFFF0A0B0C0D0E0F101112131415161718191A1B1C1D1E1F";

```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/BytesUtils.sol#L311:311

```solidity
File: contracts/automata-attestation/utils/RsaVerify.sol


https://csrc.nist.gov/CSRC/media/Projects/Cryptographic-Algorithm-Validation-Program/documents/dss/186-2rsatestvectors.zip

```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/RsaVerify.sol#L27:27

```solidity
File: contracts/thirdparty/optimism/rlp/RLPReader.sol


// https://github.com/ethereum/solidity/blob/34dd30d71b4da730488be72ff6af7083cf2a91f6/libsolidity/codegen/YulUtilFunctions.cpp#L102-L114

```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/rlp/RLPReader.sol#L293:293

</details>

## NC020 - File is missing NatSpec comments:

The file does not contain any of the NatSpec comments (@inheritdoc, @param, @return, @notice), which are important for documentation and user confirmation.


<details>
<summary>Click to show 13 findings</summary>

```solidity
File: contracts/automata-attestation/AutomataDcapV3Attestation.sol


//SPDX-License-Identifier: MIT
pragma solidity 0.8.24;

import { V3Struct } from "./lib/QuoteV3Auth/V3Struct.sol";
import { V3Parser } from "./lib/QuoteV3Auth/V3Parser.sol";
import { IPEMCertChainLib } from "./lib/interfaces/IPEMCertChainLib.sol";
import { PEMCertChainLib } from "./lib/PEMCertChainLib.sol";
import { TCBInfoStruct } from "./lib/TCBInfoStruct.sol";
import { EnclaveIdStruct } from "./lib/EnclaveIdStruct.sol";
import { IAttestation } from "./interfaces/IAttestation.sol";

// Internal Libraries
import { Base64 } from "solady/src/utils/Base64.sol";
import { LibString } from "solady/src/utils/LibString.sol";
import { BytesUtils } from "./utils/BytesUtils.sol";

// External Libraries
import { ISigVerifyLib } from "./interfaces/ISigVerifyLib.sol";

/// @title AutomataDcapV3Attestation
/// @custom:security-contact security@taiko.xyz
contract AutomataDcapV3Attestation is IAttestation {
    using BytesUtils for bytes;

    ISigVerifyLib public immutable sigVerifyLib;
    IPEMCertChainLib public immutable pemCertLib;

    // https://github.com/intel/SGXDataCenterAttestationPrimitives/blob/e7604e02331b3377f3766ed3653250e03af72d45/QuoteVerification/QVL/Src/AttestationLibrary/src/CertVerification/X509Constants.h#L64
    uint256 internal constant CPUSVN_LENGTH = 16;

    // keccak256(hex"0ba9c4c0c0c86193a3fe23d6b02cda10a8bbd4e88e48b4458561a36e705525f567918e2edc88e40d860bd0cc4ee26aacc988e505a953558c453f6b0904ae7394")
    // the uncompressed (0x04) prefix is not included in the pubkey pre-image
    bytes32 internal constant ROOTCA_PUBKEY_HASH =
        0x89f72d7c488e5b53a77c23ebcb36970ef7eb5bcf6658e9b8292cfbe4703a8473;

    uint8 internal constant INVALID_EXIT_CODE = 255;

    bool private _checkLocalEnclaveReport;
    mapping(bytes32 enclave => bool trusted) private _trustedUserMrEnclave;
    mapping(bytes32 signer => bool trusted) private _trustedUserMrSigner;

    // Quote Collateral Configuration

    // Index definition:
    // 0 = Quote PCKCrl
    // 1 = RootCrl
    mapping(uint256 idx => mapping(bytes serialNum => bool revoked)) private _serialNumIsRevoked;
    // fmspc => tcbInfo
    mapping(string fmspc => TCBInfoStruct.TCBInfo tcbInfo) public tcbInfo;
    EnclaveIdStruct.EnclaveId public qeIdentity;

    address public owner;

    constructor(address sigVerifyLibAddr, address pemCertLibAddr) {
        sigVerifyLib = ISigVerifyLib(sigVerifyLibAddr);
        pemCertLib = PEMCertChainLib(pemCertLibAddr);
        owner = msg.sender;
    }

    modifier onlyOwner() {
        require(msg.sender == owner, "onlyOwner");
        _;
    }

    function setMrSigner(bytes32 _mrSigner, bool _trusted) external onlyOwner {
        _trustedUserMrSigner[_mrSigner] = _trusted;
    }

    function setMrEnclave(bytes32 _mrEnclave, bool _trusted) external onlyOwner {
        _trustedUserMrEnclave[_mrEnclave] = _trusted;
    }

    function addRevokedCertSerialNum(
        uint256 index,
        bytes[] calldata serialNumBatch
    )
        external
        onlyOwner
    {
        for (uint256 i; i < serialNumBatch.length; ++i) {
            if (_serialNumIsRevoked[index][serialNumBatch[i]]) {
                continue;
            }
            _serialNumIsRevoked[index][serialNumBatch[i]] = true;
        }
    }

    function removeRevokedCertSerialNum(
        uint256 index,
        bytes[] calldata serialNumBatch
    )
        external
        onlyOwner
    {
        for (uint256 i; i < serialNumBatch.length; ++i) {
            if (!_serialNumIsRevoked[index][serialNumBatch[i]]) {
                continue;
            }
            delete _serialNumIsRevoked[index][serialNumBatch[i]];
        }
    }

    function configureTcbInfoJson(
        string calldata fmspc,
        TCBInfoStruct.TCBInfo calldata tcbInfoInput
    )
        public
        onlyOwner
    {
        // 2.2M gas
        tcbInfo[fmspc] = tcbInfoInput;
    }

    function configureQeIdentityJson(EnclaveIdStruct.EnclaveId calldata qeIdentityInput)
        external
        onlyOwner
    {
        // 250k gas
        qeIdentity = qeIdentityInput;
    }

    function toggleLocalReportCheck() external onlyOwner {
        _checkLocalEnclaveReport = !_checkLocalEnclaveReport;
    }

    function _attestationTcbIsValid(TCBInfoStruct.TCBStatus status)
        internal
        pure
        virtual
        returns (bool valid)
    {
        return status == TCBInfoStruct.TCBStatus.OK
            || status == TCBInfoStruct.TCBStatus.TCB_SW_HARDENING_NEEDED
            || status == TCBInfoStruct.TCBStatus.TCB_CONFIGURATION_AND_SW_HARDENING_NEEDED
            || status == TCBInfoStruct.TCBStatus.TCB_OUT_OF_DATE_CONFIGURATION_NEEDED;
    }

    function verifyAttestation(bytes calldata data) external view override returns (bool) {
        (bool success,) = _verify(data);
        return success;
    }

    /// @dev Provide the raw quote binary as input
    /// @dev The attestation data (or the returned data of this method)
    /// is constructed depending on the validity of the quote verification.
    /// @dev After confirming that a quote has been verified, the attestation's validity then
    /// depends on the
    /// status of the associated TCB.
    /// @dev Example scenarios as below:
    /// --------------------------------
    /// @dev Invalid quote verification: returns (false, INVALID_EXIT_CODE)
    ///
    /// @dev For all valid quote verification, the validity of the attestation depends on the status
    /// of a
    /// matching TCBInfo and this is defined in the _attestationTcbIsValid() method, which can be
    /// overwritten
    /// in derived contracts. (Except for "Revoked" status, which also returns (false,
    /// INVALID_EXIT_CODE) value)
    /// @dev For all valid quote verification, returns the following data:
    /// (_attestationTcbIsValid(), abi.encodePacked(sha256(quote), uint8 exitCode))
    /// @dev exitCode is defined in the {{ TCBInfoStruct.TCBStatus }} enum
    function _verify(bytes calldata quote) private view returns (bool, bytes memory) {
        bytes memory retData = abi.encodePacked(INVALID_EXIT_CODE);

        // Step 1: Parse the quote input = 152k gas
        (bool successful, V3Struct.ParsedV3QuoteStruct memory parsedV3Quote) =
            V3Parser.parseInput(quote, address(pemCertLib));
        if (!successful) {
            return (false, retData);
        }

        return _verifyParsedQuote(parsedV3Quote);
    }

    function _verifyQEReportWithIdentity(V3Struct.EnclaveReport memory quoteEnclaveReport)
        private
        view
        returns (bool, EnclaveIdStruct.EnclaveIdStatus status)
    {
        EnclaveIdStruct.EnclaveId memory enclaveId = qeIdentity;
        bool miscselectMatched =
            quoteEnclaveReport.miscSelect & enclaveId.miscselectMask == enclaveId.miscselect;

        bool attributesMatched =
            quoteEnclaveReport.attributes & enclaveId.attributesMask == enclaveId.attributes;
        bool mrsignerMatched = quoteEnclaveReport.mrSigner == enclaveId.mrsigner;

        bool isvprodidMatched = quoteEnclaveReport.isvProdId == enclaveId.isvprodid;

        bool tcbFound;
        for (uint256 i; i < enclaveId.tcbLevels.length; ++i) {
            EnclaveIdStruct.TcbLevel memory tcb = enclaveId.tcbLevels[i];
            if (tcb.tcb.isvsvn <= quoteEnclaveReport.isvSvn) {
                tcbFound = true;
                status = tcb.tcbStatus;
                break;
            }
        }
        return (
            miscselectMatched && attributesMatched && mrsignerMatched && isvprodidMatched
                && tcbFound,
            status
        );
    }

    function _checkTcbLevels(
        IPEMCertChainLib.PCKCertificateField memory pck,
        TCBInfoStruct.TCBInfo memory tcb
    )
        private
        pure
        returns (bool, TCBInfoStruct.TCBStatus status)
    {
        for (uint256 i; i < tcb.tcbLevels.length; ++i) {
            TCBInfoStruct.TCBLevelObj memory current = tcb.tcbLevels[i];
            bool pceSvnIsHigherOrGreater = pck.sgxExtension.pcesvn >= current.pcesvn;
            bool cpuSvnsAreHigherOrGreater = _isCpuSvnHigherOrGreater(
                pck.sgxExtension.sgxTcbCompSvnArr, current.sgxTcbCompSvnArr
            );
            if (pceSvnIsHigherOrGreater && cpuSvnsAreHigherOrGreater) {
                status = current.status;
                bool tcbIsRevoked = status == TCBInfoStruct.TCBStatus.TCB_REVOKED;
                return (!tcbIsRevoked, status);
            }
        }
        return (true, TCBInfoStruct.TCBStatus.TCB_UNRECOGNIZED);
    }

    function _isCpuSvnHigherOrGreater(
        uint256[] memory pckCpuSvns,
        uint8[] memory tcbCpuSvns
    )
        private
        pure
        returns (bool)
    {
        if (pckCpuSvns.length != CPUSVN_LENGTH || tcbCpuSvns.length != CPUSVN_LENGTH) {
            return false;
        }
        for (uint256 i; i < CPUSVN_LENGTH; ++i) {
            if (pckCpuSvns[i] < tcbCpuSvns[i]) {
                return false;
            }
        }
        return true;
    }

    function _verifyCertChain(IPEMCertChainLib.ECSha256Certificate[] memory certs)
        private
        view
        returns (bool)
    {
        uint256 n = certs.length;
        bool certRevoked;
        bool certNotExpired;
        bool verified;
        bool certChainCanBeTrusted;

        for (uint256 i; i < n; ++i) {
            IPEMCertChainLib.ECSha256Certificate memory issuer;
            if (i == n - 1) {
                // rootCA
                issuer = certs[i];
            } else {
                issuer = certs[i + 1];
                if (i == n - 2) {
                    // this cert is expected to be signed by the root
                    certRevoked = _serialNumIsRevoked[uint256(IPEMCertChainLib.CRL.ROOT)][certs[i]
                        .serialNumber];
                } else if (certs[i].isPck) {
                    certRevoked = _serialNumIsRevoked[uint256(IPEMCertChainLib.CRL.PCK)][certs[i]
                        .serialNumber];
                }
                if (certRevoked) {
                    break;
                }
            }

            certNotExpired =
                block.timestamp > certs[i].notBefore && block.timestamp < certs[i].notAfter;
            if (!certNotExpired) {
                break;
            }

            verified = sigVerifyLib.verifyES256Signature(
                certs[i].tbsCertificate, certs[i].signature, issuer.pubKey
            );
            if (!verified) {
                break;
            }

            bytes32 issuerPubKeyHash = keccak256(issuer.pubKey);

            if (issuerPubKeyHash == ROOTCA_PUBKEY_HASH) {
                certChainCanBeTrusted = true;
                break;
            }
        }

        return !certRevoked && certNotExpired && verified && certChainCanBeTrusted;
    }

    function _enclaveReportSigVerification(
        bytes memory pckCertPubKey,
        bytes memory signedQuoteData,
        V3Struct.ECDSAQuoteV3AuthData memory authDataV3,
        V3Struct.EnclaveReport memory qeEnclaveReport
    )
        private
        view
        returns (bool)
    {
        bytes32 expectedAuthDataHash = bytes32(qeEnclaveReport.reportData.substring(0, 32));
        bytes memory concatOfAttestKeyAndQeAuthData =
            abi.encodePacked(authDataV3.ecdsaAttestationKey, authDataV3.qeAuthData.data);
        bytes32 computedAuthDataHash = sha256(concatOfAttestKeyAndQeAuthData);

        bool qeReportDataIsValid = expectedAuthDataHash == computedAuthDataHash;
        if (qeReportDataIsValid) {
            bytes memory pckSignedQeReportBytes =
                V3Parser.packQEReport(authDataV3.pckSignedQeReport);
            bool qeSigVerified = sigVerifyLib.verifyES256Signature(
                pckSignedQeReportBytes, authDataV3.qeReportSignature, pckCertPubKey
            );
            bool quoteSigVerified = sigVerifyLib.verifyES256Signature(
                signedQuoteData, authDataV3.ecdsa256BitSignature, authDataV3.ecdsaAttestationKey
            );
            return qeSigVerified && quoteSigVerified;
        } else {
            return false;
        }
    }

    /// --------------- validate parsed quote ---------------

    /// @dev Provide the parsed quote binary as input
    /// @dev The attestation data (or the returned data of this method)
    /// is constructed depending on the validity of the quote verification.
    /// @dev After confirming that a quote has been verified, the attestation's validity then
    /// depends on the
    /// status of the associated TCB.
    /// @dev Example scenarios as below:
    /// --------------------------------
    /// @dev Invalid quote verification: returns (false, INVALID_EXIT_CODE)
    ///
    /// @dev For all valid quote verification, the validity of the attestation depends on the status
    /// of a
    /// matching TCBInfo and this is defined in the _attestationTcbIsValid() method, which can be
    /// overwritten
    /// in derived contracts. (Except for "Revoked" status, which also returns (false,
    /// INVALID_EXIT_CODE) value)
    /// @dev For all valid quote verification, returns the following data:
    /// (_attestationTcbIsValid())
    /// @dev exitCode is defined in the {{ TCBInfoStruct.TCBStatus }} enum
    function verifyParsedQuote(V3Struct.ParsedV3QuoteStruct calldata v3quote)
        external
        view
        override
        returns (bool, bytes memory)
    {
        return _verifyParsedQuote(v3quote);
    }

    function _verifyParsedQuote(V3Struct.ParsedV3QuoteStruct memory v3quote)
        internal
        view
        returns (bool, bytes memory)
    {
        bytes memory retData = abi.encodePacked(INVALID_EXIT_CODE);

        // // Step 1: Parse the quote input = 152k gas
        (
            bool successful,
            ,
            ,
            bytes memory signedQuoteData,
            V3Struct.ECDSAQuoteV3AuthData memory authDataV3
        ) = V3Parser.validateParsedInput(v3quote);
        if (!successful) {
            return (false, retData);
        }

        // Step 2: Verify application enclave report MRENCLAVE and MRSIGNER
        {
            if (_checkLocalEnclaveReport) {
                // 4k gas
                bool mrEnclaveIsTrusted =
                    _trustedUserMrEnclave[v3quote.localEnclaveReport.mrEnclave];
                bool mrSignerIsTrusted = _trustedUserMrSigner[v3quote.localEnclaveReport.mrSigner];

                if (!mrEnclaveIsTrusted || !mrSignerIsTrusted) {
                    return (false, retData);
                }
            }
        }

        // Step 3: Verify enclave identity = 43k gas
        EnclaveIdStruct.EnclaveIdStatus qeTcbStatus;
        {
            bool verifiedEnclaveIdSuccessfully;
            (verifiedEnclaveIdSuccessfully, qeTcbStatus) =
                _verifyQEReportWithIdentity(v3quote.v3AuthData.pckSignedQeReport);
            if (!verifiedEnclaveIdSuccessfully) {
                return (false, retData);
            }
            if (
                !verifiedEnclaveIdSuccessfully
                    || qeTcbStatus == EnclaveIdStruct.EnclaveIdStatus.SGX_ENCLAVE_REPORT_ISVSVN_REVOKED
            ) {
                return (false, retData);
            }
        }

        // Step 4: Parse Quote CertChain
        IPEMCertChainLib.ECSha256Certificate[] memory parsedQuoteCerts;
        TCBInfoStruct.TCBInfo memory fetchedTcbInfo;
        {
            // 536k gas
            parsedQuoteCerts = new IPEMCertChainLib.ECSha256Certificate[](3);
            for (uint256 i; i < 3; ++i) {
                bool isPckCert = i == 0; // additional parsing for PCKCert
                bool certDecodedSuccessfully;
                // todo! move decodeCert offchain
                (certDecodedSuccessfully, parsedQuoteCerts[i]) = pemCertLib.decodeCert(
                    authDataV3.certification.decodedCertDataArray[i], isPckCert
                );
                if (!certDecodedSuccessfully) {
                    return (false, retData);
                }
            }
        }

        // Step 5: basic PCK and TCB check = 381k gas
        {
            string memory parsedFmspc = parsedQuoteCerts[0].pck.sgxExtension.fmspc;
            fetchedTcbInfo = tcbInfo[parsedFmspc];
            bool tcbConfigured = LibString.eq(parsedFmspc, fetchedTcbInfo.fmspc);
            if (!tcbConfigured) {
                return (false, retData);
            }

            IPEMCertChainLib.ECSha256Certificate memory pckCert = parsedQuoteCerts[0];
            bool pceidMatched = LibString.eq(pckCert.pck.sgxExtension.pceid, fetchedTcbInfo.pceid);
            if (!pceidMatched) {
                return (false, retData);
            }
        }

        // Step 6: Verify TCB Level
        TCBInfoStruct.TCBStatus tcbStatus;
        {
            // 4k gas
            bool tcbVerified;
            (tcbVerified, tcbStatus) = _checkTcbLevels(parsedQuoteCerts[0].pck, fetchedTcbInfo);
            if (!tcbVerified) {
                return (false, retData);
            }
        }

        // Step 7: Verify cert chain for PCK
        {
            // 660k gas (rootCA pubkey is trusted)
            bool pckCertChainVerified = _verifyCertChain(parsedQuoteCerts);
            if (!pckCertChainVerified) {
                return (false, retData);
            }
        }

        // Step 8: Verify the local attestation sig and qe report sig = 670k gas
        {
            bool enclaveReportSigsVerified = _enclaveReportSigVerification(
                parsedQuoteCerts[0].pubKey,
                signedQuoteData,
                authDataV3,
                v3quote.v3AuthData.pckSignedQeReport
            );
            if (!enclaveReportSigsVerified) {
                return (false, retData);
            }
        }

        retData = abi.encodePacked(sha256(abi.encode(v3quote)), tcbStatus);

        return (_attestationTcbIsValid(tcbStatus), retData);
    }
}


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/AutomataDcapV3Attestation.sol#L1:1

```solidity
File: contracts/automata-attestation/interfaces/IAttestation.sol


//SPDX-License-Identifier: MIT
pragma solidity 0.8.24;

import { V3Struct } from "../lib/QuoteV3Auth/V3Struct.sol";

/// @title IAttestation
/// @custom:security-contact security@taiko.xyz
interface IAttestation {
    function verifyAttestation(bytes calldata data) external returns (bool);
    function verifyParsedQuote(V3Struct.ParsedV3QuoteStruct calldata v3quote)
        external
        returns (bool success, bytes memory retData);
}


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/interfaces/IAttestation.sol#L1:1

```solidity
File: contracts/automata-attestation/interfaces/ISigVerifyLib.sol


//SPDX-License-Identifier: MIT
pragma solidity 0.8.24;

/// @title ISigVerifyLib
/// @custom:security-contact security@taiko.xyz
interface ISigVerifyLib {
    enum KeyType {
        RSA,
        ECDSA
    }

    struct PublicKey {
        KeyType keyType;
        // If RSA, pubKey = abi.encodePacked(exponent, modulus)
        // If ECDSA, pubKey = abi.encodePacked(gx, gy)
        bytes pubKey;
    }

    enum CertSigAlgorithm {
        Sha256WithRSAEncryption,
        Sha1WithRSAEncryption
    }

    struct Certificate {
        // Asn.1 DER encoding of the to-be-signed certificate
        bytes tbsCertificate;
        PublicKey publicKey;
        bytes signature;
        CertSigAlgorithm sigAlg;
    }

    enum Algorithm {
        RS256,
        ES256,
        RS1
    }

    function verifyAttStmtSignature(
        bytes memory tbs,
        bytes memory signature,
        PublicKey memory publicKey,
        Algorithm alg
    )
        external
        view
        returns (bool);

    function verifyCertificateSignature(
        bytes memory tbs,
        bytes memory signature,
        PublicKey memory publicKey,
        CertSigAlgorithm alg
    )
        external
        view
        returns (bool);

    function verifyRS256Signature(
        bytes memory tbs,
        bytes memory signature,
        bytes memory publicKey
    )
        external
        view
        returns (bool sigValid);

    function verifyRS1Signature(
        bytes memory tbs,
        bytes memory signature,
        bytes memory publicKey
    )
        external
        view
        returns (bool sigValid);

    function verifyES256Signature(
        bytes memory tbs,
        bytes memory signature,
        bytes memory publicKey
    )
        external
        view
        returns (bool sigValid);
}


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/interfaces/ISigVerifyLib.sol#L1:1

```solidity
File: contracts/automata-attestation/lib/EnclaveIdStruct.sol


//SPDX-License-Identifier: MIT
pragma solidity 0.8.24;

/// @title EnclaveIdStruct
/// @custom:security-contact security@taiko.xyz
library EnclaveIdStruct {
    struct EnclaveId {
        bytes4 miscselect;
        bytes4 miscselectMask;
        uint16 isvprodid;
        bytes16 attributes;
        bytes16 attributesMask;
        bytes32 mrsigner;
        TcbLevel[] tcbLevels;
    }

    struct TcbLevel {
        TcbObj tcb;
        EnclaveIdStatus tcbStatus;
    }

    struct TcbObj {
        uint16 isvsvn;
    }

    enum EnclaveIdStatus {
        OK,
        SGX_ENCLAVE_REPORT_ISVSVN_REVOKED
    }
}


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/EnclaveIdStruct.sol#L1:1

```solidity
File: contracts/automata-attestation/lib/PEMCertChainLib.sol


// SPDX-License-Identifier: MIT
pragma solidity 0.8.24;

import { LibString } from "solady/src/utils/LibString.sol";
import { Asn1Decode, NodePtr } from "../utils/Asn1Decode.sol";
import { BytesUtils } from "../utils/BytesUtils.sol";
import { X509DateUtils } from "../utils/X509DateUtils.sol";
import { IPEMCertChainLib } from "./interfaces/IPEMCertChainLib.sol";

/// @title PEMCertChainLib
/// @custom:security-contact security@taiko.xyz
contract PEMCertChainLib is IPEMCertChainLib {
    using Asn1Decode for bytes;
    using NodePtr for uint256;
    using BytesUtils for bytes;

    string internal constant HEADER = "-----BEGIN CERTIFICATE-----";
    string internal constant FOOTER = "-----END CERTIFICATE-----";
    uint256 internal constant HEADER_LENGTH = 27;
    uint256 internal constant FOOTER_LENGTH = 25;

    string internal constant PCK_COMMON_NAME = "Intel SGX PCK Certificate";
    string internal constant PLATFORM_ISSUER_NAME = "Intel SGX PCK Platform CA";
    string internal constant PROCESSOR_ISSUER_NAME = "Intel SGX PCK Processor CA";
    bytes internal constant SGX_EXTENSION_OID = hex"2A864886F84D010D01";
    bytes internal constant TCB_OID = hex"2A864886F84D010D0102";
    bytes internal constant PCESVN_OID = hex"2A864886F84D010D010211";
    bytes internal constant PCEID_OID = hex"2A864886F84D010D0103";
    bytes internal constant FMSPC_OID = hex"2A864886F84D010D0104";

    // https://github.com/intel/SGXDataCenterAttestationPrimitives/blob/e7604e02331b3377f3766ed3653250e03af72d45/QuoteVerification/QVL/Src/AttestationLibrary/src/CertVerification/X509Constants.h#L64
    uint256 constant SGX_TCB_CPUSVN_SIZE = 16;

    struct PCKTCBFlags {
        bool fmspcFound;
        bool pceidFound;
        bool tcbFound;
    }

    function splitCertificateChain(
        bytes memory pemChain,
        uint256 size
    )
        external
        pure
        returns (bool success, bytes[] memory certs)
    {
        certs = new bytes[](size);
        string memory pemChainStr = string(pemChain);

        uint256 index = 0;
        uint256 len = pemChain.length;

        for (uint256 i; i < size; ++i) {
            string memory input;
            if (i > 0) {
                input = LibString.slice(pemChainStr, index, index + len);
            } else {
                input = pemChainStr;
            }
            uint256 increment;
            (success, certs[i], increment) = _removeHeadersAndFooters(input);

            if (!success) {
                return (false, certs);
            }

            index += increment;
        }

        success = true;
    }

    function decodeCert(
        bytes memory der,
        bool isPckCert
    )
        external
        pure
        returns (bool success, ECSha256Certificate memory cert)
    {
        uint256 root = der.root();

        // Entering tbsCertificate sequence
        uint256 tbsParentPtr = der.firstChildOf(root);

        // Begin iterating through the descendants of tbsCertificate
        uint256 tbsPtr = der.firstChildOf(tbsParentPtr);

        // The Serial Number is located one element below Version

        // The issuer commonName value is contained in the Issuer sequence
        // which is 3 elements below the first element of the tbsCertificate sequence

        // The Validity sequence is located 4 elements below the first element of the tbsCertificate
        // sequence

        // The subject commanName value is contained in the Subject sequence
        // which is 5 elements below the first element of the tbsCertificate sequence

        // The PublicKey is located in the second element of subjectPublicKeyInfo sequence
        // which is 6 elements below the first element of the tbsCertificate sequence

        tbsPtr = der.nextSiblingOf(tbsPtr);

        {
            bytes memory serialNumBytes = der.bytesAt(tbsPtr);
            cert.serialNumber = serialNumBytes;
        }

        tbsPtr = der.nextSiblingOf(tbsPtr);
        tbsPtr = der.nextSiblingOf(tbsPtr);

        if (isPckCert) {
            uint256 issuerPtr = der.firstChildOf(tbsPtr);
            issuerPtr = der.firstChildOf(issuerPtr);
            issuerPtr = der.firstChildOf(issuerPtr);
            issuerPtr = der.nextSiblingOf(issuerPtr);
            cert.pck.issuerName = string(der.bytesAt(issuerPtr));
            bool issuerNameIsValid = LibString.eq(cert.pck.issuerName, PLATFORM_ISSUER_NAME)
                || LibString.eq(cert.pck.issuerName, PROCESSOR_ISSUER_NAME);
            if (!issuerNameIsValid) {
                return (false, cert);
            }
        }

        tbsPtr = der.nextSiblingOf(tbsPtr);

        {
            uint256 notBeforePtr = der.firstChildOf(tbsPtr);
            uint256 notAfterPtr = der.nextSiblingOf(notBeforePtr);
            bytes1 notBeforeTag = der[notBeforePtr.ixs()];
            bytes1 notAfterTag = der[notAfterPtr.ixs()];
            if (
                (notBeforeTag != 0x17 && notBeforeTag == 0x18)
                    || (notAfterTag != 0x17 && notAfterTag != 0x18)
            ) {
                return (false, cert);
            }
            cert.notBefore = X509DateUtils.toTimestamp(der.bytesAt(notBeforePtr));
            cert.notAfter = X509DateUtils.toTimestamp(der.bytesAt(notAfterPtr));
        }

        tbsPtr = der.nextSiblingOf(tbsPtr);

        if (isPckCert) {
            uint256 subjectPtr = der.firstChildOf(tbsPtr);
            subjectPtr = der.firstChildOf(subjectPtr);
            subjectPtr = der.firstChildOf(subjectPtr);
            subjectPtr = der.nextSiblingOf(subjectPtr);
            cert.pck.commonName = string(der.bytesAt(subjectPtr));
            if (!LibString.eq(cert.pck.commonName, PCK_COMMON_NAME)) {
                return (false, cert);
            }
        }

        tbsPtr = der.nextSiblingOf(tbsPtr);

        {
            // Entering subjectPublicKeyInfo sequence
            uint256 subjectPublicKeyInfoPtr = der.firstChildOf(tbsPtr);
            subjectPublicKeyInfoPtr = der.nextSiblingOf(subjectPublicKeyInfoPtr);

            // The Signature sequence is located two sibling elements below the tbsCertificate
            // element
            uint256 sigPtr = der.nextSiblingOf(tbsParentPtr);
            sigPtr = der.nextSiblingOf(sigPtr);

            // Skip three bytes to the right
            // the three bytes in question: 0x034700 or 0x034800 or 0x034900
            sigPtr = NodePtr.getPtr(sigPtr.ixs() + 3, sigPtr.ixf() + 3, sigPtr.ixl());

            sigPtr = der.firstChildOf(sigPtr);
            bytes memory sigX = _trimBytes(der.bytesAt(sigPtr), 32);

            sigPtr = der.nextSiblingOf(sigPtr);
            bytes memory sigY = _trimBytes(der.bytesAt(sigPtr), 32);

            cert.tbsCertificate = der.allBytesAt(tbsParentPtr);
            cert.pubKey = _trimBytes(der.bytesAt(subjectPublicKeyInfoPtr), 64);
            cert.signature = abi.encodePacked(sigX, sigY);
        }

        if (isPckCert) {
            // entering Extension sequence
            tbsPtr = der.nextSiblingOf(tbsPtr);

            // check for the extension tag
            if (der[tbsPtr.ixs()] != 0xA3) {
                return (false, cert);
            }

            tbsPtr = der.firstChildOf(tbsPtr);
            tbsPtr = der.firstChildOf(tbsPtr);

            bool sgxExtnTraversedSuccessfully;
            uint256 pcesvn;
            uint256[] memory cpuSvns;
            bytes memory fmspcBytes;
            bytes memory pceidBytes;
            (sgxExtnTraversedSuccessfully, pcesvn, cpuSvns, fmspcBytes, pceidBytes) =
                _findPckTcbInfo(der, tbsPtr, tbsParentPtr);
            if (!sgxExtnTraversedSuccessfully) {
                return (false, cert);
            }
            cert.pck.sgxExtension.pcesvn = pcesvn;
            cert.pck.sgxExtension.sgxTcbCompSvnArr = cpuSvns;
            cert.pck.sgxExtension.pceid = LibString.toHexStringNoPrefix(pceidBytes);
            cert.pck.sgxExtension.fmspc = LibString.toHexStringNoPrefix(fmspcBytes);
            cert.isPck = true;
        }

        success = true;
    }

    function _removeHeadersAndFooters(string memory pemData)
        private
        pure
        returns (bool success, bytes memory extracted, uint256 endIndex)
    {
        // Check if the input contains the "BEGIN" and "END" headers
        uint256 beginPos = LibString.indexOf(pemData, HEADER);
        uint256 endPos = LibString.indexOf(pemData, FOOTER);

        bool headerFound = beginPos != LibString.NOT_FOUND;
        bool footerFound = endPos != LibString.NOT_FOUND;

        if (!headerFound || !footerFound) {
            return (false, extracted, endIndex);
        }

        // Extract the content between the headers
        uint256 contentStart = beginPos + HEADER_LENGTH;

        // Extract and return the content
        bytes memory contentBytes;

        // do not include newline
        bytes memory delimiter = hex"0a";
        string memory contentSlice = LibString.slice(pemData, contentStart, endPos);
        string[] memory split = LibString.split(contentSlice, string(delimiter));
        string memory contentStr;

        for (uint256 i; i < split.length; ++i) {
            contentStr = LibString.concat(contentStr, split[i]);
        }

        contentBytes = bytes(contentStr);
        return (true, contentBytes, endPos + FOOTER_LENGTH);
    }

    function _trimBytes(
        bytes memory input,
        uint256 expectedLength
    )
        private
        pure
        returns (bytes memory output)
    {
        uint256 n = input.length;

        if (n <= expectedLength) {
            return input;
        }
        uint256 lengthDiff = n - expectedLength;
        output = input.substring(lengthDiff, expectedLength);
    }

    function _findPckTcbInfo(
        bytes memory der,
        uint256 tbsPtr,
        uint256 tbsParentPtr
    )
        private
        pure
        returns (
            bool success,
            uint256 pcesvn,
            uint256[] memory cpusvns,
            bytes memory fmspcBytes,
            bytes memory pceidBytes
        )
    {
        // iterate through the elements in the Extension sequence
        // until we locate the SGX Extension OID
        while (tbsPtr != 0) {
            uint256 internalPtr = der.firstChildOf(tbsPtr);
            if (der[internalPtr.ixs()] != 0x06) {
                return (false, pcesvn, cpusvns, fmspcBytes, pceidBytes);
            }

            if (BytesUtils.compareBytes(der.bytesAt(internalPtr), SGX_EXTENSION_OID)) {
                // 1.2.840.113741.1.13.1
                internalPtr = der.nextSiblingOf(internalPtr);
                uint256 extnValueParentPtr = der.rootOfOctetStringAt(internalPtr);
                uint256 extnValuePtr = der.firstChildOf(extnValueParentPtr);

                // Copy flags to memory to avoid stack too deep
                PCKTCBFlags memory flags;

                while (!(flags.fmspcFound && flags.pceidFound && flags.tcbFound)) {
                    uint256 extnValueOidPtr = der.firstChildOf(extnValuePtr);
                    if (der[extnValueOidPtr.ixs()] != 0x06) {
                        return (false, pcesvn, cpusvns, fmspcBytes, pceidBytes);
                    }
                    if (BytesUtils.compareBytes(der.bytesAt(extnValueOidPtr), TCB_OID)) {
                        // 1.2.840.113741.1.13.1.2
                        (flags.tcbFound, pcesvn, cpusvns) = _findTcb(der, extnValueOidPtr);
                    }
                    if (BytesUtils.compareBytes(der.bytesAt(extnValueOidPtr), PCEID_OID)) {
                        // 1.2.840.113741.1.13.1.3
                        uint256 pceidPtr = der.nextSiblingOf(extnValueOidPtr);
                        pceidBytes = der.bytesAt(pceidPtr);
                        flags.pceidFound = true;
                    }
                    if (BytesUtils.compareBytes(der.bytesAt(extnValueOidPtr), FMSPC_OID)) {
                        // 1.2.840.113741.1.13.1.4
                        uint256 fmspcPtr = der.nextSiblingOf(extnValueOidPtr);
                        fmspcBytes = der.bytesAt(fmspcPtr);
                        flags.fmspcFound = true;
                    }

                    if (extnValuePtr.ixl() < extnValueParentPtr.ixl()) {
                        extnValuePtr = der.nextSiblingOf(extnValuePtr);
                    } else {
                        break;
                    }
                }
                success = flags.fmspcFound && flags.pceidFound && flags.tcbFound;
                break;
            }

            if (tbsPtr.ixl() < tbsParentPtr.ixl()) {
                tbsPtr = der.nextSiblingOf(tbsPtr);
            } else {
                tbsPtr = 0; // exit
            }
        }
    }

    function _findTcb(
        bytes memory der,
        uint256 oidPtr
    )
        private
        pure
        returns (bool success, uint256 pcesvn, uint256[] memory cpusvns)
    {
        // sibiling of tcbOid
        uint256 tcbPtr = der.nextSiblingOf(oidPtr);
        // get the first svn object in the sequence
        uint256 svnParentPtr = der.firstChildOf(tcbPtr);
        cpusvns = new uint256[](SGX_TCB_CPUSVN_SIZE);
        for (uint256 i; i < SGX_TCB_CPUSVN_SIZE + 1; ++i) {
            uint256 svnPtr = der.firstChildOf(svnParentPtr); // OID
            uint256 svnValuePtr = der.nextSiblingOf(svnPtr); // value
            bytes memory svnValueBytes = der.bytesAt(svnValuePtr);
            uint16 svnValue = svnValueBytes.length < 2
                ? uint16(bytes2(svnValueBytes)) / 256
                : uint16(bytes2(svnValueBytes));
            if (BytesUtils.compareBytes(der.bytesAt(svnPtr), PCESVN_OID)) {
                // pcesvn is 4 bytes in size
                pcesvn = uint256(svnValue);
            } else {
                // each cpusvn is at maximum two bytes in size
                uint256 cpusvn = uint256(svnValue);
                cpusvns[i] = cpusvn;
            }

            // iterate to the next svn object in the sequence
            svnParentPtr = der.nextSiblingOf(svnParentPtr);
        }
        success = true;
    }
}


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/PEMCertChainLib.sol#L1:1

```solidity
File: contracts/automata-attestation/lib/QuoteV3Auth/V3Struct.sol


//SPDX-License-Identifier: MIT
pragma solidity 0.8.24;

/// @title V3Struct
/// @custom:security-contact security@taiko.xyz
library V3Struct {
    struct Header {
        bytes2 version;
        bytes2 attestationKeyType;
        bytes4 teeType;
        bytes2 qeSvn;
        bytes2 pceSvn;
        bytes16 qeVendorId;
        bytes20 userData;
    }

    struct EnclaveReport {
        bytes16 cpuSvn;
        bytes4 miscSelect;
        bytes28 reserved1;
        bytes16 attributes;
        bytes32 mrEnclave;
        bytes32 reserved2;
        bytes32 mrSigner;
        bytes reserved3; // 96 bytes
        uint16 isvProdId;
        uint16 isvSvn;
        bytes reserved4; // 60 bytes
        bytes reportData; // 64 bytes - For QEReports, this contains the hash of the concatenation
            // of attestation key and QEAuthData
    }

    struct QEAuthData {
        uint16 parsedDataSize;
        bytes data;
    }

    struct CertificationData {
        uint16 certType;
        // todo! In encoded path, we need to calculate the size of certDataArray
        // certDataSize = len(join((BEGIN_CERT, certArray[i], END_CERT) for i in 0..3))
        // But for plain bytes path, we don't need that.
        uint32 certDataSize;
        bytes[3] decodedCertDataArray; // base64 decoded cert bytes array
    }

    struct ECDSAQuoteV3AuthData {
        bytes ecdsa256BitSignature; // 64 bytes
        bytes ecdsaAttestationKey; // 64 bytes
        EnclaveReport pckSignedQeReport; // 384 bytes
        bytes qeReportSignature; // 64 bytes
        QEAuthData qeAuthData;
        CertificationData certification;
    }

    struct ParsedV3QuoteStruct {
        Header header;
        EnclaveReport localEnclaveReport;
        ECDSAQuoteV3AuthData v3AuthData;
    }
}


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/QuoteV3Auth/V3Struct.sol#L1:1

```solidity
File: contracts/automata-attestation/lib/TCBInfoStruct.sol


//SPDX-License-Identifier: MIT
pragma solidity 0.8.24;

/// @title TCBInfoStruct
/// @custom:security-contact security@taiko.xyz
library TCBInfoStruct {
    struct TCBInfo {
        string pceid;
        string fmspc;
        TCBLevelObj[] tcbLevels;
    }

    struct TCBLevelObj {
        uint256 pcesvn;
        uint8[] sgxTcbCompSvnArr;
        TCBStatus status;
    }

    enum TCBStatus {
        OK,
        TCB_SW_HARDENING_NEEDED,
        TCB_CONFIGURATION_AND_SW_HARDENING_NEEDED,
        TCB_CONFIGURATION_NEEDED,
        TCB_OUT_OF_DATE,
        TCB_OUT_OF_DATE_CONFIGURATION_NEEDED,
        TCB_REVOKED,
        TCB_UNRECOGNIZED
    }
}


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/TCBInfoStruct.sol#L1:1

```solidity
File: contracts/automata-attestation/lib/interfaces/IPEMCertChainLib.sol


// SPDX-License-Identifier: MIT
pragma solidity 0.8.24;

/// @title IPEMCertChainLib
/// @custom:security-contact security@taiko.xyz
interface IPEMCertChainLib {
    struct ECSha256Certificate {
        uint256 notBefore;
        uint256 notAfter;
        bytes serialNumber;
        bytes tbsCertificate;
        bytes pubKey;
        bytes signature;
        bool isPck;
        PCKCertificateField pck;
    }

    struct PCKCertificateField {
        string commonName;
        string issuerName;
        PCKTCBInfo sgxExtension;
    }

    struct PCKTCBInfo {
        string pceid;
        string fmspc;
        uint256 pcesvn;
        uint256[] sgxTcbCompSvnArr;
    }

    enum CRL {
        PCK,
        ROOT
    }

    function splitCertificateChain(
        bytes memory pemChain,
        uint256 size
    )
        external
        pure
        returns (bool success, bytes[] memory certs);

    function decodeCert(
        bytes memory der,
        bool isPckCert
    )
        external
        pure
        returns (bool success, ECSha256Certificate memory cert);
}


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/interfaces/IPEMCertChainLib.sol#L1:1

```solidity
File: contracts/automata-attestation/utils/SHA1.sol


// SPDX-License-Identifier: BSD 2-Clause License

pragma solidity 0.8.24;

// Inspired by ensdomains/solsha1 - BSD 2-Clause License
// https://github.com/ensdomains/solsha1/blob/master/contracts/SHA1.sol

/// @title SHA1
/// @custom:security-contact security@taiko.xyz
library SHA1 {
    function sha1(bytes memory data) internal pure returns (bytes20 ret) {
        assembly {
            // Get a safe scratch location
            let scratch := mload(0x40)

            // Get the data length, and point data at the first byte
            let len := mload(data)
            data := add(data, 32)

            // Find the length after padding
            let totallen := add(and(add(len, 1), 0xFFFFFFFFFFFFFFC0), 64)
            switch lt(sub(totallen, len), 9)
            case 1 { totallen := add(totallen, 64) }

            let h := 0x6745230100EFCDAB890098BADCFE001032547600C3D2E1F0

            function readword(ptr, off, count) -> result {
                result := 0
                if lt(off, count) {
                    result := mload(add(ptr, off))
                    count := sub(count, off)
                    if lt(count, 32) {
                        let mask := not(sub(exp(256, sub(32, count)), 1))
                        result := and(result, mask)
                    }
                }
            }

            for { let i := 0 } lt(i, totallen) { i := add(i, 64) } {
                mstore(scratch, readword(data, i, len))
                mstore(add(scratch, 32), readword(data, add(i, 32), len))

                // If we loaded the last byte, store the terminator byte
                switch lt(sub(len, i), 64)
                case 1 { mstore8(add(scratch, sub(len, i)), 0x80) }

                // If this is the last block, store the length
                switch eq(i, sub(totallen, 64))
                case 1 { mstore(add(scratch, 32), or(mload(add(scratch, 32)), mul(len, 8))) }

                // Expand the 16 32-bit words into 80
                for { let j := 64 } lt(j, 128) { j := add(j, 12) } {
                    let temp :=
                        xor(
                            xor(mload(add(scratch, sub(j, 12))), mload(add(scratch, sub(j, 32)))),
                            xor(mload(add(scratch, sub(j, 56))), mload(add(scratch, sub(j, 64))))
                        )
                    temp :=
                        or(
                            and(
                                mul(temp, 2),
                                0xFFFFFFFEFFFFFFFEFFFFFFFEFFFFFFFEFFFFFFFEFFFFFFFEFFFFFFFEFFFFFFFE
                            ),
                            and(
                                div(temp, 0x80000000),
                                0x0000000100000001000000010000000100000001000000010000000100000001
                            )
                        )
                    mstore(add(scratch, j), temp)
                }
                for { let j := 128 } lt(j, 320) { j := add(j, 24) } {
                    let temp :=
                        xor(
                            xor(mload(add(scratch, sub(j, 24))), mload(add(scratch, sub(j, 64)))),
                            xor(mload(add(scratch, sub(j, 112))), mload(add(scratch, sub(j, 128))))
                        )
                    temp :=
                        or(
                            and(
                                mul(temp, 4),
                                0xFFFFFFFCFFFFFFFCFFFFFFFCFFFFFFFCFFFFFFFCFFFFFFFCFFFFFFFCFFFFFFFC
                            ),
                            and(
                                div(temp, 0x40000000),
                                0x0000000300000003000000030000000300000003000000030000000300000003
                            )
                        )
                    mstore(add(scratch, j), temp)
                }

                let x := h
                let f := 0
                let k := 0
                for { let j := 0 } lt(j, 80) { j := add(j, 1) } {
                    switch div(j, 20)
                    case 0 {
                        // f = d xor (b and (c xor d))
                        f := xor(div(x, 0x100000000000000000000), div(x, 0x10000000000))
                        f := and(div(x, 0x1000000000000000000000000000000), f)
                        f := xor(div(x, 0x10000000000), f)
                        k := 0x5A827999
                    }
                    case 1 {
                        // f = b xor c xor d
                        f :=
                            xor(
                                div(x, 0x1000000000000000000000000000000),
                                div(x, 0x100000000000000000000)
                            )
                        f := xor(div(x, 0x10000000000), f)
                        k := 0x6ED9EBA1
                    }
                    case 2 {
                        // f = (b and c) or (d and (b or c))
                        f :=
                            or(
                                div(x, 0x1000000000000000000000000000000),
                                div(x, 0x100000000000000000000)
                            )
                        f := and(div(x, 0x10000000000), f)
                        f :=
                            or(
                                and(
                                    div(x, 0x1000000000000000000000000000000),
                                    div(x, 0x100000000000000000000)
                                ),
                                f
                            )
                        k := 0x8F1BBCDC
                    }
                    case 3 {
                        // f = b xor c xor d
                        f :=
                            xor(
                                div(x, 0x1000000000000000000000000000000),
                                div(x, 0x100000000000000000000)
                            )
                        f := xor(div(x, 0x10000000000), f)
                        k := 0xCA62C1D6
                    }
                    // temp = (a leftrotate 5) + f + e + k + w[i]
                    let temp := and(div(x, 0x80000000000000000000000000000000000000000000000), 0x1F)
                    temp :=
                        or(and(div(x, 0x800000000000000000000000000000000000000), 0xFFFFFFE0), temp)
                    temp := add(f, temp)
                    temp := add(and(x, 0xFFFFFFFF), temp)
                    temp := add(k, temp)
                    temp :=
                        add(
                            div(
                                mload(add(scratch, mul(j, 4))),
                                0x100000000000000000000000000000000000000000000000000000000
                            ),
                            temp
                        )
                    x :=
                        or(
                            div(x, 0x10000000000),
                            mul(temp, 0x10000000000000000000000000000000000000000)
                        )
                    x :=
                        or(
                            and(x, 0xFFFFFFFF00FFFFFFFF000000000000FFFFFFFF00FFFFFFFF),
                            mul(
                                or(
                                    and(div(x, 0x4000000000000), 0xC0000000),
                                    and(div(x, 0x400000000000000000000), 0x3FFFFFFF)
                                ),
                                0x100000000000000000000
                            )
                        )
                }

                h := and(add(h, x), 0xFFFFFFFF00FFFFFFFF00FFFFFFFF00FFFFFFFF00FFFFFFFF)
            }
            ret :=
                mul(
                    or(
                        or(
                            or(
                                or(
                                    and(div(h, 0x100000000), 0xFFFFFFFF00000000000000000000000000000000),
                                    and(div(h, 0x1000000), 0xFFFFFFFF000000000000000000000000)
                                ),
                                and(div(h, 0x10000), 0xFFFFFFFF0000000000000000)
                            ),
                            and(div(h, 0x100), 0xFFFFFFFF00000000)
                        ),
                        and(h, 0xFFFFFFFF)
                    ),
                    0x1000000000000000000000000
                )
        }
    }
}


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/SHA1.sol#L1:1

```solidity
File: contracts/automata-attestation/utils/SigVerifyLib.sol


// SPDX-License-Identifier: GPL-3.0
pragma solidity 0.8.24;

import "../interfaces/ISigVerifyLib.sol";
import "./RsaVerify.sol";
import "./BytesUtils.sol";

/// @title SigVerifyLib
/// @custom:security-contact security@taiko.xyz
// Library for verifying signatures
// Supports verifying signatures with the following algorithms:
// - RS256
// - ES256
// - RS1
contract SigVerifyLib is ISigVerifyLib {
    using BytesUtils for bytes;

    address private ES256VERIFIER;

    constructor(address es256Verifier) {
        ES256VERIFIER = es256Verifier;
    }

    function verifyAttStmtSignature(
        bytes memory tbs,
        bytes memory signature,
        PublicKey memory publicKey,
        Algorithm alg
    )
        public
        view
        returns (bool)
    {
        if (alg == Algorithm.RS256) {
            if (publicKey.keyType != KeyType.RSA) {
                return false;
            }
            return verifyRS256Signature(tbs, signature, publicKey.pubKey);
        } else if (alg == Algorithm.ES256) {
            if (publicKey.keyType != KeyType.ECDSA) {
                return false;
            }
            return verifyES256Signature(tbs, signature, publicKey.pubKey);
        } else if (alg == Algorithm.RS1) {
            if (publicKey.keyType != KeyType.RSA) {
                return false;
            }
            return verifyRS1Signature(tbs, signature, publicKey.pubKey);
        } else {
            revert("Unsupported algorithm");
        }
    }

    function verifyCertificateSignature(
        bytes memory tbs,
        bytes memory signature,
        PublicKey memory publicKey,
        CertSigAlgorithm alg
    )
        public
        view
        returns (bool)
    {
        if (alg == CertSigAlgorithm.Sha256WithRSAEncryption) {
            if (publicKey.keyType != KeyType.RSA) {
                return false;
            }
            return verifyRS256Signature(tbs, signature, publicKey.pubKey);
        } else if (alg == CertSigAlgorithm.Sha1WithRSAEncryption) {
            if (publicKey.keyType != KeyType.RSA) {
                return false;
            }
            return verifyRS1Signature(tbs, signature, publicKey.pubKey);
        } else {
            revert("Unsupported algorithm");
        }
    }

    function verifyRS256Signature(
        bytes memory tbs,
        bytes memory signature,
        bytes memory publicKey
    )
        public
        view
        returns (bool sigValid)
    {
        // Parse public key
        bytes memory exponent = publicKey.substring(0, 3);
        bytes memory modulus = publicKey.substring(3, publicKey.length - 3);

        // Verify signature
        sigValid = RsaVerify.pkcs1Sha256Raw(tbs, signature, exponent, modulus);
    }

    function verifyRS1Signature(
        bytes memory tbs,
        bytes memory signature,
        bytes memory publicKey
    )
        public
        view
        returns (bool sigValid)
    {
        // Parse public key
        bytes memory exponent = publicKey.substring(0, 3);
        bytes memory modulus = publicKey.substring(3, publicKey.length - 3);

        // Verify signature
        sigValid = RsaVerify.pkcs1Sha1Raw(tbs, signature, exponent, modulus);
    }

    function verifyES256Signature(
        bytes memory tbs,
        bytes memory signature,
        bytes memory publicKey
    )
        public
        view
        returns (bool sigValid)
    {
        // Parse signature
        if (signature.length != 64) {
            return false;
        }
        uint256 r = uint256(bytes32(signature.substring(0, 32)));
        uint256 s = uint256(bytes32(signature.substring(32, 32)));
        // Parse public key
        if (publicKey.length != 64) {
            return false;
        }
        uint256 gx = uint256(bytes32(publicKey.substring(0, 32)));
        uint256 gy = uint256(bytes32(publicKey.substring(32, 32)));

        // Verify signature
        bytes memory args = abi.encode(sha256(tbs), r, s, gx, gy);
        (bool success, bytes memory ret) = ES256VERIFIER.staticcall(args);
        assert(success); // never reverts, always returns 0 or 1

        return abi.decode(ret, (uint256)) == 1;
    }
}


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/SigVerifyLib.sol#L1:1

```solidity
File: contracts/automata-attestation/utils/X509DateUtils.sol


// SPDX-License-Identifier: MIT

pragma solidity 0.8.24;

/// @title X509DateUtils
/// @custom:security-contact security@taiko.xyz
library X509DateUtils {
    function toTimestamp(bytes memory x509Time) internal pure returns (uint256) {
        uint16 yrs;
        uint8 mnths;
        uint8 dys;
        uint8 hrs;
        uint8 mins;
        uint8 secs;
        uint8 offset;

        if (x509Time.length == 13) {
            if (uint8(x509Time[0]) - 48 < 5) yrs += 2000;
            else yrs += 1900;
        } else {
            yrs += (uint8(x509Time[0]) - 48) * 1000 + (uint8(x509Time[1]) - 48) * 100;
            offset = 2;
        }
        yrs += (uint8(x509Time[offset + 0]) - 48) * 10 + uint8(x509Time[offset + 1]) - 48;
        mnths = (uint8(x509Time[offset + 2]) - 48) * 10 + uint8(x509Time[offset + 3]) - 48;
        dys += (uint8(x509Time[offset + 4]) - 48) * 10 + uint8(x509Time[offset + 5]) - 48;
        hrs += (uint8(x509Time[offset + 6]) - 48) * 10 + uint8(x509Time[offset + 7]) - 48;
        mins += (uint8(x509Time[offset + 8]) - 48) * 10 + uint8(x509Time[offset + 9]) - 48;
        secs += (uint8(x509Time[offset + 10]) - 48) * 10 + uint8(x509Time[offset + 11]) - 48;

        return toUnixTimestamp(yrs, mnths, dys, hrs, mins, secs);
    }

    function toUnixTimestamp(
        uint16 year,
        uint8 month,
        uint8 day,
        uint8 hour,
        uint8 minute,
        uint8 second
    )
        internal
        pure
        returns (uint256)
    {
        uint256 timestamp = 0;

        for (uint16 i = 1970; i < year; ++i) {
            if (isLeapYear(i)) {
                timestamp += 31_622_400; // Leap year in seconds
            } else {
                timestamp += 31_536_000; // Normal year in seconds
            }
        }

        uint8[12] memory monthDays = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
        if (isLeapYear(year)) monthDays[1] = 29;

        for (uint8 i = 1; i < month; ++i) {
            timestamp += uint256(monthDays[i - 1]) * 86_400; // Days in seconds
        }

        timestamp += uint256(day - 1) * 86_400; // Days in seconds
        timestamp += uint256(hour) * 3600; // Hours in seconds
        timestamp += uint256(minute) * 60; // Minutes in seconds
        timestamp += second;

        return timestamp;
    }

    function isLeapYear(uint16 year) internal pure returns (bool) {
        if (year % 4 != 0) return false;
        if (year % 100 != 0) return true;
        if (year % 400 != 0) return false;
        return true;
    }
}


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/X509DateUtils.sol#L1:1

```solidity
File: contracts/thirdparty/solmate/LibFixedPointMath.sol


// SPDX-License-Identifier: MIT
// Taken from the contract below, expWad() function tailored to Taiko's need
// https://github.com/transmissions11/solmate/blob/v7/src/utils/FixedPointMathLib.sol
pragma solidity 0.8.24;

library LibFixedPointMath {
    uint128 public constant MAX_EXP_INPUT = 135_305_999_368_893_231_588;
    uint256 public constant SCALING_FACTOR = 1e18; // For fixed point representation factor

    error Overflow();

    // Computes e^x in 1e18 fixed point.
    function exp(int256 x) internal pure returns (int256 r) {
        unchecked {
            // Input x is in fixed point format, with scale factor 1/1e18.

            // When the result is < 0.5 we return zero. This happens when
            // x <= floor(log(0.5e18) * 1e18) ~ -42e18
            if (x <= -42_139_678_854_452_767_551) {
                return 0;
            }

            // When the result is > (2**255 - 1) / 1e18 we can not represent it
            // as an int256. This happens when x >= floor(log((2**255 -1) /
            // 1e18) * 1e18) ~ 135.
            if (x >= 135_305_999_368_893_231_589) revert Overflow();

            // x is now in the range (-42, 136) * 1e18. Convert to (-42, 136) *
            // 2**96
            // for more intermediate precision and a binary basis. This base
            // conversion
            // is a multiplication by 1e18 / 2**96 = 5**18 / 2**78.
            x = (x << 78) / 5 ** 18;

            // Reduce range of x to (-½ ln 2, ½ ln 2) * 2**96 by factoring out
            // powers of two
            // such that exp(x) = exp(x') * 2**k, where k is an integer.
            // Solving this gives k = round(x / log(2)) and x' = x - k * log(2).
            int256 k = ((x << 96) / 54_916_777_467_707_473_351_141_471_128 + 2 ** 95) >> 96;
            x = x - k * 54_916_777_467_707_473_351_141_471_128;
            // k is in the range [-61, 195].

            // Evaluate using a (6, 7)-term rational approximation.
            // p is made monic, we'll multiply by a scale factor later.
            int256 y = x + 1_346_386_616_545_796_478_920_950_773_328;
            y = ((y * x) >> 96) + 57_155_421_227_552_351_082_224_309_758_442;
            int256 p = y + x - 94_201_549_194_550_492_254_356_042_504_812;
            p = ((p * y) >> 96) + 28_719_021_644_029_726_153_956_944_680_412_240;
            p = p * x + (4_385_272_521_454_847_904_659_076_985_693_276 << 96);

            // We leave p in 2**192 basis so we don't need to scale it back up
            // for the division.
            int256 q = x - 2_855_989_394_907_223_263_936_484_059_900;
            q = ((q * x) >> 96) + 50_020_603_652_535_783_019_961_831_881_945;
            q = ((q * x) >> 96) - 533_845_033_583_426_703_283_633_433_725_380;
            q = ((q * x) >> 96) + 3_604_857_256_930_695_427_073_651_918_091_429;
            q = ((q * x) >> 96) - 14_423_608_567_350_463_180_887_372_962_807_573;
            q = ((q * x) >> 96) + 26_449_188_498_355_588_339_934_803_723_976_023;
            assembly {
                // Div in assembly because solidity adds a zero check despite
                // the `unchecked`.
                // The q polynomial is known not to have zeros in the domain.
                // (All roots are complex)
                // No scaling required because p is already 2**96 too large.
                r := sdiv(p, q)
            }
            // r should be in the range (0.09, 0.25) * 2**96.

            // We now need to multiply r by
            //  * the scale factor s = ~6.031367120...,
            //  * the 2**k factor from the range reduction, and
            //  * the 1e18 / 2**96 factor for base converison.
            // We do all of this at once, with an intermediate result in 2**213
            // basis
            // so the final right shift is always by a positive amount.
            r = int256(
                (uint256(r) * 3_822_833_074_963_236_453_042_738_258_902_158_003_155_416_615_667)
                    >> uint256(195 - k)
            );
        }
    }
}


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/solmate/LibFixedPointMath.sol#L1:1

```solidity
File: contracts/tokenvault/LibBridgedToken.sol


// SPDX-License-Identifier: MIT
pragma solidity 0.8.24;

import "@openzeppelin/contracts/utils/Strings.sol";

/// @title LibBridgedToken
/// @custom:security-contact security@taiko.xyz
library LibBridgedToken {
    error BTOKEN_INVALID_PARAMS();

    function validateInputs(
        address _srcToken,
        uint256 _srcChainId,
        string memory _symbol,
        string memory _name
    )
        internal
        view
    {
        if (
            _srcToken == address(0) || _srcChainId == 0 || _srcChainId == block.chainid
                || bytes(_symbol).length == 0 || bytes(_name).length == 0
        ) {
            revert BTOKEN_INVALID_PARAMS();
        }
    }

    function buildName(
        string memory _name,
        uint256 _srcChainId
    )
        internal
        pure
        returns (string memory)
    {
        return string.concat("Bridged ", _name, unicode" (⭀", Strings.toString(_srcChainId), ")");
    }

    function buildSymbol(string memory _symbol) internal pure returns (string memory) {
        return string.concat(_symbol, ".t");
    }

    function buildURI(
        address _srcToken,
        uint256 _srcChainId
    )
        internal
        pure
        returns (string memory)
    {
        // Creates a base URI in the format specified by EIP-681:
        // https://eips.ethereum.org/EIPS/eip-681
        return string(
            abi.encodePacked(
                "ethereum:",
                Strings.toHexString(uint160(_srcToken), 20),
                "@",
                Strings.toString(_srcChainId),
                "/tokenURI?uint256="
            )
        );
    }
}


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/LibBridgedToken.sol#L1:1

</details>

## NC021 - Function declarations should have NatSpec descriptions:

Function declarations should be preceded by a NatSpec comment.


<details>
<summary>Click to show 58 findings</summary>

```solidity
File: contracts/L1/provers/Guardians.sol


111         function approve(uint256 _operationId, bytes32 _hash) internal returns (bool approved_) {


124         function deleteApproval(bytes32 _hash) internal {


128         function isApproved(uint256 _approvalBits) internal view returns (bool) {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/provers/Guardians.sol#L128:128

```solidity
File: contracts/automata-attestation/AutomataDcapV3Attestation.sol


54          constructor(address sigVerifyLibAddr, address pemCertLibAddr) {


65          function setMrSigner(bytes32 _mrSigner, bool _trusted) external onlyOwner {


69          function setMrEnclave(bytes32 _mrEnclave, bool _trusted) external onlyOwner {


73          function addRevokedCertSerialNum(


88          function removeRevokedCertSerialNum(


103         function configureTcbInfoJson(


114         function configureQeIdentityJson(EnclaveIdStruct.EnclaveId calldata qeIdentityInput)


122         function toggleLocalReportCheck() external onlyOwner {


138         function verifyAttestation(bytes calldata data) external view override returns (bool) {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/AutomataDcapV3Attestation.sol#L138:138

```solidity
File: contracts/automata-attestation/interfaces/IAttestation.sol


9           function verifyAttestation(bytes calldata data) external returns (bool);


10          function verifyParsedQuote(V3Struct.ParsedV3QuoteStruct calldata v3quote)


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/interfaces/IAttestation.sol#L10:10

```solidity
File: contracts/automata-attestation/interfaces/ISigVerifyLib.sol


38          function verifyAttStmtSignature(


48          function verifyCertificateSignature(


58          function verifyRS256Signature(


67          function verifyRS1Signature(


76          function verifyES256Signature(


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/interfaces/ISigVerifyLib.sol#L76:76

```solidity
File: contracts/automata-attestation/lib/PEMCertChainLib.sol


40          function splitCertificateChain(


74          function decodeCert(


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/PEMCertChainLib.sol#L74:74

```solidity
File: contracts/automata-attestation/lib/QuoteV3Auth/V3Parser.sol


21          function parseInput(


62          function validateParsedInput(V3Struct.ParsedV3QuoteStruct memory v3Quote)


133         function parseEnclaveReport(bytes memory rawEnclaveReport)


152         function littleEndianDecode(bytes memory encoded) private pure returns (uint256 decoded) {


165         function parseAndVerifyHeader(bytes memory rawHeader)


203         function parseAuthDataAndVerifyCertType(


267         function parseCerificationChainBytes(


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/QuoteV3Auth/V3Parser.sol#L267:267

```solidity
File: contracts/automata-attestation/lib/interfaces/IPEMCertChainLib.sol


36          function splitCertificateChain(


44          function decodeCert(


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/interfaces/IPEMCertChainLib.sol#L44:44

```solidity
File: contracts/automata-attestation/utils/Asn1Decode.sol


14          function ixs(uint256 self) internal pure returns (uint256) {


19          function ixf(uint256 self) internal pure returns (uint256) {


24          function ixl(uint256 self) internal pure returns (uint256) {


29          function getPtr(uint256 _ixs, uint256 _ixf, uint256 _ixl) internal pure returns (uint256) {


165         function keccakOfBytesAt(bytes memory der, uint256 ptr) internal pure returns (bytes32) {


169         function keccakOfAllBytesAt(bytes memory der, uint256 ptr) internal pure returns (bytes32) {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/Asn1Decode.sol#L169:169

```solidity
File: contracts/automata-attestation/utils/BytesUtils.sol


272         function memcpy(uint256 dest, uint256 src, uint256 len) private pure {


371         function compareBytes(bytes memory a, bytes memory b) internal pure returns (bool) {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/BytesUtils.sol#L371:371

```solidity
File: contracts/automata-attestation/utils/SHA1.sol


11          function sha1(bytes memory data) internal pure returns (bytes20 ret) {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/SHA1.sol#L11:11

```solidity
File: contracts/automata-attestation/utils/SigVerifyLib.sol


20          constructor(address es256Verifier) {


24          function verifyAttStmtSignature(


54          function verifyCertificateSignature(


79          function verifyRS256Signature(


96          function verifyRS1Signature(


113         function verifyES256Signature(


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/SigVerifyLib.sol#L113:113

```solidity
File: contracts/automata-attestation/utils/X509DateUtils.sol


8           function toTimestamp(bytes memory x509Time) internal pure returns (uint256) {


34          function toUnixTimestamp(


71          function isLeapYear(uint16 year) internal pure returns (bool) {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/X509DateUtils.sol#L71:71

```solidity
File: contracts/libs/LibAddress.sol


46          function supportsInterface(


61          function isValidSignature(


77          function isSenderEOA() internal view returns (bool) {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/libs/LibAddress.sol#L77:77

```solidity
File: contracts/thirdparty/solmate/LibFixedPointMath.sol


13          function exp(int256 x) internal pure returns (int256 r) {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/solmate/LibFixedPointMath.sol#L13:13

```solidity
File: contracts/tokenvault/BaseVault.sol


47          function checkProcessMessageContext()


58          function checkRecallMessageContext()


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BaseVault.sol#L58:58

```solidity
File: contracts/tokenvault/LibBridgedToken.sol


11          function validateInputs(


28          function buildName(


39          function buildSymbol(string memory _symbol) internal pure returns (string memory) {


43          function buildURI(


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/LibBridgedToken.sol#L43:43

</details>

## NC022 - Contract declarations should have `@notice` tags:

`@notice` is used to explain to end users what the contract does, and the compiler interprets `///` or `/**` comments as this tag if one wasn't explicitly provided.


<details>
<summary>Click to show 39 findings</summary>

```solidity
File: contracts/L1/ITaikoL1.sol


8       interface ITaikoL1 {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/ITaikoL1.sol#L8:8

```solidity
File: contracts/L1/gov/TaikoGovernor.sol


16      contract TaikoGovernor is


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/gov/TaikoGovernor.sol#L16:16

```solidity
File: contracts/L1/gov/TaikoTimelockController.sol


9       contract TaikoTimelockController is EssentialContract, TimelockControllerUpgradeable {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/gov/TaikoTimelockController.sol#L9:9

```solidity
File: contracts/L1/hooks/IHook.sol


8       interface IHook {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/hooks/IHook.sol#L8:8

```solidity
File: contracts/L1/provers/GuardianProver.sol


10      contract GuardianProver is Guardians {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/provers/GuardianProver.sol#L10:10

```solidity
File: contracts/L1/tiers/DevnetTierProvider.sol


10      contract DevnetTierProvider is EssentialContract, ITierProvider {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/tiers/DevnetTierProvider.sol#L10:10

```solidity
File: contracts/L1/tiers/ITierProvider.sol


37      library LibTiers {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/tiers/ITierProvider.sol#L37:37

```solidity
File: contracts/L1/tiers/MainnetTierProvider.sol


10      contract MainnetTierProvider is EssentialContract, ITierProvider {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/tiers/MainnetTierProvider.sol#L10:10

```solidity
File: contracts/L1/tiers/TestnetTierProvider.sol


10      contract TestnetTierProvider is EssentialContract, ITierProvider {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/tiers/TestnetTierProvider.sol#L10:10

```solidity
File: contracts/automata-attestation/AutomataDcapV3Attestation.sol


22      contract AutomataDcapV3Attestation is IAttestation {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/AutomataDcapV3Attestation.sol#L22:22

```solidity
File: contracts/automata-attestation/interfaces/IAttestation.sol


8       interface IAttestation {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/interfaces/IAttestation.sol#L8:8

```solidity
File: contracts/automata-attestation/interfaces/ISigVerifyLib.sol


6       interface ISigVerifyLib {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/interfaces/ISigVerifyLib.sol#L6:6

```solidity
File: contracts/automata-attestation/lib/EnclaveIdStruct.sol


6       library EnclaveIdStruct {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/EnclaveIdStruct.sol#L6:6

```solidity
File: contracts/automata-attestation/lib/PEMCertChainLib.sol


12      contract PEMCertChainLib is IPEMCertChainLib {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/PEMCertChainLib.sol#L12:12

```solidity
File: contracts/automata-attestation/lib/QuoteV3Auth/V3Parser.sol


11      library V3Parser {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/QuoteV3Auth/V3Parser.sol#L11:11

```solidity
File: contracts/automata-attestation/lib/QuoteV3Auth/V3Struct.sol


6       library V3Struct {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/QuoteV3Auth/V3Struct.sol#L6:6

```solidity
File: contracts/automata-attestation/lib/TCBInfoStruct.sol


6       library TCBInfoStruct {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/TCBInfoStruct.sol#L6:6

```solidity
File: contracts/automata-attestation/lib/interfaces/IPEMCertChainLib.sol


6       interface IPEMCertChainLib {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/interfaces/IPEMCertChainLib.sol#L6:6

```solidity
File: contracts/automata-attestation/utils/Asn1Decode.sol


12      library NodePtr {


38      library Asn1Decode {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/Asn1Decode.sol#L38:38

```solidity
File: contracts/automata-attestation/utils/BytesUtils.sol


8       library BytesUtils {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/BytesUtils.sol#L8:8

```solidity
File: contracts/automata-attestation/utils/RsaVerify.sol


34      library RsaVerify {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/RsaVerify.sol#L34:34

```solidity
File: contracts/automata-attestation/utils/SHA1.sol


10      library SHA1 {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/SHA1.sol#L10:10

```solidity
File: contracts/automata-attestation/utils/SigVerifyLib.sol


15      contract SigVerifyLib is ISigVerifyLib {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/SigVerifyLib.sol#L15:15

```solidity
File: contracts/automata-attestation/utils/X509DateUtils.sol


7       library X509DateUtils {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/X509DateUtils.sol#L7:7

```solidity
File: contracts/common/EssentialContract.sol


10      abstract contract EssentialContract is UUPSUpgradeable, Ownable2StepUpgradeable, AddressResolver {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/common/EssentialContract.sol#L10:10

```solidity
File: contracts/libs/LibAddress.sol


13      library LibAddress {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/libs/LibAddress.sol#L13:13

```solidity
File: contracts/libs/LibMath.sol


7       library LibMath {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/libs/LibMath.sol#L7:7

```solidity
File: contracts/libs/LibTrieProof.sol


15      library LibTrieProof {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/libs/LibTrieProof.sol#L15:15

```solidity
File: contracts/signal/LibSignals.sol


6       library LibSignals {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/signal/LibSignals.sol#L6:6

```solidity
File: contracts/team/airdrop/ERC721Airdrop.sol


9       contract ERC721Airdrop is MerkleClaimable {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/airdrop/ERC721Airdrop.sol#L9:9

```solidity
File: contracts/thirdparty/nomad-xyz/ExcessivelySafeCall.sol


5       library ExcessivelySafeCall {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/nomad-xyz/ExcessivelySafeCall.sol#L5:5

```solidity
File: contracts/thirdparty/optimism/rlp/RLPWriter.sol


9       library RLPWriter {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/rlp/RLPWriter.sol#L9:9

```solidity
File: contracts/thirdparty/solmate/LibFixedPointMath.sol


6       library LibFixedPointMath {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/solmate/LibFixedPointMath.sol#L6:6

```solidity
File: contracts/tokenvault/BridgedERC20Base.sol


9       abstract contract BridgedERC20Base is EssentialContract, IBridgedERC20 {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC20Base.sol#L9:9

```solidity
File: contracts/tokenvault/LibBridgedToken.sol


8       library LibBridgedToken {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/LibBridgedToken.sol#L8:8

```solidity
File: contracts/tokenvault/adapters/USDCAdapter.sol


8       interface IUSDC {


28      contract USDCAdapter is BridgedERC20Base {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/adapters/USDCAdapter.sol#L28:28

```solidity
File: contracts/verifiers/GuardianVerifier.sol


10      contract GuardianVerifier is EssentialContract, IVerifier {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/verifiers/GuardianVerifier.sol#L10:10

</details>

## NC023 - Error declarations should have NatSpec descriptions:




<details>
<summary>Click to show 160 findings</summary>

```solidity
File: contracts/L1/TaikoErrors.sol


12          error L1_ALREADY_CONTESTED();


13          error L1_ALREADY_PROVED();


14          error L1_ASSIGNED_PROVER_NOT_ALLOWED();


15          error L1_BLOB_FOR_DA_DISABLED();


16          error L1_BLOB_NOT_FOUND();


17          error L1_BLOB_NOT_REUSABLE();


18          error L1_BLOB_REUSE_DISABLED();


19          error L1_BLOCK_MISMATCH();


20          error L1_INVALID_BLOCK_ID();


21          error L1_INVALID_CONFIG();


22          error L1_INVALID_ETH_DEPOSIT();


23          error L1_INVALID_HOOK();


24          error L1_INVALID_PARAM();


25          error L1_INVALID_PAUSE_STATUS();


26          error L1_INVALID_PROVER();


27          error L1_INVALID_TIER();


28          error L1_INVALID_TRANSITION();


29          error L1_LIVENESS_BOND_NOT_RECEIVED();


30          error L1_NOT_ASSIGNED_PROVER();


31          error L1_PROPOSER_NOT_EOA();


32          error L1_PROVING_PAUSED();


33          error L1_RECEIVE_DISABLED();


34          error L1_MISSING_VERIFIER();


35          error L1_TOO_MANY_BLOCKS();


36          error L1_TOO_MANY_TIERS();


37          error L1_TRANSITION_ID_ZERO();


38          error L1_TRANSITION_NOT_FOUND();


39          error L1_TXLIST_SIZE();


40          error L1_UNAUTHORIZED();


41          error L1_UNEXPECTED_PARENT();


42          error L1_UNEXPECTED_TRANSITION_ID();


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/TaikoErrors.sol#L42:42

```solidity
File: contracts/L1/TaikoToken.sol


18          error TKO_INVALID_ADDR();


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/TaikoToken.sol#L18:18

```solidity
File: contracts/L1/gov/TaikoGovernor.sol


25          error TG_INVALID_SIGNATURES_LENGTH();


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/gov/TaikoGovernor.sol#L25:25

```solidity
File: contracts/L1/hooks/AssignmentHook.sol


50          error HOOK_ASSIGNMENT_EXPIRED();


51          error HOOK_ASSIGNMENT_INVALID_SIG();


52          error HOOK_TIER_NOT_FOUND();


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/hooks/AssignmentHook.sol#L52:52

```solidity
File: contracts/L1/libs/LibProposing.sol


44          error L1_BLOB_FOR_DA_DISABLED();


45          error L1_BLOB_NOT_FOUND();


46          error L1_BLOB_NOT_REUSABLE();


47          error L1_BLOB_REUSE_DISABLED();


48          error L1_INVALID_HOOK();


49          error L1_INVALID_PARAM();


50          error L1_INVALID_PROVER();


51          error L1_LIVENESS_BOND_NOT_RECEIVED();


52          error L1_PROPOSER_NOT_EOA();


53          error L1_TOO_MANY_BLOCKS();


54          error L1_TXLIST_OFFSET();


55          error L1_TXLIST_SIZE();


56          error L1_UNAUTHORIZED();


57          error L1_UNEXPECTED_PARENT();


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProposing.sol#L57:57

```solidity
File: contracts/L1/libs/LibProving.sol


59          error L1_ALREADY_CONTESTED();


60          error L1_ALREADY_PROVED();


61          error L1_ASSIGNED_PROVER_NOT_ALLOWED();


62          error L1_BLOCK_MISMATCH();


63          error L1_INVALID_BLOCK_ID();


64          error L1_INVALID_PAUSE_STATUS();


65          error L1_INVALID_TIER();


66          error L1_INVALID_TRANSITION();


67          error L1_MISSING_VERIFIER();


68          error L1_NOT_ASSIGNED_PROVER();


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProving.sol#L68:68

```solidity
File: contracts/L1/libs/LibUtils.sol


11          error L1_BLOCK_MISMATCH();


12          error L1_INVALID_BLOCK_ID();


13          error L1_TRANSITION_NOT_FOUND();


14          error L1_UNEXPECTED_TRANSITION_ID();


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibUtils.sol#L14:14

```solidity
File: contracts/L1/libs/LibVerifying.sol


39          error L1_BLOCK_MISMATCH();


40          error L1_INVALID_CONFIG();


41          error L1_TRANSITION_ID_ZERO();


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibVerifying.sol#L41:41

```solidity
File: contracts/L1/provers/Guardians.sol


45          error INVALID_GUARDIAN();


46          error INVALID_GUARDIAN_SET();


47          error INVALID_MIN_GUARDIANS();


48          error INVALID_PROOF();


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/provers/Guardians.sol#L48:48

```solidity
File: contracts/L1/tiers/ITierProvider.sol


17          error TIER_NOT_FOUND();


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/tiers/ITierProvider.sol#L17:17

```solidity
File: contracts/L2/CrossChainOwned.sol


28          error XCO_INVALID_OWNER_CHAINID();


29          error XCO_INVALID_TX_ID();


30          error XCO_PERMISSION_DENIED();


31          error XCO_TX_REVERTED();


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/CrossChainOwned.sol#L31:31

```solidity
File: contracts/L2/Lib1559Math.sol


11          error EIP1559_INVALID_PARAMS();


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/Lib1559Math.sol#L11:11

```solidity
File: contracts/L2/TaikoL2.sol


59          error L2_BASEFEE_MISMATCH();


60          error L2_INVALID_CHAIN_ID();


61          error L2_INVALID_PARAM();


62          error L2_INVALID_SENDER();


63          error L2_PUBLIC_INPUT_HASH_MISMATCH();


64          error L2_TOO_LATE();


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/TaikoL2.sol#L64:64

```solidity
File: contracts/L2/TaikoL2EIP1559Configurable.sol


20          error L2_INVALID_CONFIG();


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/TaikoL2EIP1559Configurable.sol#L20:20

```solidity
File: contracts/bridge/Bridge.sol


50          error B_INVALID_CHAINID();


51          error B_INVALID_CONTEXT();


52          error B_INVALID_GAS_LIMIT();


53          error B_INVALID_STATUS();


54          error B_INVALID_USER();


55          error B_INVALID_VALUE();


56          error B_MESSAGE_NOT_SENT();


57          error B_NON_RETRIABLE();


58          error B_NOT_FAILED();


59          error B_NOT_RECEIVED();


60          error B_PERMISSION_DENIED();


61          error B_STATUS_MISMATCH();


62          error B_INVOCATION_TOO_EARLY();


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/Bridge.sol#L62:62

```solidity
File: contracts/common/AddressManager.sol


25          error AM_INVALID_PARAMS();


26          error AM_UNSUPPORTED();


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/common/AddressManager.sol#L26:26

```solidity
File: contracts/common/AddressResolver.sol


16          error RESOLVER_DENIED();


17          error RESOLVER_INVALID_MANAGER();


18          error RESOLVER_UNEXPECTED_CHAINID();


19          error RESOLVER_ZERO_ADDR(uint64 chainId, bytes32 name);


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/common/AddressResolver.sol#L19:19

```solidity
File: contracts/common/EssentialContract.sol


35          error REENTRANT_CALL();


36          error INVALID_PAUSE_STATUS();


37          error ZERO_ADDR_MANAGER();


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/common/EssentialContract.sol#L37:37

```solidity
File: contracts/libs/Lib4844.sol


19          error EVAL_FAILED_1();


20          error EVAL_FAILED_2();


21          error POINT_X_TOO_LARGE();


22          error POINT_Y_TOO_LARGE();


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/libs/Lib4844.sol#L22:22

```solidity
File: contracts/libs/LibAddress.sol


16          error ETH_TRANSFER_FAILED();


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/libs/LibAddress.sol#L16:16

```solidity
File: contracts/libs/LibTrieProof.sol


20          error LTP_INVALID_ACCOUNT_PROOF();


21          error LTP_INVALID_INCLUSION_PROOF();


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/libs/LibTrieProof.sol#L21:21

```solidity
File: contracts/signal/SignalService.sol


25          error SS_EMPTY_PROOF();


26          error SS_INVALID_SENDER();


27          error SS_INVALID_LAST_HOP_CHAINID();


28          error SS_INVALID_MID_HOP_CHAINID();


29          error SS_INVALID_STATE();


30          error SS_INVALID_VALUE();


31          error SS_SIGNAL_NOT_FOUND();


32          error SS_UNAUTHORIZED();


33          error SS_UNSUPPORTED();


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/signal/SignalService.sol#L33:33

```solidity
File: contracts/team/TimelockTokenPool.sol


101         error ALREADY_GRANTED();


102         error INVALID_GRANT();


103         error INVALID_PARAM();


104         error NOTHING_TO_VOID();


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/TimelockTokenPool.sol#L104:104

```solidity
File: contracts/team/airdrop/ERC20Airdrop2.sol


37          error WITHDRAWALS_NOT_ONGOING();


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/airdrop/ERC20Airdrop2.sol#L37:37

```solidity
File: contracts/team/airdrop/MerkleClaimable.sol


29          error CLAIM_NOT_ONGOING();


30          error CLAIMED_ALREADY();


31          error INVALID_PROOF();


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/airdrop/MerkleClaimable.sol#L31:31

```solidity
File: contracts/thirdparty/solmate/LibFixedPointMath.sol


10          error Overflow();


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/solmate/LibFixedPointMath.sol#L10:10

```solidity
File: contracts/tokenvault/BaseNFTVault.sol


133         error VAULT_INVALID_TOKEN();


134         error VAULT_INVALID_AMOUNT();


135         error VAULT_INVALID_TO();


136         error VAULT_INTERFACE_NOT_SUPPORTED();


137         error VAULT_TOKEN_ARRAY_MISMATCH();


138         error VAULT_MAX_TOKEN_PER_TXN_EXCEEDED();


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BaseNFTVault.sol#L138:138

```solidity
File: contracts/tokenvault/BaseVault.sol


20          error VAULT_PERMISSION_DENIED();


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BaseVault.sol#L20:20

```solidity
File: contracts/tokenvault/BridgedERC1155.sol


29          error BTOKEN_CANNOT_RECEIVE();


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC1155.sol#L29:29

```solidity
File: contracts/tokenvault/BridgedERC20.sol


34          error BTOKEN_CANNOT_RECEIVE();


35          error BTOKEN_UNAUTHORIZED();


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC20.sol#L35:35

```solidity
File: contracts/tokenvault/BridgedERC20Base.sol


29          error BB_PERMISSION_DENIED();


30          error BB_INVALID_PARAMS();


31          error BB_MINT_DISALLOWED();


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC20Base.sol#L31:31

```solidity
File: contracts/tokenvault/BridgedERC721.sol


21          error BTOKEN_CANNOT_RECEIVE();


22          error BTOKEN_INVALID_BURN();


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC721.sol#L22:22

```solidity
File: contracts/tokenvault/ERC20Vault.sol


136         error VAULT_BTOKEN_BLACKLISTED();


137         error VAULT_CTOKEN_MISMATCH();


138         error VAULT_INVALID_TOKEN();


139         error VAULT_INVALID_AMOUNT();


140         error VAULT_INVALID_NEW_BTOKEN();


141         error VAULT_INVALID_TO();


142         error VAULT_NOT_SAME_OWNER();


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC20Vault.sol#L142:142

```solidity
File: contracts/tokenvault/LibBridgedToken.sol


9           error BTOKEN_INVALID_PARAMS();


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/LibBridgedToken.sol#L9:9

```solidity
File: contracts/verifiers/GuardianVerifier.sol


13          error PERMISSION_DENIED();


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/verifiers/GuardianVerifier.sol#L13:13

```solidity
File: contracts/verifiers/SgxVerifier.sol


74          error SGX_ALREADY_ATTESTED();


75          error SGX_INVALID_ATTESTATION();


76          error SGX_INVALID_INSTANCE();


77          error SGX_INVALID_PROOF();


78          error SGX_RA_NOT_SUPPORTED();


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/verifiers/SgxVerifier.sol#L78:78

</details>

## NC024 - Inconsistent spacing in comments:

Some lines use // x and some use //x. The instances below point out the usages that don't follow the majority, within each file.


<details>
<summary>Click to show 12 findings</summary>

```solidity
File: contracts/automata-attestation/AutomataDcapV3Attestation.sol


1       //SPDX-License-Identifier: MIT


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/AutomataDcapV3Attestation.sol#L1:1

```solidity
File: contracts/automata-attestation/interfaces/IAttestation.sol


1       //SPDX-License-Identifier: MIT


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/interfaces/IAttestation.sol#L1:1

```solidity
File: contracts/automata-attestation/interfaces/ISigVerifyLib.sol


1       //SPDX-License-Identifier: MIT


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/interfaces/ISigVerifyLib.sol#L1:1

```solidity
File: contracts/automata-attestation/lib/EnclaveIdStruct.sol


1       //SPDX-License-Identifier: MIT


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/EnclaveIdStruct.sol#L1:1

```solidity
File: contracts/automata-attestation/lib/QuoteV3Auth/V3Parser.sol


1       //SPDX-License-Identifier: MIT


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/QuoteV3Auth/V3Parser.sol#L1:1

```solidity
File: contracts/automata-attestation/lib/QuoteV3Auth/V3Struct.sol


1       //SPDX-License-Identifier: MIT


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/QuoteV3Auth/V3Struct.sol#L1:1

```solidity
File: contracts/automata-attestation/lib/TCBInfoStruct.sol


1       //SPDX-License-Identifier: MIT


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/TCBInfoStruct.sol#L1:1

```solidity
File: contracts/thirdparty/optimism/Bytes.sol


67                      //update free-memory pointer


68                      //allocating the array padded to 32 bytes like the compiler does now


71                  //if we want a zero-length slice let's just return a zero-length array


75                      //zero out the 32 bytes slice we are about to return


76                      //we need to do it because Solidity does not garbage collect


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/Bytes.sol#L76:76

</details>

## NC025 - Contract does not follow the Solidity style guide's suggested layout ordering:

The [style guide](https://docs.soliditylang.org/en/v0.8.16/style-guide.html#order-of-layout) says that, within a contract, the ordering should be 1) Type declarations, 2) State variables, 3) Events, 4) Modifiers, and 5) Functions, but the contract(s) below do not follow this ordering.


```solidity
File: contracts/automata-attestation/AutomataDcapV3Attestation.sol


60          modifier onlyOwner() {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/AutomataDcapV3Attestation.sol#L60:60

## NC026 - Non-external/public variable names should begin with an underscore:

According to the Solidity Style Guide, non-external/public variable names should begin with an underscore


```solidity
File: contracts/automata-attestation/utils/SigVerifyLib.sol


18          address private ES256VERIFIER;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/SigVerifyLib.sol#L18:18

## NC027 - Consider disabling `renounceOwnership()`:

If the plan for your project does not include eventually giving up all ownership control, consider overwriting OpenZeppelin's Ownable's `renounceOwnership()` function in order to disable it.


```solidity
File: contracts/common/EssentialContract.sol


10      abstract contract EssentialContract is UUPSUpgradeable, Ownable2StepUpgradeable, AddressResolver {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/common/EssentialContract.sol#L10:10

## NC028 - Not using the named return variables anywhere in the function is confusing:

Consider changing the return variable to be an unnamed one, since the variable is never assigned, nor is it returned by name


<details>
<summary>Click to show 10 findings</summary>

```solidity
File: contracts/L1/libs/LibProving.sol


100             returns (uint8 maxBlocksToVerify_)


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProving.sol#L100:100

```solidity
File: contracts/automata-attestation/AutomataDcapV3Attestation.sol


130             returns (bool valid)


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/AutomataDcapV3Attestation.sol#L130:130

```solidity
File: contracts/automata-attestation/lib/PEMCertChainLib.sol


219             returns (bool success, bytes memory extracted, uint256 endIndex)


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/PEMCertChainLib.sol#L219:219

```solidity
File: contracts/automata-attestation/utils/BytesUtils.sol


188         function readUint8(bytes memory self, uint256 idx) internal pure returns (uint8 ret) {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/BytesUtils.sol#L188:188

```solidity
File: contracts/automata-attestation/utils/SigVerifyLib.sol


120             returns (bool sigValid)


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/SigVerifyLib.sol#L120:120

```solidity
File: contracts/bridge/Bridge.sol


421             returns (uint256 invocationDelay_, uint256 invocationExtraDelay_)


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/Bridge.sol#L421:421

```solidity
File: contracts/common/AddressResolver.sol


37              returns (address payable)


51              returns (address payable)


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/common/AddressResolver.sol#L51:51

```solidity
File: contracts/thirdparty/optimism/rlp/RLPReader.sol


147             returns (uint256 offset_, uint256 length_, RLPItemType type_)


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/rlp/RLPReader.sol#L147:147

```solidity
File: contracts/thirdparty/optimism/trie/MerkleTrie.sol


241             returns (uint256 shared_)


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/trie/MerkleTrie.sol#L241:241

</details>

## NC029 - Expressions for constant values such as a call to `keccak256()`, should use `immutable` rather than `constant`:

While it **doesn't save any gas** because the compiler knows that developers often make this mistake, it's still best to use the right tool for the task at hand. There is a difference between `constant` variables and `immutable` variables, and they should each be used in their appropriate contexts. `constants` should be used for literal values written into the code, and `immutable` variables should be used for expressions, or values calculated in, or passed into the constructor.


```solidity
File: contracts/L1/libs/LibProving.sol


20          bytes32 public constant RETURN_LIVENESS_BOND = keccak256("RETURN_LIVENESS_BOND");


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProving.sol#L20:20

```solidity
File: contracts/signal/LibSignals.sol


8           bytes32 public constant STATE_ROOT = keccak256("STATE_ROOT");


11          bytes32 public constant SIGNAL_ROOT = keccak256("SIGNAL_ROOT");


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/signal/LibSignals.sol#L11:11

## NC030 - Empty Function Body - Consider commenting why:




<details>
<summary>Click to show 4 findings</summary>

```solidity
File: contracts/L1/TaikoL1.sol


220         function _authorizePause(address)
221             internal
222             view
223             virtual
224             override
225             onlyFromOwnerOrNamed("chain_pauser")
226         { }


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/TaikoL1.sol#L220:226

```solidity
File: contracts/bridge/Bridge.sol


461         function _authorizePause(address)
462             internal
463             view
464             virtual
465             override
466             onlyFromOwnerOrNamed("bridge_pauser")
467         { }


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/Bridge.sol#L461:467

```solidity
File: contracts/common/EssentialContract.sol


114         function _authorizeUpgrade(address) internal virtual override onlyOwner { }


116         function _authorizePause(address) internal virtual onlyOwner { }


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/common/EssentialContract.sol#L116:116

</details>

## NC031 - Contracts should have full test coverage:

While 100% code coverage does not guarantee that there are no bugs, it often will catch easy-to-find bugs, and will ensure that there are fewer regressions when the code invariably has to be modified. Furthermore, in order to get full coverage, code authors will often have to re-organize their code so that it is more modular, so that each component can be tested separately, which reduces interdependencies between modules and layers, and makes for code that is easier to reason about and audit.


```solidity
File: Various Files


None

```

## NC032 - Large or complicated code bases should implement invariant tests:

Large code bases, or code with lots of inline-assembly, complicated math, or complicated interactions between multiple contracts, should implement invariant fuzzing tests. Invariant fuzzers such as Echidna require the test writer to come up with invariants which should not be violated under any circumstances, and the fuzzer tests various inputs and function calls to ensure that the invariants always hold. Even code with 100% code coverage can still have bugs due to the order of the operations a user performs, and invariant fuzzers, with properly and extensively-written invariants, can close this testing gap significantly.


```solidity
File: Various Files


None

```

## NC033 - Long functions should be refactored into multiple, smaller, functions:




<details>
<summary>Click to show 24 findings</summary>

```solidity
File: contracts/L1/hooks/AssignmentHook.sol


62          function onBlockProposed(
63              TaikoData.Block memory _blk,
64              TaikoData.BlockMetadata memory _meta,
65              bytes memory _data
66          )
67              external
68              payable
69              nonReentrant
70              onlyFromNamed("taiko")
71          {
72              // Note that
73              // - 'msg.sender' is the TaikoL1 contract address
74              // - 'block.coinbase' is the L1 block builder
75              // - 'meta.coinbase' is the L2 block proposer
76      
77              Input memory input = abi.decode(_data, (Input));
78              ProverAssignment memory assignment = input.assignment;
79      
80              // Check assignment validity
81              if (
82                  block.timestamp > assignment.expiry
83                      || assignment.metaHash != 0 && _blk.metaHash != assignment.metaHash
84                      || assignment.parentMetaHash != 0 && _meta.parentMetaHash != assignment.parentMetaHash
85                      || assignment.maxBlockId != 0 && _meta.id > assignment.maxBlockId
86                      || assignment.maxProposedIn != 0 && block.number > assignment.maxProposedIn
87              ) {
88                  revert HOOK_ASSIGNMENT_EXPIRED();
89              }
90      
91              // Hash the assignment with the blobHash, this hash will be signed by
92              // the prover, therefore, we add a string as a prefix.
93              address taikoL1Address = msg.sender;
94              bytes32 hash = hashAssignment(assignment, taikoL1Address, _meta.blobHash);
95      
96              if (!_blk.assignedProver.isValidSignature(hash, assignment.signature)) {
97                  revert HOOK_ASSIGNMENT_INVALID_SIG();
98              }
99      
100             // Send the liveness bond to the Taiko contract
101             IERC20 tko = IERC20(resolve("taiko_token", false));
102             tko.transferFrom(_blk.assignedProver, taikoL1Address, _blk.livenessBond);
103     
104             // Find the prover fee using the minimal tier
105             uint256 proverFee = _getProverFee(assignment.tierFees, _meta.minTier);
106     
107             // The proposer irrevocably pays a fee to the assigned prover, either in
108             // Ether or ERC20 tokens.
109             if (assignment.feeToken == address(0)) {
110                 // Paying Ether
111                 _blk.assignedProver.sendEther(proverFee, MAX_GAS_PAYING_PROVER);
112             } else {
113                 // Paying ERC20 tokens
114                 IERC20(assignment.feeToken).safeTransferFrom(
115                     _meta.coinbase, _blk.assignedProver, proverFee
116                 );
117             }
118     
119             // block.coinbase can be address(0) in tests
120             if (input.tip != 0 && block.coinbase != address(0)) {
121                 address(block.coinbase).sendEther(input.tip);
122             }
123     
124             // Send all remaining Ether back to TaikoL1 contract
125             if (address(this).balance > 0) {
126                 taikoL1Address.sendEther(address(this).balance);
127             }
128     
129             emit BlockAssigned(_blk.assignedProver, _meta, assignment);
130         }


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/hooks/AssignmentHook.sol#L62:130

```solidity
File: contracts/L1/libs/LibDepositing.sol


67          function processDeposits(
68              TaikoData.State storage _state,
69              TaikoData.Config memory _config,
70              address _feeRecipient
71          )
72              internal
73              returns (TaikoData.EthDeposit[] memory deposits_)
74          {
75              // Calculate the number of pending deposits.
76              uint256 numPending = _state.slotA.numEthDeposits - _state.slotA.nextEthDepositToProcess;
77      
78              if (numPending < _config.ethDepositMinCountPerBlock) {
79                  deposits_ = new TaikoData.EthDeposit[](0);
80              } else {
81                  deposits_ =
82                      new TaikoData.EthDeposit[](numPending.min(_config.ethDepositMaxCountPerBlock));
83                  uint96 fee = uint96(_config.ethDepositMaxFee.min(block.basefee * _config.ethDepositGas));
84                  uint64 j = _state.slotA.nextEthDepositToProcess;
85                  uint96 totalFee;
86                  for (uint256 i; i < deposits_.length;) {
87                      uint256 data = _state.ethDeposits[j % _config.ethDepositRingBufferSize];
88                      deposits_[i] = TaikoData.EthDeposit({
89                          recipient: address(uint160(data >> 96)),
90                          amount: uint96(data),
91                          id: j
92                      });
93                      uint96 _fee = deposits_[i].amount > fee ? fee : deposits_[i].amount;
94      
95                      // Unchecked is safe:
96                      // - _fee cannot be bigger than deposits_[i].amount
97                      // - all values are in the same range (uint96) except loop
98                      // counter, which obviously cannot be bigger than uint95
99                      // otherwise the function would be gassing out.
100                     unchecked {
101                         deposits_[i].amount -= _fee;
102                         totalFee += _fee;
103                         ++i;
104                         ++j;
105                     }
106                 }
107                 _state.slotA.nextEthDepositToProcess = j;
108                 // This is the fee deposit
109                 _state.ethDeposits[_state.slotA.numEthDeposits % _config.ethDepositRingBufferSize] =
110                     _encodeEthDeposit(_feeRecipient, totalFee);
111     
112                 // Unchecked is safe:
113                 // - uint64 can store up to ~1.8 * 1e19, which can represent 584K
114                 // years if we are depositing at every second
115                 unchecked {
116                     _state.slotA.numEthDeposits++;
117                 }
118             }
119         }


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibDepositing.sol#L67:119

```solidity
File: contracts/L1/libs/LibProposing.sol


68          function proposeBlock(
69              TaikoData.State storage _state,
70              TaikoData.Config memory _config,
71              IAddressResolver _resolver,
72              bytes calldata _data,
73              bytes calldata _txList
74          )
75              internal
76              returns (TaikoData.BlockMetadata memory meta_, TaikoData.EthDeposit[] memory deposits_)
77          {
78              TaikoData.BlockParams memory params = abi.decode(_data, (TaikoData.BlockParams));
79      
80              // We need a prover that will submit proofs after the block has been submitted
81              if (params.assignedProver == address(0)) {
82                  revert L1_INVALID_PROVER();
83              }
84      
85              if (params.coinbase == address(0)) {
86                  params.coinbase = msg.sender;
87              }
88      
89              // Taiko, as a Based Rollup, enables permissionless block proposals.
90              // However, if the "proposer" address is set to a non-zero value, we
91              // ensure that only that specific address has the authority to propose
92              // blocks.
93              TaikoData.SlotB memory b = _state.slotB;
94              if (!_isProposerPermitted(b, _resolver)) revert L1_UNAUTHORIZED();
95      
96              // It's essential to ensure that the ring buffer for proposed blocks
97              // still has space for at least one more block.
98              if (b.numBlocks >= b.lastVerifiedBlockId + _config.blockMaxProposals + 1) {
99                  revert L1_TOO_MANY_BLOCKS();
100             }
101     
102             bytes32 parentMetaHash =
103                 _state.blocks[(b.numBlocks - 1) % _config.blockRingBufferSize].metaHash;
104     
105             // Check if parent block has the right meta hash
106             // This is to allow the proposer to make sure the block builds on the expected latest chain
107             // state
108             if (params.parentMetaHash != 0 && parentMetaHash != params.parentMetaHash) {
109                 revert L1_UNEXPECTED_PARENT();
110             }
111     
112             // Each transaction must handle a specific quantity of L1-to-L2
113             // Ether deposits.
114             deposits_ = LibDepositing.processDeposits(_state, _config, params.coinbase);
115     
116             // Initialize metadata to compute a metaHash, which forms a part of
117             // the block data to be stored on-chain for future integrity checks.
118             // If we choose to persist all data fields in the metadata, it will
119             // require additional storage slots.
120             unchecked {
121                 meta_ = TaikoData.BlockMetadata({
122                     l1Hash: blockhash(block.number - 1),
123                     difficulty: 0, // to be initialized below
124                     blobHash: 0, // to be initialized below
125                     extraData: params.extraData,
126                     depositsHash: keccak256(abi.encode(deposits_)),
127                     coinbase: params.coinbase,
128                     id: b.numBlocks,
129                     gasLimit: _config.blockMaxGasLimit,
130                     timestamp: uint64(block.timestamp),
131                     l1Height: uint64(block.number - 1),
132                     txListByteOffset: 0, // to be initialized below
133                     txListByteSize: 0, // to be initialized below
134                     minTier: 0, // to be initialized below
135                     blobUsed: _txList.length == 0,
136                     parentMetaHash: parentMetaHash
137                 });
138             }
139     
140             // Update certain meta fields
141             if (meta_.blobUsed) {
142                 if (!_config.blobAllowedForDA) revert L1_BLOB_FOR_DA_DISABLED();
143     
144                 if (params.blobHash != 0) {
145                     if (!_config.blobReuseEnabled) revert L1_BLOB_REUSE_DISABLED();
146     
147                     // We try to reuse an old blob
148                     if (!isBlobReusable(_state, _config, params.blobHash)) {
149                         revert L1_BLOB_NOT_REUSABLE();
150                     }
151                     meta_.blobHash = params.blobHash;
152                 } else {
153                     // Always use the first blob in this transaction. If the
154                     // proposeBlock functions are called more than once in the same
155                     // L1 transaction, these multiple L2 blocks will share the same
156                     // blob.
157                     meta_.blobHash = blobhash(0);
158     
159                     if (meta_.blobHash == 0) revert L1_BLOB_NOT_FOUND();
160     
161                     // Depends on the blob data price, it may not make sense to
162                     // cache the blob which costs 20,000 (sstore) + 631 (event)
163                     // extra gas.
164                     if (_config.blobReuseEnabled && params.cacheBlobForReuse) {
165                         _state.reusableBlobs[meta_.blobHash] = block.timestamp;
166                         emit BlobCached(meta_.blobHash);
167                     }
168                 }
169     
170                 // Check that the txList data range is within the max size of a blob
171                 if (uint256(params.txListByteOffset) + params.txListByteSize > MAX_BYTES_PER_BLOB) {
172                     revert L1_TXLIST_OFFSET();
173                 }
174     
175                 meta_.txListByteOffset = params.txListByteOffset;
176                 meta_.txListByteSize = params.txListByteSize;
177             } else {
178                 // The proposer must be an Externally Owned Account (EOA) for
179                 // calldata usage. This ensures that the transaction is not an
180                 // internal one, making calldata retrieval more straightforward for
181                 // Taiko node software.
182                 if (!LibAddress.isSenderEOA()) revert L1_PROPOSER_NOT_EOA();
183     
184                 // The txList is the full byte array without any offset
185                 if (params.txListByteOffset != 0) {
186                     revert L1_INVALID_PARAM();
187                 }
188     
189                 meta_.blobHash = keccak256(_txList);
190                 meta_.txListByteOffset = 0;
191                 meta_.txListByteSize = uint24(_txList.length);
192             }
193     
194             // Check that the tx length is non-zero and within the supported range
195             if (meta_.txListByteSize == 0 || meta_.txListByteSize > _config.blockMaxTxListBytes) {
196                 revert L1_TXLIST_SIZE();
197             }
198     
199             // Following the Merge, the L1 mixHash incorporates the
200             // prevrandao value from the beacon chain. Given the possibility
201             // of multiple Taiko blocks being proposed within a single
202             // Ethereum block, we choose to introduce a salt to this random
203             // number as the L2 mixHash.
204             meta_.difficulty = keccak256(abi.encodePacked(block.prevrandao, b.numBlocks, block.number));
205     
206             // Use the difficulty as a random number
207             meta_.minTier = ITierProvider(_resolver.resolve("tier_provider", false)).getMinTier(
208                 uint256(meta_.difficulty)
209             );
210     
211             // Create the block that will be stored onchain
212             TaikoData.Block memory blk = TaikoData.Block({
213                 metaHash: keccak256(abi.encode(meta_)),
214                 // Safeguard the liveness bond to ensure its preservation,
215                 // particularly in scenarios where it might be altered after the
216                 // block's proposal but before it has been proven or verified.
217                 livenessBond: _config.livenessBond,
218                 blockId: b.numBlocks,
219                 proposedAt: meta_.timestamp,
220                 proposedIn: uint64(block.number),
221                 // For a new block, the next transition ID is always 1, not 0.
222                 nextTransitionId: 1,
223                 // For unverified block, its verifiedTransitionId is always 0.
224                 verifiedTransitionId: 0,
225                 assignedProver: params.assignedProver
226             });
227     
228             // Store the block in the ring buffer
229             _state.blocks[b.numBlocks % _config.blockRingBufferSize] = blk;
230     
231             // Increment the counter (cursor) by 1.
232             unchecked {
233                 ++_state.slotB.numBlocks;
234             }
235     
236             {
237                 IERC20 tko = IERC20(_resolver.resolve("taiko_token", false));
238                 uint256 tkoBalance = tko.balanceOf(address(this));
239     
240                 // Run all hooks.
241                 // Note that address(this).balance has been updated with msg.value,
242                 // prior to any code in this function has been executed.
243                 address prevHook;
244                 for (uint256 i; i < params.hookCalls.length; ++i) {
245                     if (uint160(prevHook) >= uint160(params.hookCalls[i].hook)) {
246                         revert L1_INVALID_HOOK();
247                     }
248     
249                     // When a hook is called, all ether in this contract will be send to the hook.
250                     // If the ether sent to the hook is not used entirely, the hook shall send the Ether
251                     // back to this contract for the next hook to use.
252                     // Proposers shall choose use extra hooks wisely.
253                     IHook(params.hookCalls[i].hook).onBlockProposed{ value: address(this).balance }(
254                         blk, meta_, params.hookCalls[i].data
255                     );
256     
257                     prevHook = params.hookCalls[i].hook;
258                 }
259                 // Refund Ether
260                 if (address(this).balance != 0) {
261                     msg.sender.sendEther(address(this).balance);
262                 }
263     
264                 // Check that after hooks, the Taiko Token balance of this contract
265                 // have increased by the same amount as _config.livenessBond (to prevent)
266                 // multiple draining payments by a malicious proposer nesting the same
267                 // hook.
268                 if (tko.balanceOf(address(this)) != tkoBalance + _config.livenessBond) {
269                     revert L1_LIVENESS_BOND_NOT_RECEIVED();
270                 }
271             }
272     
273             emit BlockProposed({
274                 blockId: blk.blockId,
275                 assignedProver: blk.assignedProver,
276                 livenessBond: _config.livenessBond,
277                 meta: meta_,
278                 depositsProcessed: deposits_
279             });
280         }


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProposing.sol#L68:280

```solidity
File: contracts/L1/libs/LibProving.sol


91          function proveBlock(
92              TaikoData.State storage _state,
93              TaikoData.Config memory _config,
94              IAddressResolver _resolver,
95              TaikoData.BlockMetadata memory _meta,
96              TaikoData.Transition memory _tran,
97              TaikoData.TierProof memory _proof
98          )
99              internal
100             returns (uint8 maxBlocksToVerify_)
101         {
102             // Make sure parentHash is not zero
103             // To contest an existing transition, simply use any non-zero value as
104             // the blockHash and stateRoot.
105             if (_tran.parentHash == 0 || _tran.blockHash == 0 || _tran.stateRoot == 0) {
106                 revert L1_INVALID_TRANSITION();
107             }
108     
109             // Check that the block has been proposed but has not yet been verified.
110             TaikoData.SlotB memory b = _state.slotB;
111             if (_meta.id <= b.lastVerifiedBlockId || _meta.id >= b.numBlocks) {
112                 revert L1_INVALID_BLOCK_ID();
113             }
114     
115             uint64 slot = _meta.id % _config.blockRingBufferSize;
116             TaikoData.Block storage blk = _state.blocks[slot];
117     
118             // Check the integrity of the block data. It's worth noting that in
119             // theory, this check may be skipped, but it's included for added
120             // caution.
121             if (blk.blockId != _meta.id || blk.metaHash != keccak256(abi.encode(_meta))) {
122                 revert L1_BLOCK_MISMATCH();
123             }
124     
125             // Each transition is uniquely identified by the parentHash, with the
126             // blockHash and stateRoot open for later updates as higher-tier proofs
127             // become available. In cases where a transition with the specified
128             // parentHash does not exist, the transition ID (tid) will be set to 0.
129             (uint32 tid, TaikoData.TransitionState storage ts) =
130                 _createTransition(_state, blk, _tran, slot);
131     
132             // The new proof must meet or exceed the minimum tier required by the
133             // block or the previous proof; it cannot be on a lower tier.
134             if (_proof.tier == 0 || _proof.tier < _meta.minTier || _proof.tier < ts.tier) {
135                 revert L1_INVALID_TIER();
136             }
137     
138             // Retrieve the tier configurations. If the tier is not supported, the
139             // subsequent action will result in a revert.
140             ITierProvider.Tier memory tier =
141                 ITierProvider(_resolver.resolve("tier_provider", false)).getTier(_proof.tier);
142     
143             // Check if this prover is allowed to submit a proof for this block
144             _checkProverPermission(_state, blk, ts, tid, tier);
145     
146             // We must verify the proof, and any failure in proof verification will
147             // result in a revert.
148             //
149             // It's crucial to emphasize that the proof can be assessed in two
150             // potential modes: "proving mode" and "contesting mode." However, the
151             // precise verification logic is defined within each tier's IVerifier
152             // contract implementation. We simply specify to the verifier contract
153             // which mode it should utilize - if the new tier is higher than the
154             // previous tier, we employ the proving mode; otherwise, we employ the
155             // contesting mode (the new tier cannot be lower than the previous tier,
156             // this has been checked above).
157             //
158             // It's obvious that proof verification is entirely decoupled from
159             // Taiko's core protocol.
160             {
161                 address verifier = _resolver.resolve(tier.verifierName, true);
162     
163                 if (verifier != address(0)) {
164                     bool isContesting = _proof.tier == ts.tier && tier.contestBond != 0;
165     
166                     IVerifier.Context memory ctx = IVerifier.Context({
167                         metaHash: blk.metaHash,
168                         blobHash: _meta.blobHash,
169                         // Separate msgSender to allow the prover to be any address in the future.
170                         prover: msg.sender,
171                         msgSender: msg.sender,
172                         blockId: blk.blockId,
173                         isContesting: isContesting,
174                         blobUsed: _meta.blobUsed
175                     });
176     
177                     IVerifier(verifier).verifyProof(ctx, _tran, _proof);
178                 } else if (tier.verifierName != TIER_OP) {
179                     // The verifier can be address-zero, signifying that there are no
180                     // proof checks for the tier. In practice, this only applies to
181                     // optimistic proofs.
182                     revert L1_MISSING_VERIFIER();
183                 }
184             }
185     
186             bool isTopTier = tier.contestBond == 0;
187             IERC20 tko = IERC20(_resolver.resolve("taiko_token", false));
188     
189             if (isTopTier) {
190                 // A special return value from the top tier prover can signal this
191                 // contract to return all liveness bond.
192                 bool returnLivenessBond = blk.livenessBond > 0 && _proof.data.length == 32
193                     && bytes32(_proof.data) == RETURN_LIVENESS_BOND;
194     
195                 if (returnLivenessBond) {
196                     tko.transfer(blk.assignedProver, blk.livenessBond);
197                     blk.livenessBond = 0;
198                 }
199             }
200     
201             bool sameTransition = _tran.blockHash == ts.blockHash && _tran.stateRoot == ts.stateRoot;
202     
203             if (_proof.tier > ts.tier) {
204                 // Handles the case when an incoming tier is higher than the current transition's tier.
205                 // Reverts when the incoming proof tries to prove the same transition
206                 // (L1_ALREADY_PROVED).
207                 _overrideWithHigherProof(ts, _tran, _proof, tier, tko, sameTransition);
208     
209                 emit TransitionProved({
210                     blockId: blk.blockId,
211                     tran: _tran,
212                     prover: msg.sender,
213                     validityBond: tier.validityBond,
214                     tier: _proof.tier
215                 });
216             } else {
217                 // New transition and old transition on the same tier - and if this transaction tries to
218                 // prove the same, it reverts
219                 if (sameTransition) revert L1_ALREADY_PROVED();
220     
221                 if (isTopTier) {
222                     // The top tier prover re-proves.
223                     assert(tier.validityBond == 0);
224                     assert(ts.validityBond == 0 && ts.contestBond == 0 && ts.contester == address(0));
225     
226                     ts.prover = msg.sender;
227                     ts.blockHash = _tran.blockHash;
228                     ts.stateRoot = _tran.stateRoot;
229     
230                     emit TransitionProved({
231                         blockId: blk.blockId,
232                         tran: _tran,
233                         prover: msg.sender,
234                         validityBond: 0,
235                         tier: _proof.tier
236                     });
237                 } else {
238                     // Contesting but not on the highest tier
239                     if (ts.contester != address(0)) revert L1_ALREADY_CONTESTED();
240     
241                     // Burn the contest bond from the prover.
242                     tko.transferFrom(msg.sender, address(this), tier.contestBond);
243     
244                     // We retain the contest bond within the transition, just in
245                     // case this configuration is altered to a different value
246                     // before the contest is resolved.
247                     //
248                     // It's worth noting that the previous value of ts.contestBond
249                     // doesn't have any significance.
250                     ts.contestBond = tier.contestBond;
251                     ts.contester = msg.sender;
252                     ts.contestations += 1;
253     
254                     emit TransitionContested({
255                         blockId: blk.blockId,
256                         tran: _tran,
257                         contester: msg.sender,
258                         contestBond: tier.contestBond,
259                         tier: _proof.tier
260                     });
261                 }
262             }
263     
264             ts.timestamp = uint64(block.timestamp);
265             return tier.maxBlocksToVerifyPerProof;
266         }


269         function _createTransition(
270             TaikoData.State storage _state,
271             TaikoData.Block storage _blk,
272             TaikoData.Transition memory _tran,
273             uint64 slot
274         )
275             private
276             returns (uint32 tid_, TaikoData.TransitionState storage ts_)
277         {
278             tid_ = LibUtils.getTransitionId(_state, _blk, slot, _tran.parentHash);
279     
280             if (tid_ == 0) {
281                 // In cases where a transition with the provided parentHash is not
282                 // found, we must essentially "create" one and set it to its initial
283                 // state. This initial state can be viewed as a special transition
284                 // on tier-0.
285                 //
286                 // Subsequently, we transform this tier-0 transition into a
287                 // non-zero-tier transition with a proof. This approach ensures that
288                 // the same logic is applicable for both 0-to-non-zero transition
289                 // updates and non-zero-to-non-zero transition updates.
290                 unchecked {
291                     // Unchecked is safe:  Not realistic 2**32 different fork choice
292                     // per block will be proven and none of them is valid
293                     tid_ = _blk.nextTransitionId++;
294                 }
295     
296                 // Keep in mind that state.transitions are also reusable storage
297                 // slots, so it's necessary to reinitialize all transition fields
298                 // below.
299                 ts_ = _state.transitions[slot][tid_];
300                 ts_.blockHash = 0;
301                 ts_.stateRoot = 0;
302                 ts_.validityBond = 0;
303                 ts_.contester = address(0);
304                 ts_.contestBond = 1; // to save gas
305                 ts_.timestamp = _blk.proposedAt;
306                 ts_.tier = 0;
307                 ts_.contestations = 0;
308     
309                 if (tid_ == 1) {
310                     // This approach serves as a cost-saving technique for the
311                     // majority of blocks, where the first transition is expected to
312                     // be the correct one. Writing to `tran` is more economical
313                     // since it resides in the ring buffer, whereas writing to
314                     // `transitionIds` is not as cost-effective.
315                     ts_.key = _tran.parentHash;
316     
317                     // In the case of this first transition, the block's assigned
318                     // prover has the privilege to re-prove it, but only when the
319                     // assigned prover matches the previous prover. To ensure this,
320                     // we establish the transition's prover as the block's assigned
321                     // prover. Consequently, when we carry out a 0-to-non-zero
322                     // transition update, the previous prover will consistently be
323                     // the block's assigned prover.
324                     //
325                     // While alternative implementations are possible, introducing
326                     // such changes would require additional if-else logic.
327                     ts_.prover = _blk.assignedProver;
328                 } else {
329                     // In scenarios where this transition is not the first one, we
330                     // straightforwardly reset the transition prover to address
331                     // zero.
332                     ts_.prover = address(0);
333     
334                     // Furthermore, we index the transition for future retrieval.
335                     // It's worth emphasizing that this mapping for indexing is not
336                     // reusable. However, given that the majority of blocks will
337                     // only possess one transition — the correct one — we don't need
338                     // to be concerned about the cost in this case.
339                     _state.transitionIds[_blk.blockId][_tran.parentHash] = tid_;
340     
341                     // There is no need to initialize ts.key here because it's only used when tid == 1
342                 }
343             } else {
344                 // A transition with the provided parentHash has been located.
345                 ts_ = _state.transitions[slot][tid_];
346             }
347         }


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProving.sol#L269:347

```solidity
File: contracts/L1/libs/LibVerifying.sol


85          function verifyBlocks(
86              TaikoData.State storage _state,
87              TaikoData.Config memory _config,
88              IAddressResolver _resolver,
89              uint64 _maxBlocksToVerify
90          )
91              internal
92          {
93              if (_maxBlocksToVerify == 0) {
94                  return;
95              }
96      
97              // Retrieve the latest verified block and the associated transition used
98              // for its verification.
99              TaikoData.SlotB memory b = _state.slotB;
100             uint64 blockId = b.lastVerifiedBlockId;
101     
102             uint64 slot = blockId % _config.blockRingBufferSize;
103     
104             TaikoData.Block storage blk = _state.blocks[slot];
105             if (blk.blockId != blockId) revert L1_BLOCK_MISMATCH();
106     
107             uint32 tid = blk.verifiedTransitionId;
108     
109             // The following scenario should never occur but is included as a
110             // precaution.
111             if (tid == 0) revert L1_TRANSITION_ID_ZERO();
112     
113             // The `blockHash` variable represents the most recently trusted
114             // blockHash on L2.
115             bytes32 blockHash = _state.transitions[slot][tid].blockHash;
116             bytes32 stateRoot;
117             uint64 numBlocksVerified;
118             address tierProvider;
119     
120             // Unchecked is safe:
121             // - assignment is within ranges
122             // - blockId and numBlocksVerified values incremented will still be OK in the
123             // next 584K years if we verifying one block per every second
124             unchecked {
125                 ++blockId;
126     
127                 while (blockId < b.numBlocks && numBlocksVerified < _maxBlocksToVerify) {
128                     slot = blockId % _config.blockRingBufferSize;
129     
130                     blk = _state.blocks[slot];
131                     if (blk.blockId != blockId) revert L1_BLOCK_MISMATCH();
132     
133                     tid = LibUtils.getTransitionId(_state, blk, slot, blockHash);
134                     // When `tid` is 0, it indicates that there is no proven
135                     // transition with its parentHash equal to the blockHash of the
136                     // most recently verified block.
137                     if (tid == 0) break;
138     
139                     // A transition with the correct `parentHash` has been located.
140                     TaikoData.TransitionState storage ts = _state.transitions[slot][tid];
141     
142                     // It's not possible to verify this block if either the
143                     // transition is contested and awaiting higher-tier proof or if
144                     // the transition is still within its cooldown period.
145                     if (ts.contester != address(0)) {
146                         break;
147                     } else {
148                         if (tierProvider == address(0)) {
149                             tierProvider = _resolver.resolve("tier_provider", false);
150                         }
151                         if (
152                             uint256(ITierProvider(tierProvider).getTier(ts.tier).cooldownWindow) * 60
153                                 + uint256(ts.timestamp).max(_state.slotB.lastUnpausedAt) > block.timestamp
154                         ) {
155                             // If cooldownWindow is 0, the block can theoretically
156                             // be proved and verified within the same L1 block.
157                             break;
158                         }
159                     }
160     
161                     // Mark this block as verified
162                     blk.verifiedTransitionId = tid;
163     
164                     // Update variables
165                     blockHash = ts.blockHash;
166                     stateRoot = ts.stateRoot;
167     
168                     // We consistently return the liveness bond and the validity
169                     // bond to the actual prover of the transition utilized for
170                     // block verification. If the actual prover happens to be the
171                     // block's assigned prover, he will receive both deposits,
172                     // ultimately earning the proving fee paid during block
173                     // proposal. In contrast, if the actual prover is different from
174                     // the block's assigned prover, the liveness bond serves as a
175                     // reward to the actual prover, while the assigned prover
176                     // forfeits his liveness bond due to failure to fulfill their
177                     // commitment.
178                     uint256 bondToReturn = uint256(ts.validityBond) + blk.livenessBond;
179     
180                     // Nevertheless, it's possible for the actual prover to be the
181                     // same individual or entity as the block's assigned prover.
182                     // Consequently, we have chosen to grant the actual prover only
183                     // half of the liveness bond as a reward.
184                     if (ts.prover != blk.assignedProver) {
185                         bondToReturn -= blk.livenessBond >> 1;
186                     }
187     
188                     IERC20 tko = IERC20(_resolver.resolve("taiko_token", false));
189                     tko.transfer(ts.prover, bondToReturn);
190     
191                     // Note: We exclusively address the bonds linked to the
192                     // transition used for verification. While there may exist
193                     // other transitions for this block, we disregard them entirely.
194                     // The bonds for these other transitions are burned either when
195                     // the transitions are generated or proven. In such cases, both
196                     // the provers and contesters of those transitions forfeit their bonds.
197     
198                     emit BlockVerified({
199                         blockId: blockId,
200                         assignedProver: blk.assignedProver,
201                         prover: ts.prover,
202                         blockHash: blockHash,
203                         stateRoot: stateRoot,
204                         tier: ts.tier,
205                         contestations: ts.contestations
206                     });
207     
208                     ++blockId;
209                     ++numBlocksVerified;
210                 }
211     
212                 if (numBlocksVerified > 0) {
213                     uint64 lastVerifiedBlockId = b.lastVerifiedBlockId + numBlocksVerified;
214     
215                     // Update protocol level state variables
216                     _state.slotB.lastVerifiedBlockId = lastVerifiedBlockId;
217     
218                     // sync chain data
219                     _syncChainData(_config, _resolver, lastVerifiedBlockId, stateRoot);
220                 }
221             }
222         }


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibVerifying.sol#L85:222

```solidity
File: contracts/L2/TaikoL2.sol


107         function anchor(
108             bytes32 _l1BlockHash,
109             bytes32 _l1StateRoot,
110             uint64 _l1BlockId,
111             uint32 _parentGasUsed
112         )
113             external
114             nonReentrant
115         {
116             if (
117                 _l1BlockHash == 0 || _l1StateRoot == 0 || _l1BlockId == 0
118                     || (block.number != 1 && _parentGasUsed == 0)
119             ) {
120                 revert L2_INVALID_PARAM();
121             }
122     
123             if (msg.sender != GOLDEN_TOUCH_ADDRESS) revert L2_INVALID_SENDER();
124     
125             uint256 parentId;
126             unchecked {
127                 parentId = block.number - 1;
128             }
129     
130             // Verify ancestor hashes
131             (bytes32 publicInputHashOld, bytes32 publicInputHashNew) = _calcPublicInputHash(parentId);
132             if (publicInputHash != publicInputHashOld) {
133                 revert L2_PUBLIC_INPUT_HASH_MISMATCH();
134             }
135     
136             Config memory config = getConfig();
137     
138             // Verify the base fee per gas is correct
139             uint256 basefee;
140             (basefee, gasExcess) = _calc1559BaseFee(config, _l1BlockId, _parentGasUsed);
141             if (!skipFeeCheck() && block.basefee != basefee) {
142                 revert L2_BASEFEE_MISMATCH();
143             }
144     
145             if (_l1BlockId > lastSyncedBlock + BLOCK_SYNC_THRESHOLD) {
146                 // Store the L1's state root as a signal to the local signal service to
147                 // allow for multi-hop bridging.
148                 ISignalService(resolve("signal_service", false)).syncChainData(
149                     ownerChainId, LibSignals.STATE_ROOT, _l1BlockId, _l1StateRoot
150                 );
151                 lastSyncedBlock = _l1BlockId;
152             }
153             // Update state variables
154             l2Hashes[parentId] = blockhash(parentId);
155             publicInputHash = publicInputHashNew;
156     
157             emit Anchored(blockhash(parentId), gasExcess);
158         }


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/TaikoL2.sol#L107:158

```solidity
File: contracts/automata-attestation/AutomataDcapV3Attestation.sol


248         function _verifyCertChain(IPEMCertChainLib.ECSha256Certificate[] memory certs)
249             private
250             view
251             returns (bool)
252         {
253             uint256 n = certs.length;
254             bool certRevoked;
255             bool certNotExpired;
256             bool verified;
257             bool certChainCanBeTrusted;
258     
259             for (uint256 i; i < n; ++i) {
260                 IPEMCertChainLib.ECSha256Certificate memory issuer;
261                 if (i == n - 1) {
262                     // rootCA
263                     issuer = certs[i];
264                 } else {
265                     issuer = certs[i + 1];
266                     if (i == n - 2) {
267                         // this cert is expected to be signed by the root
268                         certRevoked = _serialNumIsRevoked[uint256(IPEMCertChainLib.CRL.ROOT)][certs[i]
269                             .serialNumber];
270                     } else if (certs[i].isPck) {
271                         certRevoked = _serialNumIsRevoked[uint256(IPEMCertChainLib.CRL.PCK)][certs[i]
272                             .serialNumber];
273                     }
274                     if (certRevoked) {
275                         break;
276                     }
277                 }
278     
279                 certNotExpired =
280                     block.timestamp > certs[i].notBefore && block.timestamp < certs[i].notAfter;
281                 if (!certNotExpired) {
282                     break;
283                 }
284     
285                 verified = sigVerifyLib.verifyES256Signature(
286                     certs[i].tbsCertificate, certs[i].signature, issuer.pubKey
287                 );
288                 if (!verified) {
289                     break;
290                 }
291     
292                 bytes32 issuerPubKeyHash = keccak256(issuer.pubKey);
293     
294                 if (issuerPubKeyHash == ROOTCA_PUBKEY_HASH) {
295                     certChainCanBeTrusted = true;
296                     break;
297                 }
298             }
299     
300             return !certRevoked && certNotExpired && verified && certChainCanBeTrusted;
301         }


364         function _verifyParsedQuote(V3Struct.ParsedV3QuoteStruct memory v3quote)
365             internal
366             view
367             returns (bool, bytes memory)
368         {
369             bytes memory retData = abi.encodePacked(INVALID_EXIT_CODE);
370     
371             // // Step 1: Parse the quote input = 152k gas
372             (
373                 bool successful,
374                 ,
375                 ,
376                 bytes memory signedQuoteData,
377                 V3Struct.ECDSAQuoteV3AuthData memory authDataV3
378             ) = V3Parser.validateParsedInput(v3quote);
379             if (!successful) {
380                 return (false, retData);
381             }
382     
383             // Step 2: Verify application enclave report MRENCLAVE and MRSIGNER
384             {
385                 if (_checkLocalEnclaveReport) {
386                     // 4k gas
387                     bool mrEnclaveIsTrusted =
388                         _trustedUserMrEnclave[v3quote.localEnclaveReport.mrEnclave];
389                     bool mrSignerIsTrusted = _trustedUserMrSigner[v3quote.localEnclaveReport.mrSigner];
390     
391                     if (!mrEnclaveIsTrusted || !mrSignerIsTrusted) {
392                         return (false, retData);
393                     }
394                 }
395             }
396     
397             // Step 3: Verify enclave identity = 43k gas
398             EnclaveIdStruct.EnclaveIdStatus qeTcbStatus;
399             {
400                 bool verifiedEnclaveIdSuccessfully;
401                 (verifiedEnclaveIdSuccessfully, qeTcbStatus) =
402                     _verifyQEReportWithIdentity(v3quote.v3AuthData.pckSignedQeReport);
403                 if (!verifiedEnclaveIdSuccessfully) {
404                     return (false, retData);
405                 }
406                 if (
407                     !verifiedEnclaveIdSuccessfully
408                         || qeTcbStatus == EnclaveIdStruct.EnclaveIdStatus.SGX_ENCLAVE_REPORT_ISVSVN_REVOKED
409                 ) {
410                     return (false, retData);
411                 }
412             }
413     
414             // Step 4: Parse Quote CertChain
415             IPEMCertChainLib.ECSha256Certificate[] memory parsedQuoteCerts;
416             TCBInfoStruct.TCBInfo memory fetchedTcbInfo;
417             {
418                 // 536k gas
419                 parsedQuoteCerts = new IPEMCertChainLib.ECSha256Certificate[](3);
420                 for (uint256 i; i < 3; ++i) {
421                     bool isPckCert = i == 0; // additional parsing for PCKCert
422                     bool certDecodedSuccessfully;
423                     // todo! move decodeCert offchain
424                     (certDecodedSuccessfully, parsedQuoteCerts[i]) = pemCertLib.decodeCert(
425                         authDataV3.certification.decodedCertDataArray[i], isPckCert
426                     );
427                     if (!certDecodedSuccessfully) {
428                         return (false, retData);
429                     }
430                 }
431             }
432     
433             // Step 5: basic PCK and TCB check = 381k gas
434             {
435                 string memory parsedFmspc = parsedQuoteCerts[0].pck.sgxExtension.fmspc;
436                 fetchedTcbInfo = tcbInfo[parsedFmspc];
437                 bool tcbConfigured = LibString.eq(parsedFmspc, fetchedTcbInfo.fmspc);
438                 if (!tcbConfigured) {
439                     return (false, retData);
440                 }
441     
442                 IPEMCertChainLib.ECSha256Certificate memory pckCert = parsedQuoteCerts[0];
443                 bool pceidMatched = LibString.eq(pckCert.pck.sgxExtension.pceid, fetchedTcbInfo.pceid);
444                 if (!pceidMatched) {
445                     return (false, retData);
446                 }
447             }
448     
449             // Step 6: Verify TCB Level
450             TCBInfoStruct.TCBStatus tcbStatus;
451             {
452                 // 4k gas
453                 bool tcbVerified;
454                 (tcbVerified, tcbStatus) = _checkTcbLevels(parsedQuoteCerts[0].pck, fetchedTcbInfo);
455                 if (!tcbVerified) {
456                     return (false, retData);
457                 }
458             }
459     
460             // Step 7: Verify cert chain for PCK
461             {
462                 // 660k gas (rootCA pubkey is trusted)
463                 bool pckCertChainVerified = _verifyCertChain(parsedQuoteCerts);
464                 if (!pckCertChainVerified) {
465                     return (false, retData);
466                 }
467             }
468     
469             // Step 8: Verify the local attestation sig and qe report sig = 670k gas
470             {
471                 bool enclaveReportSigsVerified = _enclaveReportSigVerification(
472                     parsedQuoteCerts[0].pubKey,
473                     signedQuoteData,
474                     authDataV3,
475                     v3quote.v3AuthData.pckSignedQeReport
476                 );
477                 if (!enclaveReportSigsVerified) {
478                     return (false, retData);
479                 }
480             }
481     
482             retData = abi.encodePacked(sha256(abi.encode(v3quote)), tcbStatus);
483     
484             return (_attestationTcbIsValid(tcbStatus), retData);
485         }


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/AutomataDcapV3Attestation.sol#L364:485

```solidity
File: contracts/automata-attestation/lib/PEMCertChainLib.sol


74          function decodeCert(
75              bytes memory der,
76              bool isPckCert
77          )
78              external
79              pure
80              returns (bool success, ECSha256Certificate memory cert)
81          {
82              uint256 root = der.root();
83      
84              // Entering tbsCertificate sequence
85              uint256 tbsParentPtr = der.firstChildOf(root);
86      
87              // Begin iterating through the descendants of tbsCertificate
88              uint256 tbsPtr = der.firstChildOf(tbsParentPtr);
89      
90              // The Serial Number is located one element below Version
91      
92              // The issuer commonName value is contained in the Issuer sequence
93              // which is 3 elements below the first element of the tbsCertificate sequence
94      
95              // The Validity sequence is located 4 elements below the first element of the tbsCertificate
96              // sequence
97      
98              // The subject commanName value is contained in the Subject sequence
99              // which is 5 elements below the first element of the tbsCertificate sequence
100     
101             // The PublicKey is located in the second element of subjectPublicKeyInfo sequence
102             // which is 6 elements below the first element of the tbsCertificate sequence
103     
104             tbsPtr = der.nextSiblingOf(tbsPtr);
105     
106             {
107                 bytes memory serialNumBytes = der.bytesAt(tbsPtr);
108                 cert.serialNumber = serialNumBytes;
109             }
110     
111             tbsPtr = der.nextSiblingOf(tbsPtr);
112             tbsPtr = der.nextSiblingOf(tbsPtr);
113     
114             if (isPckCert) {
115                 uint256 issuerPtr = der.firstChildOf(tbsPtr);
116                 issuerPtr = der.firstChildOf(issuerPtr);
117                 issuerPtr = der.firstChildOf(issuerPtr);
118                 issuerPtr = der.nextSiblingOf(issuerPtr);
119                 cert.pck.issuerName = string(der.bytesAt(issuerPtr));
120                 bool issuerNameIsValid = LibString.eq(cert.pck.issuerName, PLATFORM_ISSUER_NAME)
121                     || LibString.eq(cert.pck.issuerName, PROCESSOR_ISSUER_NAME);
122                 if (!issuerNameIsValid) {
123                     return (false, cert);
124                 }
125             }
126     
127             tbsPtr = der.nextSiblingOf(tbsPtr);
128     
129             {
130                 uint256 notBeforePtr = der.firstChildOf(tbsPtr);
131                 uint256 notAfterPtr = der.nextSiblingOf(notBeforePtr);
132                 bytes1 notBeforeTag = der[notBeforePtr.ixs()];
133                 bytes1 notAfterTag = der[notAfterPtr.ixs()];
134                 if (
135                     (notBeforeTag != 0x17 && notBeforeTag == 0x18)
136                         || (notAfterTag != 0x17 && notAfterTag != 0x18)
137                 ) {
138                     return (false, cert);
139                 }
140                 cert.notBefore = X509DateUtils.toTimestamp(der.bytesAt(notBeforePtr));
141                 cert.notAfter = X509DateUtils.toTimestamp(der.bytesAt(notAfterPtr));
142             }
143     
144             tbsPtr = der.nextSiblingOf(tbsPtr);
145     
146             if (isPckCert) {
147                 uint256 subjectPtr = der.firstChildOf(tbsPtr);
148                 subjectPtr = der.firstChildOf(subjectPtr);
149                 subjectPtr = der.firstChildOf(subjectPtr);
150                 subjectPtr = der.nextSiblingOf(subjectPtr);
151                 cert.pck.commonName = string(der.bytesAt(subjectPtr));
152                 if (!LibString.eq(cert.pck.commonName, PCK_COMMON_NAME)) {
153                     return (false, cert);
154                 }
155             }
156     
157             tbsPtr = der.nextSiblingOf(tbsPtr);
158     
159             {
160                 // Entering subjectPublicKeyInfo sequence
161                 uint256 subjectPublicKeyInfoPtr = der.firstChildOf(tbsPtr);
162                 subjectPublicKeyInfoPtr = der.nextSiblingOf(subjectPublicKeyInfoPtr);
163     
164                 // The Signature sequence is located two sibling elements below the tbsCertificate
165                 // element
166                 uint256 sigPtr = der.nextSiblingOf(tbsParentPtr);
167                 sigPtr = der.nextSiblingOf(sigPtr);
168     
169                 // Skip three bytes to the right
170                 // the three bytes in question: 0x034700 or 0x034800 or 0x034900
171                 sigPtr = NodePtr.getPtr(sigPtr.ixs() + 3, sigPtr.ixf() + 3, sigPtr.ixl());
172     
173                 sigPtr = der.firstChildOf(sigPtr);
174                 bytes memory sigX = _trimBytes(der.bytesAt(sigPtr), 32);
175     
176                 sigPtr = der.nextSiblingOf(sigPtr);
177                 bytes memory sigY = _trimBytes(der.bytesAt(sigPtr), 32);
178     
179                 cert.tbsCertificate = der.allBytesAt(tbsParentPtr);
180                 cert.pubKey = _trimBytes(der.bytesAt(subjectPublicKeyInfoPtr), 64);
181                 cert.signature = abi.encodePacked(sigX, sigY);
182             }
183     
184             if (isPckCert) {
185                 // entering Extension sequence
186                 tbsPtr = der.nextSiblingOf(tbsPtr);
187     
188                 // check for the extension tag
189                 if (der[tbsPtr.ixs()] != 0xA3) {
190                     return (false, cert);
191                 }
192     
193                 tbsPtr = der.firstChildOf(tbsPtr);
194                 tbsPtr = der.firstChildOf(tbsPtr);
195     
196                 bool sgxExtnTraversedSuccessfully;
197                 uint256 pcesvn;
198                 uint256[] memory cpuSvns;
199                 bytes memory fmspcBytes;
200                 bytes memory pceidBytes;
201                 (sgxExtnTraversedSuccessfully, pcesvn, cpuSvns, fmspcBytes, pceidBytes) =
202                     _findPckTcbInfo(der, tbsPtr, tbsParentPtr);
203                 if (!sgxExtnTraversedSuccessfully) {
204                     return (false, cert);
205                 }
206                 cert.pck.sgxExtension.pcesvn = pcesvn;
207                 cert.pck.sgxExtension.sgxTcbCompSvnArr = cpuSvns;
208                 cert.pck.sgxExtension.pceid = LibString.toHexStringNoPrefix(pceidBytes);
209                 cert.pck.sgxExtension.fmspc = LibString.toHexStringNoPrefix(fmspcBytes);
210                 cert.isPck = true;
211             }
212     
213             success = true;
214         }


269         function _findPckTcbInfo(
270             bytes memory der,
271             uint256 tbsPtr,
272             uint256 tbsParentPtr
273         )
274             private
275             pure
276             returns (
277                 bool success,
278                 uint256 pcesvn,
279                 uint256[] memory cpusvns,
280                 bytes memory fmspcBytes,
281                 bytes memory pceidBytes
282             )
283         {
284             // iterate through the elements in the Extension sequence
285             // until we locate the SGX Extension OID
286             while (tbsPtr != 0) {
287                 uint256 internalPtr = der.firstChildOf(tbsPtr);
288                 if (der[internalPtr.ixs()] != 0x06) {
289                     return (false, pcesvn, cpusvns, fmspcBytes, pceidBytes);
290                 }
291     
292                 if (BytesUtils.compareBytes(der.bytesAt(internalPtr), SGX_EXTENSION_OID)) {
293                     // 1.2.840.113741.1.13.1
294                     internalPtr = der.nextSiblingOf(internalPtr);
295                     uint256 extnValueParentPtr = der.rootOfOctetStringAt(internalPtr);
296                     uint256 extnValuePtr = der.firstChildOf(extnValueParentPtr);
297     
298                     // Copy flags to memory to avoid stack too deep
299                     PCKTCBFlags memory flags;
300     
301                     while (!(flags.fmspcFound && flags.pceidFound && flags.tcbFound)) {
302                         uint256 extnValueOidPtr = der.firstChildOf(extnValuePtr);
303                         if (der[extnValueOidPtr.ixs()] != 0x06) {
304                             return (false, pcesvn, cpusvns, fmspcBytes, pceidBytes);
305                         }
306                         if (BytesUtils.compareBytes(der.bytesAt(extnValueOidPtr), TCB_OID)) {
307                             // 1.2.840.113741.1.13.1.2
308                             (flags.tcbFound, pcesvn, cpusvns) = _findTcb(der, extnValueOidPtr);
309                         }
310                         if (BytesUtils.compareBytes(der.bytesAt(extnValueOidPtr), PCEID_OID)) {
311                             // 1.2.840.113741.1.13.1.3
312                             uint256 pceidPtr = der.nextSiblingOf(extnValueOidPtr);
313                             pceidBytes = der.bytesAt(pceidPtr);
314                             flags.pceidFound = true;
315                         }
316                         if (BytesUtils.compareBytes(der.bytesAt(extnValueOidPtr), FMSPC_OID)) {
317                             // 1.2.840.113741.1.13.1.4
318                             uint256 fmspcPtr = der.nextSiblingOf(extnValueOidPtr);
319                             fmspcBytes = der.bytesAt(fmspcPtr);
320                             flags.fmspcFound = true;
321                         }
322     
323                         if (extnValuePtr.ixl() < extnValueParentPtr.ixl()) {
324                             extnValuePtr = der.nextSiblingOf(extnValuePtr);
325                         } else {
326                             break;
327                         }
328                     }
329                     success = flags.fmspcFound && flags.pceidFound && flags.tcbFound;
330                     break;
331                 }
332     
333                 if (tbsPtr.ixl() < tbsParentPtr.ixl()) {
334                     tbsPtr = der.nextSiblingOf(tbsPtr);
335                 } else {
336                     tbsPtr = 0; // exit
337                 }
338             }
339         }


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/PEMCertChainLib.sol#L269:339

```solidity
File: contracts/automata-attestation/lib/QuoteV3Auth/V3Parser.sol


62          function validateParsedInput(V3Struct.ParsedV3QuoteStruct memory v3Quote)
63              internal
64              pure
65              returns (
66                  bool success,
67                  V3Struct.Header memory header,
68                  V3Struct.EnclaveReport memory localEnclaveReport,
69                  bytes memory signedQuoteData, // concatenation of header and local enclave report bytes
70                  V3Struct.ECDSAQuoteV3AuthData memory authDataV3
71              )
72          {
73              success = true;
74              localEnclaveReport = v3Quote.localEnclaveReport;
75              V3Struct.EnclaveReport memory pckSignedQeReport = v3Quote.v3AuthData.pckSignedQeReport;
76      
77              require(
78                  localEnclaveReport.reserved3.length == 96 && localEnclaveReport.reserved4.length == 60
79                      && localEnclaveReport.reportData.length == 64,
80                  "local QE report has wrong length"
81              );
82              require(
83                  pckSignedQeReport.reserved3.length == 96 && pckSignedQeReport.reserved4.length == 60
84                      && pckSignedQeReport.reportData.length == 64,
85                  "QE report has wrong length"
86              );
87              require(
88                  v3Quote.v3AuthData.certification.certType == 5,
89                  "certType must be 5: Concatenated PCK Cert Chain (PEM formatted)"
90              );
91              require(
92                  v3Quote.v3AuthData.certification.decodedCertDataArray.length == 3, "3 certs in chain"
93              );
94              require(
95                  v3Quote.v3AuthData.ecdsa256BitSignature.length == 64
96                      && v3Quote.v3AuthData.ecdsaAttestationKey.length == 64
97                      && v3Quote.v3AuthData.qeReportSignature.length == 64,
98                  "Invalid ECDSA signature format"
99              );
100             require(
101                 v3Quote.v3AuthData.qeAuthData.parsedDataSize
102                     == v3Quote.v3AuthData.qeAuthData.data.length,
103                 "Invalid QEAuthData size"
104             );
105     
106             uint32 totalQuoteSize = 48 // header
107                 + 384 // local QE report
108                 + 64 // ecdsa256BitSignature
109                 + 64 // ecdsaAttestationKey
110                 + 384 // QE report
111                 + 64 // qeReportSignature
112                 + 2 // sizeof(v3Quote.v3AuthData.qeAuthData.parsedDataSize)
113                 + v3Quote.v3AuthData.qeAuthData.parsedDataSize + 2 // sizeof(v3Quote.v3AuthData.certification.certType)
114                 + 4 // sizeof(v3Quote.v3AuthData.certification.certDataSize)
115                 + v3Quote.v3AuthData.certification.certDataSize;
116             require(totalQuoteSize >= MINIMUM_QUOTE_LENGTH, "Invalid quote size");
117     
118             header = v3Quote.header;
119             bytes memory headerBytes = abi.encodePacked(
120                 header.version,
121                 header.attestationKeyType,
122                 header.teeType,
123                 header.qeSvn,
124                 header.pceSvn,
125                 header.qeVendorId,
126                 header.userData
127             );
128     
129             signedQuoteData = abi.encodePacked(headerBytes, V3Parser.packQEReport(localEnclaveReport));
130             authDataV3 = v3Quote.v3AuthData;
131         }


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/QuoteV3Auth/V3Parser.sol#L62:131

```solidity
File: contracts/automata-attestation/utils/RsaVerify.sol


43          function pkcs1Sha256(
44              bytes32 _sha256,
45              bytes memory _s,
46              bytes memory _e,
47              bytes memory _m
48          )
49              internal
50              view
51              returns (bool)
52          {
53              uint8[17] memory sha256ExplicitNullParam = [
54                  0x30,
55                  0x31,
56                  0x30,
57                  0x0d,
58                  0x06,
59                  0x09,
60                  0x60,
61                  0x86,
62                  0x48,
63                  0x01,
64                  0x65,
65                  0x03,
66                  0x04,
67                  0x02,
68                  0x01,
69                  0x05,
70                  0x00
71              ];
72      
73              uint8[15] memory sha256ImplicitNullParam = [
74                  0x30,
75                  0x2f,
76                  0x30,
77                  0x0b,
78                  0x06,
79                  0x09,
80                  0x60,
81                  0x86,
82                  0x48,
83                  0x01,
84                  0x65,
85                  0x03,
86                  0x04,
87                  0x02,
88                  0x01
89              ];
90      
91              // decipher
92      
93              bytes memory input =
94                  bytes.concat(bytes32(_s.length), bytes32(_e.length), bytes32(_m.length), _s, _e, _m);
95              uint256 inputlen = input.length;
96      
97              uint256 decipherlen = _m.length;
98              bytes memory decipher = new bytes(decipherlen);
99              assembly {
100                 pop(
101                     staticcall(
102                         sub(gas(), 2000),
103                         5,
104                         add(input, 0x20),
105                         inputlen,
106                         add(decipher, 0x20),
107                         decipherlen
108                     )
109                 )
110             }
111     
112             // Check that is well encoded:
113             //
114             // 0x00 || 0x01 || PS || 0x00 || DigestInfo
115             // PS is padding filled with 0xff
116             // DigestInfo ::= SEQUENCE {
117             //    digestAlgorithm AlgorithmIdentifier,
118             //      [optional algorithm parameters]
119             //    digest OCTET STRING
120             // }
121     
122             bool hasNullParam;
123             uint256 digestAlgoWithParamLen;
124     
125             if (uint8(decipher[decipherlen - 50]) == 0x31) {
126                 hasNullParam = true;
127                 digestAlgoWithParamLen = sha256ExplicitNullParam.length;
128             } else if (uint8(decipher[decipherlen - 48]) == 0x2f) {
129                 hasNullParam = false;
130                 digestAlgoWithParamLen = sha256ImplicitNullParam.length;
131             } else {
132                 return false;
133             }
134     
135             uint256 paddingLen = decipherlen - 5 - digestAlgoWithParamLen - 32;
136     
137             if (decipher[0] != 0 || decipher[1] != 0x01) {
138                 return false;
139             }
140             for (uint256 i = 2; i < 2 + paddingLen; ++i) {
141                 if (decipher[i] != 0xff) {
142                     return false;
143                 }
144             }
145             if (decipher[2 + paddingLen] != 0) {
146                 return false;
147             }
148     
149             // check digest algorithm
150     
151             if (digestAlgoWithParamLen == sha256ExplicitNullParam.length) {
152                 for (uint256 i; i < digestAlgoWithParamLen; ++i) {
153                     if (decipher[3 + paddingLen + i] != bytes1(sha256ExplicitNullParam[i])) {
154                         return false;
155                     }
156                 }
157             } else {
158                 for (uint256 i; i < digestAlgoWithParamLen; ++i) {
159                     if (decipher[3 + paddingLen + i] != bytes1(sha256ImplicitNullParam[i])) {
160                         return false;
161                     }
162                 }
163             }
164     
165             // check digest
166     
167             if (
168                 decipher[3 + paddingLen + digestAlgoWithParamLen] != 0x04
169                     || decipher[4 + paddingLen + digestAlgoWithParamLen] != 0x20
170             ) {
171                 return false;
172             }
173     
174             for (uint256 i; i < _sha256.length; ++i) {
175                 if (decipher[5 + paddingLen + digestAlgoWithParamLen + i] != _sha256[i]) {
176                     return false;
177                 }
178             }
179     
180             return true;
181         }


212         function pkcs1Sha1(
213             bytes20 _sha1,
214             bytes memory _s,
215             bytes memory _e,
216             bytes memory _m
217         )
218             internal
219             view
220             returns (bool)
221         {
222             uint8[15] memory sha1Prefix = [
223                 0x30,
224                 0x21,
225                 0x30,
226                 0x09,
227                 0x06,
228                 0x05,
229                 0x2b,
230                 0x0e,
231                 0x03,
232                 0x02,
233                 0x1a,
234                 0x05,
235                 0x00,
236                 0x04,
237                 0x14
238             ];
239     
240             // decipher
241             bytes memory input =
242                 bytes.concat(bytes32(_s.length), bytes32(_e.length), bytes32(_m.length), _s, _e, _m);
243             uint256 inputlen = input.length;
244     
245             uint256 decipherlen = _m.length;
246             bytes memory decipher = new bytes(decipherlen);
247             assembly {
248                 pop(
249                     staticcall(
250                         sub(gas(), 2000),
251                         5,
252                         add(input, 0x20),
253                         inputlen,
254                         add(decipher, 0x20),
255                         decipherlen
256                     )
257                 )
258             }
259     
260             // Check that is well encoded:
261             // 0x00 || 0x01 || PS || 0x00 || DigestInfo
262             // PS is padding filled with 0xff
263             // DigestInfo ::= SEQUENCE {
264             //    digestAlgorithm AlgorithmIdentifier,
265             //    digest OCTET STRING
266             // }
267     
268             uint256 paddingLen = decipherlen - 3 - sha1Prefix.length - 20;
269     
270             if (decipher[0] != 0 || decipher[1] != 0x01) {
271                 return false;
272             }
273             for (uint256 i = 2; i < 2 + paddingLen; ++i) {
274                 if (decipher[i] != 0xff) {
275                     return false;
276                 }
277             }
278             if (decipher[2 + paddingLen] != 0) {
279                 return false;
280             }
281     
282             // check digest algorithm
283             for (uint256 i; i < sha1Prefix.length; ++i) {
284                 if (decipher[3 + paddingLen + i] != bytes1(sha1Prefix[i])) {
285                     return false;
286                 }
287             }
288     
289             // check digest
290             for (uint256 i; i < _sha1.length; ++i) {
291                 if (decipher[3 + paddingLen + sha1Prefix.length + i] != _sha1[i]) {
292                     return false;
293                 }
294             }
295     
296             return true;
297         }


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/RsaVerify.sol#L212:297

```solidity
File: contracts/automata-attestation/utils/SHA1.sol


11          function sha1(bytes memory data) internal pure returns (bytes20 ret) {
12              assembly {
13                  // Get a safe scratch location
14                  let scratch := mload(0x40)
15      
16                  // Get the data length, and point data at the first byte
17                  let len := mload(data)
18                  data := add(data, 32)
19      
20                  // Find the length after padding
21                  let totallen := add(and(add(len, 1), 0xFFFFFFFFFFFFFFC0), 64)
22                  switch lt(sub(totallen, len), 9)
23                  case 1 { totallen := add(totallen, 64) }
24      
25                  let h := 0x6745230100EFCDAB890098BADCFE001032547600C3D2E1F0
26      
27                  function readword(ptr, off, count) -> result {
28                      result := 0
29                      if lt(off, count) {
30                          result := mload(add(ptr, off))
31                          count := sub(count, off)
32                          if lt(count, 32) {
33                              let mask := not(sub(exp(256, sub(32, count)), 1))
34                              result := and(result, mask)
35                          }
36                      }
37                  }
38      
39                  for { let i := 0 } lt(i, totallen) { i := add(i, 64) } {
40                      mstore(scratch, readword(data, i, len))
41                      mstore(add(scratch, 32), readword(data, add(i, 32), len))
42      
43                      // If we loaded the last byte, store the terminator byte
44                      switch lt(sub(len, i), 64)
45                      case 1 { mstore8(add(scratch, sub(len, i)), 0x80) }
46      
47                      // If this is the last block, store the length
48                      switch eq(i, sub(totallen, 64))
49                      case 1 { mstore(add(scratch, 32), or(mload(add(scratch, 32)), mul(len, 8))) }
50      
51                      // Expand the 16 32-bit words into 80
52                      for { let j := 64 } lt(j, 128) { j := add(j, 12) } {
53                          let temp :=
54                              xor(
55                                  xor(mload(add(scratch, sub(j, 12))), mload(add(scratch, sub(j, 32)))),
56                                  xor(mload(add(scratch, sub(j, 56))), mload(add(scratch, sub(j, 64))))
57                              )
58                          temp :=
59                              or(
60                                  and(
61                                      mul(temp, 2),
62                                      0xFFFFFFFEFFFFFFFEFFFFFFFEFFFFFFFEFFFFFFFEFFFFFFFEFFFFFFFEFFFFFFFE
63                                  ),
64                                  and(
65                                      div(temp, 0x80000000),
66                                      0x0000000100000001000000010000000100000001000000010000000100000001
67                                  )
68                              )
69                          mstore(add(scratch, j), temp)
70                      }
71                      for { let j := 128 } lt(j, 320) { j := add(j, 24) } {
72                          let temp :=
73                              xor(
74                                  xor(mload(add(scratch, sub(j, 24))), mload(add(scratch, sub(j, 64)))),
75                                  xor(mload(add(scratch, sub(j, 112))), mload(add(scratch, sub(j, 128))))
76                              )
77                          temp :=
78                              or(
79                                  and(
80                                      mul(temp, 4),
81                                      0xFFFFFFFCFFFFFFFCFFFFFFFCFFFFFFFCFFFFFFFCFFFFFFFCFFFFFFFCFFFFFFFC
82                                  ),
83                                  and(
84                                      div(temp, 0x40000000),
85                                      0x0000000300000003000000030000000300000003000000030000000300000003
86                                  )
87                              )
88                          mstore(add(scratch, j), temp)
89                      }
90      
91                      let x := h
92                      let f := 0
93                      let k := 0
94                      for { let j := 0 } lt(j, 80) { j := add(j, 1) } {
95                          switch div(j, 20)
96                          case 0 {
97                              // f = d xor (b and (c xor d))
98                              f := xor(div(x, 0x100000000000000000000), div(x, 0x10000000000))
99                              f := and(div(x, 0x1000000000000000000000000000000), f)
100                             f := xor(div(x, 0x10000000000), f)
101                             k := 0x5A827999
102                         }
103                         case 1 {
104                             // f = b xor c xor d
105                             f :=
106                                 xor(
107                                     div(x, 0x1000000000000000000000000000000),
108                                     div(x, 0x100000000000000000000)
109                                 )
110                             f := xor(div(x, 0x10000000000), f)
111                             k := 0x6ED9EBA1
112                         }
113                         case 2 {
114                             // f = (b and c) or (d and (b or c))
115                             f :=
116                                 or(
117                                     div(x, 0x1000000000000000000000000000000),
118                                     div(x, 0x100000000000000000000)
119                                 )
120                             f := and(div(x, 0x10000000000), f)
121                             f :=
122                                 or(
123                                     and(
124                                         div(x, 0x1000000000000000000000000000000),
125                                         div(x, 0x100000000000000000000)
126                                     ),
127                                     f
128                                 )
129                             k := 0x8F1BBCDC
130                         }
131                         case 3 {
132                             // f = b xor c xor d
133                             f :=
134                                 xor(
135                                     div(x, 0x1000000000000000000000000000000),
136                                     div(x, 0x100000000000000000000)
137                                 )
138                             f := xor(div(x, 0x10000000000), f)
139                             k := 0xCA62C1D6
140                         }
141                         // temp = (a leftrotate 5) + f + e + k + w[i]
142                         let temp := and(div(x, 0x80000000000000000000000000000000000000000000000), 0x1F)
143                         temp :=
144                             or(and(div(x, 0x800000000000000000000000000000000000000), 0xFFFFFFE0), temp)
145                         temp := add(f, temp)
146                         temp := add(and(x, 0xFFFFFFFF), temp)
147                         temp := add(k, temp)
148                         temp :=
149                             add(
150                                 div(
151                                     mload(add(scratch, mul(j, 4))),
152                                     0x100000000000000000000000000000000000000000000000000000000
153                                 ),
154                                 temp
155                             )
156                         x :=
157                             or(
158                                 div(x, 0x10000000000),
159                                 mul(temp, 0x10000000000000000000000000000000000000000)
160                             )
161                         x :=
162                             or(
163                                 and(x, 0xFFFFFFFF00FFFFFFFF000000000000FFFFFFFF00FFFFFFFF),
164                                 mul(
165                                     or(
166                                         and(div(x, 0x4000000000000), 0xC0000000),
167                                         and(div(x, 0x400000000000000000000), 0x3FFFFFFF)
168                                     ),
169                                     0x100000000000000000000
170                                 )
171                             )
172                     }
173     
174                     h := and(add(h, x), 0xFFFFFFFF00FFFFFFFF00FFFFFFFF00FFFFFFFF00FFFFFFFF)
175                 }
176                 ret :=
177                     mul(
178                         or(
179                             or(
180                                 or(
181                                     or(
182                                         and(div(h, 0x100000000), 0xFFFFFFFF00000000000000000000000000000000),
183                                         and(div(h, 0x1000000), 0xFFFFFFFF000000000000000000000000)
184                                     ),
185                                     and(div(h, 0x10000), 0xFFFFFFFF0000000000000000)
186                                 ),
187                                 and(div(h, 0x100), 0xFFFFFFFF00000000)
188                             ),
189                             and(h, 0xFFFFFFFF)
190                         ),
191                         0x1000000000000000000000000
192                     )
193             }
194         }


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/SHA1.sol#L11:194

```solidity
File: contracts/bridge/Bridge.sol


155         function recallMessage(
156             Message calldata _message,
157             bytes calldata _proof
158         )
159             external
160             nonReentrant
161             whenNotPaused
162             sameChain(_message.srcChainId)
163         {
164             bytes32 msgHash = hashMessage(_message);
165     
166             if (messageStatus[msgHash] != Status.NEW) revert B_STATUS_MISMATCH();
167     
168             uint64 receivedAt = proofReceipt[msgHash].receivedAt;
169             bool isMessageProven = receivedAt != 0;
170     
171             if (!isMessageProven) {
172                 address signalService = resolve("signal_service", false);
173     
174                 if (!ISignalService(signalService).isSignalSent(address(this), msgHash)) {
175                     revert B_MESSAGE_NOT_SENT();
176                 }
177     
178                 bytes32 failureSignal = signalForFailedMessage(msgHash);
179                 if (!_proveSignalReceived(signalService, failureSignal, _message.destChainId, _proof)) {
180                     revert B_NOT_FAILED();
181                 }
182     
183                 receivedAt = uint64(block.timestamp);
184                 proofReceipt[msgHash].receivedAt = receivedAt;
185             }
186     
187             (uint256 invocationDelay,) = getInvocationDelays();
188     
189             if (block.timestamp >= invocationDelay + receivedAt) {
190                 delete proofReceipt[msgHash];
191                 messageStatus[msgHash] = Status.RECALLED;
192     
193                 // Execute the recall logic based on the contract's support for the
194                 // IRecallableSender interface
195                 if (_message.from.supportsInterface(type(IRecallableSender).interfaceId)) {
196                     _storeContext(msgHash, address(this), _message.srcChainId);
197     
198                     // Perform recall
199                     IRecallableSender(_message.from).onMessageRecalled{ value: _message.value }(
200                         _message, msgHash
201                     );
202     
203                     // Must reset the context after the message call
204                     _resetContext();
205                 } else {
206                     _message.srcOwner.sendEther(_message.value);
207                 }
208                 emit MessageRecalled(msgHash);
209             } else if (!isMessageProven) {
210                 emit MessageReceived(msgHash, _message, true);
211             } else {
212                 revert B_INVOCATION_TOO_EARLY();
213             }
214         }


217         function processMessage(
218             Message calldata _message,
219             bytes calldata _proof
220         )
221             external
222             nonReentrant
223             whenNotPaused
224             sameChain(_message.destChainId)
225         {
226             bytes32 msgHash = hashMessage(_message);
227             if (messageStatus[msgHash] != Status.NEW) revert B_STATUS_MISMATCH();
228     
229             address signalService = resolve("signal_service", false);
230             uint64 receivedAt = proofReceipt[msgHash].receivedAt;
231             bool isMessageProven = receivedAt != 0;
232     
233             (uint256 invocationDelay, uint256 invocationExtraDelay) = getInvocationDelays();
234     
235             if (!isMessageProven) {
236                 if (!_proveSignalReceived(signalService, msgHash, _message.srcChainId, _proof)) {
237                     revert B_NOT_RECEIVED();
238                 }
239     
240                 receivedAt = uint64(block.timestamp);
241     
242                 if (invocationDelay != 0) {
243                     proofReceipt[msgHash] = ProofReceipt({
244                         receivedAt: receivedAt,
245                         preferredExecutor: _message.gasLimit == 0 ? _message.destOwner : msg.sender
246                     });
247                 }
248             }
249     
250             if (invocationDelay != 0 && msg.sender != proofReceipt[msgHash].preferredExecutor) {
251                 // If msg.sender is not the one that proved the message, then there
252                 // is an extra delay.
253                 unchecked {
254                     invocationDelay += invocationExtraDelay;
255                 }
256             }
257     
258             if (block.timestamp >= invocationDelay + receivedAt) {
259                 // If the gas limit is set to zero, only the owner can process the message.
260                 if (_message.gasLimit == 0 && msg.sender != _message.destOwner) {
261                     revert B_PERMISSION_DENIED();
262                 }
263     
264                 delete proofReceipt[msgHash];
265     
266                 uint256 refundAmount;
267     
268                 // Process message differently based on the target address
269                 if (
270                     _message.to == address(0) || _message.to == address(this)
271                         || _message.to == signalService || addressBanned[_message.to]
272                 ) {
273                     // Handle special addresses that don't require actual invocation but
274                     // mark message as DONE
275                     refundAmount = _message.value;
276                     _updateMessageStatus(msgHash, Status.DONE);
277                 } else {
278                     // Use the specified message gas limit if called by the owner, else
279                     // use remaining gas
280                     uint256 gasLimit = msg.sender == _message.destOwner ? gasleft() : _message.gasLimit;
281     
282                     if (_invokeMessageCall(_message, msgHash, gasLimit)) {
283                         _updateMessageStatus(msgHash, Status.DONE);
284                     } else {
285                         _updateMessageStatus(msgHash, Status.RETRIABLE);
286                     }
287                 }
288     
289                 // Determine the refund recipient
290                 address refundTo =
291                     _message.refundTo == address(0) ? _message.destOwner : _message.refundTo;
292     
293                 // Refund the processing fee
294                 if (msg.sender == refundTo) {
295                     refundTo.sendEther(_message.fee + refundAmount);
296                 } else {
297                     // If sender is another address, reward it and refund the rest
298                     msg.sender.sendEther(_message.fee);
299                     refundTo.sendEther(refundAmount);
300                 }
301                 emit MessageExecuted(msgHash);
302             } else if (!isMessageProven) {
303                 emit MessageReceived(msgHash, _message, false);
304             } else {
305                 revert B_INVOCATION_TOO_EARLY();
306             }
307         }


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/Bridge.sol#L217:307

```solidity
File: contracts/signal/SignalService.sol


83          function proveSignalReceived(
84              uint64 _chainId,
85              address _app,
86              bytes32 _signal,
87              bytes calldata _proof
88          )
89              public
90              virtual
91              validSender(_app)
92              nonZeroValue(_signal)
93          {
94              HopProof[] memory hopProofs = abi.decode(_proof, (HopProof[]));
95              if (hopProofs.length == 0) revert SS_EMPTY_PROOF();
96      
97              uint64 chainId = _chainId;
98              address app = _app;
99              bytes32 signal = _signal;
100             bytes32 value = _signal;
101             address signalService = resolve(chainId, "signal_service", false);
102     
103             HopProof memory hop;
104             for (uint256 i; i < hopProofs.length; ++i) {
105                 hop = hopProofs[i];
106     
107                 bytes32 signalRoot = _verifyHopProof(chainId, app, signal, value, hop, signalService);
108                 bool isLastHop = i == hopProofs.length - 1;
109     
110                 if (isLastHop) {
111                     if (hop.chainId != block.chainid) revert SS_INVALID_LAST_HOP_CHAINID();
112                     signalService = address(this);
113                 } else {
114                     if (hop.chainId == 0 || hop.chainId == block.chainid) {
115                         revert SS_INVALID_MID_HOP_CHAINID();
116                     }
117                     signalService = resolve(hop.chainId, "signal_service", false);
118                 }
119     
120                 bool isFullProof = hop.accountProof.length > 0;
121     
122                 _cacheChainData(hop, chainId, hop.blockId, signalRoot, isFullProof, isLastHop);
123     
124                 bytes32 kind = isFullProof ? LibSignals.STATE_ROOT : LibSignals.SIGNAL_ROOT;
125                 signal = signalForChainData(chainId, kind, hop.blockId);
126                 value = hop.rootHash;
127                 chainId = hop.chainId;
128                 app = signalService;
129             }
130     
131             if (value == 0 || value != _loadSignalValue(address(this), signal)) {
132                 revert SS_SIGNAL_NOT_FOUND();
133             }
134         }


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/signal/SignalService.sol#L83:134

```solidity
File: contracts/thirdparty/optimism/Bytes.sol


15          function slice(
16              bytes memory _bytes,
17              uint256 _start,
18              uint256 _length
19          )
20              internal
21              pure
22              returns (bytes memory)
23          {
24              unchecked {
25                  require(_length + 31 >= _length, "slice_overflow");
26                  require(_start + _length >= _start, "slice_overflow");
27                  require(_bytes.length >= _start + _length, "slice_outOfBounds");
28              }
29      
30              bytes memory tempBytes;
31      
32              assembly {
33                  switch iszero(_length)
34                  case 0 {
35                      // Get a location of some free memory and store it in tempBytes as
36                      // Solidity does for memory variables.
37                      tempBytes := mload(0x40)
38      
39                      // The first word of the slice result is potentially a partial
40                      // word read from the original array. To read it, we calculate
41                      // the length of that partial word and start copying that many
42                      // bytes into the array. The first word we copy will start with
43                      // data we don't care about, but the last `lengthmod` bytes will
44                      // land at the beginning of the contents of the new array. When
45                      // we're done copying, we overwrite the full first word with
46                      // the actual length of the slice.
47                      let lengthmod := and(_length, 31)
48      
49                      // The multiplication in the next line is necessary
50                      // because when slicing multiples of 32 bytes (lengthmod == 0)
51                      // the following copy loop was copying the origin's length
52                      // and then ending prematurely not copying everything it should.
53                      let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))
54                      let end := add(mc, _length)
55      
56                      for {
57                          // The multiplication in the next line has the same exact purpose
58                          // as the one above.
59                          let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)
60                      } lt(mc, end) {
61                          mc := add(mc, 0x20)
62                          cc := add(cc, 0x20)
63                      } { mstore(mc, mload(cc)) }
64      
65                      mstore(tempBytes, _length)
66      
67                      //update free-memory pointer
68                      //allocating the array padded to 32 bytes like the compiler does now
69                      mstore(0x40, and(add(mc, 31), not(31)))
70                  }
71                  //if we want a zero-length slice let's just return a zero-length array
72                  default {
73                      tempBytes := mload(0x40)
74      
75                      //zero out the 32 bytes slice we are about to return
76                      //we need to do it because Solidity does not garbage collect
77                      mstore(tempBytes, 0)
78      
79                      mstore(0x40, add(tempBytes, 0x20))
80                  }
81              }
82      
83              return tempBytes;
84          }


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/Bytes.sol#L15:84

```solidity
File: contracts/thirdparty/optimism/rlp/RLPReader.sol


144         function _decodeLength(RLPItem memory _in)
145             private
146             pure
147             returns (uint256 offset_, uint256 length_, RLPItemType type_)
148         {
149             // Short-circuit if there's nothing to decode, note that we perform this check when
150             // the user creates an RLP item via toRLPItem, but it's always possible for them to bypass
151             // that function and create an RLP item directly. So we need to check this anyway.
152             require(
153                 _in.length > 0,
154                 "RLPReader: length of an RLP item must be greater than zero to be decodable"
155             );
156     
157             MemoryPointer ptr = _in.ptr;
158             uint256 prefix;
159             assembly {
160                 prefix := byte(0, mload(ptr))
161             }
162     
163             if (prefix <= 0x7f) {
164                 // Single byte.
165                 return (0, 1, RLPItemType.DATA_ITEM);
166             } else if (prefix <= 0xb7) {
167                 // Short string.
168     
169                 // slither-disable-next-line variable-scope
170                 uint256 strLen = prefix - 0x80;
171     
172                 require(
173                     _in.length > strLen,
174                     "RLPReader: length of content must be greater than string length (short string)"
175                 );
176     
177                 bytes1 firstByteOfContent;
178                 assembly {
179                     firstByteOfContent := and(mload(add(ptr, 1)), shl(248, 0xff))
180                 }
181     
182                 require(
183                     strLen != 1 || firstByteOfContent >= 0x80,
184                     "RLPReader: invalid prefix, single byte < 0x80 are not prefixed (short string)"
185                 );
186     
187                 return (1, strLen, RLPItemType.DATA_ITEM);
188             } else if (prefix <= 0xbf) {
189                 // Long string.
190                 uint256 lenOfStrLen = prefix - 0xb7;
191     
192                 require(
193                     _in.length > lenOfStrLen,
194                     "RLPReader: length of content must be > than length of string length (long string)"
195                 );
196     
197                 bytes1 firstByteOfContent;
198                 assembly {
199                     firstByteOfContent := and(mload(add(ptr, 1)), shl(248, 0xff))
200                 }
201     
202                 require(
203                     firstByteOfContent != 0x00,
204                     "RLPReader: length of content must not have any leading zeros (long string)"
205                 );
206     
207                 uint256 strLen;
208                 assembly {
209                     strLen := shr(sub(256, mul(8, lenOfStrLen)), mload(add(ptr, 1)))
210                 }
211     
212                 require(
213                     strLen > 55,
214                     "RLPReader: length of content must be greater than 55 bytes (long string)"
215                 );
216     
217                 require(
218                     _in.length > lenOfStrLen + strLen,
219                     "RLPReader: length of content must be greater than total length (long string)"
220                 );
221     
222                 return (1 + lenOfStrLen, strLen, RLPItemType.DATA_ITEM);
223             } else if (prefix <= 0xf7) {
224                 // Short list.
225                 // slither-disable-next-line variable-scope
226                 uint256 listLen = prefix - 0xc0;
227     
228                 require(
229                     _in.length > listLen,
230                     "RLPReader: length of content must be greater than list length (short list)"
231                 );
232     
233                 return (1, listLen, RLPItemType.LIST_ITEM);
234             } else {
235                 // Long list.
236                 uint256 lenOfListLen = prefix - 0xf7;
237     
238                 require(
239                     _in.length > lenOfListLen,
240                     "RLPReader: length of content must be > than length of list length (long list)"
241                 );
242     
243                 bytes1 firstByteOfContent;
244                 assembly {
245                     firstByteOfContent := and(mload(add(ptr, 1)), shl(248, 0xff))
246                 }
247     
248                 require(
249                     firstByteOfContent != 0x00,
250                     "RLPReader: length of content must not have any leading zeros (long list)"
251                 );
252     
253                 uint256 listLen;
254                 assembly {
255                     listLen := shr(sub(256, mul(8, lenOfListLen)), mload(add(ptr, 1)))
256                 }
257     
258                 require(
259                     listLen > 55,
260                     "RLPReader: length of content must be greater than 55 bytes (long list)"
261                 );
262     
263                 require(
264                     _in.length > lenOfListLen + listLen,
265                     "RLPReader: length of content must be greater than total length (long list)"
266                 );
267     
268                 return (1 + lenOfListLen, listLen, RLPItemType.LIST_ITEM);
269             }
270         }


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/rlp/RLPReader.sol#L144:270

```solidity
File: contracts/thirdparty/optimism/trie/MerkleTrie.sol


68          function get(
69              bytes memory _key,
70              bytes[] memory _proof,
71              bytes32 _root
72          )
73              internal
74              pure
75              returns (bytes memory value_)
76          {
77              require(_key.length > 0, "MerkleTrie: empty key");
78      
79              TrieNode[] memory proof = _parseProof(_proof);
80              bytes memory key = Bytes.toNibbles(_key);
81              bytes memory currentNodeID = abi.encodePacked(_root);
82              uint256 currentKeyIndex = 0;
83      
84              // Proof is top-down, so we start at the first element (root).
85              for (uint256 i = 0; i < proof.length; i++) {
86                  TrieNode memory currentNode = proof[i];
87      
88                  // Key index should never exceed total key length or we'll be out of bounds.
89                  require(currentKeyIndex <= key.length, "MerkleTrie: key index exceeds total key length");
90      
91                  if (currentKeyIndex == 0) {
92                      // First proof element is always the root node.
93                      require(
94                          Bytes.equal(abi.encodePacked(keccak256(currentNode.encoded)), currentNodeID),
95                          "MerkleTrie: invalid root hash"
96                      );
97                  } else if (currentNode.encoded.length >= 32) {
98                      // Nodes 32 bytes or larger are hashed inside branch nodes.
99                      require(
100                         Bytes.equal(abi.encodePacked(keccak256(currentNode.encoded)), currentNodeID),
101                         "MerkleTrie: invalid large internal hash"
102                     );
103                 } else {
104                     // Nodes smaller than 32 bytes aren't hashed.
105                     require(
106                         Bytes.equal(currentNode.encoded, currentNodeID),
107                         "MerkleTrie: invalid internal node hash"
108                     );
109                 }
110     
111                 if (currentNode.decoded.length == BRANCH_NODE_LENGTH) {
112                     if (currentKeyIndex == key.length) {
113                         // Value is the last element of the decoded list (for branch nodes). There's
114                         // some ambiguity in the Merkle trie specification because bytes(0) is a
115                         // valid value to place into the trie, but for branch nodes bytes(0) can exist
116                         // even when the value wasn't explicitly placed there. Geth treats a value of
117                         // bytes(0) as "key does not exist" and so we do the same.
118                         value_ = RLPReader.readBytes(currentNode.decoded[TREE_RADIX]);
119                         require(
120                             value_.length > 0,
121                             "MerkleTrie: value length must be greater than zero (branch)"
122                         );
123     
124                         // Extra proof elements are not allowed.
125                         require(
126                             i == proof.length - 1,
127                             "MerkleTrie: value node must be last node in proof (branch)"
128                         );
129     
130                         return value_;
131                     } else {
132                         // We're not at the end of the key yet.
133                         // Figure out what the next node ID should be and continue.
134                         uint8 branchKey = uint8(key[currentKeyIndex]);
135                         RLPReader.RLPItem memory nextNode = currentNode.decoded[branchKey];
136                         currentNodeID = _getNodeID(nextNode);
137                         currentKeyIndex += 1;
138                     }
139                 } else if (currentNode.decoded.length == LEAF_OR_EXTENSION_NODE_LENGTH) {
140                     bytes memory path = _getNodePath(currentNode);
141                     uint8 prefix = uint8(path[0]);
142                     uint8 offset = 2 - (prefix % 2);
143                     bytes memory pathRemainder = Bytes.slice(path, offset);
144                     bytes memory keyRemainder = Bytes.slice(key, currentKeyIndex);
145                     uint256 sharedNibbleLength = _getSharedNibbleLength(pathRemainder, keyRemainder);
146     
147                     // Whether this is a leaf node or an extension node, the path remainder MUST be a
148                     // prefix of the key remainder (or be equal to the key remainder) or the proof is
149                     // considered invalid.
150                     require(
151                         pathRemainder.length == sharedNibbleLength,
152                         "MerkleTrie: path remainder must share all nibbles with key"
153                     );
154     
155                     if (prefix == PREFIX_LEAF_EVEN || prefix == PREFIX_LEAF_ODD) {
156                         // Prefix of 2 or 3 means this is a leaf node. For the leaf node to be valid,
157                         // the key remainder must be exactly equal to the path remainder. We already
158                         // did the necessary byte comparison, so it's more efficient here to check that
159                         // the key remainder length equals the shared nibble length, which implies
160                         // equality with the path remainder (since we already did the same check with
161                         // the path remainder and the shared nibble length).
162                         require(
163                             keyRemainder.length == sharedNibbleLength,
164                             "MerkleTrie: key remainder must be identical to path remainder"
165                         );
166     
167                         // Our Merkle Trie is designed specifically for the purposes of the Ethereum
168                         // state trie. Empty values are not allowed in the state trie, so we can safely
169                         // say that if the value is empty, the key should not exist and the proof is
170                         // invalid.
171                         value_ = RLPReader.readBytes(currentNode.decoded[1]);
172                         require(
173                             value_.length > 0,
174                             "MerkleTrie: value length must be greater than zero (leaf)"
175                         );
176     
177                         // Extra proof elements are not allowed.
178                         require(
179                             i == proof.length - 1,
180                             "MerkleTrie: value node must be last node in proof (leaf)"
181                         );
182     
183                         return value_;
184                     } else if (prefix == PREFIX_EXTENSION_EVEN || prefix == PREFIX_EXTENSION_ODD) {
185                         // Prefix of 0 or 1 means this is an extension node. We move onto the next node
186                         // in the proof and increment the key index by the length of the path remainder
187                         // which is equal to the shared nibble length.
188                         currentNodeID = _getNodeID(currentNode.decoded[1]);
189                         currentKeyIndex += sharedNibbleLength;
190                     } else {
191                         revert("MerkleTrie: received a node with an unknown prefix");
192                     }
193                 } else {
194                     revert("MerkleTrie: received an unparseable node");
195                 }
196             }
197     
198             revert("MerkleTrie: ran out of proof elements");
199         }


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/trie/MerkleTrie.sol#L68:199

```solidity
File: contracts/thirdparty/solmate/LibFixedPointMath.sol


13          function exp(int256 x) internal pure returns (int256 r) {
14              unchecked {
15                  // Input x is in fixed point format, with scale factor 1/1e18.
16      
17                  // When the result is < 0.5 we return zero. This happens when
18                  // x <= floor(log(0.5e18) * 1e18) ~ -42e18
19                  if (x <= -42_139_678_854_452_767_551) {
20                      return 0;
21                  }
22      
23                  // When the result is > (2**255 - 1) / 1e18 we can not represent it
24                  // as an int256. This happens when x >= floor(log((2**255 -1) /
25                  // 1e18) * 1e18) ~ 135.
26                  if (x >= 135_305_999_368_893_231_589) revert Overflow();
27      
28                  // x is now in the range (-42, 136) * 1e18. Convert to (-42, 136) *
29                  // 2**96
30                  // for more intermediate precision and a binary basis. This base
31                  // conversion
32                  // is a multiplication by 1e18 / 2**96 = 5**18 / 2**78.
33                  x = (x << 78) / 5 ** 18;
34      
35                  // Reduce range of x to (-½ ln 2, ½ ln 2) * 2**96 by factoring out
36                  // powers of two
37                  // such that exp(x) = exp(x') * 2**k, where k is an integer.
38                  // Solving this gives k = round(x / log(2)) and x' = x - k * log(2).
39                  int256 k = ((x << 96) / 54_916_777_467_707_473_351_141_471_128 + 2 ** 95) >> 96;
40                  x = x - k * 54_916_777_467_707_473_351_141_471_128;
41                  // k is in the range [-61, 195].
42      
43                  // Evaluate using a (6, 7)-term rational approximation.
44                  // p is made monic, we'll multiply by a scale factor later.
45                  int256 y = x + 1_346_386_616_545_796_478_920_950_773_328;
46                  y = ((y * x) >> 96) + 57_155_421_227_552_351_082_224_309_758_442;
47                  int256 p = y + x - 94_201_549_194_550_492_254_356_042_504_812;
48                  p = ((p * y) >> 96) + 28_719_021_644_029_726_153_956_944_680_412_240;
49                  p = p * x + (4_385_272_521_454_847_904_659_076_985_693_276 << 96);
50      
51                  // We leave p in 2**192 basis so we don't need to scale it back up
52                  // for the division.
53                  int256 q = x - 2_855_989_394_907_223_263_936_484_059_900;
54                  q = ((q * x) >> 96) + 50_020_603_652_535_783_019_961_831_881_945;
55                  q = ((q * x) >> 96) - 533_845_033_583_426_703_283_633_433_725_380;
56                  q = ((q * x) >> 96) + 3_604_857_256_930_695_427_073_651_918_091_429;
57                  q = ((q * x) >> 96) - 14_423_608_567_350_463_180_887_372_962_807_573;
58                  q = ((q * x) >> 96) + 26_449_188_498_355_588_339_934_803_723_976_023;
59                  assembly {
60                      // Div in assembly because solidity adds a zero check despite
61                      // the `unchecked`.
62                      // The q polynomial is known not to have zeros in the domain.
63                      // (All roots are complex)
64                      // No scaling required because p is already 2**96 too large.
65                      r := sdiv(p, q)
66                  }
67                  // r should be in the range (0.09, 0.25) * 2**96.
68      
69                  // We now need to multiply r by
70                  //  * the scale factor s = ~6.031367120...,
71                  //  * the 2**k factor from the range reduction, and
72                  //  * the 1e18 / 2**96 factor for base converison.
73                  // We do all of this at once, with an intermediate result in 2**213
74                  // basis
75                  // so the final right shift is always by a positive amount.
76                  r = int256(
77                      (uint256(r) * 3_822_833_074_963_236_453_042_738_258_902_158_003_155_416_615_667)
78                          >> uint256(195 - k)
79                  );
80              }
81          }


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/solmate/LibFixedPointMath.sol#L13:81

```solidity
File: contracts/tokenvault/ERC1155Vault.sol


39          function sendToken(BridgeTransferOp memory _op)
40              external
41              payable
42              nonReentrant
43              whenNotPaused
44              withValidOperation(_op)
45              returns (IBridge.Message memory message_)
46          {
47              for (uint256 i; i < _op.amounts.length; ++i) {
48                  if (_op.amounts[i] == 0) revert VAULT_INVALID_AMOUNT();
49              }
50              // Check token interface support
51              if (!_op.token.supportsInterface(ERC1155_INTERFACE_ID)) {
52                  revert VAULT_INTERFACE_NOT_SUPPORTED();
53              }
54      
55              (bytes memory data, CanonicalNFT memory ctoken) = _handleMessage(msg.sender, _op);
56      
57              // Create a message to send to the destination chain
58              IBridge.Message memory message = IBridge.Message({
59                  id: 0, // will receive a new value
60                  from: address(0), // will receive a new value
61                  srcChainId: 0, // will receive a new value
62                  destChainId: _op.destChainId,
63                  srcOwner: msg.sender,
64                  destOwner: _op.destOwner != address(0) ? _op.destOwner : msg.sender,
65                  to: resolve(_op.destChainId, name(), false),
66                  refundTo: _op.refundTo,
67                  value: msg.value - _op.fee,
68                  fee: _op.fee,
69                  gasLimit: _op.gasLimit,
70                  data: data,
71                  memo: _op.memo
72              });
73      
74              // Send the message and obtain the message hash
75              bytes32 msgHash;
76              (msgHash, message_) =
77                  IBridge(resolve("bridge", false)).sendMessage{ value: msg.value }(message);
78      
79              // Emit TokenSent event
80              emit TokenSent({
81                  msgHash: msgHash,
82                  from: message_.srcOwner,
83                  to: _op.to,
84                  destChainId: message_.destChainId,
85                  ctoken: ctoken.addr,
86                  token: _op.token,
87                  tokenIds: _op.tokenIds,
88                  amounts: _op.amounts
89              });
90          }


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC1155Vault.sol#L39:90

```solidity
File: contracts/tokenvault/ERC20Vault.sol


148         function changeBridgedToken(
149             CanonicalERC20 calldata _ctoken,
150             address _btokenNew
151         )
152             external
153             nonReentrant
154             whenNotPaused
155             onlyOwner
156             returns (address btokenOld_)
157         {
158             if (_btokenNew == address(0) || bridgedToCanonical[_btokenNew].addr != address(0)) {
159                 revert VAULT_INVALID_NEW_BTOKEN();
160             }
161     
162             if (btokenBlacklist[_btokenNew]) revert VAULT_BTOKEN_BLACKLISTED();
163     
164             if (IBridgedERC20(_btokenNew).owner() != owner()) {
165                 revert VAULT_NOT_SAME_OWNER();
166             }
167     
168             btokenOld_ = canonicalToBridged[_ctoken.chainId][_ctoken.addr];
169     
170             if (btokenOld_ != address(0)) {
171                 CanonicalERC20 memory ctoken = bridgedToCanonical[btokenOld_];
172     
173                 // The ctoken must match the saved one.
174                 if (
175                     ctoken.decimals != _ctoken.decimals
176                         || keccak256(bytes(ctoken.symbol)) != keccak256(bytes(_ctoken.symbol))
177                         || keccak256(bytes(ctoken.name)) != keccak256(bytes(_ctoken.name))
178                 ) revert VAULT_CTOKEN_MISMATCH();
179     
180                 delete bridgedToCanonical[_btokenNew];
181                 btokenBlacklist[btokenOld_] = true;
182     
183                 // Start the migration
184                 IBridgedERC20(btokenOld_).changeMigrationStatus(_btokenNew, false);
185                 IBridgedERC20(_btokenNew).changeMigrationStatus(btokenOld_, true);
186             }
187     
188             bridgedToCanonical[_btokenNew] = _ctoken;
189             canonicalToBridged[_ctoken.chainId][_ctoken.addr] = _btokenNew;
190     
191             emit BridgedTokenChanged({
192                 srcChainId: _ctoken.chainId,
193                 ctoken: _ctoken.addr,
194                 btokenOld: btokenOld_,
195                 btokenNew: _btokenNew,
196                 ctokenSymbol: _ctoken.symbol,
197                 ctokenName: _ctoken.name,
198                 ctokenDecimal: _ctoken.decimals
199             });
200         }


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC20Vault.sol#L148:200

</details>

## NC034 - `address` shouldn't be hard-coded:

It is often better to declare addresses as `immutable`, and assign them via constructor arguments. This allows the code to remain the same across deployments on different networks and avoids recompilation when addresses need to change.


```solidity
File: contracts/L2/TaikoL2.sol


32          address public constant GOLDEN_TOUCH_ADDRESS = 0x0000777735367b36bC9B61C50022d9D0700dB4Ec;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/TaikoL2.sol#L32:32

## NC035 - Consider using `block.number` instead of `block.timestamp`:

`block.timestamp` is vulnerable to miner manipulation and creates a potential front-running vulnerability. Consider using `block.number` instead.


<details>
<summary>Click to show 34 findings</summary>

```solidity
File: contracts/L1/TaikoL1.sol


126             state.slotB.lastUnpausedAt = uint64(block.timestamp);


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/TaikoL1.sol#L126:126

```solidity
File: contracts/L1/hooks/AssignmentHook.sol


82                  block.timestamp > assignment.expiry


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/hooks/AssignmentHook.sol#L82:82

```solidity
File: contracts/L1/libs/LibProposing.sol


130                     timestamp: uint64(block.timestamp),


165                         _state.reusableBlobs[meta_.blobHash] = block.timestamp;


296             return _state.reusableBlobs[_blobHash] + _config.blobExpiry > block.timestamp;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProposing.sol#L296:296

```solidity
File: contracts/L1/libs/LibProving.sol


78                  _state.slotB.lastUnpausedAt = uint64(block.timestamp);


264             ts.timestamp = uint64(block.timestamp);


415                 + _tier.provingWindow * 60 >= block.timestamp;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProving.sol#L415:415

```solidity
File: contracts/L1/libs/LibVerifying.sol


58              _state.slotA.genesisTimestamp = uint64(block.timestamp);


64              blk.proposedAt = uint64(block.timestamp);


71              ts.timestamp = uint64(block.timestamp);


153                                 + uint256(ts.timestamp).max(_state.slotB.lastUnpausedAt) > block.timestamp


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibVerifying.sol#L153:153

```solidity
File: contracts/automata-attestation/AutomataDcapV3Attestation.sol


280                     block.timestamp > certs[i].notBefore && block.timestamp < certs[i].notAfter;


280                     block.timestamp > certs[i].notBefore && block.timestamp < certs[i].notAfter;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/AutomataDcapV3Attestation.sol#L280:280

```solidity
File: contracts/bridge/Bridge.sol


89              uint64 _timestamp = _suspend ? type(uint64).max : uint64(block.timestamp);


183                 receivedAt = uint64(block.timestamp);


189             if (block.timestamp >= invocationDelay + receivedAt) {


240                 receivedAt = uint64(block.timestamp);


258             if (block.timestamp >= invocationDelay + receivedAt) {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/Bridge.sol#L258:258

```solidity
File: contracts/team/TimelockTokenPool.sol


257             if (block.timestamp <= _start) return 0;


260             if (block.timestamp >= _start + _period) return _amount;


262             if (block.timestamp <= _cliff) return 0;


264             return _amount * uint64(block.timestamp - _start) / _period;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/TimelockTokenPool.sol#L264:264

```solidity
File: contracts/team/airdrop/ERC20Airdrop2.sol


40              if (claimEnd > block.timestamp || claimEnd + withdrawalWindow < block.timestamp) {


40              if (claimEnd > block.timestamp || claimEnd + withdrawalWindow < block.timestamp) {


114             if (block.timestamp < claimEnd) return (balance, 0);


118                 * (block.timestamp.min(claimEnd + withdrawalWindow) - claimEnd) / withdrawalWindow;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/airdrop/ERC20Airdrop2.sol#L118:118

```solidity
File: contracts/team/airdrop/MerkleClaimable.sol


35                  merkleRoot == 0x0 || claimStart == 0 || claimEnd == 0 || claimStart > block.timestamp


36                      || claimEnd < block.timestamp


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/airdrop/MerkleClaimable.sol#L36:36

```solidity
File: contracts/verifiers/SgxVerifier.sol


204             uint64 validSince = uint64(block.timestamp);


229             instances[id] = Instance(newInstance, uint64(block.timestamp));


230             emit InstanceAdded(id, newInstance, oldInstance, block.timestamp);


236             return instances[id].validSince <= block.timestamp


237                 && block.timestamp <= instances[id].validSince + INSTANCE_EXPIRY;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/verifiers/SgxVerifier.sol#L237:237

</details>

## NC036 - Consider bounding input array length:

The functions below take in an unbounded array, and make function calls for entries in the array. While the function will revert if it eventually runs out of gas, it may be a nicer user experience to `require()` that the length of the array is below some reasonable maximum, so that the user doesn't have to use up a full transaction's gas only to see that the transaction reverts.


<details>
<summary>Click to show 10 findings</summary>

```solidity
File: contracts/L1/provers/Guardians.sol


80              for (uint256 i = 0; i < _newGuardians.length; ++i) {
81                  address guardian = _newGuardians[i];
82                  if (guardian == address(0)) revert INVALID_GUARDIAN();
83                  // This makes sure there are not duplicate addresses
84                  if (guardianIds[guardian] != 0) revert INVALID_GUARDIAN_SET();
85      
86                  // Save and index the guardian
87                  guardians.push(guardian);
88                  guardianIds[guardian] = guardians.length;
89              }


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/provers/Guardians.sol#L80:89

```solidity
File: contracts/automata-attestation/AutomataDcapV3Attestation.sol


259             for (uint256 i; i < n; ++i) {
260                 IPEMCertChainLib.ECSha256Certificate memory issuer;
261                 if (i == n - 1) {
262                     // rootCA
263                     issuer = certs[i];
264                 } else {
265                     issuer = certs[i + 1];
266                     if (i == n - 2) {
267                         // this cert is expected to be signed by the root
268                         certRevoked = _serialNumIsRevoked[uint256(IPEMCertChainLib.CRL.ROOT)][certs[i]
269                             .serialNumber];
270                     } else if (certs[i].isPck) {
271                         certRevoked = _serialNumIsRevoked[uint256(IPEMCertChainLib.CRL.PCK)][certs[i]
272                             .serialNumber];
273                     }
274                     if (certRevoked) {
275                         break;
276                     }
277                 }
278     
279                 certNotExpired =
280                     block.timestamp > certs[i].notBefore && block.timestamp < certs[i].notAfter;
281                 if (!certNotExpired) {
282                     break;
283                 }
284     
285                 verified = sigVerifyLib.verifyES256Signature(
286                     certs[i].tbsCertificate, certs[i].signature, issuer.pubKey
287                 );
288                 if (!verified) {
289                     break;
290                 }
291     
292                 bytes32 issuerPubKeyHash = keccak256(issuer.pubKey);
293     
294                 if (issuerPubKeyHash == ROOTCA_PUBKEY_HASH) {
295                     certChainCanBeTrusted = true;
296                     break;
297                 }
298             }


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/AutomataDcapV3Attestation.sol#L259:298

```solidity
File: contracts/bridge/Bridge.sol


90              for (uint256 i; i < _msgHashes.length; ++i) {
91                  bytes32 msgHash = _msgHashes[i];
92                  proofReceipt[msgHash].receivedAt = _timestamp;
93                  emit MessageSuspended(msgHash, _suspend);
94              }


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/Bridge.sol#L90:94

```solidity
File: contracts/team/airdrop/ERC721Airdrop.sol


59              for (uint256 i; i < tokenIds.length; ++i) {
60                  IERC721(token).safeTransferFrom(vault, user, tokenIds[i]);
61              }


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/airdrop/ERC721Airdrop.sol#L59:61

```solidity
File: contracts/thirdparty/optimism/trie/MerkleTrie.sol


85              for (uint256 i = 0; i < proof.length; i++) {
86                  TrieNode memory currentNode = proof[i];
87      
88                  // Key index should never exceed total key length or we'll be out of bounds.
89                  require(currentKeyIndex <= key.length, "MerkleTrie: key index exceeds total key length");
90      
91                  if (currentKeyIndex == 0) {
92                      // First proof element is always the root node.
93                      require(
94                          Bytes.equal(abi.encodePacked(keccak256(currentNode.encoded)), currentNodeID),
95                          "MerkleTrie: invalid root hash"
96                      );
97                  } else if (currentNode.encoded.length >= 32) {
98                      // Nodes 32 bytes or larger are hashed inside branch nodes.
99                      require(
100                         Bytes.equal(abi.encodePacked(keccak256(currentNode.encoded)), currentNodeID),
101                         "MerkleTrie: invalid large internal hash"
102                     );
103                 } else {
104                     // Nodes smaller than 32 bytes aren't hashed.
105                     require(
106                         Bytes.equal(currentNode.encoded, currentNodeID),
107                         "MerkleTrie: invalid internal node hash"
108                     );
109                 }
110     
111                 if (currentNode.decoded.length == BRANCH_NODE_LENGTH) {
112                     if (currentKeyIndex == key.length) {
113                         // Value is the last element of the decoded list (for branch nodes). There's
114                         // some ambiguity in the Merkle trie specification because bytes(0) is a
115                         // valid value to place into the trie, but for branch nodes bytes(0) can exist
116                         // even when the value wasn't explicitly placed there. Geth treats a value of
117                         // bytes(0) as "key does not exist" and so we do the same.
118                         value_ = RLPReader.readBytes(currentNode.decoded[TREE_RADIX]);
119                         require(
120                             value_.length > 0,
121                             "MerkleTrie: value length must be greater than zero (branch)"
122                         );
123     
124                         // Extra proof elements are not allowed.
125                         require(
126                             i == proof.length - 1,
127                             "MerkleTrie: value node must be last node in proof (branch)"
128                         );
129     
130                         return value_;
131                     } else {
132                         // We're not at the end of the key yet.
133                         // Figure out what the next node ID should be and continue.
134                         uint8 branchKey = uint8(key[currentKeyIndex]);
135                         RLPReader.RLPItem memory nextNode = currentNode.decoded[branchKey];
136                         currentNodeID = _getNodeID(nextNode);
137                         currentKeyIndex += 1;
138                     }
139                 } else if (currentNode.decoded.length == LEAF_OR_EXTENSION_NODE_LENGTH) {
140                     bytes memory path = _getNodePath(currentNode);
141                     uint8 prefix = uint8(path[0]);
142                     uint8 offset = 2 - (prefix % 2);
143                     bytes memory pathRemainder = Bytes.slice(path, offset);
144                     bytes memory keyRemainder = Bytes.slice(key, currentKeyIndex);
145                     uint256 sharedNibbleLength = _getSharedNibbleLength(pathRemainder, keyRemainder);
146     
147                     // Whether this is a leaf node or an extension node, the path remainder MUST be a
148                     // prefix of the key remainder (or be equal to the key remainder) or the proof is
149                     // considered invalid.
150                     require(
151                         pathRemainder.length == sharedNibbleLength,
152                         "MerkleTrie: path remainder must share all nibbles with key"
153                     );
154     
155                     if (prefix == PREFIX_LEAF_EVEN || prefix == PREFIX_LEAF_ODD) {
156                         // Prefix of 2 or 3 means this is a leaf node. For the leaf node to be valid,
157                         // the key remainder must be exactly equal to the path remainder. We already
158                         // did the necessary byte comparison, so it's more efficient here to check that
159                         // the key remainder length equals the shared nibble length, which implies
160                         // equality with the path remainder (since we already did the same check with
161                         // the path remainder and the shared nibble length).
162                         require(
163                             keyRemainder.length == sharedNibbleLength,
164                             "MerkleTrie: key remainder must be identical to path remainder"
165                         );
166     
167                         // Our Merkle Trie is designed specifically for the purposes of the Ethereum
168                         // state trie. Empty values are not allowed in the state trie, so we can safely
169                         // say that if the value is empty, the key should not exist and the proof is
170                         // invalid.
171                         value_ = RLPReader.readBytes(currentNode.decoded[1]);
172                         require(
173                             value_.length > 0,
174                             "MerkleTrie: value length must be greater than zero (leaf)"
175                         );
176     
177                         // Extra proof elements are not allowed.
178                         require(
179                             i == proof.length - 1,
180                             "MerkleTrie: value node must be last node in proof (leaf)"
181                         );
182     
183                         return value_;
184                     } else if (prefix == PREFIX_EXTENSION_EVEN || prefix == PREFIX_EXTENSION_ODD) {
185                         // Prefix of 0 or 1 means this is an extension node. We move onto the next node
186                         // in the proof and increment the key index by the length of the path remainder
187                         // which is equal to the shared nibble length.
188                         currentNodeID = _getNodeID(currentNode.decoded[1]);
189                         currentKeyIndex += sharedNibbleLength;
190                     } else {
191                         revert("MerkleTrie: received a node with an unknown prefix");
192                     }
193                 } else {
194                     revert("MerkleTrie: received an unparseable node");
195                 }
196             }


208             for (uint256 i = 0; i < length;) {
209                 proof_[i] = TrieNode({ encoded: _proof[i], decoded: RLPReader.readList(_proof[i]) });
210                 unchecked {
211                     ++i;
212                 }
213             }


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/trie/MerkleTrie.sol#L208:213

```solidity
File: contracts/tokenvault/ERC721Vault.sol


170                 for (uint256 i; i < _tokenIds.length; ++i) {
171                     IERC721(token_).safeTransferFrom(address(this), _to, _tokenIds[i]);
172                 }


175                 for (uint256 i; i < _tokenIds.length; ++i) {
176                     BridgedERC721(token_).mint(_to, _tokenIds[i]);
177                 }


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC721Vault.sol#L175:177

```solidity
File: contracts/verifiers/SgxVerifier.sol


104             for (uint256 i; i < _ids.length; ++i) {
105                 uint256 idx = _ids[i];
106     
107                 if (instances[idx].addr == address(0)) revert SGX_INVALID_INSTANCE();
108     
109                 emit InstanceDeleted(idx, instances[idx].addr);
110     
111                 delete instances[idx];
112             }


210             for (uint256 i; i < _instances.length; ++i) {
211                 if (addressRegistered[_instances[i]]) revert SGX_ALREADY_ATTESTED();
212     
213                 addressRegistered[_instances[i]] = true;
214     
215                 if (_instances[i] == address(0)) revert SGX_INVALID_INSTANCE();
216     
217                 instances[nextInstanceId] = Instance(_instances[i], validSince);
218                 ids[i] = nextInstanceId;
219     
220                 emit InstanceAdded(nextInstanceId, _instances[i], address(0), validSince);
221     
222                 nextInstanceId++;
223             }


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/verifiers/SgxVerifier.sol#L210:223

</details>

## NC037 - Large numeric literals should use underscores for readability:

At a glance, it's quite difficult to understand how big this number is. Use underscores to make values more clear.


<details>
<summary>Click to show 23 findings</summary>

```solidity
File: contracts/L1/TaikoL1.sol


209                 ethDepositRingBufferSize: 1024,


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/TaikoL1.sol#L209:209

```solidity
File: contracts/L1/gov/TaikoGovernor.sol


112             return 7200; // 1 day


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/gov/TaikoGovernor.sol#L112:112

```solidity
File: contracts/L1/libs/LibProposing.sol


21          uint256 public constant MAX_BYTES_PER_BLOB = 4096 * 32;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProposing.sol#L21:21

```solidity
File: contracts/L1/libs/LibVerifying.sol


251                     || _config.blockMaxTxListBytes > 128 * 1024 // calldata up to 128K


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibVerifying.sol#L251:251

```solidity
File: contracts/L1/tiers/DevnetTierProvider.sol


38                      provingWindow: 2880, // 48 hours


26                      cooldownWindow: 1440, //24 hours


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/tiers/DevnetTierProvider.sol#L26:26

```solidity
File: contracts/L1/tiers/ITierProvider.sol


48          uint16 public constant TIER_GUARDIAN = 1000;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/tiers/ITierProvider.sol#L48:48

```solidity
File: contracts/L1/tiers/MainnetTierProvider.sol


68              if (_rand % 1000 == 0) return LibTiers.TIER_SGX_ZKVM;


36                      contestBond: 1000 ether, // TKO


26                      cooldownWindow: 1440, //24 hours


37                      cooldownWindow: 1440, //24 hours


49                      provingWindow: 2880, // 48 hours


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/tiers/MainnetTierProvider.sol#L49:49

```solidity
File: contracts/L1/tiers/TestnetTierProvider.sol


37                      cooldownWindow: 1440, //24 hours


36                      contestBond: 1000 ether, // TKO


49                      provingWindow: 2880, // 48 hours


26                      cooldownWindow: 1440, //24 hours


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/tiers/TestnetTierProvider.sol#L26:26

```solidity
File: contracts/automata-attestation/lib/QuoteV3Auth/V3Parser.sol


14          uint256 internal constant MINIMUM_QUOTE_LENGTH = 1020;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/QuoteV3Auth/V3Parser.sol#L14:14

```solidity
File: contracts/automata-attestation/utils/X509DateUtils.sol


19                  else yrs += 1900;


21                  yrs += (uint8(x509Time[0]) - 48) * 1000 + (uint8(x509Time[1]) - 48) * 100;


64              timestamp += uint256(hour) * 3600; // Hours in seconds


18                  if (uint8(x509Time[0]) - 48 < 5) yrs += 2000;


48              for (uint16 i = 1970; i < year; ++i) {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/X509DateUtils.sol#L48:48

```solidity
File: contracts/libs/Lib4844.sol


13          uint32 public constant FIELD_ELEMENTS_PER_BLOB = 4096;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/libs/Lib4844.sol#L13:13

</details>

## NC038 - Cast to `bytes` or `bytes32` for clearer semantic meaning:

Using a [cast](https://ethereum.stackexchange.com/questions/30912/how-to-compare-strings-in-solidity#answer-82739) on a single argument, rather than `abi.encodePacked()` makes the intended operation more clear, leading to less reviewer confusion.


<details>
<summary>Click to show 4 findings</summary>

```solidity
File: contracts/libs/LibTrieProof.sol


48                      SecureMerkleTrie.get(abi.encodePacked(_addr), _accountProof, _rootHash);


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/libs/LibTrieProof.sol#L48:48

```solidity
File: contracts/thirdparty/optimism/trie/MerkleTrie.sol


94                          Bytes.equal(abi.encodePacked(keccak256(currentNode.encoded)), currentNodeID),


100                         Bytes.equal(abi.encodePacked(keccak256(currentNode.encoded)), currentNodeID),


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/trie/MerkleTrie.sol#L100:100

```solidity
File: contracts/thirdparty/optimism/trie/SecureMerkleTrie.sol


55              hash_ = abi.encodePacked(keccak256(_key));


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/trie/SecureMerkleTrie.sol#L55:55

</details>

## NC039 - Variables should be named in mixedCase style:

As the [Solidity Style Guide](https://docs.soliditylang.org/en/latest/style-guide.html#naming-styles) suggests: arguments, local variables and mutable state variables should be named in mixedCase style.


<details>
<summary>Click to show 57 findings</summary>

```solidity
File: contracts/L1/TaikoData.sol


174             uint32 __reserved3;


32              bool blobAllowedForDA;


173             uint16 __reserved2;


193             SlotA slotA; // slot 6


195             uint256[43] __gap;


172             uint8 __reserved1;


194             SlotB slotB; // slot 7


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/TaikoData.sol#L194:194

```solidity
File: contracts/L1/TaikoL1.sol


26          uint256[50] private __gap;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/TaikoL1.sol#L26:26

```solidity
File: contracts/L1/TaikoToken.sol


16          uint256[50] private __gap;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/TaikoToken.sol#L16:16

```solidity
File: contracts/L1/gov/TaikoGovernor.sol


23          uint256[50] private __gap;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/gov/TaikoGovernor.sol#L23:23

```solidity
File: contracts/L1/gov/TaikoTimelockController.sol


10          uint256[50] private __gap;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/gov/TaikoTimelockController.sol#L10:10

```solidity
File: contracts/L1/hooks/AssignmentHook.sol


40          uint256[50] private __gap;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/hooks/AssignmentHook.sol#L40:40

```solidity
File: contracts/L1/libs/LibDepositing.sol


44              address recipient_ = _recipient == address(0) ? msg.sender : _recipient;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibDepositing.sol#L44:44

```solidity
File: contracts/L1/libs/LibProposing.sol


300             TaikoData.SlotB memory _slotB,


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProposing.sol#L300:300

```solidity
File: contracts/L1/provers/GuardianProver.sol


11          uint256[50] private __gap;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/provers/GuardianProver.sol#L11:11

```solidity
File: contracts/L1/provers/Guardians.sol


32          uint256[46] private __gap;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/provers/Guardians.sol#L32:32

```solidity
File: contracts/L1/tiers/DevnetTierProvider.sol


11          uint256[50] private __gap;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/tiers/DevnetTierProvider.sol#L11:11

```solidity
File: contracts/L1/tiers/MainnetTierProvider.sol


11          uint256[50] private __gap;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/tiers/MainnetTierProvider.sol#L11:11

```solidity
File: contracts/L1/tiers/TestnetTierProvider.sol


11          uint256[50] private __gap;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/tiers/TestnetTierProvider.sol#L11:11

```solidity
File: contracts/L2/CrossChainOwned.sol


21          uint256[49] private __gap;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/CrossChainOwned.sol#L21:21

```solidity
File: contracts/L2/TaikoL2.sol


52          uint256[47] private __gap;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/TaikoL2.sol#L52:52

```solidity
File: contracts/L2/TaikoL2EIP1559Configurable.sol


13          uint256[49] private __gap;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/TaikoL2EIP1559Configurable.sol#L13:13

```solidity
File: contracts/automata-attestation/lib/PEMCertChainLib.sol


177                 bytes memory sigY = _trimBytes(der.bytesAt(sigPtr), 32);


174                 bytes memory sigX = _trimBytes(der.bytesAt(sigPtr), 32);


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/PEMCertChainLib.sol#L174:174

```solidity
File: contracts/automata-attestation/lib/QuoteV3Auth/V3Parser.sol


250             uint16 isvSvnPackBE = (enclaveReport.isvSvn >> 8) | (enclaveReport.isvSvn << 8);


249             uint16 isvProdIdPackBE = (enclaveReport.isvProdId >> 8) | (enclaveReport.isvProdId << 8);


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/QuoteV3Auth/V3Parser.sol#L249:249

```solidity
File: contracts/automata-attestation/utils/SigVerifyLib.sol


18          address private ES256VERIFIER;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/SigVerifyLib.sol#L18:18

```solidity
File: contracts/bridge/Bridge.sol


38          Context private __ctx;


48          uint256[43] private __gap;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/Bridge.sol#L48:48

```solidity
File: contracts/common/AddressManager.sol


12          mapping(uint256 chainId => mapping(bytes32 name => address addr)) private __addresses;


14          uint256[49] private __gap;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/common/AddressManager.sol#L14:14

```solidity
File: contracts/common/AddressResolver.sol


14          uint256[49] private __gap;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/common/AddressResolver.sol#L14:14

```solidity
File: contracts/common/EssentialContract.sol


23          uint8 private __paused;


21          uint8 private __reentry;


25          uint256[49] private __gap;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/common/EssentialContract.sol#L25:25

```solidity
File: contracts/signal/SignalService.sol


23          uint256[48] private __gap;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/signal/SignalService.sol#L23:23

```solidity
File: contracts/team/TimelockTokenPool.sol


82          uint128[44] private __gap;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/TimelockTokenPool.sol#L82:82

```solidity
File: contracts/team/airdrop/ERC20Airdrop.sol


18          uint256[48] private __gap;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/airdrop/ERC20Airdrop.sol#L18:18

```solidity
File: contracts/team/airdrop/ERC20Airdrop2.sol


30          uint256[45] private __gap;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/airdrop/ERC20Airdrop2.sol#L30:30

```solidity
File: contracts/team/airdrop/ERC721Airdrop.sol


16          uint256[48] private __gap;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/airdrop/ERC721Airdrop.sol#L16:16

```solidity
File: contracts/team/airdrop/MerkleClaimable.sol


23          uint256[47] private __gap;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/airdrop/MerkleClaimable.sol#L23:23

```solidity
File: contracts/thirdparty/optimism/trie/MerkleTrie.sol


81              bytes memory currentNodeID = abi.encodePacked(_root);


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/trie/MerkleTrie.sol#L81:81

```solidity
File: contracts/tokenvault/BaseNFTVault.sol


61          uint256[48] private __gap;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BaseNFTVault.sol#L61:61

```solidity
File: contracts/tokenvault/BaseVault.sol


18          uint256[50] private __gap;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BaseVault.sol#L18:18

```solidity
File: contracts/tokenvault/BridgedERC1155.sol


27          uint256[46] private __gap;


25          string private __name;


22          string private __symbol;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC1155.sol#L22:22

```solidity
File: contracts/tokenvault/BridgedERC20.sol


32          uint256[47] private __gap;


24          uint8 private __srcDecimals;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC20.sol#L24:24

```solidity
File: contracts/tokenvault/BridgedERC20Base.sol


16          uint256[49] private __gap;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC20Base.sol#L16:16

```solidity
File: contracts/tokenvault/BridgedERC721.sol


19          uint256[48] private __gap;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC721.sol#L19:19

```solidity
File: contracts/tokenvault/ERC1155Vault.sol


32          uint256[50] private __gap;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC1155Vault.sol#L32:32

```solidity
File: contracts/tokenvault/ERC20Vault.sol


54          uint256[47] private __gap;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC20Vault.sol#L54:54

```solidity
File: contracts/tokenvault/ERC721Vault.sol


19          uint256[50] private __gap;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC721Vault.sol#L19:19

```solidity
File: contracts/tokenvault/adapters/USDCAdapter.sol


32          uint256[49] private __gap;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/adapters/USDCAdapter.sol#L32:32

```solidity
File: contracts/verifiers/GuardianVerifier.sol


11          uint256[50] private __gap;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/verifiers/GuardianVerifier.sol#L11:11

```solidity
File: contracts/verifiers/SgxVerifier.sol


57          uint256[47] private __gap;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/verifiers/SgxVerifier.sol#L57:57

</details>

## NC040 - Use allowlist/denylist rather than whitelist/blacklist:

Use alternative variants, e.g. allowlist/denylist instead of whitelist/blacklist.


<details>
<summary>Click to show 9 findings</summary>

```solidity
File: contracts/automata-attestation/utils/BytesUtils.sol


5       // https://github.com/ensdomains/dnssec-oracle/blob/master/contracts/BytesUtils.sol


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/BytesUtils.sol#L5:5

```solidity
File: contracts/automata-attestation/utils/RsaVerify.sol


8       // https://github.com/adria0/SolRsaVerify/blob/master/src/RsaVerify.sol


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/RsaVerify.sol#L8:8

```solidity
File: contracts/automata-attestation/utils/SHA1.sol


6       // https://github.com/ensdomains/solsha1/blob/master/contracts/SHA1.sol


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/SHA1.sol#L6:6

```solidity
File: contracts/tokenvault/ERC20Vault.sol


51          /// @notice Mappings from bridged tokens to their blacklist status.


52          mapping(address btoken => bool blacklisted) public btokenBlacklist;


136         error VAULT_BTOKEN_BLACKLISTED();


162             if (btokenBlacklist[_btokenNew]) revert VAULT_BTOKEN_BLACKLISTED();


181                 btokenBlacklist[btokenOld_] = true;


216             if (btokenBlacklist[_op.token]) revert VAULT_BTOKEN_BLACKLISTED();


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC20Vault.sol#L216:216

</details>

## NC041 - Contracts containing only utility functions should be made into libraries:




<details>
<summary>Click to show 4 findings</summary>

```solidity
File: contracts/L1/TaikoErrors.sol


11      abstract contract TaikoErrors {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/TaikoErrors.sol#L11:11

```solidity
File: contracts/L1/TaikoEvents.sol


13      abstract contract TaikoEvents {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/TaikoEvents.sol#L13:13

```solidity
File: contracts/automata-attestation/lib/PEMCertChainLib.sol


12      contract PEMCertChainLib is IPEMCertChainLib {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/PEMCertChainLib.sol#L12:12

```solidity
File: contracts/tokenvault/BaseNFTVault.sol


9       abstract contract BaseNFTVault is BaseVault {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BaseNFTVault.sol#L9:9

</details>

## NC042 - Function names should use lowerCamelCase:

According to the Solidity [style guide](https://docs.soliditylang.org/en/latest/style-guide.html#function-names) function names should be in `mixedCase` (lowerCamelCase).


<details>
<summary>Click to show 18 findings</summary>

```solidity
File: contracts/L2/CrossChainOwned.sol


60          function __CrossChainOwned_init(


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/CrossChainOwned.sol#L60:60

```solidity
File: contracts/automata-attestation/AutomataDcapV3Attestation.sol


175         function _verifyQEReportWithIdentity(V3Struct.EnclaveReport memory quoteEnclaveReport)


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/AutomataDcapV3Attestation.sol#L175:175

```solidity
File: contracts/automata-attestation/interfaces/ISigVerifyLib.sol


58          function verifyRS256Signature(


67          function verifyRS1Signature(


76          function verifyES256Signature(


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/interfaces/ISigVerifyLib.sol#L76:76

```solidity
File: contracts/automata-attestation/lib/QuoteV3Auth/V3Parser.sol


244         function packQEReport(V3Struct.EnclaveReport memory enclaveReport)


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/QuoteV3Auth/V3Parser.sol#L244:244

```solidity
File: contracts/automata-attestation/utils/BytesUtils.sol


255         function readBytesN(


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/BytesUtils.sol#L255:255

```solidity
File: contracts/automata-attestation/utils/SigVerifyLib.sol


79          function verifyRS256Signature(


96          function verifyRS1Signature(


113         function verifyES256Signature(


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/SigVerifyLib.sol#L113:113

```solidity
File: contracts/common/AddressResolver.sol


58          function __AddressResolver_init(address _addressManager) internal virtual onlyInitializing {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/common/AddressResolver.sol#L58:58

```solidity
File: contracts/common/EssentialContract.sol


95          function __Essential_init(


109         function __Essential_init(address _owner) internal virtual {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/common/EssentialContract.sol#L109:109

```solidity
File: contracts/libs/LibAddress.sol


77          function isSenderEOA() internal view returns (bool) {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/libs/LibAddress.sol#L77:77

```solidity
File: contracts/team/airdrop/MerkleClaimable.sol


56          function __MerkleClaimable_init(


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/airdrop/MerkleClaimable.sol#L56:56

```solidity
File: contracts/thirdparty/optimism/trie/MerkleTrie.sol


220         function _getNodeID(RLPReader.RLPItem memory _node) private pure returns (bytes memory id_) {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/trie/MerkleTrie.sol#L220:220

```solidity
File: contracts/tokenvault/BridgedERC721.sol


107         function tokenURI(uint256 _tokenId) public view virtual override returns (string memory) {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC721.sol#L107:107

```solidity
File: contracts/tokenvault/LibBridgedToken.sol


43          function buildURI(


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/LibBridgedToken.sol#L43:43

</details>

## NC043 - Consider adding a deny-list:

Doing so will significantly increase centralization, but will help to prevent hackers from using stolen tokens.


<details>
<summary>Click to show 29 findings</summary>

```solidity
File: contracts/L1/TaikoL1.sol


22      contract TaikoL1 is EssentialContract, ITaikoL1, TaikoEvents, TaikoErrors {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/TaikoL1.sol#L22:22

```solidity
File: contracts/L1/TaikoToken.sol


15      contract TaikoToken is EssentialContract, ERC20SnapshotUpgradeable, ERC20VotesUpgradeable {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/TaikoToken.sol#L15:15

```solidity
File: contracts/L1/gov/TaikoGovernor.sol


16      contract TaikoGovernor is


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/gov/TaikoGovernor.sol#L16:16

```solidity
File: contracts/L1/gov/TaikoTimelockController.sol


9       contract TaikoTimelockController is EssentialContract, TimelockControllerUpgradeable {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/gov/TaikoTimelockController.sol#L9:9

```solidity
File: contracts/L1/hooks/AssignmentHook.sol


14      contract AssignmentHook is EssentialContract, IHook {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/hooks/AssignmentHook.sol#L14:14

```solidity
File: contracts/L1/provers/GuardianProver.sol


10      contract GuardianProver is Guardians {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/provers/GuardianProver.sol#L10:10

```solidity
File: contracts/L1/tiers/DevnetTierProvider.sol


10      contract DevnetTierProvider is EssentialContract, ITierProvider {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/tiers/DevnetTierProvider.sol#L10:10

```solidity
File: contracts/L1/tiers/MainnetTierProvider.sol


10      contract MainnetTierProvider is EssentialContract, ITierProvider {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/tiers/MainnetTierProvider.sol#L10:10

```solidity
File: contracts/L1/tiers/TestnetTierProvider.sol


10      contract TestnetTierProvider is EssentialContract, ITierProvider {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/tiers/TestnetTierProvider.sol#L10:10

```solidity
File: contracts/L2/TaikoL2.sol


21      contract TaikoL2 is CrossChainOwned {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/TaikoL2.sol#L21:21

```solidity
File: contracts/L2/TaikoL2EIP1559Configurable.sol


9       contract TaikoL2EIP1559Configurable is TaikoL2 {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/TaikoL2EIP1559Configurable.sol#L9:9

```solidity
File: contracts/automata-attestation/AutomataDcapV3Attestation.sol


22      contract AutomataDcapV3Attestation is IAttestation {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/AutomataDcapV3Attestation.sol#L22:22

```solidity
File: contracts/automata-attestation/lib/PEMCertChainLib.sol


12      contract PEMCertChainLib is IPEMCertChainLib {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/PEMCertChainLib.sol#L12:12

```solidity
File: contracts/automata-attestation/utils/SigVerifyLib.sol


15      contract SigVerifyLib is ISigVerifyLib {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/SigVerifyLib.sol#L15:15

```solidity
File: contracts/bridge/Bridge.sol


16      contract Bridge is EssentialContract, IBridge {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/Bridge.sol#L16:16

```solidity
File: contracts/common/AddressManager.sol


10      contract AddressManager is EssentialContract, IAddressManager {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/common/AddressManager.sol#L10:10

```solidity
File: contracts/signal/SignalService.sol


14      contract SignalService is EssentialContract, ISignalService {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/signal/SignalService.sol#L14:14

```solidity
File: contracts/team/TimelockTokenPool.sol


25      contract TimelockTokenPool is EssentialContract {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/TimelockTokenPool.sol#L25:25

```solidity
File: contracts/team/airdrop/ERC20Airdrop.sol


11      contract ERC20Airdrop is MerkleClaimable {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/airdrop/ERC20Airdrop.sol#L11:11

```solidity
File: contracts/team/airdrop/ERC20Airdrop2.sol


12      contract ERC20Airdrop2 is MerkleClaimable {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/airdrop/ERC20Airdrop2.sol#L12:12

```solidity
File: contracts/team/airdrop/ERC721Airdrop.sol


9       contract ERC721Airdrop is MerkleClaimable {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/airdrop/ERC721Airdrop.sol#L9:9

```solidity
File: contracts/tokenvault/BridgedERC1155.sol


14      contract BridgedERC1155 is EssentialContract, IERC1155MetadataURIUpgradeable, ERC1155Upgradeable {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC1155.sol#L14:14

```solidity
File: contracts/tokenvault/BridgedERC20.sol


15      contract BridgedERC20 is


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC20.sol#L15:15

```solidity
File: contracts/tokenvault/BridgedERC721.sol


12      contract BridgedERC721 is EssentialContract, ERC721Upgradeable {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC721.sol#L12:12

```solidity
File: contracts/tokenvault/ERC1155Vault.sol


29      contract ERC1155Vault is BaseNFTVault, ERC1155ReceiverUpgradeable {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC1155Vault.sol#L29:29

```solidity
File: contracts/tokenvault/ERC721Vault.sol


16      contract ERC721Vault is BaseNFTVault, IERC721Receiver {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC721Vault.sol#L16:16

```solidity
File: contracts/tokenvault/adapters/USDCAdapter.sol


28      contract USDCAdapter is BridgedERC20Base {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/adapters/USDCAdapter.sol#L28:28

```solidity
File: contracts/verifiers/GuardianVerifier.sol


10      contract GuardianVerifier is EssentialContract, IVerifier {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/verifiers/GuardianVerifier.sol#L10:10

```solidity
File: contracts/verifiers/SgxVerifier.sol


19      contract SgxVerifier is EssentialContract, IVerifier {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/verifiers/SgxVerifier.sol#L19:19

</details>

## NC044 - Custom errors should be used rather than `revert()`/`require()`:

Custom errors are available from solidity version 0.8.4. Custom errors are more easily processed in `try`-`catch` blocks, and are easier to re-use and maintain.


<details>
<summary>Click to show 7 findings</summary>

```solidity
File: contracts/L1/hooks/AssignmentHook.sol


175             revert HOOK_TIER_NOT_FOUND();


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/hooks/AssignmentHook.sol#L175:175

```solidity
File: contracts/L1/tiers/DevnetTierProvider.sol


43              revert TIER_NOT_FOUND();


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/tiers/DevnetTierProvider.sol#L43:43

```solidity
File: contracts/L1/tiers/MainnetTierProvider.sol


54              revert TIER_NOT_FOUND();


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/tiers/MainnetTierProvider.sol#L54:54

```solidity
File: contracts/L1/tiers/TestnetTierProvider.sol


54              revert TIER_NOT_FOUND();


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/tiers/TestnetTierProvider.sol#L54:54

```solidity
File: contracts/automata-attestation/AutomataDcapV3Attestation.sol


61              require(msg.sender == owner, "onlyOwner");


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/AutomataDcapV3Attestation.sol#L61:61

```solidity
File: contracts/common/AddressManager.sol


59              revert AM_UNSUPPORTED();


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/common/AddressManager.sol#L59:59

```solidity
File: contracts/signal/SignalService.sol


232             revert SS_UNSUPPORTED();


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/signal/SignalService.sol#L232:232

</details>

## NC045 - Interfaces should be defined in separate files from their usage:

This issue arises when the interfaces are defined in the same files where they are used. They should be separated into different files for better readability and reusability.


```solidity
File: contracts/tokenvault/ERC1155Vault.sol


16      interface IERC1155NameAndSymbol {
17          /// @notice Returns the name of the token.
18          function name() external view returns (string memory);
19      
20          /// @notice Returns the symbol of the token.
21          function symbol() external view returns (string memory);
22      }


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC1155Vault.sol#L16:22

```solidity
File: contracts/tokenvault/adapters/USDCAdapter.sol


8       interface IUSDC {
9           /// @notice Burns a specific amount of tokens.
10          /// @param _amount The amount of token to be burned.
11          function burn(uint256 _amount) external;
12      
13          /// @notice Mints a specific amount of new tokens to an address.
14          /// @param _to The address that will receive the minted tokens.
15          /// @param _amount The amount of tokens to mint.
16          function mint(address _to, uint256 _amount) external;
17      
18          /// @notice Transfers tokens from one address to another.
19          /// @param from The address which you want to send tokens from.
20          /// @param _to The address which you want to transfer to.
21          /// @param _amount The amount of tokens to be transferred.
22          /// @return true if the transfer was successful, otherwise false.
23          function transferFrom(address from, address _to, uint256 _amount) external returns (bool);
24      }


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/adapters/USDCAdapter.sol#L8:24

## NC046 - Custom error has no error details:

Consider adding parameters to the error to indicate which user or values caused the failure.


<details>
<summary>Click to show 160 findings</summary>

```solidity
File: contracts/L1/TaikoErrors.sol


12          error L1_ALREADY_CONTESTED();


13          error L1_ALREADY_PROVED();


14          error L1_ASSIGNED_PROVER_NOT_ALLOWED();


15          error L1_BLOB_FOR_DA_DISABLED();


16          error L1_BLOB_NOT_FOUND();


17          error L1_BLOB_NOT_REUSABLE();


18          error L1_BLOB_REUSE_DISABLED();


19          error L1_BLOCK_MISMATCH();


20          error L1_INVALID_BLOCK_ID();


21          error L1_INVALID_CONFIG();


22          error L1_INVALID_ETH_DEPOSIT();


23          error L1_INVALID_HOOK();


24          error L1_INVALID_PARAM();


25          error L1_INVALID_PAUSE_STATUS();


26          error L1_INVALID_PROVER();


27          error L1_INVALID_TIER();


28          error L1_INVALID_TRANSITION();


29          error L1_LIVENESS_BOND_NOT_RECEIVED();


30          error L1_NOT_ASSIGNED_PROVER();


31          error L1_PROPOSER_NOT_EOA();


32          error L1_PROVING_PAUSED();


33          error L1_RECEIVE_DISABLED();


34          error L1_MISSING_VERIFIER();


35          error L1_TOO_MANY_BLOCKS();


36          error L1_TOO_MANY_TIERS();


37          error L1_TRANSITION_ID_ZERO();


38          error L1_TRANSITION_NOT_FOUND();


39          error L1_TXLIST_SIZE();


40          error L1_UNAUTHORIZED();


41          error L1_UNEXPECTED_PARENT();


42          error L1_UNEXPECTED_TRANSITION_ID();


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/TaikoErrors.sol#L42:42

```solidity
File: contracts/L1/TaikoToken.sol


18          error TKO_INVALID_ADDR();


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/TaikoToken.sol#L18:18

```solidity
File: contracts/L1/gov/TaikoGovernor.sol


25          error TG_INVALID_SIGNATURES_LENGTH();


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/gov/TaikoGovernor.sol#L25:25

```solidity
File: contracts/L1/hooks/AssignmentHook.sol


50          error HOOK_ASSIGNMENT_EXPIRED();


51          error HOOK_ASSIGNMENT_INVALID_SIG();


52          error HOOK_TIER_NOT_FOUND();


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/hooks/AssignmentHook.sol#L52:52

```solidity
File: contracts/L1/libs/LibDepositing.sol


22          error L1_INVALID_ETH_DEPOSIT();


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibDepositing.sol#L22:22

```solidity
File: contracts/L1/libs/LibProposing.sol


44          error L1_BLOB_FOR_DA_DISABLED();


45          error L1_BLOB_NOT_FOUND();


46          error L1_BLOB_NOT_REUSABLE();


47          error L1_BLOB_REUSE_DISABLED();


48          error L1_INVALID_HOOK();


49          error L1_INVALID_PARAM();


50          error L1_INVALID_PROVER();


51          error L1_LIVENESS_BOND_NOT_RECEIVED();


52          error L1_PROPOSER_NOT_EOA();


53          error L1_TOO_MANY_BLOCKS();


54          error L1_TXLIST_OFFSET();


55          error L1_TXLIST_SIZE();


56          error L1_UNAUTHORIZED();


57          error L1_UNEXPECTED_PARENT();


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProposing.sol#L57:57

```solidity
File: contracts/L1/libs/LibProving.sol


59          error L1_ALREADY_CONTESTED();


60          error L1_ALREADY_PROVED();


61          error L1_ASSIGNED_PROVER_NOT_ALLOWED();


62          error L1_BLOCK_MISMATCH();


63          error L1_INVALID_BLOCK_ID();


64          error L1_INVALID_PAUSE_STATUS();


65          error L1_INVALID_TIER();


66          error L1_INVALID_TRANSITION();


67          error L1_MISSING_VERIFIER();


68          error L1_NOT_ASSIGNED_PROVER();


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProving.sol#L68:68

```solidity
File: contracts/L1/libs/LibUtils.sol


11          error L1_BLOCK_MISMATCH();


12          error L1_INVALID_BLOCK_ID();


13          error L1_TRANSITION_NOT_FOUND();


14          error L1_UNEXPECTED_TRANSITION_ID();


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibUtils.sol#L14:14

```solidity
File: contracts/L1/libs/LibVerifying.sol


39          error L1_BLOCK_MISMATCH();


40          error L1_INVALID_CONFIG();


41          error L1_TRANSITION_ID_ZERO();


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibVerifying.sol#L41:41

```solidity
File: contracts/L1/provers/Guardians.sol


45          error INVALID_GUARDIAN();


46          error INVALID_GUARDIAN_SET();


47          error INVALID_MIN_GUARDIANS();


48          error INVALID_PROOF();


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/provers/Guardians.sol#L48:48

```solidity
File: contracts/L1/tiers/ITierProvider.sol


17          error TIER_NOT_FOUND();


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/tiers/ITierProvider.sol#L17:17

```solidity
File: contracts/L2/CrossChainOwned.sol


28          error XCO_INVALID_OWNER_CHAINID();


29          error XCO_INVALID_TX_ID();


30          error XCO_PERMISSION_DENIED();


31          error XCO_TX_REVERTED();


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/CrossChainOwned.sol#L31:31

```solidity
File: contracts/L2/Lib1559Math.sol


11          error EIP1559_INVALID_PARAMS();


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/Lib1559Math.sol#L11:11

```solidity
File: contracts/L2/TaikoL2.sol


59          error L2_BASEFEE_MISMATCH();


60          error L2_INVALID_CHAIN_ID();


61          error L2_INVALID_PARAM();


62          error L2_INVALID_SENDER();


63          error L2_PUBLIC_INPUT_HASH_MISMATCH();


64          error L2_TOO_LATE();


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/TaikoL2.sol#L64:64

```solidity
File: contracts/L2/TaikoL2EIP1559Configurable.sol


20          error L2_INVALID_CONFIG();


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/TaikoL2EIP1559Configurable.sol#L20:20

```solidity
File: contracts/bridge/Bridge.sol


50          error B_INVALID_CHAINID();


51          error B_INVALID_CONTEXT();


52          error B_INVALID_GAS_LIMIT();


53          error B_INVALID_STATUS();


54          error B_INVALID_USER();


55          error B_INVALID_VALUE();


56          error B_MESSAGE_NOT_SENT();


57          error B_NON_RETRIABLE();


58          error B_NOT_FAILED();


59          error B_NOT_RECEIVED();


60          error B_PERMISSION_DENIED();


61          error B_STATUS_MISMATCH();


62          error B_INVOCATION_TOO_EARLY();


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/Bridge.sol#L62:62

```solidity
File: contracts/common/AddressManager.sol


25          error AM_INVALID_PARAMS();


26          error AM_UNSUPPORTED();


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/common/AddressManager.sol#L26:26

```solidity
File: contracts/common/AddressResolver.sol


16          error RESOLVER_DENIED();


17          error RESOLVER_INVALID_MANAGER();


18          error RESOLVER_UNEXPECTED_CHAINID();


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/common/AddressResolver.sol#L18:18

```solidity
File: contracts/common/EssentialContract.sol


35          error REENTRANT_CALL();


36          error INVALID_PAUSE_STATUS();


37          error ZERO_ADDR_MANAGER();


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/common/EssentialContract.sol#L37:37

```solidity
File: contracts/libs/Lib4844.sol


19          error EVAL_FAILED_1();


20          error EVAL_FAILED_2();


21          error POINT_X_TOO_LARGE();


22          error POINT_Y_TOO_LARGE();


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/libs/Lib4844.sol#L22:22

```solidity
File: contracts/libs/LibAddress.sol


16          error ETH_TRANSFER_FAILED();


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/libs/LibAddress.sol#L16:16

```solidity
File: contracts/libs/LibTrieProof.sol


20          error LTP_INVALID_ACCOUNT_PROOF();


21          error LTP_INVALID_INCLUSION_PROOF();


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/libs/LibTrieProof.sol#L21:21

```solidity
File: contracts/signal/SignalService.sol


25          error SS_EMPTY_PROOF();


26          error SS_INVALID_SENDER();


27          error SS_INVALID_LAST_HOP_CHAINID();


28          error SS_INVALID_MID_HOP_CHAINID();


29          error SS_INVALID_STATE();


30          error SS_INVALID_VALUE();


31          error SS_SIGNAL_NOT_FOUND();


32          error SS_UNAUTHORIZED();


33          error SS_UNSUPPORTED();


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/signal/SignalService.sol#L33:33

```solidity
File: contracts/team/TimelockTokenPool.sol


101         error ALREADY_GRANTED();


102         error INVALID_GRANT();


103         error INVALID_PARAM();


104         error NOTHING_TO_VOID();


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/TimelockTokenPool.sol#L104:104

```solidity
File: contracts/team/airdrop/ERC20Airdrop2.sol


37          error WITHDRAWALS_NOT_ONGOING();


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/airdrop/ERC20Airdrop2.sol#L37:37

```solidity
File: contracts/team/airdrop/MerkleClaimable.sol


29          error CLAIM_NOT_ONGOING();


30          error CLAIMED_ALREADY();


31          error INVALID_PROOF();


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/airdrop/MerkleClaimable.sol#L31:31

```solidity
File: contracts/thirdparty/solmate/LibFixedPointMath.sol


10          error Overflow();


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/solmate/LibFixedPointMath.sol#L10:10

```solidity
File: contracts/tokenvault/BaseNFTVault.sol


133         error VAULT_INVALID_TOKEN();


134         error VAULT_INVALID_AMOUNT();


135         error VAULT_INVALID_TO();


136         error VAULT_INTERFACE_NOT_SUPPORTED();


137         error VAULT_TOKEN_ARRAY_MISMATCH();


138         error VAULT_MAX_TOKEN_PER_TXN_EXCEEDED();


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BaseNFTVault.sol#L138:138

```solidity
File: contracts/tokenvault/BaseVault.sol


20          error VAULT_PERMISSION_DENIED();


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BaseVault.sol#L20:20

```solidity
File: contracts/tokenvault/BridgedERC1155.sol


29          error BTOKEN_CANNOT_RECEIVE();


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC1155.sol#L29:29

```solidity
File: contracts/tokenvault/BridgedERC20.sol


34          error BTOKEN_CANNOT_RECEIVE();


35          error BTOKEN_UNAUTHORIZED();


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC20.sol#L35:35

```solidity
File: contracts/tokenvault/BridgedERC20Base.sol


29          error BB_PERMISSION_DENIED();


30          error BB_INVALID_PARAMS();


31          error BB_MINT_DISALLOWED();


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC20Base.sol#L31:31

```solidity
File: contracts/tokenvault/BridgedERC721.sol


21          error BTOKEN_CANNOT_RECEIVE();


22          error BTOKEN_INVALID_BURN();


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC721.sol#L22:22

```solidity
File: contracts/tokenvault/ERC20Vault.sol


136         error VAULT_BTOKEN_BLACKLISTED();


137         error VAULT_CTOKEN_MISMATCH();


138         error VAULT_INVALID_TOKEN();


139         error VAULT_INVALID_AMOUNT();


140         error VAULT_INVALID_NEW_BTOKEN();


141         error VAULT_INVALID_TO();


142         error VAULT_NOT_SAME_OWNER();


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC20Vault.sol#L142:142

```solidity
File: contracts/tokenvault/LibBridgedToken.sol


9           error BTOKEN_INVALID_PARAMS();


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/LibBridgedToken.sol#L9:9

```solidity
File: contracts/verifiers/GuardianVerifier.sol


13          error PERMISSION_DENIED();


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/verifiers/GuardianVerifier.sol#L13:13

```solidity
File: contracts/verifiers/SgxVerifier.sol


74          error SGX_ALREADY_ATTESTED();


75          error SGX_INVALID_ATTESTATION();


76          error SGX_INVALID_INSTANCE();


77          error SGX_INVALID_PROOF();


78          error SGX_RA_NOT_SUPPORTED();


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/verifiers/SgxVerifier.sol#L78:78

</details>

## NC047 - Contract uses both `require()`/`revert()` as well as custom errors:

Consider using just one method in a single file


<details>
<summary>Click to show 16 findings</summary>

```solidity
File: contracts/L1/TaikoToken.sol


15      contract TaikoToken is EssentialContract, ERC20SnapshotUpgradeable, ERC20VotesUpgradeable {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/TaikoToken.sol#L15:15

```solidity
File: contracts/L1/gov/TaikoGovernor.sol


16      contract TaikoGovernor is


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/gov/TaikoGovernor.sol#L16:16

```solidity
File: contracts/L1/hooks/AssignmentHook.sol


14      contract AssignmentHook is EssentialContract, IHook {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/hooks/AssignmentHook.sol#L14:14

```solidity
File: contracts/L2/TaikoL2.sol


21      contract TaikoL2 is CrossChainOwned {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/TaikoL2.sol#L21:21

```solidity
File: contracts/L2/TaikoL2EIP1559Configurable.sol


9       contract TaikoL2EIP1559Configurable is TaikoL2 {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/TaikoL2EIP1559Configurable.sol#L9:9

```solidity
File: contracts/bridge/Bridge.sol


16      contract Bridge is EssentialContract, IBridge {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/Bridge.sol#L16:16

```solidity
File: contracts/common/AddressManager.sol


10      contract AddressManager is EssentialContract, IAddressManager {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/common/AddressManager.sol#L10:10

```solidity
File: contracts/signal/SignalService.sol


14      contract SignalService is EssentialContract, ISignalService {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/signal/SignalService.sol#L14:14

```solidity
File: contracts/team/TimelockTokenPool.sol


25      contract TimelockTokenPool is EssentialContract {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/TimelockTokenPool.sol#L25:25

```solidity
File: contracts/team/airdrop/ERC20Airdrop2.sol


12      contract ERC20Airdrop2 is MerkleClaimable {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/airdrop/ERC20Airdrop2.sol#L12:12

```solidity
File: contracts/tokenvault/BridgedERC1155.sol


14      contract BridgedERC1155 is EssentialContract, IERC1155MetadataURIUpgradeable, ERC1155Upgradeable {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC1155.sol#L14:14

```solidity
File: contracts/tokenvault/BridgedERC20.sol


15      contract BridgedERC20 is


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC20.sol#L15:15

```solidity
File: contracts/tokenvault/BridgedERC721.sol


12      contract BridgedERC721 is EssentialContract, ERC721Upgradeable {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC721.sol#L12:12

```solidity
File: contracts/tokenvault/ERC20Vault.sol


18      contract ERC20Vault is BaseVault {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC20Vault.sol#L18:18

```solidity
File: contracts/verifiers/GuardianVerifier.sol


10      contract GuardianVerifier is EssentialContract, IVerifier {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/verifiers/GuardianVerifier.sol#L10:10

```solidity
File: contracts/verifiers/SgxVerifier.sol


19      contract SgxVerifier is EssentialContract, IVerifier {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/verifiers/SgxVerifier.sol#L19:19

</details>

## NC048 - Overridden function has no body:

Consider adding a NatSpec comment describing why the function doesn't need a body and or the purpose it serves.


```solidity
File: contracts/L1/TaikoL1.sol


220         function _authorizePause(address)
221             internal
222             view
223             virtual
224             override
225             onlyFromOwnerOrNamed("chain_pauser")
226         { }


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/TaikoL1.sol#L220:226

```solidity
File: contracts/bridge/Bridge.sol


461         function _authorizePause(address)
462             internal
463             view
464             virtual
465             override
466             onlyFromOwnerOrNamed("bridge_pauser")
467         { }


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/Bridge.sol#L461:467

```solidity
File: contracts/common/EssentialContract.sol


114         function _authorizeUpgrade(address) internal virtual override onlyOwner { }


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/common/EssentialContract.sol#L114:114

## NC049 - Unused `struct` definition:

Note that there may be cases where a struct superficially appears to be used, but this is only because there are multiple definitions of the struct in different files. In such cases, the struct definition should be moved into a separate file. The instances below are the unused definitions.


<details>
<summary>Click to show 5 findings</summary>

```solidity
File: contracts/L1/TaikoData.sol


    struct TierFee {
        uint16 tier;
        uint128 fee;
    }

    struct State {
        // Ring buffer for proposed blocks and a some recent verified blocks.
        mapping(uint64 blockId_mod_blockRingBufferSize => Block blk) blocks;
        // Indexing to transition ids (ring buffer not possible)
        mapping(uint64 blockId => mapping(bytes32 parentHash => uint32 transitionId)) transitionIds;
        // Ring buffer for transitions
        mapping(
            uint64 blockId_mod_blockRingBufferSize
                => mapping(uint32 transitionId => TransitionState ts)
            ) transitions;
        // Ring buffer for Ether deposits
        mapping(uint256 depositId_mod_ethDepositRingBufferSize => uint256 depositAmount) ethDeposits;
        // Reusable blobs
        mapping(bytes32 blobHash => uint256 since) reusableBlobs;
        SlotA slotA; // slot 6
        SlotB slotB; // slot 7
        uint256[43] __gap;
    }

```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/TaikoData.sol#L179:196

```solidity
File: contracts/automata-attestation/interfaces/ISigVerifyLib.sol


    struct Certificate {
        // Asn.1 DER encoding of the to-be-signed certificate
        bytes tbsCertificate;
        PublicKey publicKey;
        bytes signature;
        CertSigAlgorithm sigAlg;
    }

```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/interfaces/ISigVerifyLib.sol#L24:30

```solidity
File: contracts/automata-attestation/lib/EnclaveIdStruct.sol


    struct EnclaveId {
        bytes4 miscselect;
        bytes4 miscselectMask;
        uint16 isvprodid;
        bytes16 attributes;
        bytes16 attributesMask;
        bytes32 mrsigner;
        TcbLevel[] tcbLevels;
    }

```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/EnclaveIdStruct.sol#L7:15

```solidity
File: contracts/automata-attestation/lib/TCBInfoStruct.sol


    struct TCBInfo {
        string pceid;
        string fmspc;
        TCBLevelObj[] tcbLevels;
    }

```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/TCBInfoStruct.sol#L7:11

</details>

## NC050 - Unused `error` definition:

Note that there may be cases where an error superficially appears to be used, but this is only because there are multiple definitions of the error in different files. In such cases, the error definition should be moved into a separate file. The instances below are the unused definitions.


```solidity
File: contracts/L1/TaikoErrors.sol


    error L1_TOO_MANY_TIERS();

```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/TaikoErrors.sol#L36:36

## NC051 - Events are missing sender information:

When an action is triggered based on a user's action, not being able to filter based on who triggered the action makes event processing a lot more cumbersome. Including the msg.sender the events of these types of action will make events much more useful to end users. Include `msg.sender` in the event output.


<details>
<summary>Click to show 32 findings</summary>

```solidity
File: contracts/L1/hooks/AssignmentHook.sol


129             emit BlockAssigned(_blk.assignedProver, _meta, assignment);


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/hooks/AssignmentHook.sol#L129:129

```solidity
File: contracts/L1/libs/LibProving.sol


80              emit ProvingPaused(_pause);


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProving.sol#L80:80

```solidity
File: contracts/L1/libs/LibVerifying.sol


73              emit BlockVerified({
74                  blockId: 0,
75                  assignedProver: address(0),
76                  prover: address(0),
77                  blockHash: _genesisBlockHash,
78                  stateRoot: 0,
79                  tier: 0,
80                  contestations: 0
81              });


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibVerifying.sol#L73:81

```solidity
File: contracts/L1/provers/Guardians.sol


95              emit GuardiansUpdated(version, _newGuardians);


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/provers/Guardians.sol#L95:95

```solidity
File: contracts/L2/CrossChainOwned.sol


53              emit TransactionExecuted(nextTxId++, bytes4(txdata));


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/CrossChainOwned.sol#L53:53

```solidity
File: contracts/L2/TaikoL2.sol


157             emit Anchored(blockhash(parentId), gasExcess);


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/TaikoL2.sol#L157:157

```solidity
File: contracts/L2/TaikoL2EIP1559Configurable.sol


39              emit ConfigAndExcessChanged(_newConfig, _newGasExcess);


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/TaikoL2EIP1559Configurable.sol#L39:39

```solidity
File: contracts/bridge/Bridge.sol


93                  emit MessageSuspended(msgHash, _suspend);


111             emit AddressBanned(_addr, _ban);


151             emit MessageSent(msgHash_, message_);


208                 emit MessageRecalled(msgHash);


210                 emit MessageReceived(msgHash, _message, true);


301                 emit MessageExecuted(msgHash);


303                 emit MessageReceived(msgHash, _message, false);


336             emit MessageRetried(msgHash);


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/Bridge.sol#L336:336

```solidity
File: contracts/common/AddressManager.sol


50              emit AddressSet(_chainId, _name, _newAddress, oldAddress);


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/common/AddressManager.sol#L50:50

```solidity
File: contracts/signal/SignalService.sol


59              emit Authorized(_addr, _authorize);


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/signal/SignalService.sol#L59:59

```solidity
File: contracts/team/TimelockTokenPool.sol


143             emit Granted(_recipient, _grant);


157             emit Voided(_recipient, amountVoided);


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/TimelockTokenPool.sol#L157:157

```solidity
File: contracts/team/airdrop/ERC20Airdrop2.sol


93              emit Withdrawn(user, amount);


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/airdrop/ERC20Airdrop2.sol#L93:93

```solidity
File: contracts/tokenvault/BridgedERC20Base.sol


51              emit MigrationStatusChanged(_migratingAddress, _migratingInbound);


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC20Base.sol#L51:51

```solidity
File: contracts/tokenvault/ERC1155Vault.sol


80              emit TokenSent({
81                  msgHash: msgHash,
82                  from: message_.srcOwner,
83                  to: _op.to,
84                  destChainId: message_.destChainId,
85                  ctoken: ctoken.addr,
86                  token: _op.token,
87                  tokenIds: _op.tokenIds,
88                  amounts: _op.amounts
89              });


114             emit TokenReceived({
115                 msgHash: ctx.msgHash,
116                 from: from,
117                 to: to,
118                 srcChainId: ctx.srcChainId,
119                 ctoken: ctoken.addr,
120                 token: token,
121                 tokenIds: tokenIds,
122                 amounts: amounts
123             });


149             emit TokenReleased({
150                 msgHash: msgHash,
151                 from: message.srcOwner,
152                 ctoken: ctoken.addr,
153                 token: token,
154                 tokenIds: tokenIds,
155                 amounts: amounts
156             });


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC1155Vault.sol#L149:156

```solidity
File: contracts/tokenvault/ERC20Vault.sol


191             emit BridgedTokenChanged({
192                 srcChainId: _ctoken.chainId,
193                 ctoken: _ctoken.addr,
194                 btokenOld: btokenOld_,
195                 btokenNew: _btokenNew,
196                 ctokenSymbol: _ctoken.symbol,
197                 ctokenName: _ctoken.name,
198                 ctokenDecimal: _ctoken.decimals
199             });


241             emit TokenSent({
242                 msgHash: msgHash,
243                 from: message_.srcOwner,
244                 to: _op.to,
245                 destChainId: _op.destChainId,
246                 ctoken: ctoken.addr,
247                 token: _op.token,
248                 amount: balanceChange
249             });


273             emit TokenReceived({
274                 msgHash: ctx.msgHash,
275                 from: from,
276                 to: to,
277                 srcChainId: ctx.srcChainId,
278                 ctoken: ctoken.addr,
279                 token: token,
280                 amount: amount
281             });


306             emit TokenReleased({
307                 msgHash: _msgHash,
308                 from: _message.srcOwner,
309                 ctoken: ctoken.addr,
310                 token: token,
311                 amount: amount
312             });


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC20Vault.sol#L306:312

```solidity
File: contracts/tokenvault/ERC721Vault.sol


64              emit TokenSent({
65                  msgHash: msgHash,
66                  from: message_.srcOwner,
67                  to: _op.to,
68                  destChainId: message_.destChainId,
69                  ctoken: ctoken.addr,
70                  token: _op.token,
71                  tokenIds: _op.tokenIds,
72                  amounts: _op.amounts
73              });


97              emit TokenReceived({
98                  msgHash: ctx.msgHash,
99                  from: from,
100                 to: to,
101                 srcChainId: ctx.srcChainId,
102                 ctoken: ctoken.addr,
103                 token: token,
104                 tokenIds: tokenIds,
105                 amounts: new uint256[](tokenIds.length)
106             });


131             emit TokenReleased({
132                 msgHash: _msgHash,
133                 from: _message.srcOwner,
134                 ctoken: ctoken.addr,
135                 token: token,
136                 tokenIds: tokenIds,
137                 amounts: new uint256[](tokenIds.length)
138             });


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC721Vault.sol#L131:138

```solidity
File: contracts/verifiers/SgxVerifier.sol


109                 emit InstanceDeleted(idx, instances[idx].addr);


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/verifiers/SgxVerifier.sol#L109:109

</details>

## NC052 - Enum values should be used in place of constant array indexes:

Create a commented enum value to use in place of constant array indexes, this makes the code far easier to understand.


<details>
<summary>Click to show 37 findings</summary>

```solidity
File: contracts/L1/libs/LibUtils.sol


80              if (_state.transitions[_slot][1].key == _parentHash) {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibUtils.sol#L80:80

```solidity
File: contracts/L1/libs/LibVerifying.sol


62              TaikoData.Block storage blk = _state.blocks[0];


68              TaikoData.TransitionState storage ts = _state.transitions[0][1];


68              TaikoData.TransitionState storage ts = _state.transitions[0][1];


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibVerifying.sol#L68:68

```solidity
File: contracts/L1/tiers/DevnetTierProvider.sol


49              tiers_[0] = LibTiers.TIER_OPTIMISTIC;


50              tiers_[1] = LibTiers.TIER_GUARDIAN;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/tiers/DevnetTierProvider.sol#L50:50

```solidity
File: contracts/L1/tiers/MainnetTierProvider.sol


60              tiers_[0] = LibTiers.TIER_SGX;


61              tiers_[1] = LibTiers.TIER_SGX_ZKVM;


62              tiers_[2] = LibTiers.TIER_GUARDIAN;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/tiers/MainnetTierProvider.sol#L62:62

```solidity
File: contracts/L1/tiers/TestnetTierProvider.sol


60              tiers_[0] = LibTiers.TIER_OPTIMISTIC;


61              tiers_[1] = LibTiers.TIER_SGX;


62              tiers_[2] = LibTiers.TIER_GUARDIAN;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/tiers/TestnetTierProvider.sol#L62:62

```solidity
File: contracts/L2/TaikoL2.sol


240             inputs[255] = bytes32(block.chainid);


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/TaikoL2.sol#L240:240

```solidity
File: contracts/automata-attestation/AutomataDcapV3Attestation.sol


435                 string memory parsedFmspc = parsedQuoteCerts[0].pck.sgxExtension.fmspc;


442                 IPEMCertChainLib.ECSha256Certificate memory pckCert = parsedQuoteCerts[0];


454                 (tcbVerified, tcbStatus) = _checkTcbLevels(parsedQuoteCerts[0].pck, fetchedTcbInfo);


472                     parsedQuoteCerts[0].pubKey,


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/AutomataDcapV3Attestation.sol#L472:472

```solidity
File: contracts/automata-attestation/lib/QuoteV3Auth/V3Parser.sol


285             certChainData = [quoteCerts[0], quoteCerts[1], quoteCerts[2]];


285             certChainData = [quoteCerts[0], quoteCerts[1], quoteCerts[2]];


285             certChainData = [quoteCerts[0], quoteCerts[1], quoteCerts[2]];


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/QuoteV3Auth/V3Parser.sol#L285:285

```solidity
File: contracts/automata-attestation/utils/RsaVerify.sol


137             if (decipher[0] != 0 || decipher[1] != 0x01) {


137             if (decipher[0] != 0 || decipher[1] != 0x01) {


270             if (decipher[0] != 0 || decipher[1] != 0x01) {


270             if (decipher[0] != 0 || decipher[1] != 0x01) {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/RsaVerify.sol#L270:270

```solidity
File: contracts/automata-attestation/utils/X509DateUtils.sol


18                  if (uint8(x509Time[0]) - 48 < 5) yrs += 2000;


21                  yrs += (uint8(x509Time[0]) - 48) * 1000 + (uint8(x509Time[1]) - 48) * 100;


21                  yrs += (uint8(x509Time[0]) - 48) * 1000 + (uint8(x509Time[1]) - 48) * 100;


57              if (isLeapYear(year)) monthDays[1] = 29;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/X509DateUtils.sol#L57:57

```solidity
File: contracts/thirdparty/optimism/rlp/RLPWriter.sol


14              if (_in.length == 1 && uint8(_in[0]) < 128) {


35                  out_[0] = bytes1(uint8(_len) + uint8(_offset));


45                  out_[0] = bytes1(uint8(lenLen) + uint8(_offset) + 55);


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/rlp/RLPWriter.sol#L45:45

```solidity
File: contracts/thirdparty/optimism/trie/MerkleTrie.sol


141                     uint8 prefix = uint8(path[0]);


171                         value_ = RLPReader.readBytes(currentNode.decoded[1]);


188                         currentNodeID = _getNodeID(currentNode.decoded[1]);


228             nibbles_ = Bytes.toNibbles(RLPReader.readBytes(_node.decoded[0]));


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/trie/MerkleTrie.sol#L228:228

```solidity
File: contracts/verifiers/SgxVerifier.sol


133             _address[0] = address(bytes20(_attestation.localEnclaveReport.reportData));


135             return _addInstances(_address, false)[0];


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/verifiers/SgxVerifier.sol#L135:135

</details>

## NC053 - Zero as a function argument should have a descriptive meaning:

Consider using descriptive constants or an enum instead of passing zero directly on function calls, as that might be error-prone, to fully describe the caller's intention.


<details>
<summary>Click to show 87 findings</summary>

```solidity
File: contracts/L1/TaikoL1.sol


191             return TaikoData.Config({
192                 chainId: 167_008,
193                 // Assume the block time is 3s, the protocol will allow ~1 month of
194                 // new blocks without any verification.
195                 blockMaxProposals: 864_000,
196                 blockRingBufferSize: 864_100,
197                 // Can be overridden by the tier config.
198                 maxBlocksToVerifyPerProposal: 10,
199                 blockMaxGasLimit: 15_000_000,
200                 // Each go-ethereum transaction has a size limit of 128KB,
201                 // and right now txList is still saved in calldata, so we set it
202                 // to 120KB.
203                 blockMaxTxListBytes: 120_000,
204                 blobExpiry: 24 hours,
205                 blobAllowedForDA: false,
206                 blobReuseEnabled: false,
207                 livenessBond: 250e18, // 250 Taiko token
208                 // ETH deposit related.
209                 ethDepositRingBufferSize: 1024,
210                 ethDepositMinCountPerBlock: 8,
211                 ethDepositMaxCountPerBlock: 32,
212                 ethDepositMinAmount: 1 ether,
213                 ethDepositMaxAmount: 10_000 ether,
214                 ethDepositGas: 21_000,
215                 ethDepositMaxFee: 1 ether / 10,
216                 blockSyncThreshold: 16
217             });


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/TaikoL1.sol#L191:217

```solidity
File: contracts/L1/TaikoToken.sol


41              _mint(_recipient, 1_000_000_000 ether);


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/TaikoToken.sol#L41:41

```solidity
File: contracts/L1/gov/TaikoGovernor.sol


43              __GovernorVotesQuorumFraction_init(4);


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/gov/TaikoGovernor.sol#L43:43

```solidity
File: contracts/L1/gov/TaikoTimelockController.sol


17              address[] memory nil = new address[](0);


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/gov/TaikoTimelockController.sol#L17:17

```solidity
File: contracts/L1/libs/LibDepositing.sol


79                  deposits_ = new TaikoData.EthDeposit[](0);


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibDepositing.sol#L79:79

```solidity
File: contracts/L1/libs/LibProposing.sol


121                 meta_ = TaikoData.BlockMetadata({
122                     l1Hash: blockhash(block.number - 1),
123                     difficulty: 0, // to be initialized below
124                     blobHash: 0, // to be initialized below
125                     extraData: params.extraData,
126                     depositsHash: keccak256(abi.encode(deposits_)),
127                     coinbase: params.coinbase,
128                     id: b.numBlocks,
129                     gasLimit: _config.blockMaxGasLimit,
130                     timestamp: uint64(block.timestamp),
131                     l1Height: uint64(block.number - 1),
132                     txListByteOffset: 0, // to be initialized below
133                     txListByteSize: 0, // to be initialized below
134                     minTier: 0, // to be initialized below
135                     blobUsed: _txList.length == 0,
136                     parentMetaHash: parentMetaHash
137                 });


157                     meta_.blobHash = blobhash(0);


212             TaikoData.Block memory blk = TaikoData.Block({
213                 metaHash: keccak256(abi.encode(meta_)),
214                 // Safeguard the liveness bond to ensure its preservation,
215                 // particularly in scenarios where it might be altered after the
216                 // block's proposal but before it has been proven or verified.
217                 livenessBond: _config.livenessBond,
218                 blockId: b.numBlocks,
219                 proposedAt: meta_.timestamp,
220                 proposedIn: uint64(block.number),
221                 // For a new block, the next transition ID is always 1, not 0.
222                 nextTransitionId: 1,
223                 // For unverified block, its verifiedTransitionId is always 0.
224                 verifiedTransitionId: 0,
225                 assignedProver: params.assignedProver
226             });


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProposing.sol#L212:226

```solidity
File: contracts/L1/libs/LibProving.sol


230                     emit TransitionProved({
231                         blockId: blk.blockId,
232                         tran: _tran,
233                         prover: msg.sender,
234                         validityBond: 0,
235                         tier: _proof.tier
236                     });


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProving.sol#L230:236

```solidity
File: contracts/L1/libs/LibVerifying.sol


73              emit BlockVerified({
74                  blockId: 0,
75                  assignedProver: address(0),
76                  prover: address(0),
77                  blockHash: _genesisBlockHash,
78                  stateRoot: 0,
79                  tier: 0,
80                  contestations: 0
81              });


234             (uint64 lastSyncedBlock,) = signalService.getSyncedChainData(
235                 _config.chainId, LibSignals.STATE_ROOT, 0 /* latest block Id*/
236             );


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibVerifying.sol#L234:236

```solidity
File: contracts/L1/tiers/DevnetTierProvider.sol


22                  return ITierProvider.Tier({
23                      verifierName: "tier_optimistic",
24                      validityBond: 250 ether, // TKO
25                      contestBond: 500 ether, // TKO
26                      cooldownWindow: 1440, //24 hours
27                      provingWindow: 120, // 2 hours
28                      maxBlocksToVerifyPerProof: 16
29                  });


33                  return ITierProvider.Tier({
34                      verifierName: "tier_guardian",
35                      validityBond: 0, // must be 0 for top tier
36                      contestBond: 0, // must be 0 for top tier
37                      cooldownWindow: 60, //1 hours
38                      provingWindow: 2880, // 48 hours
39                      maxBlocksToVerifyPerProof: 16
40                  });


48              tiers_ = new uint16[](2);


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/tiers/DevnetTierProvider.sol#L48:48

```solidity
File: contracts/L1/tiers/MainnetTierProvider.sol


22                  return ITierProvider.Tier({
23                      verifierName: "tier_sgx",
24                      validityBond: 250 ether, // TKO
25                      contestBond: 500 ether, // TKO
26                      cooldownWindow: 1440, //24 hours
27                      provingWindow: 60, // 1 hours
28                      maxBlocksToVerifyPerProof: 8
29                  });


33                  return ITierProvider.Tier({
34                      verifierName: "tier_sgx_zkvm",
35                      validityBond: 500 ether, // TKO
36                      contestBond: 1000 ether, // TKO
37                      cooldownWindow: 1440, //24 hours
38                      provingWindow: 240, // 4 hours
39                      maxBlocksToVerifyPerProof: 4
40                  });


44                  return ITierProvider.Tier({
45                      verifierName: "tier_guardian",
46                      validityBond: 0, // must be 0 for top tier
47                      contestBond: 0, // must be 0 for top tier
48                      cooldownWindow: 60, //1 hours
49                      provingWindow: 2880, // 48 hours
50                      maxBlocksToVerifyPerProof: 16
51                  });


59              tiers_ = new uint16[](3);


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/tiers/MainnetTierProvider.sol#L59:59

```solidity
File: contracts/L1/tiers/TestnetTierProvider.sol


22                  return ITierProvider.Tier({
23                      verifierName: "tier_optimistic",
24                      validityBond: 250 ether, // TKO
25                      contestBond: 500 ether, // TKO
26                      cooldownWindow: 1440, //24 hours
27                      provingWindow: 30, // 0.5 hours
28                      maxBlocksToVerifyPerProof: 12
29                  });


33                  return ITierProvider.Tier({
34                      verifierName: "tier_sgx",
35                      validityBond: 500 ether, // TKO
36                      contestBond: 1000 ether, // TKO
37                      cooldownWindow: 1440, //24 hours
38                      provingWindow: 60, // 1 hours
39                      maxBlocksToVerifyPerProof: 8
40                  });


44                  return ITierProvider.Tier({
45                      verifierName: "tier_guardian",
46                      validityBond: 0, // must be 0 for top tier
47                      contestBond: 0, // must be 0 for top tier
48                      cooldownWindow: 60, //1 hours
49                      provingWindow: 2880, // 48 hours
50                      maxBlocksToVerifyPerProof: 16
51                  });


59              tiers_ = new uint16[](3);


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/tiers/TestnetTierProvider.sol#L59:59

```solidity
File: contracts/automata-attestation/AutomataDcapV3Attestation.sol


313             bytes32 expectedAuthDataHash = bytes32(qeEnclaveReport.reportData.substring(0, 32));


419                 parsedQuoteCerts = new IPEMCertChainLib.ECSha256Certificate[](3);


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/AutomataDcapV3Attestation.sol#L419:419

```solidity
File: contracts/automata-attestation/lib/PEMCertChainLib.sol


174                 bytes memory sigX = _trimBytes(der.bytesAt(sigPtr), 32);


177                 bytes memory sigY = _trimBytes(der.bytesAt(sigPtr), 32);


180                 cert.pubKey = _trimBytes(der.bytesAt(subjectPublicKeyInfoPtr), 64);


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/PEMCertChainLib.sol#L180:180

```solidity
File: contracts/automata-attestation/lib/QuoteV3Auth/V3Parser.sol


33              uint256 localAuthDataSize = littleEndianDecode(quote.substring(432, 4));


38              bytes memory rawHeader = quote.substring(0, 48);


46                  parseAuthDataAndVerifyCertType(quote.substring(436, localAuthDataSize), pemCertLibAddr);


51              bytes memory rawLocalEnclaveReport = quote.substring(48, 384);


138             enclaveReport.cpuSvn = bytes16(rawEnclaveReport.substring(0, 16));


139             enclaveReport.miscSelect = bytes4(rawEnclaveReport.substring(16, 4));


140             enclaveReport.reserved1 = bytes28(rawEnclaveReport.substring(20, 28));


141             enclaveReport.attributes = bytes16(rawEnclaveReport.substring(48, 16));


142             enclaveReport.mrEnclave = bytes32(rawEnclaveReport.substring(64, 32));


143             enclaveReport.reserved2 = bytes32(rawEnclaveReport.substring(96, 32));


144             enclaveReport.mrSigner = bytes32(rawEnclaveReport.substring(128, 32));


145             enclaveReport.reserved3 = rawEnclaveReport.substring(160, 96);


146             enclaveReport.isvProdId = uint16(littleEndianDecode(rawEnclaveReport.substring(256, 2)));


147             enclaveReport.isvSvn = uint16(littleEndianDecode(rawEnclaveReport.substring(258, 2)));


148             enclaveReport.reserved4 = rawEnclaveReport.substring(260, 60);


149             enclaveReport.reportData = rawEnclaveReport.substring(320, 64);


170             bytes2 version = bytes2(rawHeader.substring(0, 2));


175             bytes2 attestationKeyType = bytes2(rawHeader.substring(2, 2));


180             bytes4 teeType = bytes4(rawHeader.substring(4, 4));


185             bytes16 qeVendorId = bytes16(rawHeader.substring(12, 16));


194                 qeSvn: bytes2(rawHeader.substring(8, 2)),


195                 pceSvn: bytes2(rawHeader.substring(10, 2)),


197                 userData: bytes20(rawHeader.substring(28, 20))


212             qeAuthData.parsedDataSize = uint16(littleEndianDecode(rawAuthData.substring(576, 2)));


213             qeAuthData.data = rawAuthData.substring(578, qeAuthData.parsedDataSize);


217             cert.certType = uint16(littleEndianDecode(rawAuthData.substring(offset, 2)));


222             cert.certDataSize = uint32(littleEndianDecode(rawAuthData.substring(offset, 4)));


227             authDataV3.ecdsa256BitSignature = rawAuthData.substring(0, 64);


228             authDataV3.ecdsaAttestationKey = rawAuthData.substring(64, 64);


229             bytes memory rawQeReport = rawAuthData.substring(128, 384);


231             authDataV3.qeReportSignature = rawAuthData.substring(512, 64);


278                 pemCertLib.splitCertificateChain(certBytes, 3);


280             parsedQuoteCerts = new IPEMCertChainLib.ECSha256Certificate[](3);


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/QuoteV3Auth/V3Parser.sol#L280:280

```solidity
File: contracts/automata-attestation/utils/Asn1Decode.sol


48              return _readNodeLength(der, 0);


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/Asn1Decode.sol#L48:48

```solidity
File: contracts/automata-attestation/utils/BytesUtils.sol


40              return compare(self, 0, self.length, other, 0, other.length);


169             return self.length >= offset + other.length && equals(self, offset, other, 0, other.length);


179             return self.length == other.length && equals(self, 0, other, 0, self.length);


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/BytesUtils.sol#L179:179

```solidity
File: contracts/automata-attestation/utils/SigVerifyLib.sol


89              bytes memory exponent = publicKey.substring(0, 3);


90              bytes memory modulus = publicKey.substring(3, publicKey.length - 3);


106             bytes memory exponent = publicKey.substring(0, 3);


107             bytes memory modulus = publicKey.substring(3, publicKey.length - 3);


126             uint256 r = uint256(bytes32(signature.substring(0, 32)));


127             uint256 s = uint256(bytes32(signature.substring(32, 32)));


132             uint256 gx = uint256(bytes32(publicKey.substring(0, 32)));


133             uint256 gy = uint256(bytes32(publicKey.substring(32, 32)));


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/SigVerifyLib.sol#L133:133

```solidity
File: contracts/bridge/Bridge.sol


497                 (success_,) = ExcessivelySafeCall.excessivelySafeCall(
498                     _message.to,
499                     _gasLimit,
500                     _message.value,
501                     64, // return max 64 bytes
502                     _message.data
503                 );


531                 _storeContext(bytes32(0), address(0), uint64(0));


531                 _storeContext(bytes32(0), address(0), uint64(0));


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/Bridge.sol#L531:531

```solidity
File: contracts/libs/LibAddress.sol


27              (bool success,) = ExcessivelySafeCall.excessivelySafeCall(
28                  _to,
29                  _gasLimit,
30                  _amount,
31                  64, // return max 64 bytes
32                  ""
33              );


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/libs/LibAddress.sol#L27:33

```solidity
File: contracts/thirdparty/optimism/rlp/RLPReader.sol


136             out_ = _copy(_in.ptr, 0, _in.length);


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/rlp/RLPReader.sol#L136:136

```solidity
File: contracts/thirdparty/optimism/rlp/RLPWriter.sol


17                  out_ = abi.encodePacked(_writeLength(_in.length, 128), _in);


34                  out_ = new bytes(1);


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/rlp/RLPWriter.sol#L34:34

```solidity
File: contracts/tokenvault/ERC1155Vault.sol


58              IBridge.Message memory message = IBridge.Message({
59                  id: 0, // will receive a new value
60                  from: address(0), // will receive a new value
61                  srcChainId: 0, // will receive a new value
62                  destChainId: _op.destChainId,
63                  srcOwner: msg.sender,
64                  destOwner: _op.destOwner != address(0) ? _op.destOwner : msg.sender,
65                  to: resolve(_op.destChainId, name(), false),
66                  refundTo: _op.refundTo,
67                  value: msg.value - _op.fee,
68                  fee: _op.fee,
69                  gasLimit: _op.gasLimit,
70                  data: data,
71                  memo: _op.memo
72              });


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC1155Vault.sol#L58:72

```solidity
File: contracts/tokenvault/ERC20Vault.sol


221             IBridge.Message memory message = IBridge.Message({
222                 id: 0, // will receive a new value
223                 from: address(0), // will receive a new value
224                 srcChainId: 0, // will receive a new value
225                 destChainId: _op.destChainId,
226                 srcOwner: msg.sender,
227                 destOwner: _op.destOwner != address(0) ? _op.destOwner : msg.sender,
228                 to: resolve(_op.destChainId, name(), false),
229                 refundTo: _op.refundTo,
230                 value: msg.value - _op.fee,
231                 fee: _op.fee,
232                 gasLimit: _op.gasLimit,
233                 data: data,
234                 memo: _op.memo
235             });


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC20Vault.sol#L221:235

```solidity
File: contracts/tokenvault/ERC721Vault.sol


44              IBridge.Message memory message = IBridge.Message({
45                  id: 0, // will receive a new value
46                  from: address(0), // will receive a new value
47                  srcChainId: 0, // will receive a new value
48                  destChainId: _op.destChainId,
49                  srcOwner: msg.sender,
50                  destOwner: _op.destOwner != address(0) ? _op.destOwner : msg.sender,
51                  to: resolve(_op.destChainId, name(), false),
52                  refundTo: _op.refundTo,
53                  value: msg.value - _op.fee,
54                  fee: _op.fee,
55                  gasLimit: _op.gasLimit,
56                  data: data,
57                  memo: _op.memo
58              });


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC721Vault.sol#L44:58

```solidity
File: contracts/tokenvault/LibBridgedToken.sol


56                      Strings.toHexString(uint160(_srcToken), 20),


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/LibBridgedToken.sol#L56:56

```solidity
File: contracts/verifiers/SgxVerifier.sol


132             address[] memory _address = new address[](1);


154             uint32 id = uint32(bytes4(Bytes.slice(_proof.data, 0, 4)));


155             address newInstance = address(bytes20(Bytes.slice(_proof.data, 4, 20)));


156             bytes memory signature = Bytes.slice(_proof.data, 24);


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/verifiers/SgxVerifier.sol#L156:156

</details>

## NC054 - Function names should differ to make the code more readable:

In Solidity, while function overriding allows for functions with the same name to coexist, it is advisable to avoid this practice to enhance code readability and maintainability. Having multiple functions with the same name, even with different parameters or in inherited contracts, can cause confusion and increase the likelihood of errors during development, testing, and debugging. Using distinct and descriptive function names not only clarifies the purpose and behavior of each function, but also helps prevent unintended function calls or incorrect overriding. By adopting a clear and consistent naming convention, developers can create more comprehensible and maintainable smart contracts.


<details>
<summary>Click to show 237 findings</summary>

```solidity
File: contracts/L1/ITaikoL1.sol


    function proposeBlock(
        bytes calldata _params,
        bytes calldata _txList
    )
        external
        payable
        returns (TaikoData.BlockMetadata memory meta_, TaikoData.EthDeposit[] memory deposits_);

    function proveBlock(uint64 _blockId, bytes calldata _input) external;

    function verifyBlocks(uint64 _maxBlocksToVerify) external;

    function getConfig() external view returns (TaikoData.Config memory);

```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/ITaikoL1.sol#L35:35

```solidity
File: contracts/L1/TaikoL1.sol


    function proposeBlock(
        bytes calldata _params,
        bytes calldata _txList
    )
        external
        payable
        nonReentrant
        whenNotPaused
        returns (TaikoData.BlockMetadata memory meta_, TaikoData.EthDeposit[] memory deposits_)
    {
        TaikoData.Config memory config = getConfig();

        (meta_, deposits_) = LibProposing.proposeBlock(state, config, this, _params, _txList);

        if (!state.slotB.provingPaused) {
            LibVerifying.verifyBlocks(state, config, this, config.maxBlocksToVerifyPerProposal);
        }
    }

    function proveBlock(
        uint64 _blockId,
        bytes calldata _input
    )
        external
        nonReentrant
        whenNotPaused
        whenProvingNotPaused
    {
        (
            TaikoData.BlockMetadata memory meta,
            TaikoData.Transition memory tran,
            TaikoData.TierProof memory proof
        ) = abi.decode(_input, (TaikoData.BlockMetadata, TaikoData.Transition, TaikoData.TierProof));

        if (_blockId != meta.id) revert L1_INVALID_BLOCK_ID();

        TaikoData.Config memory config = getConfig();

        uint8 maxBlocksToVerify = LibProving.proveBlock(state, config, this, meta, tran, proof);

        LibVerifying.verifyBlocks(state, config, this, maxBlocksToVerify);
    }

    function verifyBlocks(uint64 _maxBlocksToVerify)
        external
        nonReentrant
        whenNotPaused
        whenProvingNotPaused
    {
        LibVerifying.verifyBlocks(state, getConfig(), this, _maxBlocksToVerify);
    }

    function getConfig() public view virtual override returns (TaikoData.Config memory) {
        // All hard-coded configurations:
        // - treasury: the actual TaikoL2 address.
        // - anchorGasLimit: 250_000 (based on internal devnet, its ~220_000
        // after 256 L2 blocks)
        return TaikoData.Config({
            chainId: 167_008,
            // Assume the block time is 3s, the protocol will allow ~1 month of
            // new blocks without any verification.
            blockMaxProposals: 864_000,
            blockRingBufferSize: 864_100,
            // Can be overridden by the tier config.
            maxBlocksToVerifyPerProposal: 10,
            blockMaxGasLimit: 15_000_000,
            // Each go-ethereum transaction has a size limit of 128KB,
            // and right now txList is still saved in calldata, so we set it
            // to 120KB.
            blockMaxTxListBytes: 120_000,
            blobExpiry: 24 hours,
            blobAllowedForDA: false,
            blobReuseEnabled: false,
            livenessBond: 250e18, // 250 Taiko token
            // ETH deposit related.
            ethDepositRingBufferSize: 1024,
            ethDepositMinCountPerBlock: 8,
            ethDepositMaxCountPerBlock: 32,
            ethDepositMinAmount: 1 ether,
            ethDepositMaxAmount: 10_000 ether,
            ethDepositGas: 21_000,
            ethDepositMaxFee: 1 ether / 10,
            blockSyncThreshold: 16
        });
    }

    receive() external payable {
        if (!_inNonReentrant()) revert L1_RECEIVE_DISABLED();
    }

    function init(
        address _owner,
        address _addressManager,
        bytes32 _genesisBlockHash
    )
        external
        initializer
    {
        __Essential_init(_owner, _addressManager);
        LibVerifying.init(state, getConfig(), _genesisBlockHash);
    }

    function pauseProving(bool _pause) external {
        _authorizePause(msg.sender);
        LibProving.pauseProving(state, _pause);
    }

    function depositEtherToL2(address _recipient) external payable nonReentrant whenNotPaused {
        LibDepositing.depositEtherToL2(state, getConfig(), this, _recipient);
    }

    function unpause() public override {
        super.unpause(); // permission checked inside
        state.slotB.lastUnpausedAt = uint64(block.timestamp);
    }

    function canDepositEthToL2(uint256 _amount) public view returns (bool) {
        return LibDepositing.canDepositEthToL2(state, getConfig(), _amount);
    }

    function isBlobReusable(bytes32 _blobHash) public view returns (bool) {
        return LibProposing.isBlobReusable(state, getConfig(), _blobHash);
    }

    function getBlock(uint64 _blockId)
        public
        view
        returns (TaikoData.Block memory blk_, TaikoData.TransitionState memory ts_)
    {
        uint64 slot;
        (blk_, slot) = LibUtils.getBlock(state, getConfig(), _blockId);

        if (blk_.verifiedTransitionId != 0) {
            ts_ = state.transitions[slot][blk_.verifiedTransitionId];
        }
    }

    function getTransition(
        uint64 _blockId,
        bytes32 _parentHash
    )
        public
        view
        returns (TaikoData.TransitionState memory)
    {
        return LibUtils.getTransition(state, getConfig(), _blockId, _parentHash);
    }

    function _authorizePause(address)
        internal
        view
        virtual
        override
        onlyFromOwnerOrNamed("chain_pauser")
    { }

```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/TaikoL1.sol#L220:226

```solidity
File: contracts/L1/libs/LibProposing.sol


    function proposeBlock(
        TaikoData.State storage _state,
        TaikoData.Config memory _config,
        IAddressResolver _resolver,
        bytes calldata _data,
        bytes calldata _txList
    )
        internal
        returns (TaikoData.BlockMetadata memory meta_, TaikoData.EthDeposit[] memory deposits_)
    {
        TaikoData.BlockParams memory params = abi.decode(_data, (TaikoData.BlockParams));

        // We need a prover that will submit proofs after the block has been submitted
        if (params.assignedProver == address(0)) {
            revert L1_INVALID_PROVER();
        }

        if (params.coinbase == address(0)) {
            params.coinbase = msg.sender;
        }

        // Taiko, as a Based Rollup, enables permissionless block proposals.
        // However, if the "proposer" address is set to a non-zero value, we
        // ensure that only that specific address has the authority to propose
        // blocks.
        TaikoData.SlotB memory b = _state.slotB;
        if (!_isProposerPermitted(b, _resolver)) revert L1_UNAUTHORIZED();

        // It's essential to ensure that the ring buffer for proposed blocks
        // still has space for at least one more block.
        if (b.numBlocks >= b.lastVerifiedBlockId + _config.blockMaxProposals + 1) {
            revert L1_TOO_MANY_BLOCKS();
        }

        bytes32 parentMetaHash =
            _state.blocks[(b.numBlocks - 1) % _config.blockRingBufferSize].metaHash;

        // Check if parent block has the right meta hash
        // This is to allow the proposer to make sure the block builds on the expected latest chain
        // state
        if (params.parentMetaHash != 0 && parentMetaHash != params.parentMetaHash) {
            revert L1_UNEXPECTED_PARENT();
        }

        // Each transaction must handle a specific quantity of L1-to-L2
        // Ether deposits.
        deposits_ = LibDepositing.processDeposits(_state, _config, params.coinbase);

        // Initialize metadata to compute a metaHash, which forms a part of
        // the block data to be stored on-chain for future integrity checks.
        // If we choose to persist all data fields in the metadata, it will
        // require additional storage slots.
        unchecked {
            meta_ = TaikoData.BlockMetadata({
                l1Hash: blockhash(block.number - 1),
                difficulty: 0, // to be initialized below
                blobHash: 0, // to be initialized below
                extraData: params.extraData,
                depositsHash: keccak256(abi.encode(deposits_)),
                coinbase: params.coinbase,
                id: b.numBlocks,
                gasLimit: _config.blockMaxGasLimit,
                timestamp: uint64(block.timestamp),
                l1Height: uint64(block.number - 1),
                txListByteOffset: 0, // to be initialized below
                txListByteSize: 0, // to be initialized below
                minTier: 0, // to be initialized below
                blobUsed: _txList.length == 0,
                parentMetaHash: parentMetaHash
            });
        }

        // Update certain meta fields
        if (meta_.blobUsed) {
            if (!_config.blobAllowedForDA) revert L1_BLOB_FOR_DA_DISABLED();

            if (params.blobHash != 0) {
                if (!_config.blobReuseEnabled) revert L1_BLOB_REUSE_DISABLED();

                // We try to reuse an old blob
                if (!isBlobReusable(_state, _config, params.blobHash)) {
                    revert L1_BLOB_NOT_REUSABLE();
                }
                meta_.blobHash = params.blobHash;
            } else {
                // Always use the first blob in this transaction. If the
                // proposeBlock functions are called more than once in the same
                // L1 transaction, these multiple L2 blocks will share the same
                // blob.
                meta_.blobHash = blobhash(0);

                if (meta_.blobHash == 0) revert L1_BLOB_NOT_FOUND();

                // Depends on the blob data price, it may not make sense to
                // cache the blob which costs 20,000 (sstore) + 631 (event)
                // extra gas.
                if (_config.blobReuseEnabled && params.cacheBlobForReuse) {
                    _state.reusableBlobs[meta_.blobHash] = block.timestamp;
                    emit BlobCached(meta_.blobHash);
                }
            }

            // Check that the txList data range is within the max size of a blob
            if (uint256(params.txListByteOffset) + params.txListByteSize > MAX_BYTES_PER_BLOB) {
                revert L1_TXLIST_OFFSET();
            }

            meta_.txListByteOffset = params.txListByteOffset;
            meta_.txListByteSize = params.txListByteSize;
        } else {
            // The proposer must be an Externally Owned Account (EOA) for
            // calldata usage. This ensures that the transaction is not an
            // internal one, making calldata retrieval more straightforward for
            // Taiko node software.
            if (!LibAddress.isSenderEOA()) revert L1_PROPOSER_NOT_EOA();

            // The txList is the full byte array without any offset
            if (params.txListByteOffset != 0) {
                revert L1_INVALID_PARAM();
            }

            meta_.blobHash = keccak256(_txList);
            meta_.txListByteOffset = 0;
            meta_.txListByteSize = uint24(_txList.length);
        }

        // Check that the tx length is non-zero and within the supported range
        if (meta_.txListByteSize == 0 || meta_.txListByteSize > _config.blockMaxTxListBytes) {
            revert L1_TXLIST_SIZE();
        }

        // Following the Merge, the L1 mixHash incorporates the
        // prevrandao value from the beacon chain. Given the possibility
        // of multiple Taiko blocks being proposed within a single
        // Ethereum block, we choose to introduce a salt to this random
        // number as the L2 mixHash.
        meta_.difficulty = keccak256(abi.encodePacked(block.prevrandao, b.numBlocks, block.number));

        // Use the difficulty as a random number
        meta_.minTier = ITierProvider(_resolver.resolve("tier_provider", false)).getMinTier(
            uint256(meta_.difficulty)
        );

        // Create the block that will be stored onchain
        TaikoData.Block memory blk = TaikoData.Block({
            metaHash: keccak256(abi.encode(meta_)),
            // Safeguard the liveness bond to ensure its preservation,
            // particularly in scenarios where it might be altered after the
            // block's proposal but before it has been proven or verified.
            livenessBond: _config.livenessBond,
            blockId: b.numBlocks,
            proposedAt: meta_.timestamp,
            proposedIn: uint64(block.number),
            // For a new block, the next transition ID is always 1, not 0.
            nextTransitionId: 1,
            // For unverified block, its verifiedTransitionId is always 0.
            verifiedTransitionId: 0,
            assignedProver: params.assignedProver
        });

        // Store the block in the ring buffer
        _state.blocks[b.numBlocks % _config.blockRingBufferSize] = blk;

        // Increment the counter (cursor) by 1.
        unchecked {
            ++_state.slotB.numBlocks;
        }

        {
            IERC20 tko = IERC20(_resolver.resolve("taiko_token", false));
            uint256 tkoBalance = tko.balanceOf(address(this));

            // Run all hooks.
            // Note that address(this).balance has been updated with msg.value,
            // prior to any code in this function has been executed.
            address prevHook;
            for (uint256 i; i < params.hookCalls.length; ++i) {
                if (uint160(prevHook) >= uint160(params.hookCalls[i].hook)) {
                    revert L1_INVALID_HOOK();
                }

                // When a hook is called, all ether in this contract will be send to the hook.
                // If the ether sent to the hook is not used entirely, the hook shall send the Ether
                // back to this contract for the next hook to use.
                // Proposers shall choose use extra hooks wisely.
                IHook(params.hookCalls[i].hook).onBlockProposed{ value: address(this).balance }(
                    blk, meta_, params.hookCalls[i].data
                );

                prevHook = params.hookCalls[i].hook;
            }
            // Refund Ether
            if (address(this).balance != 0) {
                msg.sender.sendEther(address(this).balance);
            }

            // Check that after hooks, the Taiko Token balance of this contract
            // have increased by the same amount as _config.livenessBond (to prevent)
            // multiple draining payments by a malicious proposer nesting the same
            // hook.
            if (tko.balanceOf(address(this)) != tkoBalance + _config.livenessBond) {
                revert L1_LIVENESS_BOND_NOT_RECEIVED();
            }
        }

        emit BlockProposed({
            blockId: blk.blockId,
            assignedProver: blk.assignedProver,
            livenessBond: _config.livenessBond,
            meta: meta_,
            depositsProcessed: deposits_
        });
    }

    function isBlobReusable(
        TaikoData.State storage _state,
        TaikoData.Config memory _config,
        bytes32 _blobHash
    )
        internal
        view
        returns (bool)
    {
        return _state.reusableBlobs[_blobHash] + _config.blobExpiry > block.timestamp;
    }

```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProposing.sol#L287:297

```solidity
File: contracts/L1/libs/LibProving.sol


    function proveBlock(
        TaikoData.State storage _state,
        TaikoData.Config memory _config,
        IAddressResolver _resolver,
        TaikoData.BlockMetadata memory _meta,
        TaikoData.Transition memory _tran,
        TaikoData.TierProof memory _proof
    )
        internal
        returns (uint8 maxBlocksToVerify_)
    {
        // Make sure parentHash is not zero
        // To contest an existing transition, simply use any non-zero value as
        // the blockHash and stateRoot.
        if (_tran.parentHash == 0 || _tran.blockHash == 0 || _tran.stateRoot == 0) {
            revert L1_INVALID_TRANSITION();
        }

        // Check that the block has been proposed but has not yet been verified.
        TaikoData.SlotB memory b = _state.slotB;
        if (_meta.id <= b.lastVerifiedBlockId || _meta.id >= b.numBlocks) {
            revert L1_INVALID_BLOCK_ID();
        }

        uint64 slot = _meta.id % _config.blockRingBufferSize;
        TaikoData.Block storage blk = _state.blocks[slot];

        // Check the integrity of the block data. It's worth noting that in
        // theory, this check may be skipped, but it's included for added
        // caution.
        if (blk.blockId != _meta.id || blk.metaHash != keccak256(abi.encode(_meta))) {
            revert L1_BLOCK_MISMATCH();
        }

        // Each transition is uniquely identified by the parentHash, with the
        // blockHash and stateRoot open for later updates as higher-tier proofs
        // become available. In cases where a transition with the specified
        // parentHash does not exist, the transition ID (tid) will be set to 0.
        (uint32 tid, TaikoData.TransitionState storage ts) =
            _createTransition(_state, blk, _tran, slot);

        // The new proof must meet or exceed the minimum tier required by the
        // block or the previous proof; it cannot be on a lower tier.
        if (_proof.tier == 0 || _proof.tier < _meta.minTier || _proof.tier < ts.tier) {
            revert L1_INVALID_TIER();
        }

        // Retrieve the tier configurations. If the tier is not supported, the
        // subsequent action will result in a revert.
        ITierProvider.Tier memory tier =
            ITierProvider(_resolver.resolve("tier_provider", false)).getTier(_proof.tier);

        // Check if this prover is allowed to submit a proof for this block
        _checkProverPermission(_state, blk, ts, tid, tier);

        // We must verify the proof, and any failure in proof verification will
        // result in a revert.
        //
        // It's crucial to emphasize that the proof can be assessed in two
        // potential modes: "proving mode" and "contesting mode." However, the
        // precise verification logic is defined within each tier's IVerifier
        // contract implementation. We simply specify to the verifier contract
        // which mode it should utilize - if the new tier is higher than the
        // previous tier, we employ the proving mode; otherwise, we employ the
        // contesting mode (the new tier cannot be lower than the previous tier,
        // this has been checked above).
        //
        // It's obvious that proof verification is entirely decoupled from
        // Taiko's core protocol.
        {
            address verifier = _resolver.resolve(tier.verifierName, true);

            if (verifier != address(0)) {
                bool isContesting = _proof.tier == ts.tier && tier.contestBond != 0;

                IVerifier.Context memory ctx = IVerifier.Context({
                    metaHash: blk.metaHash,
                    blobHash: _meta.blobHash,
                    // Separate msgSender to allow the prover to be any address in the future.
                    prover: msg.sender,
                    msgSender: msg.sender,
                    blockId: blk.blockId,
                    isContesting: isContesting,
                    blobUsed: _meta.blobUsed
                });

                IVerifier(verifier).verifyProof(ctx, _tran, _proof);
            } else if (tier.verifierName != TIER_OP) {
                // The verifier can be address-zero, signifying that there are no
                // proof checks for the tier. In practice, this only applies to
                // optimistic proofs.
                revert L1_MISSING_VERIFIER();
            }
        }

        bool isTopTier = tier.contestBond == 0;
        IERC20 tko = IERC20(_resolver.resolve("taiko_token", false));

        if (isTopTier) {
            // A special return value from the top tier prover can signal this
            // contract to return all liveness bond.
            bool returnLivenessBond = blk.livenessBond > 0 && _proof.data.length == 32
                && bytes32(_proof.data) == RETURN_LIVENESS_BOND;

            if (returnLivenessBond) {
                tko.transfer(blk.assignedProver, blk.livenessBond);
                blk.livenessBond = 0;
            }
        }

        bool sameTransition = _tran.blockHash == ts.blockHash && _tran.stateRoot == ts.stateRoot;

        if (_proof.tier > ts.tier) {
            // Handles the case when an incoming tier is higher than the current transition's tier.
            // Reverts when the incoming proof tries to prove the same transition
            // (L1_ALREADY_PROVED).
            _overrideWithHigherProof(ts, _tran, _proof, tier, tko, sameTransition);

            emit TransitionProved({
                blockId: blk.blockId,
                tran: _tran,
                prover: msg.sender,
                validityBond: tier.validityBond,
                tier: _proof.tier
            });
        } else {
            // New transition and old transition on the same tier - and if this transaction tries to
            // prove the same, it reverts
            if (sameTransition) revert L1_ALREADY_PROVED();

            if (isTopTier) {
                // The top tier prover re-proves.
                assert(tier.validityBond == 0);
                assert(ts.validityBond == 0 && ts.contestBond == 0 && ts.contester == address(0));

                ts.prover = msg.sender;
                ts.blockHash = _tran.blockHash;
                ts.stateRoot = _tran.stateRoot;

                emit TransitionProved({
                    blockId: blk.blockId,
                    tran: _tran,
                    prover: msg.sender,
                    validityBond: 0,
                    tier: _proof.tier
                });
            } else {
                // Contesting but not on the highest tier
                if (ts.contester != address(0)) revert L1_ALREADY_CONTESTED();

                // Burn the contest bond from the prover.
                tko.transferFrom(msg.sender, address(this), tier.contestBond);

                // We retain the contest bond within the transition, just in
                // case this configuration is altered to a different value
                // before the contest is resolved.
                //
                // It's worth noting that the previous value of ts.contestBond
                // doesn't have any significance.
                ts.contestBond = tier.contestBond;
                ts.contester = msg.sender;
                ts.contestations += 1;

                emit TransitionContested({
                    blockId: blk.blockId,
                    tran: _tran,
                    contester: msg.sender,
                    contestBond: tier.contestBond,
                    tier: _proof.tier
                });
            }
        }

        ts.timestamp = uint64(block.timestamp);
        return tier.maxBlocksToVerifyPerProof;
    }

    function pauseProving(TaikoData.State storage _state, bool _pause) external {
        if (_state.slotB.provingPaused == _pause) revert L1_INVALID_PAUSE_STATUS();
        _state.slotB.provingPaused = _pause;

        if (!_pause) {
            _state.slotB.lastUnpausedAt = uint64(block.timestamp);
        }
        emit ProvingPaused(_pause);
    }

```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProving.sol#L73:81

```solidity
File: contracts/L1/libs/LibVerifying.sol


    function verifyBlocks(
        TaikoData.State storage _state,
        TaikoData.Config memory _config,
        IAddressResolver _resolver,
        uint64 _maxBlocksToVerify
    )
        internal
    {
        if (_maxBlocksToVerify == 0) {
            return;
        }

        // Retrieve the latest verified block and the associated transition used
        // for its verification.
        TaikoData.SlotB memory b = _state.slotB;
        uint64 blockId = b.lastVerifiedBlockId;

        uint64 slot = blockId % _config.blockRingBufferSize;

        TaikoData.Block storage blk = _state.blocks[slot];
        if (blk.blockId != blockId) revert L1_BLOCK_MISMATCH();

        uint32 tid = blk.verifiedTransitionId;

        // The following scenario should never occur but is included as a
        // precaution.
        if (tid == 0) revert L1_TRANSITION_ID_ZERO();

        // The `blockHash` variable represents the most recently trusted
        // blockHash on L2.
        bytes32 blockHash = _state.transitions[slot][tid].blockHash;
        bytes32 stateRoot;
        uint64 numBlocksVerified;
        address tierProvider;

        // Unchecked is safe:
        // - assignment is within ranges
        // - blockId and numBlocksVerified values incremented will still be OK in the
        // next 584K years if we verifying one block per every second
        unchecked {
            ++blockId;

            while (blockId < b.numBlocks && numBlocksVerified < _maxBlocksToVerify) {
                slot = blockId % _config.blockRingBufferSize;

                blk = _state.blocks[slot];
                if (blk.blockId != blockId) revert L1_BLOCK_MISMATCH();

                tid = LibUtils.getTransitionId(_state, blk, slot, blockHash);
                // When `tid` is 0, it indicates that there is no proven
                // transition with its parentHash equal to the blockHash of the
                // most recently verified block.
                if (tid == 0) break;

                // A transition with the correct `parentHash` has been located.
                TaikoData.TransitionState storage ts = _state.transitions[slot][tid];

                // It's not possible to verify this block if either the
                // transition is contested and awaiting higher-tier proof or if
                // the transition is still within its cooldown period.
                if (ts.contester != address(0)) {
                    break;
                } else {
                    if (tierProvider == address(0)) {
                        tierProvider = _resolver.resolve("tier_provider", false);
                    }
                    if (
                        uint256(ITierProvider(tierProvider).getTier(ts.tier).cooldownWindow) * 60
                            + uint256(ts.timestamp).max(_state.slotB.lastUnpausedAt) > block.timestamp
                    ) {
                        // If cooldownWindow is 0, the block can theoretically
                        // be proved and verified within the same L1 block.
                        break;
                    }
                }

                // Mark this block as verified
                blk.verifiedTransitionId = tid;

                // Update variables
                blockHash = ts.blockHash;
                stateRoot = ts.stateRoot;

                // We consistently return the liveness bond and the validity
                // bond to the actual prover of the transition utilized for
                // block verification. If the actual prover happens to be the
                // block's assigned prover, he will receive both deposits,
                // ultimately earning the proving fee paid during block
                // proposal. In contrast, if the actual prover is different from
                // the block's assigned prover, the liveness bond serves as a
                // reward to the actual prover, while the assigned prover
                // forfeits his liveness bond due to failure to fulfill their
                // commitment.
                uint256 bondToReturn = uint256(ts.validityBond) + blk.livenessBond;

                // Nevertheless, it's possible for the actual prover to be the
                // same individual or entity as the block's assigned prover.
                // Consequently, we have chosen to grant the actual prover only
                // half of the liveness bond as a reward.
                if (ts.prover != blk.assignedProver) {
                    bondToReturn -= blk.livenessBond >> 1;
                }

                IERC20 tko = IERC20(_resolver.resolve("taiko_token", false));
                tko.transfer(ts.prover, bondToReturn);

                // Note: We exclusively address the bonds linked to the
                // transition used for verification. While there may exist
                // other transitions for this block, we disregard them entirely.
                // The bonds for these other transitions are burned either when
                // the transitions are generated or proven. In such cases, both
                // the provers and contesters of those transitions forfeit their bonds.

                emit BlockVerified({
                    blockId: blockId,
                    assignedProver: blk.assignedProver,
                    prover: ts.prover,
                    blockHash: blockHash,
                    stateRoot: stateRoot,
                    tier: ts.tier,
                    contestations: ts.contestations
                });

                ++blockId;
                ++numBlocksVerified;
            }

            if (numBlocksVerified > 0) {
                uint64 lastVerifiedBlockId = b.lastVerifiedBlockId + numBlocksVerified;

                // Update protocol level state variables
                _state.slotB.lastVerifiedBlockId = lastVerifiedBlockId;

                // sync chain data
                _syncChainData(_config, _resolver, lastVerifiedBlockId, stateRoot);
            }
        }
    }

    function init(
        TaikoData.State storage _state,
        TaikoData.Config memory _config,
        bytes32 _genesisBlockHash
    )
        external
    {
        if (!_isConfigValid(_config)) revert L1_INVALID_CONFIG();

        // Init state
        _state.slotA.genesisHeight = uint64(block.number);
        _state.slotA.genesisTimestamp = uint64(block.timestamp);
        _state.slotB.numBlocks = 1;

        // Init the genesis block
        TaikoData.Block storage blk = _state.blocks[0];
        blk.nextTransitionId = 2;
        blk.proposedAt = uint64(block.timestamp);
        blk.verifiedTransitionId = 1;

        // Init the first state transition
        TaikoData.TransitionState storage ts = _state.transitions[0][1];
        ts.blockHash = _genesisBlockHash;
        ts.prover = address(0);
        ts.timestamp = uint64(block.timestamp);

        emit BlockVerified({
            blockId: 0,
            assignedProver: address(0),
            prover: address(0),
            blockHash: _genesisBlockHash,
            stateRoot: 0,
            tier: 0,
            contestations: 0
        });
    }

    function _syncChainData(
        TaikoData.Config memory _config,
        IAddressResolver _resolver,
        uint64 _lastVerifiedBlockId,
        bytes32 _stateRoot
    )
        private
    {
        ISignalService signalService = ISignalService(_resolver.resolve("signal_service", false));

        (uint64 lastSyncedBlock,) = signalService.getSyncedChainData(
            _config.chainId, LibSignals.STATE_ROOT, 0 /* latest block Id*/
        );

        if (_lastVerifiedBlockId > lastSyncedBlock + _config.blockSyncThreshold) {
            signalService.syncChainData(
                _config.chainId, LibSignals.STATE_ROOT, _lastVerifiedBlockId, _stateRoot
            );
        }
    }

```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibVerifying.sol#L224:243

```solidity
File: contracts/L2/TaikoL2.sol


    function getConfig() public view virtual returns (Config memory config_) {
        // 4x Ethereum gas target, if we assume most of the time, L2 block time
        // is 3s, and each block is full (gasUsed is 15_000_000), then its
        // ~60_000_000, if the  network is congester than that, the base fee
        // will increase.
        config_.gasTargetPerL1Block = 15 * 1e6 * 4;
        config_.basefeeAdjustmentQuotient = 8;
    }

    function init(
        address _owner,
        address _addressManager,
        uint64 _l1ChainId,
        uint64 _gasExcess
    )
        external
        initializer
    {
        __CrossChainOwned_init(_owner, _addressManager, _l1ChainId);

        if (block.chainid <= 1 || block.chainid > type(uint64).max) {
            revert L2_INVALID_CHAIN_ID();
        }

        if (block.number == 0) {
            // This is the case in real L2 genesis
        } else if (block.number == 1) {
            // This is the case in tests
            uint256 parentHeight = block.number - 1;
            l2Hashes[parentHeight] = blockhash(parentHeight);
        } else {
            revert L2_TOO_LATE();
        }

        gasExcess = _gasExcess;
        (publicInputHash,) = _calcPublicInputHash(block.number);
    }

    function withdraw(
        address _token,
        address _to
    )
        external
        onlyFromOwnerOrNamed("withdrawer")
        nonReentrant
        whenNotPaused
    {
        if (_to == address(0)) revert L2_INVALID_PARAM();
        if (_token == address(0)) {
            _to.sendEther(address(this).balance);
        } else {
            IERC20(_token).safeTransfer(_to, IERC20(_token).balanceOf(address(this)));
        }
    }

```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/TaikoL2.sol#L163:178

```solidity
File: contracts/L2/TaikoL2EIP1559Configurable.sol


    function getConfig() public view override returns (Config memory) {
        return customConfig;
    }

```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/TaikoL2EIP1559Configurable.sol#L43:45

```solidity
File: contracts/bridge/Bridge.sol


    receive() external payable { }

    function init(address _owner, address _addressManager) external initializer {
        __Essential_init(_owner, _addressManager);
    }

    function _authorizePause(address)
        internal
        view
        virtual
        override
        onlyFromOwnerOrNamed("bridge_pauser")
    { }

    function sendMessage(Message calldata _message)
        external
        payable
        override
        nonReentrant
        whenNotPaused
        returns (bytes32 msgHash_, Message memory message_)
    {
        // Ensure the message owner is not null.
        if (_message.srcOwner == address(0) || _message.destOwner == address(0)) {
            revert B_INVALID_USER();
        }

        // Check if the destination chain is enabled.
        (bool destChainEnabled,) = isDestChainEnabled(_message.destChainId);

        // Verify destination chain and to address.
        if (!destChainEnabled) revert B_INVALID_CHAINID();
        if (_message.destChainId == block.chainid) {
            revert B_INVALID_CHAINID();
        }

        // Ensure the sent value matches the expected amount.
        uint256 expectedAmount = _message.value + _message.fee;
        if (expectedAmount != msg.value) revert B_INVALID_VALUE();

        message_ = _message;

        // Configure message details and send signal to indicate message sending.
        message_.id = nextMessageId++;
        message_.from = msg.sender;
        message_.srcChainId = uint64(block.chainid);

        msgHash_ = hashMessage(message_);

        ISignalService(resolve("signal_service", false)).sendSignal(msgHash_);
        emit MessageSent(msgHash_, message_);
    }

    function recallMessage(
        Message calldata _message,
        bytes calldata _proof
    )
        external
        nonReentrant
        whenNotPaused
        sameChain(_message.srcChainId)
    {
        bytes32 msgHash = hashMessage(_message);

        if (messageStatus[msgHash] != Status.NEW) revert B_STATUS_MISMATCH();

        uint64 receivedAt = proofReceipt[msgHash].receivedAt;
        bool isMessageProven = receivedAt != 0;

        if (!isMessageProven) {
            address signalService = resolve("signal_service", false);

            if (!ISignalService(signalService).isSignalSent(address(this), msgHash)) {
                revert B_MESSAGE_NOT_SENT();
            }

            bytes32 failureSignal = signalForFailedMessage(msgHash);
            if (!_proveSignalReceived(signalService, failureSignal, _message.destChainId, _proof)) {
                revert B_NOT_FAILED();
            }

            receivedAt = uint64(block.timestamp);
            proofReceipt[msgHash].receivedAt = receivedAt;
        }

        (uint256 invocationDelay,) = getInvocationDelays();

        if (block.timestamp >= invocationDelay + receivedAt) {
            delete proofReceipt[msgHash];
            messageStatus[msgHash] = Status.RECALLED;

            // Execute the recall logic based on the contract's support for the
            // IRecallableSender interface
            if (_message.from.supportsInterface(type(IRecallableSender).interfaceId)) {
                _storeContext(msgHash, address(this), _message.srcChainId);

                // Perform recall
                IRecallableSender(_message.from).onMessageRecalled{ value: _message.value }(
                    _message, msgHash
                );

                // Must reset the context after the message call
                _resetContext();
            } else {
                _message.srcOwner.sendEther(_message.value);
            }
            emit MessageRecalled(msgHash);
        } else if (!isMessageProven) {
            emit MessageReceived(msgHash, _message, true);
        } else {
            revert B_INVOCATION_TOO_EARLY();
        }
    }

    function processMessage(
        Message calldata _message,
        bytes calldata _proof
    )
        external
        nonReentrant
        whenNotPaused
        sameChain(_message.destChainId)
    {
        bytes32 msgHash = hashMessage(_message);
        if (messageStatus[msgHash] != Status.NEW) revert B_STATUS_MISMATCH();

        address signalService = resolve("signal_service", false);
        uint64 receivedAt = proofReceipt[msgHash].receivedAt;
        bool isMessageProven = receivedAt != 0;

        (uint256 invocationDelay, uint256 invocationExtraDelay) = getInvocationDelays();

        if (!isMessageProven) {
            if (!_proveSignalReceived(signalService, msgHash, _message.srcChainId, _proof)) {
                revert B_NOT_RECEIVED();
            }

            receivedAt = uint64(block.timestamp);

            if (invocationDelay != 0) {
                proofReceipt[msgHash] = ProofReceipt({
                    receivedAt: receivedAt,
                    preferredExecutor: _message.gasLimit == 0 ? _message.destOwner : msg.sender
                });
            }
        }

        if (invocationDelay != 0 && msg.sender != proofReceipt[msgHash].preferredExecutor) {
            // If msg.sender is not the one that proved the message, then there
            // is an extra delay.
            unchecked {
                invocationDelay += invocationExtraDelay;
            }
        }

        if (block.timestamp >= invocationDelay + receivedAt) {
            // If the gas limit is set to zero, only the owner can process the message.
            if (_message.gasLimit == 0 && msg.sender != _message.destOwner) {
                revert B_PERMISSION_DENIED();
            }

            delete proofReceipt[msgHash];

            uint256 refundAmount;

            // Process message differently based on the target address
            if (
                _message.to == address(0) || _message.to == address(this)
                    || _message.to == signalService || addressBanned[_message.to]
            ) {
                // Handle special addresses that don't require actual invocation but
                // mark message as DONE
                refundAmount = _message.value;
                _updateMessageStatus(msgHash, Status.DONE);
            } else {
                // Use the specified message gas limit if called by the owner, else
                // use remaining gas
                uint256 gasLimit = msg.sender == _message.destOwner ? gasleft() : _message.gasLimit;

                if (_invokeMessageCall(_message, msgHash, gasLimit)) {
                    _updateMessageStatus(msgHash, Status.DONE);
                } else {
                    _updateMessageStatus(msgHash, Status.RETRIABLE);
                }
            }

            // Determine the refund recipient
            address refundTo =
                _message.refundTo == address(0) ? _message.destOwner : _message.refundTo;

            // Refund the processing fee
            if (msg.sender == refundTo) {
                refundTo.sendEther(_message.fee + refundAmount);
            } else {
                // If sender is another address, reward it and refund the rest
                msg.sender.sendEther(_message.fee);
                refundTo.sendEther(refundAmount);
            }
            emit MessageExecuted(msgHash);
        } else if (!isMessageProven) {
            emit MessageReceived(msgHash, _message, false);
        } else {
            revert B_INVOCATION_TOO_EARLY();
        }
    }

    function retryMessage(
        Message calldata _message,
        bool _isLastAttempt
    )
        external
        nonReentrant
        whenNotPaused
        sameChain(_message.destChainId)
    {
        // If the gasLimit is set to 0 or isLastAttempt is true, the caller must
        // be the message.destOwner.
        if (_message.gasLimit == 0 || _isLastAttempt) {
            if (msg.sender != _message.destOwner) revert B_PERMISSION_DENIED();
        }

        bytes32 msgHash = hashMessage(_message);
        if (messageStatus[msgHash] != Status.RETRIABLE) {
            revert B_NON_RETRIABLE();
        }

        // Attempt to invoke the messageCall.
        if (_invokeMessageCall(_message, msgHash, gasleft())) {
            _updateMessageStatus(msgHash, Status.DONE);
        } else if (_isLastAttempt) {
            _updateMessageStatus(msgHash, Status.FAILED);
        }
        emit MessageRetried(msgHash);
    }

    function isMessageSent(Message calldata _message) public view returns (bool) {
        if (_message.srcChainId != block.chainid) return false;
        return ISignalService(resolve("signal_service", false)).isSignalSent({
            _app: address(this),
            _signal: hashMessage(_message)
        });
    }

    function context() public view returns (Context memory ctx_) {
        ctx_ = _loadContext();
        if (ctx_.msgHash == 0 || ctx_.msgHash == bytes32(PLACEHOLDER)) {
            revert B_INVALID_CONTEXT();
        }
    }

    function hashMessage(Message memory _message) public pure returns (bytes32) {
        return keccak256(abi.encode("TAIKO_MESSAGE", _message));
    }

```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/Bridge.sol#L449:451

```solidity
File: contracts/L1/TaikoToken.sol


    function init(
        address _owner,
        string calldata _name,
        string calldata _symbol,
        address _recipient
    )
        public
        initializer
    {
        __Essential_init(_owner);
        __ERC20_init(_name, _symbol);
        __ERC20Snapshot_init();
        __ERC20Votes_init();
        __ERC20Permit_init(_name);

        // Mint 1 billion tokens
        _mint(_recipient, 1_000_000_000 ether);
    }

    function burn(address _from, uint256 _amount) public onlyOwner {
        _burn(_from, _amount);
    }

    function snapshot() public onlyFromOwnerOrNamed("snapshooter") {
        _snapshot();
    }

    function transferFrom(
        address _from,
        address _to,
        uint256 _amount
    )
        public
        override
        returns (bool)
    {
        if (_to == address(this)) revert TKO_INVALID_ADDR();
        return super.transferFrom(_from, _to, _amount);
    }

    function _beforeTokenTransfer(
        address _from,
        address _to,
        uint256 _amount
    )
        internal
        override(ERC20Upgradeable, ERC20SnapshotUpgradeable)
    {
        super._beforeTokenTransfer(_from, _to, _amount);
    }

    function _afterTokenTransfer(
        address _from,
        address _to,
        uint256 _amount
    )
        internal
        override(ERC20Upgradeable, ERC20VotesUpgradeable)
    {
        super._afterTokenTransfer(_from, _to, _amount);
    }

    function _mint(
        address _to,
        uint256 _amount
    )
        internal
        override(ERC20Upgradeable, ERC20VotesUpgradeable)
    {
        super._mint(_to, _amount);
    }

    function _burn(
        address _from,
        uint256 _amount
    )
        internal
        override(ERC20Upgradeable, ERC20VotesUpgradeable)
    {
        super._burn(_from, _amount);
    }

```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/TaikoToken.sol#L115:123

```solidity
File: contracts/L1/gov/TaikoGovernor.sol


    function init(
        address _owner,
        IVotesUpgradeable _token,
        TimelockControllerUpgradeable _timelock
    )
        external
        initializer
    {
        __Essential_init(_owner);
        __Governor_init("TaikoGovernor");
        __GovernorCompatibilityBravo_init();
        __GovernorVotes_init(_token);
        __GovernorVotesQuorumFraction_init(4);
        __GovernorTimelockControl_init(_timelock);
    }

    function propose(
        address[] memory _targets,
        uint256[] memory _values,
        bytes[] memory _calldatas,
        string memory _description
    )
        public
        override(IGovernorUpgradeable, GovernorUpgradeable, GovernorCompatibilityBravoUpgradeable)
        returns (uint256)
    {
        return super.propose(_targets, _values, _calldatas, _description);
    }

    function propose(
        address[] memory _targets,
        uint256[] memory _values,
        string[] memory _signatures,
        bytes[] memory _calldatas,
        string memory _description
    )
        public
        virtual
        override(GovernorCompatibilityBravoUpgradeable)
        returns (uint256)
    {
        if (_signatures.length != _calldatas.length) revert TG_INVALID_SIGNATURES_LENGTH();

        return GovernorCompatibilityBravoUpgradeable.propose(
            _targets, _values, _signatures, _calldatas, _description
        );
    }

    function supportsInterface(bytes4 _interfaceId)
        public
        view
        override(GovernorUpgradeable, GovernorTimelockControlUpgradeable, IERC165Upgradeable)
        returns (bool)
    {
        return super.supportsInterface(_interfaceId);
    }

```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/gov/TaikoGovernor.sol#L89:96

```solidity
File: contracts/L1/gov/TaikoTimelockController.sol


    function init(address _owner, uint256 _minDelay) external initializer {
        __Essential_init(_owner);
        address[] memory nil = new address[](0);
        __TimelockController_init(_minDelay, nil, nil, owner());
    }

```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/gov/TaikoTimelockController.sol#L15:19

```solidity
File: contracts/L1/hooks/AssignmentHook.sol


    function init(address _owner, address _addressManager) external initializer {
        __Essential_init(_owner, _addressManager);
    }

    function onBlockProposed(
        TaikoData.Block memory _blk,
        TaikoData.BlockMetadata memory _meta,
        bytes memory _data
    )
        external
        payable
        nonReentrant
        onlyFromNamed("taiko")
    {
        // Note that
        // - 'msg.sender' is the TaikoL1 contract address
        // - 'block.coinbase' is the L1 block builder
        // - 'meta.coinbase' is the L2 block proposer

        Input memory input = abi.decode(_data, (Input));
        ProverAssignment memory assignment = input.assignment;

        // Check assignment validity
        if (
            block.timestamp > assignment.expiry
                || assignment.metaHash != 0 && _blk.metaHash != assignment.metaHash
                || assignment.parentMetaHash != 0 && _meta.parentMetaHash != assignment.parentMetaHash
                || assignment.maxBlockId != 0 && _meta.id > assignment.maxBlockId
                || assignment.maxProposedIn != 0 && block.number > assignment.maxProposedIn
        ) {
            revert HOOK_ASSIGNMENT_EXPIRED();
        }

        // Hash the assignment with the blobHash, this hash will be signed by
        // the prover, therefore, we add a string as a prefix.
        address taikoL1Address = msg.sender;
        bytes32 hash = hashAssignment(assignment, taikoL1Address, _meta.blobHash);

        if (!_blk.assignedProver.isValidSignature(hash, assignment.signature)) {
            revert HOOK_ASSIGNMENT_INVALID_SIG();
        }

        // Send the liveness bond to the Taiko contract
        IERC20 tko = IERC20(resolve("taiko_token", false));
        tko.transferFrom(_blk.assignedProver, taikoL1Address, _blk.livenessBond);

        // Find the prover fee using the minimal tier
        uint256 proverFee = _getProverFee(assignment.tierFees, _meta.minTier);

        // The proposer irrevocably pays a fee to the assigned prover, either in
        // Ether or ERC20 tokens.
        if (assignment.feeToken == address(0)) {
            // Paying Ether
            _blk.assignedProver.sendEther(proverFee, MAX_GAS_PAYING_PROVER);
        } else {
            // Paying ERC20 tokens
            IERC20(assignment.feeToken).safeTransferFrom(
                _meta.coinbase, _blk.assignedProver, proverFee
            );
        }

        // block.coinbase can be address(0) in tests
        if (input.tip != 0 && block.coinbase != address(0)) {
            address(block.coinbase).sendEther(input.tip);
        }

        // Send all remaining Ether back to TaikoL1 contract
        if (address(this).balance > 0) {
            taikoL1Address.sendEther(address(this).balance);
        }

        emit BlockAssigned(_blk.assignedProver, _meta, assignment);
    }

```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/hooks/AssignmentHook.sol#L62:130

```solidity
File: contracts/L1/provers/GuardianProver.sol


    function init(address _owner, address _addressManager) external initializer {
        __Essential_init(_owner, _addressManager);
    }

    function approve(
        TaikoData.BlockMetadata calldata _meta,
        TaikoData.Transition calldata _tran,
        TaikoData.TierProof calldata _proof
    )
        external
        whenNotPaused
        nonReentrant
        returns (bool approved_)
    {
        if (_proof.tier != LibTiers.TIER_GUARDIAN) revert INVALID_PROOF();
        bytes32 hash = keccak256(abi.encode(_meta, _tran));
        approved_ = approve(_meta.id, hash);

        if (approved_) {
            deleteApproval(hash);
            ITaikoL1(resolve("taiko", false)).proveBlock(_meta.id, abi.encode(_meta, _tran, _proof));
        }

        emit GuardianApproval(msg.sender, _meta.id, _tran.blockHash, approved_);
    }

```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/provers/GuardianProver.sol#L35:55

```solidity
File: contracts/L1/tiers/DevnetTierProvider.sol


    function init(address _owner) external initializer {
        __Essential_init(_owner);
    }

    function getTier(uint16 _tierId) public pure override returns (ITierProvider.Tier memory) {
        if (_tierId == LibTiers.TIER_OPTIMISTIC) {
            return ITierProvider.Tier({
                verifierName: "tier_optimistic",
                validityBond: 250 ether, // TKO
                contestBond: 500 ether, // TKO
                cooldownWindow: 1440, //24 hours
                provingWindow: 120, // 2 hours
                maxBlocksToVerifyPerProof: 16
            });
        }

        if (_tierId == LibTiers.TIER_GUARDIAN) {
            return ITierProvider.Tier({
                verifierName: "tier_guardian",
                validityBond: 0, // must be 0 for top tier
                contestBond: 0, // must be 0 for top tier
                cooldownWindow: 60, //1 hours
                provingWindow: 2880, // 48 hours
                maxBlocksToVerifyPerProof: 16
            });
        }

        revert TIER_NOT_FOUND();
    }

    function getTierIds() public pure override returns (uint16[] memory tiers_) {
        tiers_ = new uint16[](2);
        tiers_[0] = LibTiers.TIER_OPTIMISTIC;
        tiers_[1] = LibTiers.TIER_GUARDIAN;
    }

    function getMinTier(uint256) public pure override returns (uint16) {
        return LibTiers.TIER_OPTIMISTIC;
    }

```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/tiers/DevnetTierProvider.sol#L54:56

```solidity
File: contracts/L1/tiers/MainnetTierProvider.sol


    function init(address _owner) external initializer {
        __Essential_init(_owner);
    }

    function getTier(uint16 _tierId) public pure override returns (ITierProvider.Tier memory) {
        if (_tierId == LibTiers.TIER_SGX) {
            return ITierProvider.Tier({
                verifierName: "tier_sgx",
                validityBond: 250 ether, // TKO
                contestBond: 500 ether, // TKO
                cooldownWindow: 1440, //24 hours
                provingWindow: 60, // 1 hours
                maxBlocksToVerifyPerProof: 8
            });
        }

        if (_tierId == LibTiers.TIER_SGX_ZKVM) {
            return ITierProvider.Tier({
                verifierName: "tier_sgx_zkvm",
                validityBond: 500 ether, // TKO
                contestBond: 1000 ether, // TKO
                cooldownWindow: 1440, //24 hours
                provingWindow: 240, // 4 hours
                maxBlocksToVerifyPerProof: 4
            });
        }

        if (_tierId == LibTiers.TIER_GUARDIAN) {
            return ITierProvider.Tier({
                verifierName: "tier_guardian",
                validityBond: 0, // must be 0 for top tier
                contestBond: 0, // must be 0 for top tier
                cooldownWindow: 60, //1 hours
                provingWindow: 2880, // 48 hours
                maxBlocksToVerifyPerProof: 16
            });
        }

        revert TIER_NOT_FOUND();
    }

    function getTierIds() public pure override returns (uint16[] memory tiers_) {
        tiers_ = new uint16[](3);
        tiers_[0] = LibTiers.TIER_SGX;
        tiers_[1] = LibTiers.TIER_SGX_ZKVM;
        tiers_[2] = LibTiers.TIER_GUARDIAN;
    }

    function getMinTier(uint256 _rand) public pure override returns (uint16) {
        // 0.1% require SGX + ZKVM; all others require SGX
        if (_rand % 1000 == 0) return LibTiers.TIER_SGX_ZKVM;
        else return LibTiers.TIER_SGX;
    }

```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/tiers/MainnetTierProvider.sol#L66:70

```solidity
File: contracts/L1/tiers/TestnetTierProvider.sol


    function init(address _owner) external initializer {
        __Essential_init(_owner);
    }

    function getTier(uint16 _tierId) public pure override returns (ITierProvider.Tier memory) {
        if (_tierId == LibTiers.TIER_OPTIMISTIC) {
            return ITierProvider.Tier({
                verifierName: "tier_optimistic",
                validityBond: 250 ether, // TKO
                contestBond: 500 ether, // TKO
                cooldownWindow: 1440, //24 hours
                provingWindow: 30, // 0.5 hours
                maxBlocksToVerifyPerProof: 12
            });
        }

        if (_tierId == LibTiers.TIER_SGX) {
            return ITierProvider.Tier({
                verifierName: "tier_sgx",
                validityBond: 500 ether, // TKO
                contestBond: 1000 ether, // TKO
                cooldownWindow: 1440, //24 hours
                provingWindow: 60, // 1 hours
                maxBlocksToVerifyPerProof: 8
            });
        }

        if (_tierId == LibTiers.TIER_GUARDIAN) {
            return ITierProvider.Tier({
                verifierName: "tier_guardian",
                validityBond: 0, // must be 0 for top tier
                contestBond: 0, // must be 0 for top tier
                cooldownWindow: 60, //1 hours
                provingWindow: 2880, // 48 hours
                maxBlocksToVerifyPerProof: 16
            });
        }

        revert TIER_NOT_FOUND();
    }

    function getTierIds() public pure override returns (uint16[] memory tiers_) {
        tiers_ = new uint16[](3);
        tiers_[0] = LibTiers.TIER_OPTIMISTIC;
        tiers_[1] = LibTiers.TIER_SGX;
        tiers_[2] = LibTiers.TIER_GUARDIAN;
    }

    function getMinTier(uint256 _rand) public pure override returns (uint16) {
        // 10% will be selected to require SGX proofs.
        if (_rand % 10 == 0) return LibTiers.TIER_SGX;
        // Other blocks are optimistic, without validity proofs.
        return LibTiers.TIER_OPTIMISTIC;
    }

```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/tiers/TestnetTierProvider.sol#L66:71

```solidity
File: contracts/common/AddressManager.sol


    function init(address _owner) external initializer {
        __Essential_init(_owner);
    }

    function _authorizePause(address) internal pure override {
        revert AM_UNSUPPORTED();
    }

    function getAddress(uint64 _chainId, bytes32 _name) public view override returns (address) {
        return __addresses[_chainId][_name];
    }

```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/common/AddressManager.sol#L54:56

```solidity
File: contracts/signal/SignalService.sol


    function init(address _owner, address _addressManager) external initializer {
        __Essential_init(_owner, _addressManager);
    }

    function _authorizePause(address) internal pure override {
        revert SS_UNSUPPORTED();
    }

    function _syncChainData(
        uint64 _chainId,
        bytes32 _kind,
        uint64 _blockId,
        bytes32 _chainData
    )
        private
        returns (bytes32 signal_)
    {
        signal_ = signalForChainData(_chainId, _kind, _blockId);
        _sendSignal(address(this), signal_, _chainData);

        if (topBlockId[_chainId][_kind] < _blockId) {
            topBlockId[_chainId][_kind] = _blockId;
        }
        emit ChainDataSynced(_chainId, _blockId, _kind, _chainData, signal_);
    }

    function sendSignal(bytes32 _signal) external returns (bytes32) {
        return _sendSignal(msg.sender, _signal, _signal);
    }

    function syncChainData(
        uint64 _chainId,
        bytes32 _kind,
        uint64 _blockId,
        bytes32 _chainData
    )
        external
        returns (bytes32)
    {
        if (!isAuthorized[msg.sender]) revert SS_UNAUTHORIZED();
        return _syncChainData(_chainId, _kind, _blockId, _chainData);
    }

    function proveSignalReceived(
        uint64 _chainId,
        address _app,
        bytes32 _signal,
        bytes calldata _proof
    )
        public
        virtual
        validSender(_app)
        nonZeroValue(_signal)
    {
        HopProof[] memory hopProofs = abi.decode(_proof, (HopProof[]));
        if (hopProofs.length == 0) revert SS_EMPTY_PROOF();

        uint64 chainId = _chainId;
        address app = _app;
        bytes32 signal = _signal;
        bytes32 value = _signal;
        address signalService = resolve(chainId, "signal_service", false);

        HopProof memory hop;
        for (uint256 i; i < hopProofs.length; ++i) {
            hop = hopProofs[i];

            bytes32 signalRoot = _verifyHopProof(chainId, app, signal, value, hop, signalService);
            bool isLastHop = i == hopProofs.length - 1;

            if (isLastHop) {
                if (hop.chainId != block.chainid) revert SS_INVALID_LAST_HOP_CHAINID();
                signalService = address(this);
            } else {
                if (hop.chainId == 0 || hop.chainId == block.chainid) {
                    revert SS_INVALID_MID_HOP_CHAINID();
                }
                signalService = resolve(hop.chainId, "signal_service", false);
            }

            bool isFullProof = hop.accountProof.length > 0;

            _cacheChainData(hop, chainId, hop.blockId, signalRoot, isFullProof, isLastHop);

            bytes32 kind = isFullProof ? LibSignals.STATE_ROOT : LibSignals.SIGNAL_ROOT;
            signal = signalForChainData(chainId, kind, hop.blockId);
            value = hop.rootHash;
            chainId = hop.chainId;
            app = signalService;
        }

        if (value == 0 || value != _loadSignalValue(address(this), signal)) {
            revert SS_SIGNAL_NOT_FOUND();
        }
    }

    function isSignalSent(address _app, bytes32 _signal) public view returns (bool) {
        return _loadSignalValue(_app, _signal) != 0;
    }

    function isChainDataSynced(
        uint64 _chainId,
        bytes32 _kind,
        uint64 _blockId,
        bytes32 _chainData
    )
        public
        view
        nonZeroValue(_chainData)
        returns (bool)
    {
        bytes32 signal = signalForChainData(_chainId, _kind, _blockId);
        return _loadSignalValue(address(this), signal) == _chainData;
    }

    function getSyncedChainData(
        uint64 _chainId,
        bytes32 _kind,
        uint64 _blockId
    )
        public
        view
        returns (uint64 blockId_, bytes32 chainData_)
    {
        blockId_ = _blockId != 0 ? _blockId : topBlockId[_chainId][_kind];

        if (blockId_ != 0) {
            bytes32 signal = signalForChainData(_chainId, _kind, blockId_);
            chainData_ = _loadSignalValue(address(this), signal);
            if (chainData_ == 0) revert SS_SIGNAL_NOT_FOUND();
        }
    }

    function signalForChainData(
        uint64 _chainId,
        bytes32 _kind,
        uint64 _blockId
    )
        public
        pure
        returns (bytes32)
    {
        return keccak256(abi.encode(_chainId, _kind, _blockId));
    }

```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/signal/SignalService.sol#L177:187

```solidity
File: contracts/team/TimelockTokenPool.sol


    function init(
        address _owner,
        address _taikoToken,
        address _costToken,
        address _sharedVault
    )
        external
        initializer
    {
        __Essential_init(_owner);
        if (_taikoToken == address(0)) revert INVALID_PARAM();
        taikoToken = _taikoToken;

        if (_costToken == address(0)) revert INVALID_PARAM();
        costToken = _costToken;

        if (_sharedVault == address(0)) revert INVALID_PARAM();
        sharedVault = _sharedVault;
    }

    function withdraw() external {
        _withdraw(msg.sender, msg.sender);
    }

    function withdraw(address _to, bytes memory _sig) external {
        if (_to == address(0)) revert INVALID_PARAM();
        bytes32 hash = keccak256(abi.encodePacked("Withdraw unlocked Taiko token to: ", _to));
        address recipient = ECDSA.recover(hash, _sig);
        _withdraw(recipient, _to);
    }

```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/TimelockTokenPool.sol#L168:173

```solidity
File: contracts/team/airdrop/ERC20Airdrop.sol


    function init(
        address _owner,
        uint64 _claimStart,
        uint64 _claimEnd,
        bytes32 _merkleRoot,
        address _token,
        address _vault
    )
        external
        initializer
    {
        __Essential_init(_owner);
        __MerkleClaimable_init(_claimStart, _claimEnd, _merkleRoot);

        token = _token;
        vault = _vault;
    }

```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/airdrop/ERC20Airdrop.sol#L27:43

```solidity
File: contracts/team/airdrop/ERC20Airdrop2.sol


    function init(
        address _owner,
        uint64 _claimStart,
        uint64 _claimEnd,
        bytes32 _merkleRoot,
        address _token,
        address _vault,
        uint64 _withdrawalWindow
    )
        external
        initializer
    {
        __Essential_init(_owner);
        __MerkleClaimable_init(_claimStart, _claimEnd, _merkleRoot);

        token = _token;
        vault = _vault;
        withdrawalWindow = _withdrawalWindow;
    }

    function withdraw(address user) external ongoingWithdrawals {
        (, uint256 amount) = getBalance(user);
        withdrawnAmount[user] += amount;
        IERC20(token).transferFrom(vault, user, amount);

        emit Withdrawn(user, amount);
    }

    function claim(address user, uint256 amount, bytes32[] calldata proof) external nonReentrant {
        // Check if this can be claimed
        _verifyClaim(abi.encode(user, amount), proof);

        // Assign the tokens
        claimedAmount[user] += amount;
    }

```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/airdrop/ERC20Airdrop2.sol#L78:84

```solidity
File: contracts/team/airdrop/ERC721Airdrop.sol


    function init(
        address _owner,
        uint64 _claimStart,
        uint64 _claimEnd,
        bytes32 _merkleRoot,
        address _token,
        address _vault
    )
        external
        initializer
    {
        __Essential_init(_owner);
        __MerkleClaimable_init(_claimStart, _claimEnd, _merkleRoot);

        token = _token;
        vault = _vault;
    }

    function claim(
        address user,
        uint256[] calldata tokenIds,
        bytes32[] calldata proof
    )
        external
        nonReentrant
    {
        // Check if this can be claimed
        _verifyClaim(abi.encode(user, tokenIds), proof);

        // Transfer the tokens
        for (uint256 i; i < tokenIds.length; ++i) {
            IERC721(token).safeTransferFrom(vault, user, tokenIds[i]);
        }
    }

```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/airdrop/ERC721Airdrop.sol#L47:62

```solidity
File: contracts/tokenvault/BaseVault.sol


    function init(address _owner, address _addressManager) external initializer {
        __Essential_init(_owner, _addressManager);
    }

    function supportsInterface(bytes4 _interfaceId) public view virtual override returns (bool) {
        return _interfaceId == type(IRecallableSender).interfaceId;
    }

    function name() public pure virtual returns (bytes32);

```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BaseVault.sol#L45:45

```solidity
File: contracts/tokenvault/BridgedERC1155.sol


    function init(
        address _owner,
        address _addressManager,
        address _srcToken,
        uint256 _srcChainId,
        string memory _symbol,
        string memory _name
    )
        external
        initializer
    {
        // Check if provided parameters are valid.
        // The symbol and the name can be empty for ERC1155 tokens so we use some placeholder data
        // for them instead.
        LibBridgedToken.validateInputs(_srcToken, _srcChainId, "foo", "foo");
        __Essential_init(_owner, _addressManager);
        __ERC1155_init(LibBridgedToken.buildURI(_srcToken, _srcChainId));

        srcToken = _srcToken;
        srcChainId = _srcChainId;
        __symbol = _symbol;
        __name = _name;
    }

    function burn(
        address _account,
        uint256 _tokenId,
        uint256 _amount
    )
        public
        nonReentrant
        whenNotPaused
        onlyFromNamed("erc1155_vault")
    {
        _burn(_account, _tokenId, _amount);
    }

    function _beforeTokenTransfer(
        address, /*_operator*/
        address, /*_from*/
        address _to,
        uint256[] memory, /*_ids*/
        uint256[] memory, /*_amounts*/
        bytes memory /*_data*/
    )
        internal
        virtual
        override
    {
        if (_to == address(this)) revert BTOKEN_CANNOT_RECEIVE();
        if (paused()) revert INVALID_PAUSE_STATUS();
    }

    function name() public view returns (string memory) {
        return LibBridgedToken.buildName(__name, srcChainId);
    }

    function mint(
        address _to,
        uint256 _tokenId,
        uint256 _amount
    )
        public
        nonReentrant
        whenNotPaused
        onlyFromNamed("erc1155_vault")
    {
        _mint(_to, _tokenId, _amount, "");
    }

    function symbol() public view returns (string memory) {
        return LibBridgedToken.buildSymbol(__symbol);
    }

```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC1155.sol#L121:123

```solidity
File: contracts/tokenvault/BridgedERC20.sol


    function init(
        address _owner,
        address _addressManager,
        address _srcToken,
        uint256 _srcChainId,
        uint8 _decimals,
        string memory _symbol,
        string memory _name
    )
        external
        initializer
    {
        // Check if provided parameters are valid
        LibBridgedToken.validateInputs(_srcToken, _srcChainId, _symbol, _name);
        __Essential_init(_owner, _addressManager);
        __ERC20_init(_name, _symbol);
        __ERC20Snapshot_init();
        __ERC20Votes_init();
        __ERC20Permit_init(_name);

        // Set contract properties
        srcToken = _srcToken;
        srcChainId = _srcChainId;
        __srcDecimals = _decimals;
    }

    function snapshot() external onlyOwnerOrSnapshooter {
        _snapshot();
    }

    function _beforeTokenTransfer(
        address _from,
        address _to,
        uint256 _amount
    )
        internal
        override(ERC20Upgradeable, ERC20SnapshotUpgradeable)
    {
        if (_to == address(this)) revert BTOKEN_CANNOT_RECEIVE();
        if (paused()) revert INVALID_PAUSE_STATUS();
        super._beforeTokenTransfer(_from, _to, _amount);
    }

    function _afterTokenTransfer(
        address _from,
        address _to,
        uint256 _amount
    )
        internal
        override(ERC20Upgradeable, ERC20VotesUpgradeable)
    {
        super._afterTokenTransfer(_from, _to, _amount);
    }

    function _mint(
        address _to,
        uint256 _amount
    )
        internal
        override(ERC20Upgradeable, ERC20VotesUpgradeable)
    {
        super._mint(_to, _amount);
    }

    function _burn(
        address _from,
        uint256 _amount
    )
        internal
        override(ERC20Upgradeable, ERC20VotesUpgradeable)
    {
        super._burn(_from, _amount);
    }

    function name()
        public
        view
        override(ERC20Upgradeable, IERC20MetadataUpgradeable)
        returns (string memory)
    {
        return LibBridgedToken.buildName(super.name(), srcChainId);
    }

    function symbol()
        public
        view
        override(ERC20Upgradeable, IERC20MetadataUpgradeable)
        returns (string memory)
    {
        return LibBridgedToken.buildSymbol(super.symbol());
    }

    function _mintToken(address _account, uint256 _amount) internal override {
        _mint(_account, _amount);
    }

    function _burnToken(address _from, uint256 _amount) internal override {
        _burn(_from, _amount);
    }

```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC20.sol#L133:135

```solidity
File: contracts/tokenvault/BridgedERC721.sol


    function init(
        address _owner,
        address _addressManager,
        address _srcToken,
        uint256 _srcChainId,
        string memory _symbol,
        string memory _name
    )
        external
        initializer
    {
        // Check if provided parameters are valid
        LibBridgedToken.validateInputs(_srcToken, _srcChainId, _symbol, _name);
        __Essential_init(_owner, _addressManager);
        __ERC721_init(_name, _symbol);

        srcToken = _srcToken;
        srcChainId = _srcChainId;
    }

    function burn(
        address _account,
        uint256 _tokenId
    )
        public
        nonReentrant
        whenNotPaused
        onlyFromNamed("erc721_vault")
    {
        // Check if the caller is the owner of the token.
        if (ownerOf(_tokenId) != _account) {
            revert BTOKEN_INVALID_BURN();
        }
        _burn(_tokenId);
    }

    function _beforeTokenTransfer(
        address, /*_from*/
        address _to,
        uint256, /*_firstTokenId*/
        uint256 /*_batchSize*/
    )
        internal
        virtual
        override
    {
        if (_to == address(this)) revert BTOKEN_CANNOT_RECEIVE();
        if (paused()) revert INVALID_PAUSE_STATUS();
    }

    function name() public view override(ERC721Upgradeable) returns (string memory) {
        return LibBridgedToken.buildName(super.name(), srcChainId);
    }

    function mint(
        address _account,
        uint256 _tokenId
    )
        public
        nonReentrant
        whenNotPaused
        onlyFromNamed("erc721_vault")
    {
        _safeMint(_account, _tokenId);
    }

    function symbol() public view override(ERC721Upgradeable) returns (string memory) {
        return LibBridgedToken.buildSymbol(super.symbol());
    }

```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC721.sol#L93:95

```solidity
File: contracts/tokenvault/adapters/USDCAdapter.sol


    function init(address _owner, address _addressManager, IUSDC _usdc) external initializer {
        __Essential_init(_owner, _addressManager);
        usdc = _usdc;
    }

    function burn(uint256 _amount) external;

    function transferFrom(address from, address _to, uint256 _amount) external returns (bool);

    function mint(address _to, uint256 _amount) external;

    function _mintToken(address _account, uint256 _amount) internal override {
        usdc.mint(_account, _amount);
    }

    function _burnToken(address _from, uint256 _amount) internal override {
        usdc.transferFrom(_from, address(this), _amount);
        usdc.burn(_amount);
    }

```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/adapters/USDCAdapter.sol#L47:50

```solidity
File: contracts/verifiers/GuardianVerifier.sol


    function init(address _owner, address _addressManager) external initializer {
        __Essential_init(_owner, _addressManager);
    }

    function verifyProof(
        Context calldata _ctx,
        TaikoData.Transition calldata,
        TaikoData.TierProof calldata
    )
        external
        view
    {
        if (_ctx.msgSender != resolve("guardian_prover", false)) {
            revert PERMISSION_DENIED();
        }
    }

```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/verifiers/GuardianVerifier.sol#L23:34

```solidity
File: contracts/verifiers/SgxVerifier.sol


    function init(address _owner, address _addressManager) external initializer {
        __Essential_init(_owner, _addressManager);
    }

    function verifyProof(
        Context calldata _ctx,
        TaikoData.Transition calldata _tran,
        TaikoData.TierProof calldata _proof
    )
        external
        onlyFromNamed("taiko")
    {
        // Do not run proof verification to contest an existing proof
        if (_ctx.isContesting) return;

        // Size is: 89 bytes
        // 4 bytes + 20 bytes + 65 bytes (signature) = 89
        if (_proof.data.length != 89) revert SGX_INVALID_PROOF();

        uint32 id = uint32(bytes4(Bytes.slice(_proof.data, 0, 4)));
        address newInstance = address(bytes20(Bytes.slice(_proof.data, 4, 20)));
        bytes memory signature = Bytes.slice(_proof.data, 24);

        address oldInstance =
            ECDSA.recover(getSignedHash(_tran, newInstance, _ctx.prover, _ctx.metaHash), signature);

        if (!_isInstanceValid(id, oldInstance)) revert SGX_INVALID_INSTANCE();
        _replaceInstance(id, oldInstance, newInstance);
    }

```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/verifiers/SgxVerifier.sol#L139:163

```solidity
File: contracts/L1/libs/LibDepositing.sol


    function depositEtherToL2(
        TaikoData.State storage _state,
        TaikoData.Config memory _config,
        IAddressResolver _resolver,
        address _recipient
    )
        internal
    {
        if (!canDepositEthToL2(_state, _config, msg.value)) {
            revert L1_INVALID_ETH_DEPOSIT();
        }

        _resolver.resolve("bridge", false).sendEther(msg.value);

        // Append the deposit to the queue.
        address recipient_ = _recipient == address(0) ? msg.sender : _recipient;
        uint256 slot = _state.slotA.numEthDeposits % _config.ethDepositRingBufferSize;

        // range of msg.value is checked by next line.
        _state.ethDeposits[slot] = _encodeEthDeposit(recipient_, msg.value);

        emit EthDeposited(
            TaikoData.EthDeposit({
                recipient: recipient_,
                amount: uint96(msg.value),
                id: _state.slotA.numEthDeposits
            })
        );

        // Unchecked is safe:
        // - uint64 can store up to ~1.8 * 1e19, which can represent 584K years
        // if we are depositing at every second
        unchecked {
            _state.slotA.numEthDeposits++;
        }
    }

    function canDepositEthToL2(
        TaikoData.State storage _state,
        TaikoData.Config memory _config,
        uint256 _amount
    )
        internal
        view
        returns (bool)
    {
        // Unchecked is safe:
        // - both numEthDeposits and _state.slotA.nextEthDepositToProcess are
        // indexes. One is tracking all deposits (numEthDeposits: unprocessed)
        // and the next to be processed, so nextEthDepositToProcess cannot be
        // bigger than numEthDeposits
        // - ethDepositRingBufferSize cannot be 0 by default (validity checked
        // in LibVerifying)
        unchecked {
            return _amount >= _config.ethDepositMinAmount && _amount <= _config.ethDepositMaxAmount
                && _state.slotA.numEthDeposits - _state.slotA.nextEthDepositToProcess
                    < _config.ethDepositRingBufferSize - 1;
        }
    }

```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibDepositing.sol#L122:143

```solidity
File: contracts/common/EssentialContract.sol


    function unpause() public virtual whenPaused {
        __paused = _FALSE;
        emit Unpaused(msg.sender);
        // We call the authorize function here to avoid:
        // Warning (5740): Unreachable code.
        _authorizePause(msg.sender);
    }

    function _authorizePause(address) internal virtual onlyOwner { }

    function __Essential_init(
        address _owner,
        address _addressManager
    )
        internal
        virtual
        onlyInitializing
    {
        __Essential_init(_owner);

        if (_addressManager == address(0)) revert ZERO_ADDR_MANAGER();
        __AddressResolver_init(_addressManager);
    }

    function __Essential_init(address _owner) internal virtual {
        _transferOwnership(_owner == address(0) ? msg.sender : _owner);
        __paused = _FALSE;
    }

```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/common/EssentialContract.sol#L109:112

```solidity
File: contracts/L1/libs/LibUtils.sol


    function getBlock(
        TaikoData.State storage _state,
        TaikoData.Config memory _config,
        uint64 _blockId
    )
        external
        view
        returns (TaikoData.Block storage blk_, uint64 slot_)
    {
        slot_ = _blockId % _config.blockRingBufferSize;
        blk_ = _state.blocks[slot_];
        if (blk_.blockId != _blockId) {
            revert L1_INVALID_BLOCK_ID();
        }
    }

    function getTransition(
        TaikoData.State storage _state,
        TaikoData.Config memory _config,
        uint64 _blockId,
        bytes32 _parentHash
    )
        external
        view
        returns (TaikoData.TransitionState storage)
    {
        TaikoData.SlotB memory b = _state.slotB;
        if (_blockId < b.lastVerifiedBlockId || _blockId >= b.numBlocks) {
            revert L1_INVALID_BLOCK_ID();
        }

        uint64 slot = _blockId % _config.blockRingBufferSize;
        TaikoData.Block storage blk = _state.blocks[slot];
        if (blk.blockId != _blockId) revert L1_BLOCK_MISMATCH();

        uint32 tid = getTransitionId(_state, blk, slot, _parentHash);
        if (tid == 0) revert L1_TRANSITION_NOT_FOUND();

        return _state.transitions[slot][tid];
    }

```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibUtils.sol#L23:46

```solidity
File: contracts/tokenvault/BridgedERC20Base.sol


    function burn(address _account, uint256 _amount) public nonReentrant whenNotPaused {
        if (_isMigratingOut()) {
            // Only the owner of the tokens himself can migrate out
            if (msg.sender != _account) revert BB_PERMISSION_DENIED();
            // Outbound migration
            emit MigratedTo(migratingAddress, _account, _amount);
            // Ask the new bridged token to mint token for the user.
            IBridgedERC20(migratingAddress).mint(_account, _amount);
        } else if (msg.sender != resolve("erc20_vault", true)) {
            // Only the vault can burn tokens when not migrating out
            revert RESOLVER_DENIED();
        }

        _burnToken(_account, _amount);
    }

    function mint(address _account, uint256 _amount) public nonReentrant whenNotPaused {
        // mint is disabled while migrating outbound.
        if (_isMigratingOut()) revert BB_MINT_DISALLOWED();

        if (msg.sender == migratingAddress) {
            // Inbound migration
            emit MigratedTo(migratingAddress, _account, _amount);
        } else if (msg.sender != resolve("erc20_vault", true)) {
            // Bridging from vault
            revert BB_PERMISSION_DENIED();
        }

        _mintToken(_account, _amount);
    }

    function _mintToken(address _account, uint256 _amount) internal virtual;

    function _burnToken(address _from, uint256 _amount) internal virtual;

    function changeMigrationStatus(
        address _migratingAddress,
        bool _migratingInbound
    )
        external
        nonReentrant
        whenNotPaused
        onlyFromOwnerOrNamed("erc20_vault")
    {
        if (_migratingAddress == migratingAddress && _migratingInbound == migratingInbound) {
            revert BB_INVALID_PARAMS();
        }

        migratingAddress = _migratingAddress;
        migratingInbound = _migratingInbound;
        emit MigrationStatusChanged(_migratingAddress, _migratingInbound);
    }

    function owner() public view override(IBridgedERC20, OwnableUpgradeable) returns (address) {
        return super.owner();
    }

```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC20Base.sol#L93:95

```solidity
File: contracts/tokenvault/IBridgedERC20.sol


    function burn(address _from, uint256 _amount) external;

    function mint(address _account, uint256 _amount) external;

    function changeMigrationStatus(address _addr, bool _inbound) external;

    function owner() external view returns (address);

```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/IBridgedERC20.sol#L28:28

```solidity
File: contracts/libs/LibAddress.sol


    function supportsInterface(
        address _addr,
        bytes4 _interfaceId
    )
        internal
        view
        returns (bool result_)
    {
        if (!Address.isContract(_addr)) return false;

        try IERC165(_addr).supportsInterface(_interfaceId) returns (bool _result) {
            result_ = _result;
        } catch { }
    }

    function sendEther(address _to, uint256 _amount, uint256 _gasLimit) internal {
        // Check for zero-address transactions
        if (_to == address(0)) revert ETH_TRANSFER_FAILED();

        // Attempt to send Ether to the recipient address
        (bool success,) = ExcessivelySafeCall.excessivelySafeCall(
            _to,
            _gasLimit,
            _amount,
            64, // return max 64 bytes
            ""
        );

        // Ensure the transfer was successful
        if (!success) revert ETH_TRANSFER_FAILED();
    }

    function sendEther(address _to, uint256 _amount) internal {
        sendEther(_to, _amount, gasleft());
    }

```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/libs/LibAddress.sol#L42:44

```solidity
File: contracts/tokenvault/ERC1155Vault.sol


    function supportsInterface(bytes4 interfaceId)
        public
        view
        virtual
        override(BaseVault, ERC1155ReceiverUpgradeable)
        returns (bool)
    {
        return interfaceId == type(ERC1155ReceiverUpgradeable).interfaceId
            || BaseVault.supportsInterface(interfaceId);
    }

    function onMessageInvocation(bytes calldata data) external payable nonReentrant whenNotPaused {
        (
            CanonicalNFT memory ctoken,
            address from,
            address to,
            uint256[] memory tokenIds,
            uint256[] memory amounts
        ) = abi.decode(data, (CanonicalNFT, address, address, uint256[], uint256[]));

        // Check context validity
        // `onlyFromBridge` checked in checkProcessMessageContext
        IBridge.Context memory ctx = checkProcessMessageContext();

        // Don't allow sending to disallowed addresses.
        // Don't send the tokens back to `from` because `from` is on the source chain.
        if (to == address(0) || to == address(this)) revert VAULT_INVALID_TO();

        // Transfer the ETH and the tokens to the `to` address
        address token = _transferTokens(ctoken, to, tokenIds, amounts);
        to.sendEther(msg.value);

        emit TokenReceived({
            msgHash: ctx.msgHash,
            from: from,
            to: to,
            srcChainId: ctx.srcChainId,
            ctoken: ctoken.addr,
            token: token,
            tokenIds: tokenIds,
            amounts: amounts
        });
    }

    function onMessageRecalled(
        IBridge.Message calldata message,
        bytes32 msgHash
    )
        external
        payable
        override
        nonReentrant
        whenNotPaused
    {
        // `onlyFromBridge` checked in checkRecallMessageContext
        checkRecallMessageContext();

        (bytes memory data) = abi.decode(message.data[4:], (bytes));
        (CanonicalNFT memory ctoken,,, uint256[] memory tokenIds, uint256[] memory amounts) =
            abi.decode(data, (CanonicalNFT, address, address, uint256[], uint256[]));

        // Transfer the ETH and tokens back to the owner
        address token = _transferTokens(ctoken, message.srcOwner, tokenIds, amounts);
        message.srcOwner.sendEther(message.value);

        // Emit TokenReleased event
        emit TokenReleased({
            msgHash: msgHash,
            from: message.srcOwner,
            ctoken: ctoken.addr,
            token: token,
            tokenIds: tokenIds,
            amounts: amounts
        });
    }

    function name() external view returns (string memory);

    function name() public pure override returns (bytes32) {
        return "erc1155_vault";
    }

    function symbol() external view returns (string memory);

    function sendToken(BridgeTransferOp memory _op)
        external
        payable
        nonReentrant
        whenNotPaused
        withValidOperation(_op)
        returns (IBridge.Message memory message_)
    {
        for (uint256 i; i < _op.amounts.length; ++i) {
            if (_op.amounts[i] == 0) revert VAULT_INVALID_AMOUNT();
        }
        // Check token interface support
        if (!_op.token.supportsInterface(ERC1155_INTERFACE_ID)) {
            revert VAULT_INTERFACE_NOT_SUPPORTED();
        }

        (bytes memory data, CanonicalNFT memory ctoken) = _handleMessage(msg.sender, _op);

        // Create a message to send to the destination chain
        IBridge.Message memory message = IBridge.Message({
            id: 0, // will receive a new value
            from: address(0), // will receive a new value
            srcChainId: 0, // will receive a new value
            destChainId: _op.destChainId,
            srcOwner: msg.sender,
            destOwner: _op.destOwner != address(0) ? _op.destOwner : msg.sender,
            to: resolve(_op.destChainId, name(), false),
            refundTo: _op.refundTo,
            value: msg.value - _op.fee,
            fee: _op.fee,
            gasLimit: _op.gasLimit,
            data: data,
            memo: _op.memo
        });

        // Send the message and obtain the message hash
        bytes32 msgHash;
        (msgHash, message_) =
            IBridge(resolve("bridge", false)).sendMessage{ value: msg.value }(message);

        // Emit TokenSent event
        emit TokenSent({
            msgHash: msgHash,
            from: message_.srcOwner,
            to: _op.to,
            destChainId: message_.destChainId,
            ctoken: ctoken.addr,
            token: _op.token,
            tokenIds: _op.tokenIds,
            amounts: _op.amounts
        });
    }

    function _transferTokens(
        CanonicalNFT memory ctoken,
        address to,
        uint256[] memory tokenIds,
        uint256[] memory amounts
    )
        private
        returns (address token)
    {
        if (ctoken.chainId == block.chainid) {
            // Token lives on this chain
            token = ctoken.addr;
            IERC1155(token).safeBatchTransferFrom(address(this), to, tokenIds, amounts, "");
        } else {
            // Token does not live on this chain
            token = _getOrDeployBridgedToken(ctoken);
            BridgedERC1155(token).mintBatch(to, tokenIds, amounts);
        }
    }

    function _handleMessage(
        address _user,
        BridgeTransferOp memory _op
    )
        private
        returns (bytes memory msgData_, CanonicalNFT memory ctoken_)
    {
        unchecked {
            // is a btoken, meaning, it does not live on this chain
            if (bridgedToCanonical[_op.token].addr != address(0)) {
                ctoken_ = bridgedToCanonical[_op.token];
                for (uint256 i; i < _op.tokenIds.length; ++i) {
                    BridgedERC1155(_op.token).burn(_user, _op.tokenIds[i], _op.amounts[i]);
                }
            } else {
                // is a ctoken token, meaning, it lives on this chain
                ctoken_ = CanonicalNFT({
                    chainId: uint64(block.chainid),
                    addr: _op.token,
                    symbol: "",
                    name: ""
                });
                IERC1155NameAndSymbol t = IERC1155NameAndSymbol(_op.token);
                try t.name() returns (string memory _name) {
                    ctoken_.name = _name;
                } catch { }
                try t.symbol() returns (string memory _symbol) {
                    ctoken_.symbol = _symbol;
                } catch { }
                for (uint256 i; i < _op.tokenIds.length; ++i) {
                    IERC1155(_op.token).safeTransferFrom({
                        from: msg.sender,
                        to: address(this),
                        id: _op.tokenIds[i],
                        amount: _op.amounts[i],
                        data: ""
                    });
                }
            }
        }
        msgData_ = abi.encodeCall(
            this.onMessageInvocation, abi.encode(ctoken_, _user, _op.to, _op.tokenIds, _op.amounts)
        );
    }

    function _getOrDeployBridgedToken(CanonicalNFT memory _ctoken)
        private
        returns (address btoken_)
    {
        btoken_ = canonicalToBridged[_ctoken.chainId][_ctoken.addr];
        if (btoken_ == address(0)) {
            btoken_ = _deployBridgedToken(_ctoken);
        }
    }

    function _deployBridgedToken(CanonicalNFT memory _ctoken) private returns (address btoken_) {
        bytes memory data = abi.encodeCall(
            BridgedERC1155.init,
            (owner(), addressManager, _ctoken.addr, _ctoken.chainId, _ctoken.symbol, _ctoken.name)
        );

        btoken_ = address(new ERC1967Proxy(resolve("bridged_erc1155", false), data));

        bridgedToCanonical[btoken_] = _ctoken;
        canonicalToBridged[_ctoken.chainId][_ctoken.addr] = btoken_;

        emit BridgedTokenDeployed({
            chainId: _ctoken.chainId,
            ctoken: _ctoken.addr,
            btoken: btoken_,
            ctokenSymbol: _ctoken.symbol,
            ctokenName: _ctoken.name
        });
    }

```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC1155Vault.sol#L303:321

```solidity
File: contracts/L1/hooks/IHook.sol


    function onBlockProposed(
        TaikoData.Block memory _blk,
        TaikoData.BlockMetadata memory _meta,
        bytes memory _data
    )
        external
        payable;

```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/hooks/IHook.sol#L13:19

```solidity
File: contracts/L1/provers/Guardians.sol


    function approve(uint256 _operationId, bytes32 _hash) internal returns (bool approved_) {
        uint256 id = guardianIds[msg.sender];
        if (id == 0) revert INVALID_GUARDIAN();

        unchecked {
            _approvals[version][_hash] |= 1 << (id - 1);
        }

        uint256 _approval = _approvals[version][_hash];
        approved_ = isApproved(_approval);
        emit Approved(_operationId, _approval, approved_);
    }

    function isApproved(bytes32 _hash) public view returns (bool) {
        return isApproved(_approvals[version][_hash]);
    }

    function isApproved(uint256 _approvalBits) internal view returns (bool) {
        uint256 count;
        uint256 bits = _approvalBits;
        uint256 guardiansLength = guardians.length;
        unchecked {
            for (uint256 i; i < guardiansLength; ++i) {
                if (bits & 1 == 1) ++count;
                if (count == minGuardians) return true;
                bits >>= 1;
            }
        }
        return false;
    }

```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/provers/Guardians.sol#L128:140

```solidity
File: contracts/L1/tiers/ITierProvider.sol


    function getTier(uint16 tierId) external view returns (Tier memory);

    function getTierIds() external view returns (uint16[] memory);

    function getMinTier(uint256 rand) external view returns (uint16);

```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/tiers/ITierProvider.sol#L33:33

```solidity
File: contracts/L2/CrossChainOwned.sol


    function onMessageInvocation(bytes calldata _data)
        external
        payable
        whenNotPaused
        onlyFromNamed("bridge")
    {
        (uint64 txId, bytes memory txdata) = abi.decode(_data, (uint64, bytes));
        if (txId != nextTxId) revert XCO_INVALID_TX_ID();

        IBridge.Context memory ctx = IBridge(msg.sender).context();
        if (ctx.srcChainId != ownerChainId || ctx.from != owner()) {
            revert XCO_PERMISSION_DENIED();
        }

        (bool success,) = address(this).call(txdata);
        if (!success) revert XCO_TX_REVERTED();

        emit TransactionExecuted(nextTxId++, bytes4(txdata));
    }

```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/CrossChainOwned.sol#L36:54

```solidity
File: contracts/bridge/IBridge.sol


    function onMessageInvocation(bytes calldata _data) external payable;

    function sendMessage(Message calldata _message)
        external
        payable
        returns (bytes32 msgHash_, Message memory message_);

    function recallMessage(Message calldata _message, bytes calldata _proof) external;

    function processMessage(Message calldata _message, bytes calldata _proof) external;

    function retryMessage(Message calldata _message, bool _isLastAttempt) external;

    function isMessageSent(Message calldata _message) external view returns (bool);

    function context() external view returns (Context memory ctx_);

    function hashMessage(Message memory _message) external pure returns (bytes32);

    function onMessageRecalled(
        IBridge.Message calldata _message,
        bytes32 _msgHash
    )
        external
        payable;

```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/IBridge.sol#L164:169

```solidity
File: contracts/tokenvault/ERC20Vault.sol


    function onMessageInvocation(bytes calldata _data)
        external
        payable
        nonReentrant
        whenNotPaused
    {
        (CanonicalERC20 memory ctoken, address from, address to, uint256 amount) =
            abi.decode(_data, (CanonicalERC20, address, address, uint256));

        // `onlyFromBridge` checked in checkProcessMessageContext
        IBridge.Context memory ctx = checkProcessMessageContext();

        // Don't allow sending to disallowed addresses.
        // Don't send the tokens back to `from` because `from` is on the source chain.
        if (to == address(0) || to == address(this)) revert VAULT_INVALID_TO();

        // Transfer the ETH and the tokens to the `to` address
        address token = _transferTokens(ctoken, to, amount);
        to.sendEther(msg.value);

        emit TokenReceived({
            msgHash: ctx.msgHash,
            from: from,
            to: to,
            srcChainId: ctx.srcChainId,
            ctoken: ctoken.addr,
            token: token,
            amount: amount
        });
    }

    function onMessageRecalled(
        IBridge.Message calldata _message,
        bytes32 _msgHash
    )
        external
        payable
        override
        nonReentrant
        whenNotPaused
    {
        // `onlyFromBridge` checked in checkRecallMessageContext
        checkRecallMessageContext();

        (bytes memory data) = abi.decode(_message.data[4:], (bytes));
        (CanonicalERC20 memory ctoken,,, uint256 amount) =
            abi.decode(data, (CanonicalERC20, address, address, uint256));

        // Transfer the ETH and tokens back to the owner
        address token = _transferTokens(ctoken, _message.srcOwner, amount);
        _message.srcOwner.sendEther(_message.value);

        emit TokenReleased({
            msgHash: _msgHash,
            from: _message.srcOwner,
            ctoken: ctoken.addr,
            token: token,
            amount: amount
        });
    }

    function name() public pure override returns (bytes32) {
        return "erc20_vault";
    }

    function sendToken(BridgeTransferOp calldata _op)
        external
        payable
        nonReentrant
        whenNotPaused
        returns (IBridge.Message memory message_)
    {
        if (_op.amount == 0) revert VAULT_INVALID_AMOUNT();
        if (_op.token == address(0)) revert VAULT_INVALID_TOKEN();
        if (btokenBlacklist[_op.token]) revert VAULT_BTOKEN_BLACKLISTED();

        (bytes memory data, CanonicalERC20 memory ctoken, uint256 balanceChange) =
            _handleMessage(msg.sender, _op.token, _op.to, _op.amount);

        IBridge.Message memory message = IBridge.Message({
            id: 0, // will receive a new value
            from: address(0), // will receive a new value
            srcChainId: 0, // will receive a new value
            destChainId: _op.destChainId,
            srcOwner: msg.sender,
            destOwner: _op.destOwner != address(0) ? _op.destOwner : msg.sender,
            to: resolve(_op.destChainId, name(), false),
            refundTo: _op.refundTo,
            value: msg.value - _op.fee,
            fee: _op.fee,
            gasLimit: _op.gasLimit,
            data: data,
            memo: _op.memo
        });

        bytes32 msgHash;
        (msgHash, message_) =
            IBridge(resolve("bridge", false)).sendMessage{ value: msg.value }(message);

        emit TokenSent({
            msgHash: msgHash,
            from: message_.srcOwner,
            to: _op.to,
            destChainId: _op.destChainId,
            ctoken: ctoken.addr,
            token: _op.token,
            amount: balanceChange
        });
    }

    function _transferTokens(
        CanonicalERC20 memory _ctoken,
        address _to,
        uint256 _amount
    )
        private
        returns (address token_)
    {
        if (_ctoken.chainId == block.chainid) {
            token_ = _ctoken.addr;
            IERC20(token_).safeTransfer(_to, _amount);
        } else {
            token_ = _getOrDeployBridgedToken(_ctoken);
            IBridgedERC20(token_).mint(_to, _amount);
        }
    }

    function _handleMessage(
        address _user,
        address _token,
        address _to,
        uint256 _amount
    )
        private
        returns (bytes memory msgData_, CanonicalERC20 memory ctoken_, uint256 balanceChange_)
    {
        // If it's a bridged token
        if (bridgedToCanonical[_token].addr != address(0)) {
            ctoken_ = bridgedToCanonical[_token];
            IBridgedERC20(_token).burn(msg.sender, _amount);
            balanceChange_ = _amount;
        } else {
            // If it's a canonical token
            IERC20Metadata meta = IERC20Metadata(_token);
            ctoken_ = CanonicalERC20({
                chainId: uint64(block.chainid),
                addr: _token,
                decimals: meta.decimals(),
                symbol: meta.symbol(),
                name: meta.name()
            });

            // Query the balance then query it again to get the actual amount of
            // token transferred into this address, this is more accurate than
            // simply using `amount` -- some contract may deduct a fee from the
            // transferred amount.
            IERC20 t = IERC20(_token);
            uint256 _balance = t.balanceOf(address(this));
            t.safeTransferFrom({ from: msg.sender, to: address(this), value: _amount });
            balanceChange_ = t.balanceOf(address(this)) - _balance;
        }

        msgData_ = abi.encodeCall(
            this.onMessageInvocation, abi.encode(ctoken_, _user, _to, balanceChange_)
        );
    }

    function _getOrDeployBridgedToken(CanonicalERC20 memory ctoken)
        private
        returns (address btoken)
    {
        btoken = canonicalToBridged[ctoken.chainId][ctoken.addr];

        if (btoken == address(0)) {
            btoken = _deployBridgedToken(ctoken);
        }
    }

    function _deployBridgedToken(CanonicalERC20 memory ctoken) private returns (address btoken) {
        bytes memory data = abi.encodeCall(
            BridgedERC20.init,
            (
                owner(),
                addressManager,
                ctoken.addr,
                ctoken.chainId,
                ctoken.decimals,
                ctoken.symbol,
                ctoken.name
            )
        );

        btoken = address(new ERC1967Proxy(resolve("bridged_erc20", false), data));
        bridgedToCanonical[btoken] = ctoken;
        canonicalToBridged[ctoken.chainId][ctoken.addr] = btoken;

        emit BridgedTokenDeployed({
            srcChainId: ctoken.chainId,
            ctoken: ctoken.addr,
            btoken: btoken,
            ctokenSymbol: ctoken.symbol,
            ctokenName: ctoken.name,
            ctokenDecimal: ctoken.decimals
        });
    }

```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC20Vault.sol#L407:433

```solidity
File: contracts/tokenvault/ERC721Vault.sol


    function onMessageInvocation(bytes calldata _data)
        external
        payable
        nonReentrant
        whenNotPaused
    {
        (CanonicalNFT memory ctoken, address from, address to, uint256[] memory tokenIds) =
            abi.decode(_data, (CanonicalNFT, address, address, uint256[]));

        // `onlyFromBridge` checked in checkProcessMessageContext
        IBridge.Context memory ctx = checkProcessMessageContext();

        // Don't allow sending to disallowed addresses.
        // Don't send the tokens back to `from` because `from` is on the source chain.
        if (to == address(0) || to == address(this)) revert VAULT_INVALID_TO();

        // Transfer the ETH and the tokens to the `to` address
        address token = _transferTokens(ctoken, to, tokenIds);
        to.sendEther(msg.value);

        emit TokenReceived({
            msgHash: ctx.msgHash,
            from: from,
            to: to,
            srcChainId: ctx.srcChainId,
            ctoken: ctoken.addr,
            token: token,
            tokenIds: tokenIds,
            amounts: new uint256[](tokenIds.length)
        });
    }

    function onMessageRecalled(
        IBridge.Message calldata _message,
        bytes32 _msgHash
    )
        external
        payable
        override
        nonReentrant
        whenNotPaused
    {
        // `onlyFromBridge` checked in checkRecallMessageContext
        checkRecallMessageContext();

        (bytes memory data) = abi.decode(_message.data[4:], (bytes));
        (CanonicalNFT memory ctoken,,, uint256[] memory tokenIds) =
            abi.decode(data, (CanonicalNFT, address, address, uint256[]));

        // Transfer the ETH and tokens back to the owner
        address token = _transferTokens(ctoken, _message.srcOwner, tokenIds);
        _message.srcOwner.sendEther(_message.value);

        emit TokenReleased({
            msgHash: _msgHash,
            from: _message.srcOwner,
            ctoken: ctoken.addr,
            token: token,
            tokenIds: tokenIds,
            amounts: new uint256[](tokenIds.length)
        });
    }

    function name() public pure override returns (bytes32) {
        return "erc721_vault";
    }

    function sendToken(BridgeTransferOp memory _op)
        external
        payable
        nonReentrant
        whenNotPaused
        withValidOperation(_op)
        returns (IBridge.Message memory message_)
    {
        for (uint256 i; i < _op.tokenIds.length; ++i) {
            if (_op.amounts[i] != 0) revert VAULT_INVALID_AMOUNT();
        }

        if (!_op.token.supportsInterface(ERC721_INTERFACE_ID)) {
            revert VAULT_INTERFACE_NOT_SUPPORTED();
        }

        (bytes memory data, CanonicalNFT memory ctoken) = _handleMessage(msg.sender, _op);

        IBridge.Message memory message = IBridge.Message({
            id: 0, // will receive a new value
            from: address(0), // will receive a new value
            srcChainId: 0, // will receive a new value
            destChainId: _op.destChainId,
            srcOwner: msg.sender,
            destOwner: _op.destOwner != address(0) ? _op.destOwner : msg.sender,
            to: resolve(_op.destChainId, name(), false),
            refundTo: _op.refundTo,
            value: msg.value - _op.fee,
            fee: _op.fee,
            gasLimit: _op.gasLimit,
            data: data,
            memo: _op.memo
        });

        bytes32 msgHash;
        (msgHash, message_) =
            IBridge(resolve("bridge", false)).sendMessage{ value: msg.value }(message);

        emit TokenSent({
            msgHash: msgHash,
            from: message_.srcOwner,
            to: _op.to,
            destChainId: message_.destChainId,
            ctoken: ctoken.addr,
            token: _op.token,
            tokenIds: _op.tokenIds,
            amounts: _op.amounts
        });
    }

    function _transferTokens(
        CanonicalNFT memory _ctoken,
        address _to,
        uint256[] memory _tokenIds
    )
        private
        returns (address token_)
    {
        if (_ctoken.chainId == block.chainid) {
            token_ = _ctoken.addr;
            for (uint256 i; i < _tokenIds.length; ++i) {
                IERC721(token_).safeTransferFrom(address(this), _to, _tokenIds[i]);
            }
        } else {
            token_ = _getOrDeployBridgedToken(_ctoken);
            for (uint256 i; i < _tokenIds.length; ++i) {
                BridgedERC721(token_).mint(_to, _tokenIds[i]);
            }
        }
    }

    function _handleMessage(
        address _user,
        BridgeTransferOp memory _op
    )
        private
        returns (bytes memory msgData_, CanonicalNFT memory ctoken_)
    {
        unchecked {
            if (bridgedToCanonical[_op.token].addr != address(0)) {
                ctoken_ = bridgedToCanonical[_op.token];
                for (uint256 i; i < _op.tokenIds.length; ++i) {
                    BridgedERC721(_op.token).burn(_user, _op.tokenIds[i]);
                }
            } else {
                ERC721Upgradeable t = ERC721Upgradeable(_op.token);

                ctoken_ = CanonicalNFT({
                    chainId: uint64(block.chainid),
                    addr: _op.token,
                    symbol: t.symbol(),
                    name: t.name()
                });

                for (uint256 i; i < _op.tokenIds.length; ++i) {
                    t.safeTransferFrom(_user, address(this), _op.tokenIds[i]);
                }
            }
        }

        msgData_ = abi.encodeCall(
            this.onMessageInvocation, abi.encode(ctoken_, _user, _op.to, _op.tokenIds)
        );
    }

    function _getOrDeployBridgedToken(CanonicalNFT memory _ctoken)
        private
        returns (address btoken_)
    {
        btoken_ = canonicalToBridged[_ctoken.chainId][_ctoken.addr];

        if (btoken_ == address(0)) {
            btoken_ = _deployBridgedToken(_ctoken);
        }
    }

    function _deployBridgedToken(CanonicalNFT memory _ctoken) private returns (address btoken_) {
        bytes memory data = abi.encodeCall(
            BridgedERC721.init,
            (owner(), addressManager, _ctoken.addr, _ctoken.chainId, _ctoken.symbol, _ctoken.name)
        );

        btoken_ = address(new ERC1967Proxy(resolve("bridged_erc721", false), data));
        bridgedToCanonical[btoken_] = _ctoken;
        canonicalToBridged[_ctoken.chainId][_ctoken.addr] = btoken_;

        emit BridgedTokenDeployed({
            chainId: _ctoken.chainId,
            ctoken: _ctoken.addr,
            btoken: btoken_,
            ctokenSymbol: _ctoken.symbol,
            ctokenName: _ctoken.name
        });
    }

```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC721Vault.sol#L240:257

```solidity
File: contracts/automata-attestation/AutomataDcapV3Attestation.sol


    function verifyAttestation(bytes calldata data) external view override returns (bool) {
        (bool success,) = _verify(data);
        return success;
    }

    function verifyParsedQuote(V3Struct.ParsedV3QuoteStruct calldata v3quote)
        external
        view
        override
        returns (bool, bytes memory)
    {
        return _verifyParsedQuote(v3quote);
    }

```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/AutomataDcapV3Attestation.sol#L355:362

```solidity
File: contracts/automata-attestation/interfaces/IAttestation.sol


    function verifyAttestation(bytes calldata data) external returns (bool);

    function verifyParsedQuote(V3Struct.ParsedV3QuoteStruct calldata v3quote)
        external
        returns (bool success, bytes memory retData);

```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/interfaces/IAttestation.sol#L10:12

```solidity
File: contracts/automata-attestation/interfaces/ISigVerifyLib.sol


    function verifyAttStmtSignature(
        bytes memory tbs,
        bytes memory signature,
        PublicKey memory publicKey,
        Algorithm alg
    )
        external
        view
        returns (bool);

    function verifyCertificateSignature(
        bytes memory tbs,
        bytes memory signature,
        PublicKey memory publicKey,
        CertSigAlgorithm alg
    )
        external
        view
        returns (bool);

    function verifyRS256Signature(
        bytes memory tbs,
        bytes memory signature,
        bytes memory publicKey
    )
        external
        view
        returns (bool sigValid);

    function verifyRS1Signature(
        bytes memory tbs,
        bytes memory signature,
        bytes memory publicKey
    )
        external
        view
        returns (bool sigValid);

    function verifyES256Signature(
        bytes memory tbs,
        bytes memory signature,
        bytes memory publicKey
    )
        external
        view
        returns (bool sigValid);

```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/interfaces/ISigVerifyLib.sol#L76:83

```solidity
File: contracts/automata-attestation/utils/SigVerifyLib.sol


    function verifyAttStmtSignature(
        bytes memory tbs,
        bytes memory signature,
        PublicKey memory publicKey,
        Algorithm alg
    )
        public
        view
        returns (bool)
    {
        if (alg == Algorithm.RS256) {
            if (publicKey.keyType != KeyType.RSA) {
                return false;
            }
            return verifyRS256Signature(tbs, signature, publicKey.pubKey);
        } else if (alg == Algorithm.ES256) {
            if (publicKey.keyType != KeyType.ECDSA) {
                return false;
            }
            return verifyES256Signature(tbs, signature, publicKey.pubKey);
        } else if (alg == Algorithm.RS1) {
            if (publicKey.keyType != KeyType.RSA) {
                return false;
            }
            return verifyRS1Signature(tbs, signature, publicKey.pubKey);
        } else {
            revert("Unsupported algorithm");
        }
    }

    function verifyCertificateSignature(
        bytes memory tbs,
        bytes memory signature,
        PublicKey memory publicKey,
        CertSigAlgorithm alg
    )
        public
        view
        returns (bool)
    {
        if (alg == CertSigAlgorithm.Sha256WithRSAEncryption) {
            if (publicKey.keyType != KeyType.RSA) {
                return false;
            }
            return verifyRS256Signature(tbs, signature, publicKey.pubKey);
        } else if (alg == CertSigAlgorithm.Sha1WithRSAEncryption) {
            if (publicKey.keyType != KeyType.RSA) {
                return false;
            }
            return verifyRS1Signature(tbs, signature, publicKey.pubKey);
        } else {
            revert("Unsupported algorithm");
        }
    }

    function verifyRS256Signature(
        bytes memory tbs,
        bytes memory signature,
        bytes memory publicKey
    )
        public
        view
        returns (bool sigValid)
    {
        // Parse public key
        bytes memory exponent = publicKey.substring(0, 3);
        bytes memory modulus = publicKey.substring(3, publicKey.length - 3);

        // Verify signature
        sigValid = RsaVerify.pkcs1Sha256Raw(tbs, signature, exponent, modulus);
    }

    function verifyRS1Signature(
        bytes memory tbs,
        bytes memory signature,
        bytes memory publicKey
    )
        public
        view
        returns (bool sigValid)
    {
        // Parse public key
        bytes memory exponent = publicKey.substring(0, 3);
        bytes memory modulus = publicKey.substring(3, publicKey.length - 3);

        // Verify signature
        sigValid = RsaVerify.pkcs1Sha1Raw(tbs, signature, exponent, modulus);
    }

    function verifyES256Signature(
        bytes memory tbs,
        bytes memory signature,
        bytes memory publicKey
    )
        public
        view
        returns (bool sigValid)
    {
        // Parse signature
        if (signature.length != 64) {
            return false;
        }
        uint256 r = uint256(bytes32(signature.substring(0, 32)));
        uint256 s = uint256(bytes32(signature.substring(32, 32)));
        // Parse public key
        if (publicKey.length != 64) {
            return false;
        }
        uint256 gx = uint256(bytes32(publicKey.substring(0, 32)));
        uint256 gy = uint256(bytes32(publicKey.substring(32, 32)));

        // Verify signature
        bytes memory args = abi.encode(sha256(tbs), r, s, gx, gy);
        (bool success, bytes memory ret) = ES256VERIFIER.staticcall(args);
        assert(success); // never reverts, always returns 0 or 1

        return abi.decode(ret, (uint256)) == 1;
    }

```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/SigVerifyLib.sol#L113:141

```solidity
File: contracts/automata-attestation/lib/PEMCertChainLib.sol


    function splitCertificateChain(
        bytes memory pemChain,
        uint256 size
    )
        external
        pure
        returns (bool success, bytes[] memory certs)
    {
        certs = new bytes[](size);
        string memory pemChainStr = string(pemChain);

        uint256 index = 0;
        uint256 len = pemChain.length;

        for (uint256 i; i < size; ++i) {
            string memory input;
            if (i > 0) {
                input = LibString.slice(pemChainStr, index, index + len);
            } else {
                input = pemChainStr;
            }
            uint256 increment;
            (success, certs[i], increment) = _removeHeadersAndFooters(input);

            if (!success) {
                return (false, certs);
            }

            index += increment;
        }

        success = true;
    }

    function decodeCert(
        bytes memory der,
        bool isPckCert
    )
        external
        pure
        returns (bool success, ECSha256Certificate memory cert)
    {
        uint256 root = der.root();

        // Entering tbsCertificate sequence
        uint256 tbsParentPtr = der.firstChildOf(root);

        // Begin iterating through the descendants of tbsCertificate
        uint256 tbsPtr = der.firstChildOf(tbsParentPtr);

        // The Serial Number is located one element below Version

        // The issuer commonName value is contained in the Issuer sequence
        // which is 3 elements below the first element of the tbsCertificate sequence

        // The Validity sequence is located 4 elements below the first element of the tbsCertificate
        // sequence

        // The subject commanName value is contained in the Subject sequence
        // which is 5 elements below the first element of the tbsCertificate sequence

        // The PublicKey is located in the second element of subjectPublicKeyInfo sequence
        // which is 6 elements below the first element of the tbsCertificate sequence

        tbsPtr = der.nextSiblingOf(tbsPtr);

        {
            bytes memory serialNumBytes = der.bytesAt(tbsPtr);
            cert.serialNumber = serialNumBytes;
        }

        tbsPtr = der.nextSiblingOf(tbsPtr);
        tbsPtr = der.nextSiblingOf(tbsPtr);

        if (isPckCert) {
            uint256 issuerPtr = der.firstChildOf(tbsPtr);
            issuerPtr = der.firstChildOf(issuerPtr);
            issuerPtr = der.firstChildOf(issuerPtr);
            issuerPtr = der.nextSiblingOf(issuerPtr);
            cert.pck.issuerName = string(der.bytesAt(issuerPtr));
            bool issuerNameIsValid = LibString.eq(cert.pck.issuerName, PLATFORM_ISSUER_NAME)
                || LibString.eq(cert.pck.issuerName, PROCESSOR_ISSUER_NAME);
            if (!issuerNameIsValid) {
                return (false, cert);
            }
        }

        tbsPtr = der.nextSiblingOf(tbsPtr);

        {
            uint256 notBeforePtr = der.firstChildOf(tbsPtr);
            uint256 notAfterPtr = der.nextSiblingOf(notBeforePtr);
            bytes1 notBeforeTag = der[notBeforePtr.ixs()];
            bytes1 notAfterTag = der[notAfterPtr.ixs()];
            if (
                (notBeforeTag != 0x17 && notBeforeTag == 0x18)
                    || (notAfterTag != 0x17 && notAfterTag != 0x18)
            ) {
                return (false, cert);
            }
            cert.notBefore = X509DateUtils.toTimestamp(der.bytesAt(notBeforePtr));
            cert.notAfter = X509DateUtils.toTimestamp(der.bytesAt(notAfterPtr));
        }

        tbsPtr = der.nextSiblingOf(tbsPtr);

        if (isPckCert) {
            uint256 subjectPtr = der.firstChildOf(tbsPtr);
            subjectPtr = der.firstChildOf(subjectPtr);
            subjectPtr = der.firstChildOf(subjectPtr);
            subjectPtr = der.nextSiblingOf(subjectPtr);
            cert.pck.commonName = string(der.bytesAt(subjectPtr));
            if (!LibString.eq(cert.pck.commonName, PCK_COMMON_NAME)) {
                return (false, cert);
            }
        }

        tbsPtr = der.nextSiblingOf(tbsPtr);

        {
            // Entering subjectPublicKeyInfo sequence
            uint256 subjectPublicKeyInfoPtr = der.firstChildOf(tbsPtr);
            subjectPublicKeyInfoPtr = der.nextSiblingOf(subjectPublicKeyInfoPtr);

            // The Signature sequence is located two sibling elements below the tbsCertificate
            // element
            uint256 sigPtr = der.nextSiblingOf(tbsParentPtr);
            sigPtr = der.nextSiblingOf(sigPtr);

            // Skip three bytes to the right
            // the three bytes in question: 0x034700 or 0x034800 or 0x034900
            sigPtr = NodePtr.getPtr(sigPtr.ixs() + 3, sigPtr.ixf() + 3, sigPtr.ixl());

            sigPtr = der.firstChildOf(sigPtr);
            bytes memory sigX = _trimBytes(der.bytesAt(sigPtr), 32);

            sigPtr = der.nextSiblingOf(sigPtr);
            bytes memory sigY = _trimBytes(der.bytesAt(sigPtr), 32);

            cert.tbsCertificate = der.allBytesAt(tbsParentPtr);
            cert.pubKey = _trimBytes(der.bytesAt(subjectPublicKeyInfoPtr), 64);
            cert.signature = abi.encodePacked(sigX, sigY);
        }

        if (isPckCert) {
            // entering Extension sequence
            tbsPtr = der.nextSiblingOf(tbsPtr);

            // check for the extension tag
            if (der[tbsPtr.ixs()] != 0xA3) {
                return (false, cert);
            }

            tbsPtr = der.firstChildOf(tbsPtr);
            tbsPtr = der.firstChildOf(tbsPtr);

            bool sgxExtnTraversedSuccessfully;
            uint256 pcesvn;
            uint256[] memory cpuSvns;
            bytes memory fmspcBytes;
            bytes memory pceidBytes;
            (sgxExtnTraversedSuccessfully, pcesvn, cpuSvns, fmspcBytes, pceidBytes) =
                _findPckTcbInfo(der, tbsPtr, tbsParentPtr);
            if (!sgxExtnTraversedSuccessfully) {
                return (false, cert);
            }
            cert.pck.sgxExtension.pcesvn = pcesvn;
            cert.pck.sgxExtension.sgxTcbCompSvnArr = cpuSvns;
            cert.pck.sgxExtension.pceid = LibString.toHexStringNoPrefix(pceidBytes);
            cert.pck.sgxExtension.fmspc = LibString.toHexStringNoPrefix(fmspcBytes);
            cert.isPck = true;
        }

        success = true;
    }

```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/PEMCertChainLib.sol#L74:214

```solidity
File: contracts/automata-attestation/lib/interfaces/IPEMCertChainLib.sol


    function splitCertificateChain(
        bytes memory pemChain,
        uint256 size
    )
        external
        pure
        returns (bool success, bytes[] memory certs);

    function decodeCert(
        bytes memory der,
        bool isPckCert
    )
        external
        pure
        returns (bool success, ECSha256Certificate memory cert);

```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/interfaces/IPEMCertChainLib.sol#L44:50

```solidity
File: contracts/automata-attestation/utils/BytesUtils.sol


    function compare(bytes memory self, bytes memory other) internal pure returns (int256) {
        return compare(self, 0, self.length, other, 0, other.length);
    }

    function compare(
        bytes memory self,
        uint256 offset,
        uint256 len,
        bytes memory other,
        uint256 otheroffset,
        uint256 otherlen
    )
        internal
        pure
        returns (int256)
    {
        uint256 shortest = len;
        if (otherlen < len) {
            shortest = otherlen;
        }

        uint256 selfptr;
        uint256 otherptr;

        assembly {
            selfptr := add(self, add(offset, 32))
            otherptr := add(other, add(otheroffset, 32))
        }
        for (uint256 idx = 0; idx < shortest; idx += 32) {
            uint256 a;
            uint256 b;
            assembly {
                a := mload(selfptr)
                b := mload(otherptr)
            }
            if (a != b) {
                // Mask out irrelevant bytes and check again
                uint256 mask;
                if (shortest > 32) {
                    mask = type(uint256).max; // aka 0xffffff....
                } else {
                    mask = ~(2 ** (8 * (32 - shortest + idx)) - 1);
                }
                uint256 diff = (a & mask) - (b & mask);
                if (diff != 0) {
                    return int256(diff);
                }
            }
            selfptr += 32;
            otherptr += 32;
        }

        return int256(len) - int256(otherlen);
    }

    function equals(
        bytes memory self,
        uint256 offset,
        bytes memory other,
        uint256 otherOffset,
        uint256 len
    )
        internal
        pure
        returns (bool)
    {
        return keccak(self, offset, len) == keccak(other, otherOffset, len);
    }

    function equals(
        bytes memory self,
        uint256 offset,
        bytes memory other,
        uint256 otherOffset
    )
        internal
        pure
        returns (bool)
    {
        return keccak(self, offset, self.length - offset)
            == keccak(other, otherOffset, other.length - otherOffset);
    }

    function equals(
        bytes memory self,
        uint256 offset,
        bytes memory other
    )
        internal
        pure
        returns (bool)
    {
        return self.length >= offset + other.length && equals(self, offset, other, 0, other.length);
    }

    function equals(bytes memory self, bytes memory other) internal pure returns (bool) {
        return self.length == other.length && equals(self, 0, other, 0, self.length);
    }

```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/BytesUtils.sol#L178:180

```solidity
File: contracts/common/IAddressManager.sol


    function getAddress(uint64 _chainId, bytes32 _name) external view returns (address);

```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/common/IAddressManager.sol#L14:14

```solidity
File: contracts/common/AddressResolver.sol


    function resolve(
        bytes32 _name,
        bool _allowZeroAddress
    )
        public
        view
        virtual
        returns (address payable)
    {
        return _resolve(uint64(block.chainid), _name, _allowZeroAddress);
    }

    function resolve(
        uint64 _chainId,
        bytes32 _name,
        bool _allowZeroAddress
    )
        public
        view
        virtual
        returns (address payable)
    {
        return _resolve(_chainId, _name, _allowZeroAddress);
    }

```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/common/AddressResolver.sol#L43:54

```solidity
File: contracts/common/IAddressResolver.sol


    function resolve(
        bytes32 _name,
        bool _allowZeroAddress
    )
        external
        view
        returns (address payable);

    function resolve(
        uint64 _chainId,
        bytes32 _name,
        bool _allowZeroAddress
    )
        external
        view
        returns (address payable);

```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/common/IAddressResolver.sol#L34:41

```solidity
File: contracts/signal/ISignalService.sol


    function sendSignal(bytes32 _signal) external returns (bytes32 slot_);

    function syncChainData(
        uint64 _chainId,
        bytes32 _kind,
        uint64 _blockId,
        bytes32 _chainData
    )
        external
        returns (bytes32 signal_);

    function proveSignalReceived(
        uint64 _chainId,
        address _app,
        bytes32 _signal,
        bytes calldata _proof
    )
        external;

    function isSignalSent(address _app, bytes32 _signal) external view returns (bool);

    function isChainDataSynced(
        uint64 _chainId,
        bytes32 _kind,
        uint64 _blockId,
        bytes32 _chainData
    )
        external
        view
        returns (bool);

    function getSyncedChainData(
        uint64 _chainId,
        bytes32 _kind,
        uint64 _blockId
    )
        external
        view
        returns (uint64 blockId_, bytes32 chainData_);

    function signalForChainData(
        uint64 _chainId,
        bytes32 _kind,
        uint64 _blockId
    )
        external
        pure
        returns (bytes32 signal_);

```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/signal/ISignalService.sol#L137:144

```solidity
File: contracts/thirdparty/optimism/Bytes.sol


    function slice(
        bytes memory _bytes,
        uint256 _start,
        uint256 _length
    )
        internal
        pure
        returns (bytes memory)
    {
        unchecked {
            require(_length + 31 >= _length, "slice_overflow");
            require(_start + _length >= _start, "slice_overflow");
            require(_bytes.length >= _start + _length, "slice_outOfBounds");
        }

        bytes memory tempBytes;

        assembly {
            switch iszero(_length)
            case 0 {
                // Get a location of some free memory and store it in tempBytes as
                // Solidity does for memory variables.
                tempBytes := mload(0x40)

                // The first word of the slice result is potentially a partial
                // word read from the original array. To read it, we calculate
                // the length of that partial word and start copying that many
                // bytes into the array. The first word we copy will start with
                // data we don't care about, but the last `lengthmod` bytes will
                // land at the beginning of the contents of the new array. When
                // we're done copying, we overwrite the full first word with
                // the actual length of the slice.
                let lengthmod := and(_length, 31)

                // The multiplication in the next line is necessary
                // because when slicing multiples of 32 bytes (lengthmod == 0)
                // the following copy loop was copying the origin's length
                // and then ending prematurely not copying everything it should.
                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))
                let end := add(mc, _length)

                for {
                    // The multiplication in the next line has the same exact purpose
                    // as the one above.
                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)
                } lt(mc, end) {
                    mc := add(mc, 0x20)
                    cc := add(cc, 0x20)
                } { mstore(mc, mload(cc)) }

                mstore(tempBytes, _length)

                //update free-memory pointer
                //allocating the array padded to 32 bytes like the compiler does now
                mstore(0x40, and(add(mc, 31), not(31)))
            }
            //if we want a zero-length slice let's just return a zero-length array
            default {
                tempBytes := mload(0x40)

                //zero out the 32 bytes slice we are about to return
                //we need to do it because Solidity does not garbage collect
                mstore(tempBytes, 0)

                mstore(0x40, add(tempBytes, 0x20))
            }
        }

        return tempBytes;
    }

    function slice(bytes memory _bytes, uint256 _start) internal pure returns (bytes memory) {
        if (_start >= _bytes.length) {
            return bytes("");
        }
        return slice(_bytes, _start, _bytes.length - _start);
    }

```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/Bytes.sol#L91:96

```solidity
File: contracts/thirdparty/optimism/rlp/RLPReader.sol


    function readList(RLPItem memory _in) internal pure returns (RLPItem[] memory out_) {
        (uint256 listOffset, uint256 listLength, RLPItemType itemType) = _decodeLength(_in);

        require(
            itemType == RLPItemType.LIST_ITEM,
            "RLPReader: decoded item type for list is not a list item"
        );

        require(
            listOffset + listLength == _in.length,
            "RLPReader: list item has an invalid data remainder"
        );

        // Solidity in-memory arrays can't be increased in size, but *can* be decreased in size by
        // writing to the length. Since we can't know the number of RLP items without looping over
        // the entire input, we'd have to loop twice to accurately size this array. It's easier to
        // simply set a reasonable maximum list length and decrease the size before we finish.
        out_ = new RLPItem[](MAX_LIST_LENGTH);

        uint256 itemCount = 0;
        uint256 offset = listOffset;
        while (offset < _in.length) {
            (uint256 itemOffset, uint256 itemLength,) = _decodeLength(
                RLPItem({
                    length: _in.length - offset,
                    ptr: MemoryPointer.wrap(MemoryPointer.unwrap(_in.ptr) + offset)
                })
            );

            // We don't need to check itemCount < out.length explicitly because Solidity already
            // handles this check on our behalf, we'd just be wasting gas.
            out_[itemCount] = RLPItem({
                length: itemLength + itemOffset,
                ptr: MemoryPointer.wrap(MemoryPointer.unwrap(_in.ptr) + offset)
            });

            itemCount += 1;
            offset += itemOffset + itemLength;
        }

        // Decrease the array size to match the actual item count.
        assembly {
            mstore(out_, itemCount)
        }
    }

    function readList(bytes memory _in) internal pure returns (RLPItem[] memory out_) {
        out_ = readList(toRLPItem(_in));
    }

    function readBytes(RLPItem memory _in) internal pure returns (bytes memory out_) {
        (uint256 itemOffset, uint256 itemLength, RLPItemType itemType) = _decodeLength(_in);

        require(
            itemType == RLPItemType.DATA_ITEM,
            "RLPReader: decoded item type for bytes is not a data item"
        );

        require(
            _in.length == itemOffset + itemLength,
            "RLPReader: bytes value contains an invalid remainder"
        );

        out_ = _copy(_in.ptr, itemOffset, itemLength);
    }

    function readBytes(bytes memory _in) internal pure returns (bytes memory out_) {
        out_ = readBytes(toRLPItem(_in));
    }

```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/rlp/RLPReader.sol#L128:130

```solidity
File: contracts/thirdparty/optimism/trie/MerkleTrie.sol


    function verifyInclusionProof(
        bytes memory _key,
        bytes memory _value,
        bytes[] memory _proof,
        bytes32 _root
    )
        internal
        pure
        returns (bool valid_)
    {
        valid_ = Bytes.equal(_value, get(_key, _proof, _root));
    }

    function get(
        bytes memory _key,
        bytes[] memory _proof,
        bytes32 _root
    )
        internal
        pure
        returns (bytes memory value_)
    {
        require(_key.length > 0, "MerkleTrie: empty key");

        TrieNode[] memory proof = _parseProof(_proof);
        bytes memory key = Bytes.toNibbles(_key);
        bytes memory currentNodeID = abi.encodePacked(_root);
        uint256 currentKeyIndex = 0;

        // Proof is top-down, so we start at the first element (root).
        for (uint256 i = 0; i < proof.length; i++) {
            TrieNode memory currentNode = proof[i];

            // Key index should never exceed total key length or we'll be out of bounds.
            require(currentKeyIndex <= key.length, "MerkleTrie: key index exceeds total key length");

            if (currentKeyIndex == 0) {
                // First proof element is always the root node.
                require(
                    Bytes.equal(abi.encodePacked(keccak256(currentNode.encoded)), currentNodeID),
                    "MerkleTrie: invalid root hash"
                );
            } else if (currentNode.encoded.length >= 32) {
                // Nodes 32 bytes or larger are hashed inside branch nodes.
                require(
                    Bytes.equal(abi.encodePacked(keccak256(currentNode.encoded)), currentNodeID),
                    "MerkleTrie: invalid large internal hash"
                );
            } else {
                // Nodes smaller than 32 bytes aren't hashed.
                require(
                    Bytes.equal(currentNode.encoded, currentNodeID),
                    "MerkleTrie: invalid internal node hash"
                );
            }

            if (currentNode.decoded.length == BRANCH_NODE_LENGTH) {
                if (currentKeyIndex == key.length) {
                    // Value is the last element of the decoded list (for branch nodes). There's
                    // some ambiguity in the Merkle trie specification because bytes(0) is a
                    // valid value to place into the trie, but for branch nodes bytes(0) can exist
                    // even when the value wasn't explicitly placed there. Geth treats a value of
                    // bytes(0) as "key does not exist" and so we do the same.
                    value_ = RLPReader.readBytes(currentNode.decoded[TREE_RADIX]);
                    require(
                        value_.length > 0,
                        "MerkleTrie: value length must be greater than zero (branch)"
                    );

                    // Extra proof elements are not allowed.
                    require(
                        i == proof.length - 1,
                        "MerkleTrie: value node must be last node in proof (branch)"
                    );

                    return value_;
                } else {
                    // We're not at the end of the key yet.
                    // Figure out what the next node ID should be and continue.
                    uint8 branchKey = uint8(key[currentKeyIndex]);
                    RLPReader.RLPItem memory nextNode = currentNode.decoded[branchKey];
                    currentNodeID = _getNodeID(nextNode);
                    currentKeyIndex += 1;
                }
            } else if (currentNode.decoded.length == LEAF_OR_EXTENSION_NODE_LENGTH) {
                bytes memory path = _getNodePath(currentNode);
                uint8 prefix = uint8(path[0]);
                uint8 offset = 2 - (prefix % 2);
                bytes memory pathRemainder = Bytes.slice(path, offset);
                bytes memory keyRemainder = Bytes.slice(key, currentKeyIndex);
                uint256 sharedNibbleLength = _getSharedNibbleLength(pathRemainder, keyRemainder);

                // Whether this is a leaf node or an extension node, the path remainder MUST be a
                // prefix of the key remainder (or be equal to the key remainder) or the proof is
                // considered invalid.
                require(
                    pathRemainder.length == sharedNibbleLength,
                    "MerkleTrie: path remainder must share all nibbles with key"
                );

                if (prefix == PREFIX_LEAF_EVEN || prefix == PREFIX_LEAF_ODD) {
                    // Prefix of 2 or 3 means this is a leaf node. For the leaf node to be valid,
                    // the key remainder must be exactly equal to the path remainder. We already
                    // did the necessary byte comparison, so it's more efficient here to check that
                    // the key remainder length equals the shared nibble length, which implies
                    // equality with the path remainder (since we already did the same check with
                    // the path remainder and the shared nibble length).
                    require(
                        keyRemainder.length == sharedNibbleLength,
                        "MerkleTrie: key remainder must be identical to path remainder"
                    );

                    // Our Merkle Trie is designed specifically for the purposes of the Ethereum
                    // state trie. Empty values are not allowed in the state trie, so we can safely
                    // say that if the value is empty, the key should not exist and the proof is
                    // invalid.
                    value_ = RLPReader.readBytes(currentNode.decoded[1]);
                    require(
                        value_.length > 0,
                        "MerkleTrie: value length must be greater than zero (leaf)"
                    );

                    // Extra proof elements are not allowed.
                    require(
                        i == proof.length - 1,
                        "MerkleTrie: value node must be last node in proof (leaf)"
                    );

                    return value_;
                } else if (prefix == PREFIX_EXTENSION_EVEN || prefix == PREFIX_EXTENSION_ODD) {
                    // Prefix of 0 or 1 means this is an extension node. We move onto the next node
                    // in the proof and increment the key index by the length of the path remainder
                    // which is equal to the shared nibble length.
                    currentNodeID = _getNodeID(currentNode.decoded[1]);
                    currentKeyIndex += sharedNibbleLength;
                } else {
                    revert("MerkleTrie: received a node with an unknown prefix");
                }
            } else {
                revert("MerkleTrie: received an unparseable node");
            }
        }

        revert("MerkleTrie: ran out of proof elements");
    }

```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/trie/MerkleTrie.sol#L68:199

```solidity
File: contracts/thirdparty/optimism/trie/SecureMerkleTrie.sol


    function verifyInclusionProof(
        bytes memory _key,
        bytes memory _value,
        bytes[] memory _proof,
        bytes32 _root
    )
        internal
        pure
        returns (bool valid_)
    {
        bytes memory key = _getSecureKey(_key);
        valid_ = MerkleTrie.verifyInclusionProof(key, _value, _proof, _root);
    }

    function get(
        bytes memory _key,
        bytes[] memory _proof,
        bytes32 _root
    )
        internal
        pure
        returns (bytes memory value_)
    {
        bytes memory key = _getSecureKey(_key);
        value_ = MerkleTrie.get(key, _proof, _root);
    }

```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/trie/SecureMerkleTrie.sol#L38:49

```solidity
File: contracts/verifiers/IVerifier.sol


    function verifyProof(
        Context calldata _ctx,
        TaikoData.Transition calldata _tran,
        TaikoData.TierProof calldata _proof
    )
        external;

```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/verifiers/IVerifier.sol#L24:29

</details>

## NC055 - It is standard for all external and public functions to be override from an interface:

This is to ensure the whole API is extracted in an interface


<details>
<summary>Click to show 161 findings</summary>

```solidity
File: contracts/L1/TaikoL1.sol


34          receive() external payable {
35              if (!_inNonReentrant()) revert L1_RECEIVE_DISABLED();
36          }


42          function init(
43              address _owner,
44              address _addressManager,
45              bytes32 _genesisBlockHash
46          )
47              external
48              initializer
49          {
50              __Essential_init(_owner, _addressManager);
51              LibVerifying.init(state, getConfig(), _genesisBlockHash);
52          }


55          function proposeBlock(
56              bytes calldata _params,
57              bytes calldata _txList
58          )
59              external
60              payable
61              nonReentrant
62              whenNotPaused
63              returns (TaikoData.BlockMetadata memory meta_, TaikoData.EthDeposit[] memory deposits_)
64          {
65              TaikoData.Config memory config = getConfig();
66      
67              (meta_, deposits_) = LibProposing.proposeBlock(state, config, this, _params, _txList);
68      
69              if (!state.slotB.provingPaused) {
70                  LibVerifying.verifyBlocks(state, config, this, config.maxBlocksToVerifyPerProposal);
71              }
72          }


75          function proveBlock(
76              uint64 _blockId,
77              bytes calldata _input
78          )
79              external
80              nonReentrant
81              whenNotPaused
82              whenProvingNotPaused
83          {
84              (
85                  TaikoData.BlockMetadata memory meta,
86                  TaikoData.Transition memory tran,
87                  TaikoData.TierProof memory proof
88              ) = abi.decode(_input, (TaikoData.BlockMetadata, TaikoData.Transition, TaikoData.TierProof));
89      
90              if (_blockId != meta.id) revert L1_INVALID_BLOCK_ID();
91      
92              TaikoData.Config memory config = getConfig();
93      
94              uint8 maxBlocksToVerify = LibProving.proveBlock(state, config, this, meta, tran, proof);
95      
96              LibVerifying.verifyBlocks(state, config, this, maxBlocksToVerify);
97          }


100         function verifyBlocks(uint64 _maxBlocksToVerify)
101             external
102             nonReentrant
103             whenNotPaused
104             whenProvingNotPaused
105         {
106             LibVerifying.verifyBlocks(state, getConfig(), this, _maxBlocksToVerify);
107         }


111         function pauseProving(bool _pause) external {
112             _authorizePause(msg.sender);
113             LibProving.pauseProving(state, _pause);
114         }


119         function depositEtherToL2(address _recipient) external payable nonReentrant whenNotPaused {
120             LibDepositing.depositEtherToL2(state, getConfig(), this, _recipient);
121         }


124         function unpause() public override {
125             super.unpause(); // permission checked inside
126             state.slotB.lastUnpausedAt = uint64(block.timestamp);
127         }


132         function canDepositEthToL2(uint256 _amount) public view returns (bool) {
133             return LibDepositing.canDepositEthToL2(state, getConfig(), _amount);
134         }


137         function isBlobReusable(bytes32 _blobHash) public view returns (bool) {
138             return LibProposing.isBlobReusable(state, getConfig(), _blobHash);
139         }


145         function getBlock(uint64 _blockId)
146             public
147             view
148             returns (TaikoData.Block memory blk_, TaikoData.TransitionState memory ts_)
149         {
150             uint64 slot;
151             (blk_, slot) = LibUtils.getBlock(state, getConfig(), _blockId);
152     
153             if (blk_.verifiedTransitionId != 0) {
154                 ts_ = state.transitions[slot][blk_.verifiedTransitionId];
155             }
156         }


162         function getTransition(
163             uint64 _blockId,
164             bytes32 _parentHash
165         )
166             public
167             view
168             returns (TaikoData.TransitionState memory)
169         {
170             return LibUtils.getTransition(state, getConfig(), _blockId, _parentHash);
171         }


176         function getStateVariables()
177             public
178             view
179             returns (TaikoData.SlotA memory a_, TaikoData.SlotB memory b_)
180         {
181             a_ = state.slotA;
182             b_ = state.slotB;
183         }


186         function getConfig() public view virtual override returns (TaikoData.Config memory) {
187             // All hard-coded configurations:
188             // - treasury: the actual TaikoL2 address.
189             // - anchorGasLimit: 250_000 (based on internal devnet, its ~220_000
190             // after 256 L2 blocks)
191             return TaikoData.Config({
192                 chainId: 167_008,
193                 // Assume the block time is 3s, the protocol will allow ~1 month of
194                 // new blocks without any verification.
195                 blockMaxProposals: 864_000,
196                 blockRingBufferSize: 864_100,
197                 // Can be overridden by the tier config.
198                 maxBlocksToVerifyPerProposal: 10,
199                 blockMaxGasLimit: 15_000_000,
200                 // Each go-ethereum transaction has a size limit of 128KB,
201                 // and right now txList is still saved in calldata, so we set it
202                 // to 120KB.
203                 blockMaxTxListBytes: 120_000,
204                 blobExpiry: 24 hours,
205                 blobAllowedForDA: false,
206                 blobReuseEnabled: false,
207                 livenessBond: 250e18, // 250 Taiko token
208                 // ETH deposit related.
209                 ethDepositRingBufferSize: 1024,
210                 ethDepositMinCountPerBlock: 8,
211                 ethDepositMaxCountPerBlock: 32,
212                 ethDepositMinAmount: 1 ether,
213                 ethDepositMaxAmount: 10_000 ether,
214                 ethDepositGas: 21_000,
215                 ethDepositMaxFee: 1 ether / 10,
216                 blockSyncThreshold: 16
217             });
218         }


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/TaikoL1.sol#L186:218

```solidity
File: contracts/L1/TaikoToken.sol


25          function init(
26              address _owner,
27              string calldata _name,
28              string calldata _symbol,
29              address _recipient
30          )
31              public
32              initializer
33          {
34              __Essential_init(_owner);
35              __ERC20_init(_name, _symbol);
36              __ERC20Snapshot_init();
37              __ERC20Votes_init();
38              __ERC20Permit_init(_name);
39      
40              // Mint 1 billion tokens
41              _mint(_recipient, 1_000_000_000 ether);
42          }


47          function burn(address _from, uint256 _amount) public onlyOwner {
48              _burn(_from, _amount);
49          }


52          function snapshot() public onlyFromOwnerOrNamed("snapshooter") {
53              _snapshot();
54          }


60          function transfer(address _to, uint256 _amount) public override returns (bool) {
61              if (_to == address(this)) revert TKO_INVALID_ADDR();
62              return super.transfer(_to, _amount);
63          }


70          function transferFrom(
71              address _from,
72              address _to,
73              uint256 _amount
74          )
75              public
76              override
77              returns (bool)
78          {
79              if (_to == address(this)) revert TKO_INVALID_ADDR();
80              return super.transferFrom(_from, _to, _amount);
81          }


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/TaikoToken.sol#L70:81

```solidity
File: contracts/L1/gov/TaikoGovernor.sol


31          function init(
32              address _owner,
33              IVotesUpgradeable _token,
34              TimelockControllerUpgradeable _timelock
35          )
36              external
37              initializer
38          {
39              __Essential_init(_owner);
40              __Governor_init("TaikoGovernor");
41              __GovernorCompatibilityBravo_init();
42              __GovernorVotes_init(_token);
43              __GovernorVotesQuorumFraction_init(4);
44              __GovernorTimelockControl_init(_timelock);
45          }


48          function propose(
49              address[] memory _targets,
50              uint256[] memory _values,
51              bytes[] memory _calldatas,
52              string memory _description
53          )
54              public
55              override(IGovernorUpgradeable, GovernorUpgradeable, GovernorCompatibilityBravoUpgradeable)
56              returns (uint256)
57          {
58              return super.propose(_targets, _values, _calldatas, _description);
59          }


69          function propose(
70              address[] memory _targets,
71              uint256[] memory _values,
72              string[] memory _signatures,
73              bytes[] memory _calldatas,
74              string memory _description
75          )
76              public
77              virtual
78              override(GovernorCompatibilityBravoUpgradeable)
79              returns (uint256)
80          {
81              if (_signatures.length != _calldatas.length) revert TG_INVALID_SIGNATURES_LENGTH();
82      
83              return GovernorCompatibilityBravoUpgradeable.propose(
84                  _targets, _values, _signatures, _calldatas, _description
85              );
86          }


89          function supportsInterface(bytes4 _interfaceId)
90              public
91              view
92              override(GovernorUpgradeable, GovernorTimelockControlUpgradeable, IERC165Upgradeable)
93              returns (bool)
94          {
95              return super.supportsInterface(_interfaceId);
96          }


99          function state(uint256 _proposalId)
100             public
101             view
102             override(IGovernorUpgradeable, GovernorUpgradeable, GovernorTimelockControlUpgradeable)
103             returns (ProposalState)
104         {
105             return super.state(_proposalId);
106         }


111         function votingDelay() public pure override returns (uint256) {
112             return 7200; // 1 day
113         }


117         function votingPeriod() public pure override returns (uint256) {
118             return 50_400; // 1 week
119         }


123         function proposalThreshold() public pure override returns (uint256) {
124             return 1_000_000_000 ether / 10_000; // 0.01% of Taiko Token
125         }


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/gov/TaikoGovernor.sol#L123:125

```solidity
File: contracts/L1/gov/TaikoTimelockController.sol


15          function init(address _owner, uint256 _minDelay) external initializer {
16              __Essential_init(_owner);
17              address[] memory nil = new address[](0);
18              __TimelockController_init(_minDelay, nil, nil, owner());
19          }


24          function getMinDelay() public view override returns (uint256) {
25              return hasRole(TIMELOCK_ADMIN_ROLE, msg.sender) ? 0 : super.getMinDelay();
26          }


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/gov/TaikoTimelockController.sol#L24:26

```solidity
File: contracts/L1/hooks/AssignmentHook.sol


57          function init(address _owner, address _addressManager) external initializer {
58              __Essential_init(_owner, _addressManager);
59          }


62          function onBlockProposed(
63              TaikoData.Block memory _blk,
64              TaikoData.BlockMetadata memory _meta,
65              bytes memory _data
66          )
67              external
68              payable
69              nonReentrant
70              onlyFromNamed("taiko")
71          {
72              // Note that
73              // - 'msg.sender' is the TaikoL1 contract address
74              // - 'block.coinbase' is the L1 block builder
75              // - 'meta.coinbase' is the L2 block proposer
76      
77              Input memory input = abi.decode(_data, (Input));
78              ProverAssignment memory assignment = input.assignment;
79      
80              // Check assignment validity
81              if (
82                  block.timestamp > assignment.expiry
83                      || assignment.metaHash != 0 && _blk.metaHash != assignment.metaHash
84                      || assignment.parentMetaHash != 0 && _meta.parentMetaHash != assignment.parentMetaHash
85                      || assignment.maxBlockId != 0 && _meta.id > assignment.maxBlockId
86                      || assignment.maxProposedIn != 0 && block.number > assignment.maxProposedIn
87              ) {
88                  revert HOOK_ASSIGNMENT_EXPIRED();
89              }
90      
91              // Hash the assignment with the blobHash, this hash will be signed by
92              // the prover, therefore, we add a string as a prefix.
93              address taikoL1Address = msg.sender;
94              bytes32 hash = hashAssignment(assignment, taikoL1Address, _meta.blobHash);
95      
96              if (!_blk.assignedProver.isValidSignature(hash, assignment.signature)) {
97                  revert HOOK_ASSIGNMENT_INVALID_SIG();
98              }
99      
100             // Send the liveness bond to the Taiko contract
101             IERC20 tko = IERC20(resolve("taiko_token", false));
102             tko.transferFrom(_blk.assignedProver, taikoL1Address, _blk.livenessBond);
103     
104             // Find the prover fee using the minimal tier
105             uint256 proverFee = _getProverFee(assignment.tierFees, _meta.minTier);
106     
107             // The proposer irrevocably pays a fee to the assigned prover, either in
108             // Ether or ERC20 tokens.
109             if (assignment.feeToken == address(0)) {
110                 // Paying Ether
111                 _blk.assignedProver.sendEther(proverFee, MAX_GAS_PAYING_PROVER);
112             } else {
113                 // Paying ERC20 tokens
114                 IERC20(assignment.feeToken).safeTransferFrom(
115                     _meta.coinbase, _blk.assignedProver, proverFee
116                 );
117             }
118     
119             // block.coinbase can be address(0) in tests
120             if (input.tip != 0 && block.coinbase != address(0)) {
121                 address(block.coinbase).sendEther(input.tip);
122             }
123     
124             // Send all remaining Ether back to TaikoL1 contract
125             if (address(this).balance > 0) {
126                 taikoL1Address.sendEther(address(this).balance);
127             }
128     
129             emit BlockAssigned(_blk.assignedProver, _meta, assignment);
130         }


137         function hashAssignment(
138             ProverAssignment memory _assignment,
139             address _taikoL1Address,
140             bytes32 _blobHash
141         )
142             public
143             view
144             returns (bytes32)
145         {
146             return keccak256(
147                 abi.encode(
148                     "PROVER_ASSIGNMENT",
149                     ITaikoL1(_taikoL1Address).getConfig().chainId,
150                     _taikoL1Address,
151                     address(this),
152                     _assignment.metaHash,
153                     _assignment.parentMetaHash,
154                     _blobHash,
155                     _assignment.feeToken,
156                     _assignment.expiry,
157                     _assignment.maxBlockId,
158                     _assignment.maxProposedIn,
159                     _assignment.tierFees
160                 )
161             );
162         }


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/hooks/AssignmentHook.sol#L137:162

```solidity
File: contracts/L1/provers/GuardianProver.sol


25          function init(address _owner, address _addressManager) external initializer {
26              __Essential_init(_owner, _addressManager);
27          }


35          function approve(
36              TaikoData.BlockMetadata calldata _meta,
37              TaikoData.Transition calldata _tran,
38              TaikoData.TierProof calldata _proof
39          )
40              external
41              whenNotPaused
42              nonReentrant
43              returns (bool approved_)
44          {
45              if (_proof.tier != LibTiers.TIER_GUARDIAN) revert INVALID_PROOF();
46              bytes32 hash = keccak256(abi.encode(_meta, _tran));
47              approved_ = approve(_meta.id, hash);
48      
49              if (approved_) {
50                  deleteApproval(hash);
51                  ITaikoL1(resolve("taiko", false)).proveBlock(_meta.id, abi.encode(_meta, _tran, _proof));
52              }
53      
54              emit GuardianApproval(msg.sender, _meta.id, _tran.blockHash, approved_);
55          }


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/provers/GuardianProver.sol#L35:55

```solidity
File: contracts/L1/tiers/DevnetTierProvider.sol


15          function init(address _owner) external initializer {
16              __Essential_init(_owner);
17          }


20          function getTier(uint16 _tierId) public pure override returns (ITierProvider.Tier memory) {
21              if (_tierId == LibTiers.TIER_OPTIMISTIC) {
22                  return ITierProvider.Tier({
23                      verifierName: "tier_optimistic",
24                      validityBond: 250 ether, // TKO
25                      contestBond: 500 ether, // TKO
26                      cooldownWindow: 1440, //24 hours
27                      provingWindow: 120, // 2 hours
28                      maxBlocksToVerifyPerProof: 16
29                  });
30              }
31      
32              if (_tierId == LibTiers.TIER_GUARDIAN) {
33                  return ITierProvider.Tier({
34                      verifierName: "tier_guardian",
35                      validityBond: 0, // must be 0 for top tier
36                      contestBond: 0, // must be 0 for top tier
37                      cooldownWindow: 60, //1 hours
38                      provingWindow: 2880, // 48 hours
39                      maxBlocksToVerifyPerProof: 16
40                  });
41              }
42      
43              revert TIER_NOT_FOUND();
44          }


47          function getTierIds() public pure override returns (uint16[] memory tiers_) {
48              tiers_ = new uint16[](2);
49              tiers_[0] = LibTiers.TIER_OPTIMISTIC;
50              tiers_[1] = LibTiers.TIER_GUARDIAN;
51          }


54          function getMinTier(uint256) public pure override returns (uint16) {
55              return LibTiers.TIER_OPTIMISTIC;
56          }


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/tiers/DevnetTierProvider.sol#L54:56

```solidity
File: contracts/L1/tiers/MainnetTierProvider.sol


15          function init(address _owner) external initializer {
16              __Essential_init(_owner);
17          }


20          function getTier(uint16 _tierId) public pure override returns (ITierProvider.Tier memory) {
21              if (_tierId == LibTiers.TIER_SGX) {
22                  return ITierProvider.Tier({
23                      verifierName: "tier_sgx",
24                      validityBond: 250 ether, // TKO
25                      contestBond: 500 ether, // TKO
26                      cooldownWindow: 1440, //24 hours
27                      provingWindow: 60, // 1 hours
28                      maxBlocksToVerifyPerProof: 8
29                  });
30              }
31      
32              if (_tierId == LibTiers.TIER_SGX_ZKVM) {
33                  return ITierProvider.Tier({
34                      verifierName: "tier_sgx_zkvm",
35                      validityBond: 500 ether, // TKO
36                      contestBond: 1000 ether, // TKO
37                      cooldownWindow: 1440, //24 hours
38                      provingWindow: 240, // 4 hours
39                      maxBlocksToVerifyPerProof: 4
40                  });
41              }
42      
43              if (_tierId == LibTiers.TIER_GUARDIAN) {
44                  return ITierProvider.Tier({
45                      verifierName: "tier_guardian",
46                      validityBond: 0, // must be 0 for top tier
47                      contestBond: 0, // must be 0 for top tier
48                      cooldownWindow: 60, //1 hours
49                      provingWindow: 2880, // 48 hours
50                      maxBlocksToVerifyPerProof: 16
51                  });
52              }
53      
54              revert TIER_NOT_FOUND();
55          }


58          function getTierIds() public pure override returns (uint16[] memory tiers_) {
59              tiers_ = new uint16[](3);
60              tiers_[0] = LibTiers.TIER_SGX;
61              tiers_[1] = LibTiers.TIER_SGX_ZKVM;
62              tiers_[2] = LibTiers.TIER_GUARDIAN;
63          }


66          function getMinTier(uint256 _rand) public pure override returns (uint16) {
67              // 0.1% require SGX + ZKVM; all others require SGX
68              if (_rand % 1000 == 0) return LibTiers.TIER_SGX_ZKVM;
69              else return LibTiers.TIER_SGX;
70          }


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/tiers/MainnetTierProvider.sol#L66:70

```solidity
File: contracts/L1/tiers/TestnetTierProvider.sol


15          function init(address _owner) external initializer {
16              __Essential_init(_owner);
17          }


20          function getTier(uint16 _tierId) public pure override returns (ITierProvider.Tier memory) {
21              if (_tierId == LibTiers.TIER_OPTIMISTIC) {
22                  return ITierProvider.Tier({
23                      verifierName: "tier_optimistic",
24                      validityBond: 250 ether, // TKO
25                      contestBond: 500 ether, // TKO
26                      cooldownWindow: 1440, //24 hours
27                      provingWindow: 30, // 0.5 hours
28                      maxBlocksToVerifyPerProof: 12
29                  });
30              }
31      
32              if (_tierId == LibTiers.TIER_SGX) {
33                  return ITierProvider.Tier({
34                      verifierName: "tier_sgx",
35                      validityBond: 500 ether, // TKO
36                      contestBond: 1000 ether, // TKO
37                      cooldownWindow: 1440, //24 hours
38                      provingWindow: 60, // 1 hours
39                      maxBlocksToVerifyPerProof: 8
40                  });
41              }
42      
43              if (_tierId == LibTiers.TIER_GUARDIAN) {
44                  return ITierProvider.Tier({
45                      verifierName: "tier_guardian",
46                      validityBond: 0, // must be 0 for top tier
47                      contestBond: 0, // must be 0 for top tier
48                      cooldownWindow: 60, //1 hours
49                      provingWindow: 2880, // 48 hours
50                      maxBlocksToVerifyPerProof: 16
51                  });
52              }
53      
54              revert TIER_NOT_FOUND();
55          }


58          function getTierIds() public pure override returns (uint16[] memory tiers_) {
59              tiers_ = new uint16[](3);
60              tiers_[0] = LibTiers.TIER_OPTIMISTIC;
61              tiers_[1] = LibTiers.TIER_SGX;
62              tiers_[2] = LibTiers.TIER_GUARDIAN;
63          }


66          function getMinTier(uint256 _rand) public pure override returns (uint16) {
67              // 10% will be selected to require SGX proofs.
68              if (_rand % 10 == 0) return LibTiers.TIER_SGX;
69              // Other blocks are optimistic, without validity proofs.
70              return LibTiers.TIER_OPTIMISTIC;
71          }


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/tiers/TestnetTierProvider.sol#L66:71

```solidity
File: contracts/L2/TaikoL2.sol


71          function init(
72              address _owner,
73              address _addressManager,
74              uint64 _l1ChainId,
75              uint64 _gasExcess
76          )
77              external
78              initializer
79          {
80              __CrossChainOwned_init(_owner, _addressManager, _l1ChainId);
81      
82              if (block.chainid <= 1 || block.chainid > type(uint64).max) {
83                  revert L2_INVALID_CHAIN_ID();
84              }
85      
86              if (block.number == 0) {
87                  // This is the case in real L2 genesis
88              } else if (block.number == 1) {
89                  // This is the case in tests
90                  uint256 parentHeight = block.number - 1;
91                  l2Hashes[parentHeight] = blockhash(parentHeight);
92              } else {
93                  revert L2_TOO_LATE();
94              }
95      
96              gasExcess = _gasExcess;
97              (publicInputHash,) = _calcPublicInputHash(block.number);
98          }


107         function anchor(
108             bytes32 _l1BlockHash,
109             bytes32 _l1StateRoot,
110             uint64 _l1BlockId,
111             uint32 _parentGasUsed
112         )
113             external
114             nonReentrant
115         {
116             if (
117                 _l1BlockHash == 0 || _l1StateRoot == 0 || _l1BlockId == 0
118                     || (block.number != 1 && _parentGasUsed == 0)
119             ) {
120                 revert L2_INVALID_PARAM();
121             }
122     
123             if (msg.sender != GOLDEN_TOUCH_ADDRESS) revert L2_INVALID_SENDER();
124     
125             uint256 parentId;
126             unchecked {
127                 parentId = block.number - 1;
128             }
129     
130             // Verify ancestor hashes
131             (bytes32 publicInputHashOld, bytes32 publicInputHashNew) = _calcPublicInputHash(parentId);
132             if (publicInputHash != publicInputHashOld) {
133                 revert L2_PUBLIC_INPUT_HASH_MISMATCH();
134             }
135     
136             Config memory config = getConfig();
137     
138             // Verify the base fee per gas is correct
139             uint256 basefee;
140             (basefee, gasExcess) = _calc1559BaseFee(config, _l1BlockId, _parentGasUsed);
141             if (!skipFeeCheck() && block.basefee != basefee) {
142                 revert L2_BASEFEE_MISMATCH();
143             }
144     
145             if (_l1BlockId > lastSyncedBlock + BLOCK_SYNC_THRESHOLD) {
146                 // Store the L1's state root as a signal to the local signal service to
147                 // allow for multi-hop bridging.
148                 ISignalService(resolve("signal_service", false)).syncChainData(
149                     ownerChainId, LibSignals.STATE_ROOT, _l1BlockId, _l1StateRoot
150                 );
151                 lastSyncedBlock = _l1BlockId;
152             }
153             // Update state variables
154             l2Hashes[parentId] = blockhash(parentId);
155             publicInputHash = publicInputHashNew;
156     
157             emit Anchored(blockhash(parentId), gasExcess);
158         }


163         function withdraw(
164             address _token,
165             address _to
166         )
167             external
168             onlyFromOwnerOrNamed("withdrawer")
169             nonReentrant
170             whenNotPaused
171         {
172             if (_to == address(0)) revert L2_INVALID_PARAM();
173             if (_token == address(0)) {
174                 _to.sendEther(address(this).balance);
175             } else {
176                 IERC20(_token).safeTransfer(_to, IERC20(_token).balanceOf(address(this)));
177             }
178         }


185         function getBasefee(
186             uint64 _l1BlockId,
187             uint32 _parentGasUsed
188         )
189             public
190             view
191             returns (uint256 basefee_)
192         {
193             (basefee_,) = _calc1559BaseFee(getConfig(), _l1BlockId, _parentGasUsed);
194         }


200         function getBlockHash(uint64 _blockId) public view returns (bytes32) {
201             if (_blockId >= block.number) return 0;
202             if (_blockId + 256 >= block.number) return blockhash(_blockId);
203             return l2Hashes[_blockId];
204         }


208         function getConfig() public view virtual returns (Config memory config_) {
209             // 4x Ethereum gas target, if we assume most of the time, L2 block time
210             // is 3s, and each block is full (gasUsed is 15_000_000), then its
211             // ~60_000_000, if the  network is congester than that, the base fee
212             // will increase.
213             config_.gasTargetPerL1Block = 15 * 1e6 * 4;
214             config_.basefeeAdjustmentQuotient = 8;
215         }


219         function skipFeeCheck() public pure virtual returns (bool) {
220             return false;
221         }


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/TaikoL2.sol#L219:221

```solidity
File: contracts/L2/TaikoL2EIP1559Configurable.sol


25          function setConfigAndExcess(
26              Config memory _newConfig,
27              uint64 _newGasExcess
28          )
29              external
30              virtual
31              onlyOwner
32          {
33              if (_newConfig.gasTargetPerL1Block == 0) revert L2_INVALID_CONFIG();
34              if (_newConfig.basefeeAdjustmentQuotient == 0) revert L2_INVALID_CONFIG();
35      
36              customConfig = _newConfig;
37              gasExcess = _newGasExcess;
38      
39              emit ConfigAndExcessChanged(_newConfig, _newGasExcess);
40          }


43          function getConfig() public view override returns (Config memory) {
44              return customConfig;
45          }


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/TaikoL2EIP1559Configurable.sol#L43:45

```solidity
File: contracts/automata-attestation/AutomataDcapV3Attestation.sol


65          function setMrSigner(bytes32 _mrSigner, bool _trusted) external onlyOwner {
66              _trustedUserMrSigner[_mrSigner] = _trusted;
67          }


69          function setMrEnclave(bytes32 _mrEnclave, bool _trusted) external onlyOwner {
70              _trustedUserMrEnclave[_mrEnclave] = _trusted;
71          }


73          function addRevokedCertSerialNum(
74              uint256 index,
75              bytes[] calldata serialNumBatch
76          )
77              external
78              onlyOwner
79          {
80              for (uint256 i; i < serialNumBatch.length; ++i) {
81                  if (_serialNumIsRevoked[index][serialNumBatch[i]]) {
82                      continue;
83                  }
84                  _serialNumIsRevoked[index][serialNumBatch[i]] = true;
85              }
86          }


88          function removeRevokedCertSerialNum(
89              uint256 index,
90              bytes[] calldata serialNumBatch
91          )
92              external
93              onlyOwner
94          {
95              for (uint256 i; i < serialNumBatch.length; ++i) {
96                  if (!_serialNumIsRevoked[index][serialNumBatch[i]]) {
97                      continue;
98                  }
99                  delete _serialNumIsRevoked[index][serialNumBatch[i]];
100             }
101         }


103         function configureTcbInfoJson(
104             string calldata fmspc,
105             TCBInfoStruct.TCBInfo calldata tcbInfoInput
106         )
107             public
108             onlyOwner
109         {
110             // 2.2M gas
111             tcbInfo[fmspc] = tcbInfoInput;
112         }


114         function configureQeIdentityJson(EnclaveIdStruct.EnclaveId calldata qeIdentityInput)
115             external
116             onlyOwner
117         {
118             // 250k gas
119             qeIdentity = qeIdentityInput;
120         }


122         function toggleLocalReportCheck() external onlyOwner {
123             _checkLocalEnclaveReport = !_checkLocalEnclaveReport;
124         }


138         function verifyAttestation(bytes calldata data) external view override returns (bool) {
139             (bool success,) = _verify(data);
140             return success;
141         }


355         function verifyParsedQuote(V3Struct.ParsedV3QuoteStruct calldata v3quote)
356             external
357             view
358             override
359             returns (bool, bytes memory)
360         {
361             return _verifyParsedQuote(v3quote);
362         }


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/AutomataDcapV3Attestation.sol#L355:362

```solidity
File: contracts/automata-attestation/lib/PEMCertChainLib.sol


40          function splitCertificateChain(
41              bytes memory pemChain,
42              uint256 size
43          )
44              external
45              pure
46              returns (bool success, bytes[] memory certs)
47          {
48              certs = new bytes[](size);
49              string memory pemChainStr = string(pemChain);
50      
51              uint256 index = 0;
52              uint256 len = pemChain.length;
53      
54              for (uint256 i; i < size; ++i) {
55                  string memory input;
56                  if (i > 0) {
57                      input = LibString.slice(pemChainStr, index, index + len);
58                  } else {
59                      input = pemChainStr;
60                  }
61                  uint256 increment;
62                  (success, certs[i], increment) = _removeHeadersAndFooters(input);
63      
64                  if (!success) {
65                      return (false, certs);
66                  }
67      
68                  index += increment;
69              }
70      
71              success = true;
72          }


74          function decodeCert(
75              bytes memory der,
76              bool isPckCert
77          )
78              external
79              pure
80              returns (bool success, ECSha256Certificate memory cert)
81          {
82              uint256 root = der.root();
83      
84              // Entering tbsCertificate sequence
85              uint256 tbsParentPtr = der.firstChildOf(root);
86      
87              // Begin iterating through the descendants of tbsCertificate
88              uint256 tbsPtr = der.firstChildOf(tbsParentPtr);
89      
90              // The Serial Number is located one element below Version
91      
92              // The issuer commonName value is contained in the Issuer sequence
93              // which is 3 elements below the first element of the tbsCertificate sequence
94      
95              // The Validity sequence is located 4 elements below the first element of the tbsCertificate
96              // sequence
97      
98              // The subject commanName value is contained in the Subject sequence
99              // which is 5 elements below the first element of the tbsCertificate sequence
100     
101             // The PublicKey is located in the second element of subjectPublicKeyInfo sequence
102             // which is 6 elements below the first element of the tbsCertificate sequence
103     
104             tbsPtr = der.nextSiblingOf(tbsPtr);
105     
106             {
107                 bytes memory serialNumBytes = der.bytesAt(tbsPtr);
108                 cert.serialNumber = serialNumBytes;
109             }
110     
111             tbsPtr = der.nextSiblingOf(tbsPtr);
112             tbsPtr = der.nextSiblingOf(tbsPtr);
113     
114             if (isPckCert) {
115                 uint256 issuerPtr = der.firstChildOf(tbsPtr);
116                 issuerPtr = der.firstChildOf(issuerPtr);
117                 issuerPtr = der.firstChildOf(issuerPtr);
118                 issuerPtr = der.nextSiblingOf(issuerPtr);
119                 cert.pck.issuerName = string(der.bytesAt(issuerPtr));
120                 bool issuerNameIsValid = LibString.eq(cert.pck.issuerName, PLATFORM_ISSUER_NAME)
121                     || LibString.eq(cert.pck.issuerName, PROCESSOR_ISSUER_NAME);
122                 if (!issuerNameIsValid) {
123                     return (false, cert);
124                 }
125             }
126     
127             tbsPtr = der.nextSiblingOf(tbsPtr);
128     
129             {
130                 uint256 notBeforePtr = der.firstChildOf(tbsPtr);
131                 uint256 notAfterPtr = der.nextSiblingOf(notBeforePtr);
132                 bytes1 notBeforeTag = der[notBeforePtr.ixs()];
133                 bytes1 notAfterTag = der[notAfterPtr.ixs()];
134                 if (
135                     (notBeforeTag != 0x17 && notBeforeTag == 0x18)
136                         || (notAfterTag != 0x17 && notAfterTag != 0x18)
137                 ) {
138                     return (false, cert);
139                 }
140                 cert.notBefore = X509DateUtils.toTimestamp(der.bytesAt(notBeforePtr));
141                 cert.notAfter = X509DateUtils.toTimestamp(der.bytesAt(notAfterPtr));
142             }
143     
144             tbsPtr = der.nextSiblingOf(tbsPtr);
145     
146             if (isPckCert) {
147                 uint256 subjectPtr = der.firstChildOf(tbsPtr);
148                 subjectPtr = der.firstChildOf(subjectPtr);
149                 subjectPtr = der.firstChildOf(subjectPtr);
150                 subjectPtr = der.nextSiblingOf(subjectPtr);
151                 cert.pck.commonName = string(der.bytesAt(subjectPtr));
152                 if (!LibString.eq(cert.pck.commonName, PCK_COMMON_NAME)) {
153                     return (false, cert);
154                 }
155             }
156     
157             tbsPtr = der.nextSiblingOf(tbsPtr);
158     
159             {
160                 // Entering subjectPublicKeyInfo sequence
161                 uint256 subjectPublicKeyInfoPtr = der.firstChildOf(tbsPtr);
162                 subjectPublicKeyInfoPtr = der.nextSiblingOf(subjectPublicKeyInfoPtr);
163     
164                 // The Signature sequence is located two sibling elements below the tbsCertificate
165                 // element
166                 uint256 sigPtr = der.nextSiblingOf(tbsParentPtr);
167                 sigPtr = der.nextSiblingOf(sigPtr);
168     
169                 // Skip three bytes to the right
170                 // the three bytes in question: 0x034700 or 0x034800 or 0x034900
171                 sigPtr = NodePtr.getPtr(sigPtr.ixs() + 3, sigPtr.ixf() + 3, sigPtr.ixl());
172     
173                 sigPtr = der.firstChildOf(sigPtr);
174                 bytes memory sigX = _trimBytes(der.bytesAt(sigPtr), 32);
175     
176                 sigPtr = der.nextSiblingOf(sigPtr);
177                 bytes memory sigY = _trimBytes(der.bytesAt(sigPtr), 32);
178     
179                 cert.tbsCertificate = der.allBytesAt(tbsParentPtr);
180                 cert.pubKey = _trimBytes(der.bytesAt(subjectPublicKeyInfoPtr), 64);
181                 cert.signature = abi.encodePacked(sigX, sigY);
182             }
183     
184             if (isPckCert) {
185                 // entering Extension sequence
186                 tbsPtr = der.nextSiblingOf(tbsPtr);
187     
188                 // check for the extension tag
189                 if (der[tbsPtr.ixs()] != 0xA3) {
190                     return (false, cert);
191                 }
192     
193                 tbsPtr = der.firstChildOf(tbsPtr);
194                 tbsPtr = der.firstChildOf(tbsPtr);
195     
196                 bool sgxExtnTraversedSuccessfully;
197                 uint256 pcesvn;
198                 uint256[] memory cpuSvns;
199                 bytes memory fmspcBytes;
200                 bytes memory pceidBytes;
201                 (sgxExtnTraversedSuccessfully, pcesvn, cpuSvns, fmspcBytes, pceidBytes) =
202                     _findPckTcbInfo(der, tbsPtr, tbsParentPtr);
203                 if (!sgxExtnTraversedSuccessfully) {
204                     return (false, cert);
205                 }
206                 cert.pck.sgxExtension.pcesvn = pcesvn;
207                 cert.pck.sgxExtension.sgxTcbCompSvnArr = cpuSvns;
208                 cert.pck.sgxExtension.pceid = LibString.toHexStringNoPrefix(pceidBytes);
209                 cert.pck.sgxExtension.fmspc = LibString.toHexStringNoPrefix(fmspcBytes);
210                 cert.isPck = true;
211             }
212     
213             success = true;
214         }


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/PEMCertChainLib.sol#L74:214

```solidity
File: contracts/automata-attestation/utils/SigVerifyLib.sol


24          function verifyAttStmtSignature(
25              bytes memory tbs,
26              bytes memory signature,
27              PublicKey memory publicKey,
28              Algorithm alg
29          )
30              public
31              view
32              returns (bool)
33          {
34              if (alg == Algorithm.RS256) {
35                  if (publicKey.keyType != KeyType.RSA) {
36                      return false;
37                  }
38                  return verifyRS256Signature(tbs, signature, publicKey.pubKey);
39              } else if (alg == Algorithm.ES256) {
40                  if (publicKey.keyType != KeyType.ECDSA) {
41                      return false;
42                  }
43                  return verifyES256Signature(tbs, signature, publicKey.pubKey);
44              } else if (alg == Algorithm.RS1) {
45                  if (publicKey.keyType != KeyType.RSA) {
46                      return false;
47                  }
48                  return verifyRS1Signature(tbs, signature, publicKey.pubKey);
49              } else {
50                  revert("Unsupported algorithm");
51              }
52          }


54          function verifyCertificateSignature(
55              bytes memory tbs,
56              bytes memory signature,
57              PublicKey memory publicKey,
58              CertSigAlgorithm alg
59          )
60              public
61              view
62              returns (bool)
63          {
64              if (alg == CertSigAlgorithm.Sha256WithRSAEncryption) {
65                  if (publicKey.keyType != KeyType.RSA) {
66                      return false;
67                  }
68                  return verifyRS256Signature(tbs, signature, publicKey.pubKey);
69              } else if (alg == CertSigAlgorithm.Sha1WithRSAEncryption) {
70                  if (publicKey.keyType != KeyType.RSA) {
71                      return false;
72                  }
73                  return verifyRS1Signature(tbs, signature, publicKey.pubKey);
74              } else {
75                  revert("Unsupported algorithm");
76              }
77          }


79          function verifyRS256Signature(
80              bytes memory tbs,
81              bytes memory signature,
82              bytes memory publicKey
83          )
84              public
85              view
86              returns (bool sigValid)
87          {
88              // Parse public key
89              bytes memory exponent = publicKey.substring(0, 3);
90              bytes memory modulus = publicKey.substring(3, publicKey.length - 3);
91      
92              // Verify signature
93              sigValid = RsaVerify.pkcs1Sha256Raw(tbs, signature, exponent, modulus);
94          }


96          function verifyRS1Signature(
97              bytes memory tbs,
98              bytes memory signature,
99              bytes memory publicKey
100         )
101             public
102             view
103             returns (bool sigValid)
104         {
105             // Parse public key
106             bytes memory exponent = publicKey.substring(0, 3);
107             bytes memory modulus = publicKey.substring(3, publicKey.length - 3);
108     
109             // Verify signature
110             sigValid = RsaVerify.pkcs1Sha1Raw(tbs, signature, exponent, modulus);
111         }


113         function verifyES256Signature(
114             bytes memory tbs,
115             bytes memory signature,
116             bytes memory publicKey
117         )
118             public
119             view
120             returns (bool sigValid)
121         {
122             // Parse signature
123             if (signature.length != 64) {
124                 return false;
125             }
126             uint256 r = uint256(bytes32(signature.substring(0, 32)));
127             uint256 s = uint256(bytes32(signature.substring(32, 32)));
128             // Parse public key
129             if (publicKey.length != 64) {
130                 return false;
131             }
132             uint256 gx = uint256(bytes32(publicKey.substring(0, 32)));
133             uint256 gy = uint256(bytes32(publicKey.substring(32, 32)));
134     
135             // Verify signature
136             bytes memory args = abi.encode(sha256(tbs), r, s, gx, gy);
137             (bool success, bytes memory ret) = ES256VERIFIER.staticcall(args);
138             assert(success); // never reverts, always returns 0 or 1
139     
140             return abi.decode(ret, (uint256)) == 1;
141         }


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/SigVerifyLib.sol#L113:141

```solidity
File: contracts/bridge/Bridge.sol


70          receive() external payable { }


75          function init(address _owner, address _addressManager) external initializer {
76              __Essential_init(_owner, _addressManager);
77          }


82          function suspendMessages(
83              bytes32[] calldata _msgHashes,
84              bool _suspend
85          )
86              external
87              onlyFromOwnerOrNamed("bridge_watchdog")
88          {
89              uint64 _timestamp = _suspend ? type(uint64).max : uint64(block.timestamp);
90              for (uint256 i; i < _msgHashes.length; ++i) {
91                  bytes32 msgHash = _msgHashes[i];
92                  proofReceipt[msgHash].receivedAt = _timestamp;
93                  emit MessageSuspended(msgHash, _suspend);
94              }
95          }


101         function banAddress(
102             address _addr,
103             bool _ban
104         )
105             external
106             onlyFromOwnerOrNamed("bridge_watchdog")
107             nonReentrant
108         {
109             if (addressBanned[_addr] == _ban) revert B_INVALID_STATUS();
110             addressBanned[_addr] = _ban;
111             emit AddressBanned(_addr, _ban);
112         }


115         function sendMessage(Message calldata _message)
116             external
117             payable
118             override
119             nonReentrant
120             whenNotPaused
121             returns (bytes32 msgHash_, Message memory message_)
122         {
123             // Ensure the message owner is not null.
124             if (_message.srcOwner == address(0) || _message.destOwner == address(0)) {
125                 revert B_INVALID_USER();
126             }
127     
128             // Check if the destination chain is enabled.
129             (bool destChainEnabled,) = isDestChainEnabled(_message.destChainId);
130     
131             // Verify destination chain and to address.
132             if (!destChainEnabled) revert B_INVALID_CHAINID();
133             if (_message.destChainId == block.chainid) {
134                 revert B_INVALID_CHAINID();
135             }
136     
137             // Ensure the sent value matches the expected amount.
138             uint256 expectedAmount = _message.value + _message.fee;
139             if (expectedAmount != msg.value) revert B_INVALID_VALUE();
140     
141             message_ = _message;
142     
143             // Configure message details and send signal to indicate message sending.
144             message_.id = nextMessageId++;
145             message_.from = msg.sender;
146             message_.srcChainId = uint64(block.chainid);
147     
148             msgHash_ = hashMessage(message_);
149     
150             ISignalService(resolve("signal_service", false)).sendSignal(msgHash_);
151             emit MessageSent(msgHash_, message_);
152         }


155         function recallMessage(
156             Message calldata _message,
157             bytes calldata _proof
158         )
159             external
160             nonReentrant
161             whenNotPaused
162             sameChain(_message.srcChainId)
163         {
164             bytes32 msgHash = hashMessage(_message);
165     
166             if (messageStatus[msgHash] != Status.NEW) revert B_STATUS_MISMATCH();
167     
168             uint64 receivedAt = proofReceipt[msgHash].receivedAt;
169             bool isMessageProven = receivedAt != 0;
170     
171             if (!isMessageProven) {
172                 address signalService = resolve("signal_service", false);
173     
174                 if (!ISignalService(signalService).isSignalSent(address(this), msgHash)) {
175                     revert B_MESSAGE_NOT_SENT();
176                 }
177     
178                 bytes32 failureSignal = signalForFailedMessage(msgHash);
179                 if (!_proveSignalReceived(signalService, failureSignal, _message.destChainId, _proof)) {
180                     revert B_NOT_FAILED();
181                 }
182     
183                 receivedAt = uint64(block.timestamp);
184                 proofReceipt[msgHash].receivedAt = receivedAt;
185             }
186     
187             (uint256 invocationDelay,) = getInvocationDelays();
188     
189             if (block.timestamp >= invocationDelay + receivedAt) {
190                 delete proofReceipt[msgHash];
191                 messageStatus[msgHash] = Status.RECALLED;
192     
193                 // Execute the recall logic based on the contract's support for the
194                 // IRecallableSender interface
195                 if (_message.from.supportsInterface(type(IRecallableSender).interfaceId)) {
196                     _storeContext(msgHash, address(this), _message.srcChainId);
197     
198                     // Perform recall
199                     IRecallableSender(_message.from).onMessageRecalled{ value: _message.value }(
200                         _message, msgHash
201                     );
202     
203                     // Must reset the context after the message call
204                     _resetContext();
205                 } else {
206                     _message.srcOwner.sendEther(_message.value);
207                 }
208                 emit MessageRecalled(msgHash);
209             } else if (!isMessageProven) {
210                 emit MessageReceived(msgHash, _message, true);
211             } else {
212                 revert B_INVOCATION_TOO_EARLY();
213             }
214         }


217         function processMessage(
218             Message calldata _message,
219             bytes calldata _proof
220         )
221             external
222             nonReentrant
223             whenNotPaused
224             sameChain(_message.destChainId)
225         {
226             bytes32 msgHash = hashMessage(_message);
227             if (messageStatus[msgHash] != Status.NEW) revert B_STATUS_MISMATCH();
228     
229             address signalService = resolve("signal_service", false);
230             uint64 receivedAt = proofReceipt[msgHash].receivedAt;
231             bool isMessageProven = receivedAt != 0;
232     
233             (uint256 invocationDelay, uint256 invocationExtraDelay) = getInvocationDelays();
234     
235             if (!isMessageProven) {
236                 if (!_proveSignalReceived(signalService, msgHash, _message.srcChainId, _proof)) {
237                     revert B_NOT_RECEIVED();
238                 }
239     
240                 receivedAt = uint64(block.timestamp);
241     
242                 if (invocationDelay != 0) {
243                     proofReceipt[msgHash] = ProofReceipt({
244                         receivedAt: receivedAt,
245                         preferredExecutor: _message.gasLimit == 0 ? _message.destOwner : msg.sender
246                     });
247                 }
248             }
249     
250             if (invocationDelay != 0 && msg.sender != proofReceipt[msgHash].preferredExecutor) {
251                 // If msg.sender is not the one that proved the message, then there
252                 // is an extra delay.
253                 unchecked {
254                     invocationDelay += invocationExtraDelay;
255                 }
256             }
257     
258             if (block.timestamp >= invocationDelay + receivedAt) {
259                 // If the gas limit is set to zero, only the owner can process the message.
260                 if (_message.gasLimit == 0 && msg.sender != _message.destOwner) {
261                     revert B_PERMISSION_DENIED();
262                 }
263     
264                 delete proofReceipt[msgHash];
265     
266                 uint256 refundAmount;
267     
268                 // Process message differently based on the target address
269                 if (
270                     _message.to == address(0) || _message.to == address(this)
271                         || _message.to == signalService || addressBanned[_message.to]
272                 ) {
273                     // Handle special addresses that don't require actual invocation but
274                     // mark message as DONE
275                     refundAmount = _message.value;
276                     _updateMessageStatus(msgHash, Status.DONE);
277                 } else {
278                     // Use the specified message gas limit if called by the owner, else
279                     // use remaining gas
280                     uint256 gasLimit = msg.sender == _message.destOwner ? gasleft() : _message.gasLimit;
281     
282                     if (_invokeMessageCall(_message, msgHash, gasLimit)) {
283                         _updateMessageStatus(msgHash, Status.DONE);
284                     } else {
285                         _updateMessageStatus(msgHash, Status.RETRIABLE);
286                     }
287                 }
288     
289                 // Determine the refund recipient
290                 address refundTo =
291                     _message.refundTo == address(0) ? _message.destOwner : _message.refundTo;
292     
293                 // Refund the processing fee
294                 if (msg.sender == refundTo) {
295                     refundTo.sendEther(_message.fee + refundAmount);
296                 } else {
297                     // If sender is another address, reward it and refund the rest
298                     msg.sender.sendEther(_message.fee);
299                     refundTo.sendEther(refundAmount);
300                 }
301                 emit MessageExecuted(msgHash);
302             } else if (!isMessageProven) {
303                 emit MessageReceived(msgHash, _message, false);
304             } else {
305                 revert B_INVOCATION_TOO_EARLY();
306             }
307         }


310         function retryMessage(
311             Message calldata _message,
312             bool _isLastAttempt
313         )
314             external
315             nonReentrant
316             whenNotPaused
317             sameChain(_message.destChainId)
318         {
319             // If the gasLimit is set to 0 or isLastAttempt is true, the caller must
320             // be the message.destOwner.
321             if (_message.gasLimit == 0 || _isLastAttempt) {
322                 if (msg.sender != _message.destOwner) revert B_PERMISSION_DENIED();
323             }
324     
325             bytes32 msgHash = hashMessage(_message);
326             if (messageStatus[msgHash] != Status.RETRIABLE) {
327                 revert B_NON_RETRIABLE();
328             }
329     
330             // Attempt to invoke the messageCall.
331             if (_invokeMessageCall(_message, msgHash, gasleft())) {
332                 _updateMessageStatus(msgHash, Status.DONE);
333             } else if (_isLastAttempt) {
334                 _updateMessageStatus(msgHash, Status.FAILED);
335             }
336             emit MessageRetried(msgHash);
337         }


340         function isMessageSent(Message calldata _message) public view returns (bool) {
341             if (_message.srcChainId != block.chainid) return false;
342             return ISignalService(resolve("signal_service", false)).isSignalSent({
343                 _app: address(this),
344                 _signal: hashMessage(_message)
345             });
346         }


352         function proveMessageFailed(
353             Message calldata _message,
354             bytes calldata _proof
355         )
356             public
357             view
358             returns (bool)
359         {
360             if (_message.srcChainId != block.chainid) return false;
361     
362             return _proveSignalReceived(
363                 resolve("signal_service", false),
364                 signalForFailedMessage(hashMessage(_message)),
365                 _message.destChainId,
366                 _proof
367             );
368         }


374         function proveMessageReceived(
375             Message calldata _message,
376             bytes calldata _proof
377         )
378             public
379             view
380             returns (bool)
381         {
382             if (_message.destChainId != block.chainid) return false;
383             return _proveSignalReceived(
384                 resolve("signal_service", false), hashMessage(_message), _message.srcChainId, _proof
385             );
386         }


392         function isDestChainEnabled(uint64 _chainId)
393             public
394             view
395             returns (bool enabled_, address destBridge_)
396         {
397             destBridge_ = resolve(_chainId, "bridge", true);
398             enabled_ = destBridge_ != address(0);
399         }


403         function context() public view returns (Context memory ctx_) {
404             ctx_ = _loadContext();
405             if (ctx_.msgHash == 0 || ctx_.msgHash == bytes32(PLACEHOLDER)) {
406                 revert B_INVALID_CONTEXT();
407             }
408         }


417         function getInvocationDelays()
418             public
419             view
420             virtual
421             returns (uint256 invocationDelay_, uint256 invocationExtraDelay_)
422         {
423             if (
424                 block.chainid == 1 // Ethereum mainnet
425             ) {
426                 // For Taiko mainnet
427                 // 384 seconds = 6.4 minutes = one ethereum epoch
428                 return (1 hours, 384 seconds);
429             } else if (
430                 block.chainid == 2 // Ropsten
431                     || block.chainid == 4 // Rinkeby
432                     || block.chainid == 5 // Goerli
433                     || block.chainid == 42 // Kovan
434                     || block.chainid == 17_000 // Holesky
435                     || block.chainid == 11_155_111 // Sepolia
436             ) {
437                 // For all Taiko public testnets
438                 return (30 minutes, 384 seconds);
439             } else if (block.chainid >= 32_300 && block.chainid <= 32_400) {
440                 // For all Taiko internal devnets
441                 return (5 minutes, 384 seconds);
442             } else {
443                 // This is a Taiko L2 chain where no deleys are applied.
444                 return (0, 0);
445             }
446         }


449         function hashMessage(Message memory _message) public pure returns (bytes32) {
450             return keccak256(abi.encode("TAIKO_MESSAGE", _message));
451         }


456         function signalForFailedMessage(bytes32 _msgHash) public pure returns (bytes32) {
457             return _msgHash ^ bytes32(uint256(Status.FAILED));
458         }


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/Bridge.sol#L456:458

```solidity
File: contracts/common/AddressManager.sol


30          function init(address _owner) external initializer {
31              __Essential_init(_owner);
32          }


38          function setAddress(
39              uint64 _chainId,
40              bytes32 _name,
41              address _newAddress
42          )
43              external
44              virtual
45              onlyOwner
46          {
47              address oldAddress = __addresses[_chainId][_name];
48              if (_newAddress == oldAddress) revert AM_INVALID_PARAMS();
49              __addresses[_chainId][_name] = _newAddress;
50              emit AddressSet(_chainId, _name, _newAddress, oldAddress);
51          }


54          function getAddress(uint64 _chainId, bytes32 _name) public view override returns (address) {
55              return __addresses[_chainId][_name];
56          }


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/common/AddressManager.sol#L54:56

```solidity
File: contracts/signal/SignalService.sol


48          function init(address _owner, address _addressManager) external initializer {
49              __Essential_init(_owner, _addressManager);
50          }


56          function authorize(address _addr, bool _authorize) external onlyOwner {
57              if (isAuthorized[_addr] == _authorize) revert SS_INVALID_STATE();
58              isAuthorized[_addr] = _authorize;
59              emit Authorized(_addr, _authorize);
60          }


63          function sendSignal(bytes32 _signal) external returns (bytes32) {
64              return _sendSignal(msg.sender, _signal, _signal);
65          }


68          function syncChainData(
69              uint64 _chainId,
70              bytes32 _kind,
71              uint64 _blockId,
72              bytes32 _chainData
73          )
74              external
75              returns (bytes32)
76          {
77              if (!isAuthorized[msg.sender]) revert SS_UNAUTHORIZED();
78              return _syncChainData(_chainId, _kind, _blockId, _chainData);
79          }


83          function proveSignalReceived(
84              uint64 _chainId,
85              address _app,
86              bytes32 _signal,
87              bytes calldata _proof
88          )
89              public
90              virtual
91              validSender(_app)
92              nonZeroValue(_signal)
93          {
94              HopProof[] memory hopProofs = abi.decode(_proof, (HopProof[]));
95              if (hopProofs.length == 0) revert SS_EMPTY_PROOF();
96      
97              uint64 chainId = _chainId;
98              address app = _app;
99              bytes32 signal = _signal;
100             bytes32 value = _signal;
101             address signalService = resolve(chainId, "signal_service", false);
102     
103             HopProof memory hop;
104             for (uint256 i; i < hopProofs.length; ++i) {
105                 hop = hopProofs[i];
106     
107                 bytes32 signalRoot = _verifyHopProof(chainId, app, signal, value, hop, signalService);
108                 bool isLastHop = i == hopProofs.length - 1;
109     
110                 if (isLastHop) {
111                     if (hop.chainId != block.chainid) revert SS_INVALID_LAST_HOP_CHAINID();
112                     signalService = address(this);
113                 } else {
114                     if (hop.chainId == 0 || hop.chainId == block.chainid) {
115                         revert SS_INVALID_MID_HOP_CHAINID();
116                     }
117                     signalService = resolve(hop.chainId, "signal_service", false);
118                 }
119     
120                 bool isFullProof = hop.accountProof.length > 0;
121     
122                 _cacheChainData(hop, chainId, hop.blockId, signalRoot, isFullProof, isLastHop);
123     
124                 bytes32 kind = isFullProof ? LibSignals.STATE_ROOT : LibSignals.SIGNAL_ROOT;
125                 signal = signalForChainData(chainId, kind, hop.blockId);
126                 value = hop.rootHash;
127                 chainId = hop.chainId;
128                 app = signalService;
129             }
130     
131             if (value == 0 || value != _loadSignalValue(address(this), signal)) {
132                 revert SS_SIGNAL_NOT_FOUND();
133             }
134         }


137         function isChainDataSynced(
138             uint64 _chainId,
139             bytes32 _kind,
140             uint64 _blockId,
141             bytes32 _chainData
142         )
143             public
144             view
145             nonZeroValue(_chainData)
146             returns (bool)
147         {
148             bytes32 signal = signalForChainData(_chainId, _kind, _blockId);
149             return _loadSignalValue(address(this), signal) == _chainData;
150         }


153         function isSignalSent(address _app, bytes32 _signal) public view returns (bool) {
154             return _loadSignalValue(_app, _signal) != 0;
155         }


158         function getSyncedChainData(
159             uint64 _chainId,
160             bytes32 _kind,
161             uint64 _blockId
162         )
163             public
164             view
165             returns (uint64 blockId_, bytes32 chainData_)
166         {
167             blockId_ = _blockId != 0 ? _blockId : topBlockId[_chainId][_kind];
168     
169             if (blockId_ != 0) {
170                 bytes32 signal = signalForChainData(_chainId, _kind, blockId_);
171                 chainData_ = _loadSignalValue(address(this), signal);
172                 if (chainData_ == 0) revert SS_SIGNAL_NOT_FOUND();
173             }
174         }


177         function signalForChainData(
178             uint64 _chainId,
179             bytes32 _kind,
180             uint64 _blockId
181         )
182             public
183             pure
184             returns (bytes32)
185         {
186             return keccak256(abi.encode(_chainId, _kind, _blockId));
187         }


194         function getSignalSlot(
195             uint64 _chainId,
196             address _app,
197             bytes32 _signal
198         )
199             public
200             pure
201             returns (bytes32)
202         {
203             return keccak256(abi.encodePacked("SIGNAL", _chainId, _app, _signal));
204         }


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/signal/SignalService.sol#L194:204

```solidity
File: contracts/team/TimelockTokenPool.sol


111         function init(
112             address _owner,
113             address _taikoToken,
114             address _costToken,
115             address _sharedVault
116         )
117             external
118             initializer
119         {
120             __Essential_init(_owner);
121             if (_taikoToken == address(0)) revert INVALID_PARAM();
122             taikoToken = _taikoToken;
123     
124             if (_costToken == address(0)) revert INVALID_PARAM();
125             costToken = _costToken;
126     
127             if (_sharedVault == address(0)) revert INVALID_PARAM();
128             sharedVault = _sharedVault;
129         }


135         function grant(address _recipient, Grant memory _grant) external onlyOwner {
136             if (_recipient == address(0)) revert INVALID_PARAM();
137             if (recipients[_recipient].grant.amount != 0) revert ALREADY_GRANTED();
138     
139             _validateGrant(_grant);
140     
141             totalAmountGranted += _grant.amount;
142             recipients[_recipient].grant = _grant;
143             emit Granted(_recipient, _grant);
144         }


150         function void(address _recipient) external onlyOwner {
151             Recipient storage r = recipients[_recipient];
152             uint128 amountVoided = _voidGrant(r.grant);
153     
154             if (amountVoided == 0) revert NOTHING_TO_VOID();
155     
156             totalAmountVoided += amountVoided;
157             emit Voided(_recipient, amountVoided);
158         }


161         function withdraw() external {
162             _withdraw(msg.sender, msg.sender);
163         }


168         function withdraw(address _to, bytes memory _sig) external {
169             if (_to == address(0)) revert INVALID_PARAM();
170             bytes32 hash = keccak256(abi.encodePacked("Withdraw unlocked Taiko token to: ", _to));
171             address recipient = ECDSA.recover(hash, _sig);
172             _withdraw(recipient, _to);
173         }


176         function getMyGrantSummary(address _recipient)
177             public
178             view
179             returns (
180                 uint128 amountOwned,
181                 uint128 amountUnlocked,
182                 uint128 amountWithdrawn,
183                 uint128 amountToWithdraw,
184                 uint128 costToWithdraw
185             )
186         {
187             Recipient storage r = recipients[_recipient];
188     
189             amountOwned = _getAmountOwned(r.grant);
190             amountUnlocked = _getAmountUnlocked(r.grant);
191     
192             amountWithdrawn = r.amountWithdrawn;
193             amountToWithdraw = amountUnlocked - amountWithdrawn;
194     
195             // Note: precision is maintained at the token level rather than the wei level, otherwise,
196             // `costPaid` must be a uint256.
197             uint128 _amountUnlocked = amountUnlocked / 1e18; // divide first
198             costToWithdraw = _amountUnlocked * r.grant.costPerToken - r.costPaid;
199         }


204         function getMyGrant(address _recipient) public view returns (Grant memory) {
205             return recipients[_recipient].grant;
206         }


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/TimelockTokenPool.sol#L204:206

```solidity
File: contracts/team/airdrop/ERC20Airdrop.sol


27          function init(
28              address _owner,
29              uint64 _claimStart,
30              uint64 _claimEnd,
31              bytes32 _merkleRoot,
32              address _token,
33              address _vault
34          )
35              external
36              initializer
37          {
38              __Essential_init(_owner);
39              __MerkleClaimable_init(_claimStart, _claimEnd, _merkleRoot);
40      
41              token = _token;
42              vault = _vault;
43          }


50          function claimAndDelegate(
51              address user,
52              uint256 amount,
53              bytes32[] calldata proof,
54              bytes calldata delegationData
55          )
56              external
57              nonReentrant
58          {
59              // Check if this can be claimed
60              _verifyClaim(abi.encode(user, amount), proof);
61      
62              // Transfer the tokens
63              IERC20(token).transferFrom(vault, user, amount);
64      
65              // Delegate the voting power to delegatee.
66              // Note that the signature (v,r,s) may not correspond to the user address,
67              // but since the data is provided by Taiko backend, it's not an issue even if
68              // client can change the data to call delegateBySig for another user.
69              (address delegatee, uint256 nonce, uint256 expiry, uint8 v, bytes32 r, bytes32 s) =
70                  abi.decode(delegationData, (address, uint256, uint256, uint8, bytes32, bytes32));
71              IVotes(token).delegateBySig(delegatee, nonce, expiry, v, r, s);
72          }


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/airdrop/ERC20Airdrop.sol#L50:72

```solidity
File: contracts/team/airdrop/ERC20Airdrop2.sol


54          function init(
55              address _owner,
56              uint64 _claimStart,
57              uint64 _claimEnd,
58              bytes32 _merkleRoot,
59              address _token,
60              address _vault,
61              uint64 _withdrawalWindow
62          )
63              external
64              initializer
65          {
66              __Essential_init(_owner);
67              __MerkleClaimable_init(_claimStart, _claimEnd, _merkleRoot);
68      
69              token = _token;
70              vault = _vault;
71              withdrawalWindow = _withdrawalWindow;
72          }


78          function claim(address user, uint256 amount, bytes32[] calldata proof) external nonReentrant {
79              // Check if this can be claimed
80              _verifyClaim(abi.encode(user, amount), proof);
81      
82              // Assign the tokens
83              claimedAmount[user] += amount;
84          }


88          function withdraw(address user) external ongoingWithdrawals {
89              (, uint256 amount) = getBalance(user);
90              withdrawnAmount[user] += amount;
91              IERC20(token).transferFrom(vault, user, amount);
92      
93              emit Withdrawn(user, amount);
94          }


104         function getBalance(address user)
105             public
106             view
107             returns (uint256 balance, uint256 withdrawableAmount)
108         {
109             balance = claimedAmount[user];
110             // If balance is 0 then there is no balance and withdrawable amount
111             if (balance == 0) return (0, 0);
112             // Balance might be positive before end of claiming (claimEnd - if claimed already) but
113             // withdrawable is 0.
114             if (block.timestamp < claimEnd) return (balance, 0);
115     
116             // Hard cap timestamp - so range cannot go over - to get more allocation over time.
117             uint256 timeBasedAllowance = balance
118                 * (block.timestamp.min(claimEnd + withdrawalWindow) - claimEnd) / withdrawalWindow;
119     
120             withdrawableAmount = timeBasedAllowance - withdrawnAmount[user];
121         }


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/airdrop/ERC20Airdrop2.sol#L104:121

```solidity
File: contracts/team/airdrop/ERC721Airdrop.sol


25          function init(
26              address _owner,
27              uint64 _claimStart,
28              uint64 _claimEnd,
29              bytes32 _merkleRoot,
30              address _token,
31              address _vault
32          )
33              external
34              initializer
35          {
36              __Essential_init(_owner);
37              __MerkleClaimable_init(_claimStart, _claimEnd, _merkleRoot);
38      
39              token = _token;
40              vault = _vault;
41          }


47          function claim(
48              address user,
49              uint256[] calldata tokenIds,
50              bytes32[] calldata proof
51          )
52              external
53              nonReentrant
54          {
55              // Check if this can be claimed
56              _verifyClaim(abi.encode(user, tokenIds), proof);
57      
58              // Transfer the tokens
59              for (uint256 i; i < tokenIds.length; ++i) {
60                  IERC721(token).safeTransferFrom(vault, user, tokenIds[i]);
61              }
62          }


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/airdrop/ERC721Airdrop.sol#L47:62

```solidity
File: contracts/tokenvault/BridgedERC1155.sol


38          function init(
39              address _owner,
40              address _addressManager,
41              address _srcToken,
42              uint256 _srcChainId,
43              string memory _symbol,
44              string memory _name
45          )
46              external
47              initializer
48          {
49              // Check if provided parameters are valid.
50              // The symbol and the name can be empty for ERC1155 tokens so we use some placeholder data
51              // for them instead.
52              LibBridgedToken.validateInputs(_srcToken, _srcChainId, "foo", "foo");
53              __Essential_init(_owner, _addressManager);
54              __ERC1155_init(LibBridgedToken.buildURI(_srcToken, _srcChainId));
55      
56              srcToken = _srcToken;
57              srcChainId = _srcChainId;
58              __symbol = _symbol;
59              __name = _name;
60          }


66          function mint(
67              address _to,
68              uint256 _tokenId,
69              uint256 _amount
70          )
71              public
72              nonReentrant
73              whenNotPaused
74              onlyFromNamed("erc1155_vault")
75          {
76              _mint(_to, _tokenId, _amount, "");
77          }


83          function mintBatch(
84              address _to,
85              uint256[] memory _tokenIds,
86              uint256[] memory _amounts
87          )
88              public
89              nonReentrant
90              whenNotPaused
91              onlyFromNamed("erc1155_vault")
92          {
93              _mintBatch(_to, _tokenIds, _amounts, "");
94          }


100         function burn(
101             address _account,
102             uint256 _tokenId,
103             uint256 _amount
104         )
105             public
106             nonReentrant
107             whenNotPaused
108             onlyFromNamed("erc1155_vault")
109         {
110             _burn(_account, _tokenId, _amount);
111         }


115         function name() public view returns (string memory) {
116             return LibBridgedToken.buildName(__name, srcChainId);
117         }


121         function symbol() public view returns (string memory) {
122             return LibBridgedToken.buildSymbol(__symbol);
123         }


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC1155.sol#L121:123

```solidity
File: contracts/tokenvault/BridgedERC20.sol


52          function init(
53              address _owner,
54              address _addressManager,
55              address _srcToken,
56              uint256 _srcChainId,
57              uint8 _decimals,
58              string memory _symbol,
59              string memory _name
60          )
61              external
62              initializer
63          {
64              // Check if provided parameters are valid
65              LibBridgedToken.validateInputs(_srcToken, _srcChainId, _symbol, _name);
66              __Essential_init(_owner, _addressManager);
67              __ERC20_init(_name, _symbol);
68              __ERC20Snapshot_init();
69              __ERC20Votes_init();
70              __ERC20Permit_init(_name);
71      
72              // Set contract properties
73              srcToken = _srcToken;
74              srcChainId = _srcChainId;
75              __srcDecimals = _decimals;
76          }


80          function setSnapshoter(address _snapshooter) external onlyOwner {
81              snapshooter = _snapshooter;
82          }


85          function snapshot() external onlyOwnerOrSnapshooter {
86              _snapshot();
87          }


91          function name()
92              public
93              view
94              override(ERC20Upgradeable, IERC20MetadataUpgradeable)
95              returns (string memory)
96          {
97              return LibBridgedToken.buildName(super.name(), srcChainId);
98          }


102         function symbol()
103             public
104             view
105             override(ERC20Upgradeable, IERC20MetadataUpgradeable)
106             returns (string memory)
107         {
108             return LibBridgedToken.buildSymbol(super.symbol());
109         }


113         function decimals()
114             public
115             view
116             override(ERC20Upgradeable, IERC20MetadataUpgradeable)
117             returns (uint8)
118         {
119             return __srcDecimals;
120         }


125         function canonical() public view returns (address, uint256) {
126             return (srcToken, srcChainId);
127         }


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC20.sol#L125:127

```solidity
File: contracts/tokenvault/BridgedERC721.sol


31          function init(
32              address _owner,
33              address _addressManager,
34              address _srcToken,
35              uint256 _srcChainId,
36              string memory _symbol,
37              string memory _name
38          )
39              external
40              initializer
41          {
42              // Check if provided parameters are valid
43              LibBridgedToken.validateInputs(_srcToken, _srcChainId, _symbol, _name);
44              __Essential_init(_owner, _addressManager);
45              __ERC721_init(_name, _symbol);
46      
47              srcToken = _srcToken;
48              srcChainId = _srcChainId;
49          }


54          function mint(
55              address _account,
56              uint256 _tokenId
57          )
58              public
59              nonReentrant
60              whenNotPaused
61              onlyFromNamed("erc721_vault")
62          {
63              _safeMint(_account, _tokenId);
64          }


69          function burn(
70              address _account,
71              uint256 _tokenId
72          )
73              public
74              nonReentrant
75              whenNotPaused
76              onlyFromNamed("erc721_vault")
77          {
78              // Check if the caller is the owner of the token.
79              if (ownerOf(_tokenId) != _account) {
80                  revert BTOKEN_INVALID_BURN();
81              }
82              _burn(_tokenId);
83          }


87          function name() public view override(ERC721Upgradeable) returns (string memory) {
88              return LibBridgedToken.buildName(super.name(), srcChainId);
89          }


93          function symbol() public view override(ERC721Upgradeable) returns (string memory) {
94              return LibBridgedToken.buildSymbol(super.symbol());
95          }


100         function source() public view returns (address, uint256) {
101             return (srcToken, srcChainId);
102         }


107         function tokenURI(uint256 _tokenId) public view virtual override returns (string memory) {
108             return string(
109                 abi.encodePacked(
110                     LibBridgedToken.buildURI(srcToken, srcChainId), Strings.toString(_tokenId)
111                 )
112             );
113         }


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC721.sol#L107:113

```solidity
File: contracts/tokenvault/ERC1155Vault.sol


39          function sendToken(BridgeTransferOp memory _op)
40              external
41              payable
42              nonReentrant
43              whenNotPaused
44              withValidOperation(_op)
45              returns (IBridge.Message memory message_)
46          {
47              for (uint256 i; i < _op.amounts.length; ++i) {
48                  if (_op.amounts[i] == 0) revert VAULT_INVALID_AMOUNT();
49              }
50              // Check token interface support
51              if (!_op.token.supportsInterface(ERC1155_INTERFACE_ID)) {
52                  revert VAULT_INTERFACE_NOT_SUPPORTED();
53              }
54      
55              (bytes memory data, CanonicalNFT memory ctoken) = _handleMessage(msg.sender, _op);
56      
57              // Create a message to send to the destination chain
58              IBridge.Message memory message = IBridge.Message({
59                  id: 0, // will receive a new value
60                  from: address(0), // will receive a new value
61                  srcChainId: 0, // will receive a new value
62                  destChainId: _op.destChainId,
63                  srcOwner: msg.sender,
64                  destOwner: _op.destOwner != address(0) ? _op.destOwner : msg.sender,
65                  to: resolve(_op.destChainId, name(), false),
66                  refundTo: _op.refundTo,
67                  value: msg.value - _op.fee,
68                  fee: _op.fee,
69                  gasLimit: _op.gasLimit,
70                  data: data,
71                  memo: _op.memo
72              });
73      
74              // Send the message and obtain the message hash
75              bytes32 msgHash;
76              (msgHash, message_) =
77                  IBridge(resolve("bridge", false)).sendMessage{ value: msg.value }(message);
78      
79              // Emit TokenSent event
80              emit TokenSent({
81                  msgHash: msgHash,
82                  from: message_.srcOwner,
83                  to: _op.to,
84                  destChainId: message_.destChainId,
85                  ctoken: ctoken.addr,
86                  token: _op.token,
87                  tokenIds: _op.tokenIds,
88                  amounts: _op.amounts
89              });
90          }


93          function onMessageInvocation(bytes calldata data) external payable nonReentrant whenNotPaused {
94              (
95                  CanonicalNFT memory ctoken,
96                  address from,
97                  address to,
98                  uint256[] memory tokenIds,
99                  uint256[] memory amounts
100             ) = abi.decode(data, (CanonicalNFT, address, address, uint256[], uint256[]));
101     
102             // Check context validity
103             // `onlyFromBridge` checked in checkProcessMessageContext
104             IBridge.Context memory ctx = checkProcessMessageContext();
105     
106             // Don't allow sending to disallowed addresses.
107             // Don't send the tokens back to `from` because `from` is on the source chain.
108             if (to == address(0) || to == address(this)) revert VAULT_INVALID_TO();
109     
110             // Transfer the ETH and the tokens to the `to` address
111             address token = _transferTokens(ctoken, to, tokenIds, amounts);
112             to.sendEther(msg.value);
113     
114             emit TokenReceived({
115                 msgHash: ctx.msgHash,
116                 from: from,
117                 to: to,
118                 srcChainId: ctx.srcChainId,
119                 ctoken: ctoken.addr,
120                 token: token,
121                 tokenIds: tokenIds,
122                 amounts: amounts
123             });
124         }


127         function onMessageRecalled(
128             IBridge.Message calldata message,
129             bytes32 msgHash
130         )
131             external
132             payable
133             override
134             nonReentrant
135             whenNotPaused
136         {
137             // `onlyFromBridge` checked in checkRecallMessageContext
138             checkRecallMessageContext();
139     
140             (bytes memory data) = abi.decode(message.data[4:], (bytes));
141             (CanonicalNFT memory ctoken,,, uint256[] memory tokenIds, uint256[] memory amounts) =
142                 abi.decode(data, (CanonicalNFT, address, address, uint256[], uint256[]));
143     
144             // Transfer the ETH and tokens back to the owner
145             address token = _transferTokens(ctoken, message.srcOwner, tokenIds, amounts);
146             message.srcOwner.sendEther(message.value);
147     
148             // Emit TokenReleased event
149             emit TokenReleased({
150                 msgHash: msgHash,
151                 from: message.srcOwner,
152                 ctoken: ctoken.addr,
153                 token: token,
154                 tokenIds: tokenIds,
155                 amounts: amounts
156             });
157         }


160         function onERC1155BatchReceived(
161             address,
162             address,
163             uint256[] calldata,
164             uint256[] calldata,
165             bytes calldata
166         )
167             external
168             pure
169             returns (bytes4)
170         {
171             return IERC1155ReceiverUpgradeable.onERC1155BatchReceived.selector;
172         }


175         function onERC1155Received(
176             address,
177             address,
178             uint256,
179             uint256,
180             bytes calldata
181         )
182             external
183             pure
184             returns (bytes4)
185         {
186             return IERC1155ReceiverUpgradeable.onERC1155Received.selector;
187         }


192         function supportsInterface(bytes4 interfaceId)
193             public
194             view
195             virtual
196             override(BaseVault, ERC1155ReceiverUpgradeable)
197             returns (bool)
198         {
199             return interfaceId == type(ERC1155ReceiverUpgradeable).interfaceId
200                 || BaseVault.supportsInterface(interfaceId);
201         }


204         function name() public pure override returns (bytes32) {
205             return "erc1155_vault";
206         }


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC1155Vault.sol#L204:206

```solidity
File: contracts/tokenvault/ERC20Vault.sol


148         function changeBridgedToken(
149             CanonicalERC20 calldata _ctoken,
150             address _btokenNew
151         )
152             external
153             nonReentrant
154             whenNotPaused
155             onlyOwner
156             returns (address btokenOld_)
157         {
158             if (_btokenNew == address(0) || bridgedToCanonical[_btokenNew].addr != address(0)) {
159                 revert VAULT_INVALID_NEW_BTOKEN();
160             }
161     
162             if (btokenBlacklist[_btokenNew]) revert VAULT_BTOKEN_BLACKLISTED();
163     
164             if (IBridgedERC20(_btokenNew).owner() != owner()) {
165                 revert VAULT_NOT_SAME_OWNER();
166             }
167     
168             btokenOld_ = canonicalToBridged[_ctoken.chainId][_ctoken.addr];
169     
170             if (btokenOld_ != address(0)) {
171                 CanonicalERC20 memory ctoken = bridgedToCanonical[btokenOld_];
172     
173                 // The ctoken must match the saved one.
174                 if (
175                     ctoken.decimals != _ctoken.decimals
176                         || keccak256(bytes(ctoken.symbol)) != keccak256(bytes(_ctoken.symbol))
177                         || keccak256(bytes(ctoken.name)) != keccak256(bytes(_ctoken.name))
178                 ) revert VAULT_CTOKEN_MISMATCH();
179     
180                 delete bridgedToCanonical[_btokenNew];
181                 btokenBlacklist[btokenOld_] = true;
182     
183                 // Start the migration
184                 IBridgedERC20(btokenOld_).changeMigrationStatus(_btokenNew, false);
185                 IBridgedERC20(_btokenNew).changeMigrationStatus(btokenOld_, true);
186             }
187     
188             bridgedToCanonical[_btokenNew] = _ctoken;
189             canonicalToBridged[_ctoken.chainId][_ctoken.addr] = _btokenNew;
190     
191             emit BridgedTokenChanged({
192                 srcChainId: _ctoken.chainId,
193                 ctoken: _ctoken.addr,
194                 btokenOld: btokenOld_,
195                 btokenNew: _btokenNew,
196                 ctokenSymbol: _ctoken.symbol,
197                 ctokenName: _ctoken.name,
198                 ctokenDecimal: _ctoken.decimals
199             });
200         }


207         function sendToken(BridgeTransferOp calldata _op)
208             external
209             payable
210             nonReentrant
211             whenNotPaused
212             returns (IBridge.Message memory message_)
213         {
214             if (_op.amount == 0) revert VAULT_INVALID_AMOUNT();
215             if (_op.token == address(0)) revert VAULT_INVALID_TOKEN();
216             if (btokenBlacklist[_op.token]) revert VAULT_BTOKEN_BLACKLISTED();
217     
218             (bytes memory data, CanonicalERC20 memory ctoken, uint256 balanceChange) =
219                 _handleMessage(msg.sender, _op.token, _op.to, _op.amount);
220     
221             IBridge.Message memory message = IBridge.Message({
222                 id: 0, // will receive a new value
223                 from: address(0), // will receive a new value
224                 srcChainId: 0, // will receive a new value
225                 destChainId: _op.destChainId,
226                 srcOwner: msg.sender,
227                 destOwner: _op.destOwner != address(0) ? _op.destOwner : msg.sender,
228                 to: resolve(_op.destChainId, name(), false),
229                 refundTo: _op.refundTo,
230                 value: msg.value - _op.fee,
231                 fee: _op.fee,
232                 gasLimit: _op.gasLimit,
233                 data: data,
234                 memo: _op.memo
235             });
236     
237             bytes32 msgHash;
238             (msgHash, message_) =
239                 IBridge(resolve("bridge", false)).sendMessage{ value: msg.value }(message);
240     
241             emit TokenSent({
242                 msgHash: msgHash,
243                 from: message_.srcOwner,
244                 to: _op.to,
245                 destChainId: _op.destChainId,
246                 ctoken: ctoken.addr,
247                 token: _op.token,
248                 amount: balanceChange
249             });
250         }


253         function onMessageInvocation(bytes calldata _data)
254             external
255             payable
256             nonReentrant
257             whenNotPaused
258         {
259             (CanonicalERC20 memory ctoken, address from, address to, uint256 amount) =
260                 abi.decode(_data, (CanonicalERC20, address, address, uint256));
261     
262             // `onlyFromBridge` checked in checkProcessMessageContext
263             IBridge.Context memory ctx = checkProcessMessageContext();
264     
265             // Don't allow sending to disallowed addresses.
266             // Don't send the tokens back to `from` because `from` is on the source chain.
267             if (to == address(0) || to == address(this)) revert VAULT_INVALID_TO();
268     
269             // Transfer the ETH and the tokens to the `to` address
270             address token = _transferTokens(ctoken, to, amount);
271             to.sendEther(msg.value);
272     
273             emit TokenReceived({
274                 msgHash: ctx.msgHash,
275                 from: from,
276                 to: to,
277                 srcChainId: ctx.srcChainId,
278                 ctoken: ctoken.addr,
279                 token: token,
280                 amount: amount
281             });
282         }


285         function onMessageRecalled(
286             IBridge.Message calldata _message,
287             bytes32 _msgHash
288         )
289             external
290             payable
291             override
292             nonReentrant
293             whenNotPaused
294         {
295             // `onlyFromBridge` checked in checkRecallMessageContext
296             checkRecallMessageContext();
297     
298             (bytes memory data) = abi.decode(_message.data[4:], (bytes));
299             (CanonicalERC20 memory ctoken,,, uint256 amount) =
300                 abi.decode(data, (CanonicalERC20, address, address, uint256));
301     
302             // Transfer the ETH and tokens back to the owner
303             address token = _transferTokens(ctoken, _message.srcOwner, amount);
304             _message.srcOwner.sendEther(_message.value);
305     
306             emit TokenReleased({
307                 msgHash: _msgHash,
308                 from: _message.srcOwner,
309                 ctoken: ctoken.addr,
310                 token: token,
311                 amount: amount
312             });
313         }


316         function name() public pure override returns (bytes32) {
317             return "erc20_vault";
318         }


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC20Vault.sol#L316:318

```solidity
File: contracts/tokenvault/ERC721Vault.sol


26          function sendToken(BridgeTransferOp memory _op)
27              external
28              payable
29              nonReentrant
30              whenNotPaused
31              withValidOperation(_op)
32              returns (IBridge.Message memory message_)
33          {
34              for (uint256 i; i < _op.tokenIds.length; ++i) {
35                  if (_op.amounts[i] != 0) revert VAULT_INVALID_AMOUNT();
36              }
37      
38              if (!_op.token.supportsInterface(ERC721_INTERFACE_ID)) {
39                  revert VAULT_INTERFACE_NOT_SUPPORTED();
40              }
41      
42              (bytes memory data, CanonicalNFT memory ctoken) = _handleMessage(msg.sender, _op);
43      
44              IBridge.Message memory message = IBridge.Message({
45                  id: 0, // will receive a new value
46                  from: address(0), // will receive a new value
47                  srcChainId: 0, // will receive a new value
48                  destChainId: _op.destChainId,
49                  srcOwner: msg.sender,
50                  destOwner: _op.destOwner != address(0) ? _op.destOwner : msg.sender,
51                  to: resolve(_op.destChainId, name(), false),
52                  refundTo: _op.refundTo,
53                  value: msg.value - _op.fee,
54                  fee: _op.fee,
55                  gasLimit: _op.gasLimit,
56                  data: data,
57                  memo: _op.memo
58              });
59      
60              bytes32 msgHash;
61              (msgHash, message_) =
62                  IBridge(resolve("bridge", false)).sendMessage{ value: msg.value }(message);
63      
64              emit TokenSent({
65                  msgHash: msgHash,
66                  from: message_.srcOwner,
67                  to: _op.to,
68                  destChainId: message_.destChainId,
69                  ctoken: ctoken.addr,
70                  token: _op.token,
71                  tokenIds: _op.tokenIds,
72                  amounts: _op.amounts
73              });
74          }


77          function onMessageInvocation(bytes calldata _data)
78              external
79              payable
80              nonReentrant
81              whenNotPaused
82          {
83              (CanonicalNFT memory ctoken, address from, address to, uint256[] memory tokenIds) =
84                  abi.decode(_data, (CanonicalNFT, address, address, uint256[]));
85      
86              // `onlyFromBridge` checked in checkProcessMessageContext
87              IBridge.Context memory ctx = checkProcessMessageContext();
88      
89              // Don't allow sending to disallowed addresses.
90              // Don't send the tokens back to `from` because `from` is on the source chain.
91              if (to == address(0) || to == address(this)) revert VAULT_INVALID_TO();
92      
93              // Transfer the ETH and the tokens to the `to` address
94              address token = _transferTokens(ctoken, to, tokenIds);
95              to.sendEther(msg.value);
96      
97              emit TokenReceived({
98                  msgHash: ctx.msgHash,
99                  from: from,
100                 to: to,
101                 srcChainId: ctx.srcChainId,
102                 ctoken: ctoken.addr,
103                 token: token,
104                 tokenIds: tokenIds,
105                 amounts: new uint256[](tokenIds.length)
106             });
107         }


110         function onMessageRecalled(
111             IBridge.Message calldata _message,
112             bytes32 _msgHash
113         )
114             external
115             payable
116             override
117             nonReentrant
118             whenNotPaused
119         {
120             // `onlyFromBridge` checked in checkRecallMessageContext
121             checkRecallMessageContext();
122     
123             (bytes memory data) = abi.decode(_message.data[4:], (bytes));
124             (CanonicalNFT memory ctoken,,, uint256[] memory tokenIds) =
125                 abi.decode(data, (CanonicalNFT, address, address, uint256[]));
126     
127             // Transfer the ETH and tokens back to the owner
128             address token = _transferTokens(ctoken, _message.srcOwner, tokenIds);
129             _message.srcOwner.sendEther(_message.value);
130     
131             emit TokenReleased({
132                 msgHash: _msgHash,
133                 from: _message.srcOwner,
134                 ctoken: ctoken.addr,
135                 token: token,
136                 tokenIds: tokenIds,
137                 amounts: new uint256[](tokenIds.length)
138             });
139         }


142         function onERC721Received(
143             address,
144             address,
145             uint256,
146             bytes calldata
147         )
148             external
149             pure
150             returns (bytes4)
151         {
152             return IERC721Receiver.onERC721Received.selector;
153         }


156         function name() public pure override returns (bytes32) {
157             return "erc721_vault";
158         }


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC721Vault.sol#L156:158

```solidity
File: contracts/tokenvault/adapters/USDCAdapter.sol


38          function init(address _owner, address _addressManager, IUSDC _usdc) external initializer {
39              __Essential_init(_owner, _addressManager);
40              usdc = _usdc;
41          }


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/adapters/USDCAdapter.sol#L38:41

```solidity
File: contracts/verifiers/GuardianVerifier.sol


18          function init(address _owner, address _addressManager) external initializer {
19              __Essential_init(_owner, _addressManager);
20          }


23          function verifyProof(
24              Context calldata _ctx,
25              TaikoData.Transition calldata,
26              TaikoData.TierProof calldata
27          )
28              external
29              view
30          {
31              if (_ctx.msgSender != resolve("guardian_prover", false)) {
32                  revert PERMISSION_DENIED();
33              }
34          }


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/verifiers/GuardianVerifier.sol#L23:34

```solidity
File: contracts/verifiers/SgxVerifier.sol


83          function init(address _owner, address _addressManager) external initializer {
84              __Essential_init(_owner, _addressManager);
85          }


90          function addInstances(address[] calldata _instances)
91              external
92              onlyOwner
93              returns (uint256[] memory)
94          {
95              return _addInstances(_instances, true);
96          }


100         function deleteInstances(uint256[] calldata _ids)
101             external
102             onlyFromOwnerOrNamed("rollup_watchdog")
103         {
104             for (uint256 i; i < _ids.length; ++i) {
105                 uint256 idx = _ids[i];
106     
107                 if (instances[idx].addr == address(0)) revert SGX_INVALID_INSTANCE();
108     
109                 emit InstanceDeleted(idx, instances[idx].addr);
110     
111                 delete instances[idx];
112             }
113         }


118         function registerInstance(V3Struct.ParsedV3QuoteStruct calldata _attestation)
119             external
120             returns (uint256)
121         {
122             address automataDcapAttestation = (resolve("automata_dcap_attestation", true));
123     
124             if (automataDcapAttestation == address(0)) {
125                 revert SGX_RA_NOT_SUPPORTED();
126             }
127     
128             (bool verified,) = IAttestation(automataDcapAttestation).verifyParsedQuote(_attestation);
129     
130             if (!verified) revert SGX_INVALID_ATTESTATION();
131     
132             address[] memory _address = new address[](1);
133             _address[0] = address(bytes20(_attestation.localEnclaveReport.reportData));
134     
135             return _addInstances(_address, false)[0];
136         }


139         function verifyProof(
140             Context calldata _ctx,
141             TaikoData.Transition calldata _tran,
142             TaikoData.TierProof calldata _proof
143         )
144             external
145             onlyFromNamed("taiko")
146         {
147             // Do not run proof verification to contest an existing proof
148             if (_ctx.isContesting) return;
149     
150             // Size is: 89 bytes
151             // 4 bytes + 20 bytes + 65 bytes (signature) = 89
152             if (_proof.data.length != 89) revert SGX_INVALID_PROOF();
153     
154             uint32 id = uint32(bytes4(Bytes.slice(_proof.data, 0, 4)));
155             address newInstance = address(bytes20(Bytes.slice(_proof.data, 4, 20)));
156             bytes memory signature = Bytes.slice(_proof.data, 24);
157     
158             address oldInstance =
159                 ECDSA.recover(getSignedHash(_tran, newInstance, _ctx.prover, _ctx.metaHash), signature);
160     
161             if (!_isInstanceValid(id, oldInstance)) revert SGX_INVALID_INSTANCE();
162             _replaceInstance(id, oldInstance, newInstance);
163         }


171         function getSignedHash(
172             TaikoData.Transition memory _tran,
173             address _newInstance,
174             address _prover,
175             bytes32 _metaHash
176         )
177             public
178             view
179             returns (bytes32)
180         {
181             address taikoL1 = resolve("taiko", false);
182             return keccak256(
183                 abi.encode(
184                     "VERIFY_PROOF",
185                     ITaikoL1(taikoL1).getConfig().chainId,
186                     address(this),
187                     _tran,
188                     _newInstance,
189                     _prover,
190                     _metaHash
191                 )
192             );
193         }


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/verifiers/SgxVerifier.sol#L171:193

</details>

## NC056 - Consider adding formal verification proofs:

Consider using formal verification to mathematically prove that your code does what is intended, and does not have any edge cases with unexpected behavior. The solidity compiler itself has this functionality [built in based off of SMTChecker](https://docs.soliditylang.org/en/latest/smtchecker.html#smtchecker-and-formal-verification).


```solidity
File: Various Files


None

```

## NC057 - Assembly code blocks should be thoroughly commented:

In Solidity, assembly blocks are often harder to read and understand due to their low-level nature. Detailed comments can make the code's purpose and functionality clear, aiding in maintenance, debugging, and reviews. Moreover, comments can be crucial for auditors and other developers to understand the contract's security implications, reducing the risk of oversights and vulnerabilities.


<details>
<summary>Click to show 65 findings</summary>

```solidity
File: contracts/L2/TaikoL2.sol


242             assembly {
243                 publicInputHashOld := keccak256(inputs, 8192 /*mul(256, 32)*/ )
244             }


247             assembly {
248                 publicInputHashNew := keccak256(inputs, 8192 /*mul(256, 32)*/ )
249             }


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/TaikoL2.sol#L247:249

```solidity
File: contracts/automata-attestation/utils/BytesUtils.sol


26              assembly {
27                  ret := keccak256(add(add(self, 32), offset), len)
28              }


76              assembly {
77                  selfptr := add(self, add(offset, 32))
78                  otherptr := add(other, add(otheroffset, 32))
79              }


83                  assembly {
84                      a := mload(selfptr)
85                      b := mload(otherptr)
86                  }


200             assembly {
201                 ret := and(mload(add(add(self, 2), idx)), 0xFFFF)
202             }


213             assembly {
214                 ret := and(mload(add(add(self, 4), idx)), 0xFFFFFFFF)
215             }


226             assembly {
227                 ret := mload(add(add(self, 32), idx))
228             }


239             assembly {
240                 ret :=
241                     and(
242                         mload(add(add(self, 32), idx)),
243                         0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF000000000000000000000000
244                     )
245             }


266             assembly {
267                 let mask := not(sub(exp(256, sub(32, len)), 1))
268                 ret := and(mload(add(add(self, 32), idx)), mask)
269             }


273             assembly {
274                 mcopy(dest, src, len)
275             }


299             assembly {
300                 dest := add(ret, 32)
301                 src := add(add(self, 32), offset)
302             }


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/BytesUtils.sol#L299:302

```solidity
File: contracts/automata-attestation/utils/RsaVerify.sol


99              assembly {
100                 pop(
101                     staticcall(
102                         sub(gas(), 2000),
103                         5,
104                         add(input, 0x20),
105                         inputlen,
106                         add(decipher, 0x20),
107                         decipherlen
108                     )
109                 )
110             }


247             assembly {
248                 pop(
249                     staticcall(
250                         sub(gas(), 2000),
251                         5,
252                         add(input, 0x20),
253                         inputlen,
254                         add(decipher, 0x20),
255                         decipherlen
256                     )
257                 )
258             }


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/RsaVerify.sol#L247:258

```solidity
File: contracts/automata-attestation/utils/SHA1.sol


23                  case 1 { totallen := add(totallen, 64) }


27                  function readword(ptr, off, count) -> result {
28                      result := 0
29                      if lt(off, count) {
30                          result := mload(add(ptr, off))
31                          count := sub(count, off)
32                          if lt(count, 32) {
33                              let mask := not(sub(exp(256, sub(32, count)), 1))
34                              result := and(result, mask)
35                          }
36                      }
37                  }


29                      if lt(off, count) {
30                          result := mload(add(ptr, off))
31                          count := sub(count, off)
32                          if lt(count, 32) {
33                              let mask := not(sub(exp(256, sub(32, count)), 1))
34                              result := and(result, mask)
35                          }
36                      }


32                          if lt(count, 32) {
33                              let mask := not(sub(exp(256, sub(32, count)), 1))
34                              result := and(result, mask)
35                          }


39                  for { let i := 0 } lt(i, totallen) { i := add(i, 64) } {


39                  for { let i := 0 } lt(i, totallen) { i := add(i, 64) } {


39                  for { let i := 0 } lt(i, totallen) { i := add(i, 64) } {
40                      mstore(scratch, readword(data, i, len))
41                      mstore(add(scratch, 32), readword(data, add(i, 32), len))
42      
43                      // If we loaded the last byte, store the terminator byte
44                      switch lt(sub(len, i), 64)
45                      case 1 { mstore8(add(scratch, sub(len, i)), 0x80) }
46      
47                      // If this is the last block, store the length
48                      switch eq(i, sub(totallen, 64))
49                      case 1 { mstore(add(scratch, 32), or(mload(add(scratch, 32)), mul(len, 8))) }
50      
51                      // Expand the 16 32-bit words into 80
52                      for { let j := 64 } lt(j, 128) { j := add(j, 12) } {
53                          let temp :=
54                              xor(
55                                  xor(mload(add(scratch, sub(j, 12))), mload(add(scratch, sub(j, 32)))),
56                                  xor(mload(add(scratch, sub(j, 56))), mload(add(scratch, sub(j, 64))))
57                              )
58                          temp :=
59                              or(
60                                  and(
61                                      mul(temp, 2),
62                                      0xFFFFFFFEFFFFFFFEFFFFFFFEFFFFFFFEFFFFFFFEFFFFFFFEFFFFFFFEFFFFFFFE
63                                  ),
64                                  and(
65                                      div(temp, 0x80000000),
66                                      0x0000000100000001000000010000000100000001000000010000000100000001
67                                  )
68                              )
69                          mstore(add(scratch, j), temp)
70                      }
71                      for { let j := 128 } lt(j, 320) { j := add(j, 24) } {
72                          let temp :=
73                              xor(
74                                  xor(mload(add(scratch, sub(j, 24))), mload(add(scratch, sub(j, 64)))),
75                                  xor(mload(add(scratch, sub(j, 112))), mload(add(scratch, sub(j, 128))))
76                              )
77                          temp :=
78                              or(
79                                  and(
80                                      mul(temp, 4),
81                                      0xFFFFFFFCFFFFFFFCFFFFFFFCFFFFFFFCFFFFFFFCFFFFFFFCFFFFFFFCFFFFFFFC
82                                  ),
83                                  and(
84                                      div(temp, 0x40000000),
85                                      0x0000000300000003000000030000000300000003000000030000000300000003
86                                  )
87                              )
88                          mstore(add(scratch, j), temp)
89                      }
90      
91                      let x := h
92                      let f := 0
93                      let k := 0
94                      for { let j := 0 } lt(j, 80) { j := add(j, 1) } {
95                          switch div(j, 20)
96                          case 0 {
97                              // f = d xor (b and (c xor d))
98                              f := xor(div(x, 0x100000000000000000000), div(x, 0x10000000000))
99                              f := and(div(x, 0x1000000000000000000000000000000), f)
100                             f := xor(div(x, 0x10000000000), f)
101                             k := 0x5A827999
102                         }
103                         case 1 {
104                             // f = b xor c xor d
105                             f :=
106                                 xor(
107                                     div(x, 0x1000000000000000000000000000000),
108                                     div(x, 0x100000000000000000000)
109                                 )
110                             f := xor(div(x, 0x10000000000), f)
111                             k := 0x6ED9EBA1
112                         }
113                         case 2 {
114                             // f = (b and c) or (d and (b or c))
115                             f :=
116                                 or(
117                                     div(x, 0x1000000000000000000000000000000),
118                                     div(x, 0x100000000000000000000)
119                                 )
120                             f := and(div(x, 0x10000000000), f)
121                             f :=
122                                 or(
123                                     and(
124                                         div(x, 0x1000000000000000000000000000000),
125                                         div(x, 0x100000000000000000000)
126                                     ),
127                                     f
128                                 )
129                             k := 0x8F1BBCDC
130                         }
131                         case 3 {
132                             // f = b xor c xor d
133                             f :=
134                                 xor(
135                                     div(x, 0x1000000000000000000000000000000),
136                                     div(x, 0x100000000000000000000)
137                                 )
138                             f := xor(div(x, 0x10000000000), f)
139                             k := 0xCA62C1D6
140                         }
141                         // temp = (a leftrotate 5) + f + e + k + w[i]
142                         let temp := and(div(x, 0x80000000000000000000000000000000000000000000000), 0x1F)
143                         temp :=
144                             or(and(div(x, 0x800000000000000000000000000000000000000), 0xFFFFFFE0), temp)
145                         temp := add(f, temp)
146                         temp := add(and(x, 0xFFFFFFFF), temp)
147                         temp := add(k, temp)
148                         temp :=
149                             add(
150                                 div(
151                                     mload(add(scratch, mul(j, 4))),
152                                     0x100000000000000000000000000000000000000000000000000000000
153                                 ),
154                                 temp
155                             )
156                         x :=
157                             or(
158                                 div(x, 0x10000000000),
159                                 mul(temp, 0x10000000000000000000000000000000000000000)
160                             )
161                         x :=
162                             or(
163                                 and(x, 0xFFFFFFFF00FFFFFFFF000000000000FFFFFFFF00FFFFFFFF),
164                                 mul(
165                                     or(
166                                         and(div(x, 0x4000000000000), 0xC0000000),
167                                         and(div(x, 0x400000000000000000000), 0x3FFFFFFF)
168                                     ),
169                                     0x100000000000000000000
170                                 )
171                             )
172                     }
173     
174                     h := and(add(h, x), 0xFFFFFFFF00FFFFFFFF00FFFFFFFF00FFFFFFFF00FFFFFFFF)
175                 }


45                      case 1 { mstore8(add(scratch, sub(len, i)), 0x80) }


49                      case 1 { mstore(add(scratch, 32), or(mload(add(scratch, 32)), mul(len, 8))) }


52                      for { let j := 64 } lt(j, 128) { j := add(j, 12) } {


52                      for { let j := 64 } lt(j, 128) { j := add(j, 12) } {


52                      for { let j := 64 } lt(j, 128) { j := add(j, 12) } {
53                          let temp :=
54                              xor(
55                                  xor(mload(add(scratch, sub(j, 12))), mload(add(scratch, sub(j, 32)))),
56                                  xor(mload(add(scratch, sub(j, 56))), mload(add(scratch, sub(j, 64))))
57                              )
58                          temp :=
59                              or(
60                                  and(
61                                      mul(temp, 2),
62                                      0xFFFFFFFEFFFFFFFEFFFFFFFEFFFFFFFEFFFFFFFEFFFFFFFEFFFFFFFEFFFFFFFE
63                                  ),
64                                  and(
65                                      div(temp, 0x80000000),
66                                      0x0000000100000001000000010000000100000001000000010000000100000001
67                                  )
68                              )
69                          mstore(add(scratch, j), temp)
70                      }


71                      for { let j := 128 } lt(j, 320) { j := add(j, 24) } {


71                      for { let j := 128 } lt(j, 320) { j := add(j, 24) } {


71                      for { let j := 128 } lt(j, 320) { j := add(j, 24) } {
72                          let temp :=
73                              xor(
74                                  xor(mload(add(scratch, sub(j, 24))), mload(add(scratch, sub(j, 64)))),
75                                  xor(mload(add(scratch, sub(j, 112))), mload(add(scratch, sub(j, 128))))
76                              )
77                          temp :=
78                              or(
79                                  and(
80                                      mul(temp, 4),
81                                      0xFFFFFFFCFFFFFFFCFFFFFFFCFFFFFFFCFFFFFFFCFFFFFFFCFFFFFFFCFFFFFFFC
82                                  ),
83                                  and(
84                                      div(temp, 0x40000000),
85                                      0x0000000300000003000000030000000300000003000000030000000300000003
86                                  )
87                              )
88                          mstore(add(scratch, j), temp)
89                      }


94                      for { let j := 0 } lt(j, 80) { j := add(j, 1) } {


94                      for { let j := 0 } lt(j, 80) { j := add(j, 1) } {


94                      for { let j := 0 } lt(j, 80) { j := add(j, 1) } {
95                          switch div(j, 20)
96                          case 0 {
97                              // f = d xor (b and (c xor d))
98                              f := xor(div(x, 0x100000000000000000000), div(x, 0x10000000000))
99                              f := and(div(x, 0x1000000000000000000000000000000), f)
100                             f := xor(div(x, 0x10000000000), f)
101                             k := 0x5A827999
102                         }
103                         case 1 {
104                             // f = b xor c xor d
105                             f :=
106                                 xor(
107                                     div(x, 0x1000000000000000000000000000000),
108                                     div(x, 0x100000000000000000000)
109                                 )
110                             f := xor(div(x, 0x10000000000), f)
111                             k := 0x6ED9EBA1
112                         }
113                         case 2 {
114                             // f = (b and c) or (d and (b or c))
115                             f :=
116                                 or(
117                                     div(x, 0x1000000000000000000000000000000),
118                                     div(x, 0x100000000000000000000)
119                                 )
120                             f := and(div(x, 0x10000000000), f)
121                             f :=
122                                 or(
123                                     and(
124                                         div(x, 0x1000000000000000000000000000000),
125                                         div(x, 0x100000000000000000000)
126                                     ),
127                                     f
128                                 )
129                             k := 0x8F1BBCDC
130                         }
131                         case 3 {
132                             // f = b xor c xor d
133                             f :=
134                                 xor(
135                                     div(x, 0x1000000000000000000000000000000),
136                                     div(x, 0x100000000000000000000)
137                                 )
138                             f := xor(div(x, 0x10000000000), f)
139                             k := 0xCA62C1D6
140                         }
141                         // temp = (a leftrotate 5) + f + e + k + w[i]
142                         let temp := and(div(x, 0x80000000000000000000000000000000000000000000000), 0x1F)
143                         temp :=
144                             or(and(div(x, 0x800000000000000000000000000000000000000), 0xFFFFFFE0), temp)
145                         temp := add(f, temp)
146                         temp := add(and(x, 0xFFFFFFFF), temp)
147                         temp := add(k, temp)
148                         temp :=
149                             add(
150                                 div(
151                                     mload(add(scratch, mul(j, 4))),
152                                     0x100000000000000000000000000000000000000000000000000000000
153                                 ),
154                                 temp
155                             )
156                         x :=
157                             or(
158                                 div(x, 0x10000000000),
159                                 mul(temp, 0x10000000000000000000000000000000000000000)
160                             )
161                         x :=
162                             or(
163                                 and(x, 0xFFFFFFFF00FFFFFFFF000000000000FFFFFFFF00FFFFFFFF),
164                                 mul(
165                                     or(
166                                         and(div(x, 0x4000000000000), 0xC0000000),
167                                         and(div(x, 0x400000000000000000000), 0x3FFFFFFF)
168                                     ),
169                                     0x100000000000000000000
170                                 )
171                             )
172                     }


96                          case 0 {
97                              // f = d xor (b and (c xor d))
98                              f := xor(div(x, 0x100000000000000000000), div(x, 0x10000000000))
99                              f := and(div(x, 0x1000000000000000000000000000000), f)
100                             f := xor(div(x, 0x10000000000), f)
101                             k := 0x5A827999
102                         }


103                         case 1 {
104                             // f = b xor c xor d
105                             f :=
106                                 xor(
107                                     div(x, 0x1000000000000000000000000000000),
108                                     div(x, 0x100000000000000000000)
109                                 )
110                             f := xor(div(x, 0x10000000000), f)
111                             k := 0x6ED9EBA1
112                         }


113                         case 2 {
114                             // f = (b and c) or (d and (b or c))
115                             f :=
116                                 or(
117                                     div(x, 0x1000000000000000000000000000000),
118                                     div(x, 0x100000000000000000000)
119                                 )
120                             f := and(div(x, 0x10000000000), f)
121                             f :=
122                                 or(
123                                     and(
124                                         div(x, 0x1000000000000000000000000000000),
125                                         div(x, 0x100000000000000000000)
126                                     ),
127                                     f
128                                 )
129                             k := 0x8F1BBCDC
130                         }


131                         case 3 {
132                             // f = b xor c xor d
133                             f :=
134                                 xor(
135                                     div(x, 0x1000000000000000000000000000000),
136                                     div(x, 0x100000000000000000000)
137                                 )
138                             f := xor(div(x, 0x10000000000), f)
139                             k := 0xCA62C1D6
140                         }


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/SHA1.sol#L131:140

```solidity
File: contracts/bridge/Bridge.sol


543                 assembly {
544                     tstore(_CTX_SLOT, _msgHash)
545                     tstore(add(_CTX_SLOT, 1), _from)
546                     tstore(add(_CTX_SLOT, 2), _srcChainId)
547                 }


560                 assembly {
561                     msgHash := tload(_CTX_SLOT)
562                     from := tload(add(_CTX_SLOT, 1))
563                     srcChainId := tload(add(_CTX_SLOT, 2))
564                 }


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/Bridge.sol#L560:564

```solidity
File: contracts/common/EssentialContract.sol


121                 assembly {
122                     tstore(_REENTRY_SLOT, _reentry)
123                 }


132                 assembly {
133                     reentry_ := tload(_REENTRY_SLOT)
134                 }


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/common/EssentialContract.sol#L132:134

```solidity
File: contracts/libs/Lib4844.sol


53              assembly {
54                  first := mload(add(ret, 32))
55                  second := mload(add(ret, 64))
56              }


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/libs/Lib4844.sol#L53:56

```solidity
File: contracts/signal/SignalService.sol


265             assembly {
266                 sstore(slot_, _value)
267             }


309             assembly {
310                 value_ := sload(slot)
311             }


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/signal/SignalService.sol#L309:311

```solidity
File: contracts/thirdparty/nomad-xyz/ExcessivelySafeCall.sol


56                  if gt(_toCopy, _maxCopy) { _toCopy := _maxCopy }


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/nomad-xyz/ExcessivelySafeCall.sol#L56:56

```solidity
File: contracts/thirdparty/optimism/Bytes.sol


56                      for {
57                          // The multiplication in the next line has the same exact purpose
58                          // as the one above.
59                          let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)
60                      } lt(mc, end) {


60                      } lt(mc, end) {
61                          mc := add(mc, 0x20)
62                          cc := add(cc, 0x20)
63                      } { mstore(mc, mload(cc)) }


63                      } { mstore(mc, mload(cc)) }


72                  default {
73                      tempBytes := mload(0x40)
74      
75                      //zero out the 32 bytes slice we are about to return
76                      //we need to do it because Solidity does not garbage collect
77                      mstore(tempBytes, 0)
78      
79                      mstore(0x40, add(tempBytes, 0x20))
80                  }


104             assembly {
105                 // Grab a free memory offset for the new array
106                 _nibbles := mload(0x40)
107     
108                 // Load the length of the passed bytes array from memory
109                 let bytesLength := mload(_bytes)
110     
111                 // Calculate the length of the new nibble array
112                 // This is the length of the input array times 2
113                 let nibblesLength := shl(0x01, bytesLength)
114     
115                 // Update the free memory pointer to allocate memory for the new array.
116                 // To do this, we add the length of the new array + 32 bytes for the array length
117                 // rounded up to the nearest 32 byte boundary to the current free memory pointer.
118                 mstore(0x40, add(_nibbles, and(not(0x1F), add(nibblesLength, 0x3F))))
119     
120                 // Store the length of the new array in memory
121                 mstore(_nibbles, nibblesLength)
122     
123                 // Store the memory offset of the _bytes array's contents on the stack
124                 let bytesStart := add(_bytes, 0x20)
125     
126                 // Store the memory offset of the nibbles array's contents on the stack
127                 let nibblesStart := add(_nibbles, 0x20)
128     
129                 // Loop through each byte in the input array
130                 for { let i := 0x00 } lt(i, bytesLength) { i := add(i, 0x01) } {
131                     // Get the starting offset of the next 2 bytes in the nibbles array
132                     let offset := add(nibblesStart, shl(0x01, i))
133                     // Load the byte at the current index within the `_bytes` array
134                     let b := byte(0x00, mload(add(bytesStart, i)))
135     
136                     // Pull out the first nibble and store it in the new array
137                     mstore8(offset, shr(0x04, b))
138                     // Pull out the second nibble and store it in the new array
139                     mstore8(add(offset, 0x01), and(b, 0x0F))
140                 }
141             }


130                 for { let i := 0x00 } lt(i, bytesLength) { i := add(i, 0x01) } {


130                 for { let i := 0x00 } lt(i, bytesLength) { i := add(i, 0x01) } {


130                 for { let i := 0x00 } lt(i, bytesLength) { i := add(i, 0x01) } {
131                     // Get the starting offset of the next 2 bytes in the nibbles array
132                     let offset := add(nibblesStart, shl(0x01, i))
133                     // Load the byte at the current index within the `_bytes` array
134                     let b := byte(0x00, mload(add(bytesStart, i)))
135     
136                     // Pull out the first nibble and store it in the new array
137                     mstore8(offset, shr(0x04, b))
138                     // Pull out the second nibble and store it in the new array
139                     mstore8(add(offset, 0x01), and(b, 0x0F))
140                 }


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/Bytes.sol#L130:140

```solidity
File: contracts/thirdparty/optimism/rlp/RLPReader.sol


43              assembly {
44                  ptr := add(_in, 32)
45              }


94              assembly {
95                  mstore(out_, itemCount)
96              }


159             assembly {
160                 prefix := byte(0, mload(ptr))
161             }


178                 assembly {
179                     firstByteOfContent := and(mload(add(ptr, 1)), shl(248, 0xff))
180                 }


198                 assembly {
199                     firstByteOfContent := and(mload(add(ptr, 1)), shl(248, 0xff))
200                 }


208                 assembly {
209                     strLen := shr(sub(256, mul(8, lenOfStrLen)), mload(add(ptr, 1)))
210                 }


244                 assembly {
245                     firstByteOfContent := and(mload(add(ptr, 1)), shl(248, 0xff))
246                 }


254                 assembly {
255                     listLen := shr(sub(256, mul(8, lenOfListLen)), mload(add(ptr, 1)))
256                 }


295             assembly {
296                 let dest := add(out_, 32)
297                 let i := 0
298                 for { } lt(i, _length) { i := add(i, 32) } { mstore(add(dest, i), mload(add(src, i))) }
299     
300                 if gt(i, _length) { mstore(add(dest, _length), 0) }
301             }


298                 for { } lt(i, _length) { i := add(i, 32) } { mstore(add(dest, i), mload(add(src, i))) }


298                 for { } lt(i, _length) { i := add(i, 32) } { mstore(add(dest, i), mload(add(src, i))) }


298                 for { } lt(i, _length) { i := add(i, 32) } { mstore(add(dest, i), mload(add(src, i))) }


300                 if gt(i, _length) { mstore(add(dest, _length), 0) }


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/rlp/RLPReader.sol#L300:300

</details>

## NC058 - Large multiples of ten should use scientific notation (e.g. 1e6) rather than decimal literals (e.g. 1000000), for readability:

Using scientific notation for large multiples of ten improves code readability. Instead of writing large decimal literals, consider using scientific notation.


```solidity
File: contracts/L1/TaikoL1.sol


213                 ethDepositMaxAmount: 10_000 ether,


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/TaikoL1.sol#L213:213

```solidity
File: contracts/L1/TaikoToken.sol


41              _mint(_recipient, 1_000_000_000 ether);


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/TaikoToken.sol#L41:41

```solidity
File: contracts/L1/gov/TaikoGovernor.sol


124             return 1_000_000_000 ether / 10_000; // 0.01% of Taiko Token


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/gov/TaikoGovernor.sol#L124:124

## NC059 - Common functions should be refactored to a common base contract:

The functions below have the same implementation as is seen in other files. The functions should be refactored into functions of a common base contract.


<details>
<summary>Click to show 13 findings</summary>

```solidity
File: contracts/tokenvault/BridgedERC20.sol


/// @audit seen in Good/contracts/L1/TaikoToken.sol
    function _afterTokenTransfer(
        address _from,
        address _to,
        uint256 _amount
    )
        internal
        override(ERC20Upgradeable, ERC20VotesUpgradeable)
    {
        super._afterTokenTransfer(_from, _to, _amount);
    }

/// @audit seen in Good/contracts/L1/TaikoToken.sol
    function _mint(
        address _to,
        uint256 _amount
    )
        internal
        override(ERC20Upgradeable, ERC20VotesUpgradeable)
    {
        super._mint(_to, _amount);
    }

/// @audit seen in Good/contracts/L1/TaikoToken.sol
    function _burn(
        address _from,
        uint256 _amount
    )
        internal
        override(ERC20Upgradeable, ERC20VotesUpgradeable)
    {
        super._burn(_from, _amount);
    }

```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC20.sol#L173:181

```solidity
File: contracts/L1/provers/GuardianProver.sol


/// @audit seen in Good/contracts/L1/hooks/AssignmentHook.sol
    function init(address _owner, address _addressManager) external initializer {
        __Essential_init(_owner, _addressManager);
    }

```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/provers/GuardianProver.sol#L25:27

```solidity
File: contracts/bridge/Bridge.sol


/// @audit seen in Good/contracts/L1/hooks/AssignmentHook.sol
    function init(address _owner, address _addressManager) external initializer {
        __Essential_init(_owner, _addressManager);
    }

```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/Bridge.sol#L75:77

```solidity
File: contracts/signal/SignalService.sol


/// @audit seen in Good/contracts/L1/hooks/AssignmentHook.sol
    function init(address _owner, address _addressManager) external initializer {
        __Essential_init(_owner, _addressManager);
    }

```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/signal/SignalService.sol#L48:50

```solidity
File: contracts/tokenvault/BaseVault.sol


/// @audit seen in Good/contracts/L1/hooks/AssignmentHook.sol
    function init(address _owner, address _addressManager) external initializer {
        __Essential_init(_owner, _addressManager);
    }

```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BaseVault.sol#L32:34

```solidity
File: contracts/verifiers/GuardianVerifier.sol


/// @audit seen in Good/contracts/L1/hooks/AssignmentHook.sol
    function init(address _owner, address _addressManager) external initializer {
        __Essential_init(_owner, _addressManager);
    }

```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/verifiers/GuardianVerifier.sol#L18:20

```solidity
File: contracts/verifiers/SgxVerifier.sol


/// @audit seen in Good/contracts/L1/hooks/AssignmentHook.sol
    function init(address _owner, address _addressManager) external initializer {
        __Essential_init(_owner, _addressManager);
    }

```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/verifiers/SgxVerifier.sol#L83:85

```solidity
File: contracts/L1/tiers/MainnetTierProvider.sol


/// @audit seen in Good/contracts/L1/tiers/DevnetTierProvider.sol
    function init(address _owner) external initializer {
        __Essential_init(_owner);
    }

```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/tiers/MainnetTierProvider.sol#L15:17

```solidity
File: contracts/L1/tiers/TestnetTierProvider.sol


/// @audit seen in Good/contracts/L1/tiers/DevnetTierProvider.sol
    function init(address _owner) external initializer {
        __Essential_init(_owner);
    }

```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/tiers/TestnetTierProvider.sol#L15:17

```solidity
File: contracts/common/AddressManager.sol


/// @audit seen in Good/contracts/L1/tiers/DevnetTierProvider.sol
    function init(address _owner) external initializer {
        __Essential_init(_owner);
    }

```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/common/AddressManager.sol#L30:32

```solidity
File: contracts/team/airdrop/ERC721Airdrop.sol


/// @audit seen in Good/contracts/team/airdrop/ERC20Airdrop.sol
    function init(
        address _owner,
        uint64 _claimStart,
        uint64 _claimEnd,
        bytes32 _merkleRoot,
        address _token,
        address _vault
    )
        external
        initializer
    {
        __Essential_init(_owner);
        __MerkleClaimable_init(_claimStart, _claimEnd, _merkleRoot);

        token = _token;
        vault = _vault;
    }

```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/airdrop/ERC721Airdrop.sol#L25:41

</details>

## NC060 - Polymorphic functions make security audits more time-consuming and error-prone:

The instances below point to one of two functions with the same name. Consider naming each function differently, in order to make code navigation and analysis easier.


<details>
<summary>Click to show 13 findings</summary>

```solidity
File: contracts/L1/gov/TaikoGovernor.sol


69          function propose(


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/gov/TaikoGovernor.sol#L69:69

```solidity
File: contracts/L1/provers/Guardians.sol


128         function isApproved(uint256 _approvalBits) internal view returns (bool) {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/provers/Guardians.sol#L128:128

```solidity
File: contracts/automata-attestation/utils/BytesUtils.sol


56          function compare(


138         function equals(


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/BytesUtils.sol#L138:138

```solidity
File: contracts/common/AddressResolver.sol


43          function resolve(


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/common/AddressResolver.sol#L43:43

```solidity
File: contracts/common/EssentialContract.sol


109         function __Essential_init(address _owner) internal virtual {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/common/EssentialContract.sol#L109:109

```solidity
File: contracts/common/IAddressResolver.sol


34          function resolve(


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/common/IAddressResolver.sol#L34:34

```solidity
File: contracts/libs/LibAddress.sol


42          function sendEther(address _to, uint256 _amount) internal {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/libs/LibAddress.sol#L42:42

```solidity
File: contracts/team/TimelockTokenPool.sol


168         function withdraw(address _to, bytes memory _sig) external {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/TimelockTokenPool.sol#L168:168

```solidity
File: contracts/thirdparty/optimism/Bytes.sol


91          function slice(bytes memory _bytes, uint256 _start) internal pure returns (bytes memory) {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/Bytes.sol#L91:91

```solidity
File: contracts/thirdparty/optimism/rlp/RLPReader.sol


102         function readList(bytes memory _in) internal pure returns (RLPItem[] memory out_) {


128         function readBytes(bytes memory _in) internal pure returns (bytes memory out_) {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/rlp/RLPReader.sol#L128:128

```solidity
File: contracts/tokenvault/ERC1155Vault.sol


204         function name() public pure override returns (bytes32) {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC1155Vault.sol#L204:204

</details>

## NC061 - Error messages should descriptive, rather that cryptic:




```solidity
File: contracts/automata-attestation/AutomataDcapV3Attestation.sol


61              require(msg.sender == owner, "onlyOwner");


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/AutomataDcapV3Attestation.sol#L61:61

## NC062 - Missing timelock for critical parameter change:

Timelocks prevent users from being surprised by changes.


```solidity
File: contracts/L1/provers/Guardians.sol


94              minGuardians = _minGuardians;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/provers/Guardians.sol#L94:94

```solidity
File: contracts/L2/TaikoL2EIP1559Configurable.sol


36              customConfig = _newConfig;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/TaikoL2EIP1559Configurable.sol#L36:36

```solidity
File: contracts/tokenvault/BridgedERC20.sol


81              snapshooter = _snapshooter;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC20.sol#L81:81

## NC063 - Setters should prevent re-setting of the same value:

This especially problematic when the setter also emits the same value, which may be confusing to offline parsers.


<details>
<summary>Click to show 6 findings</summary>

```solidity
File: contracts/L2/TaikoL2EIP1559Configurable.sol


25          function setConfigAndExcess(
26              Config memory _newConfig,
27              uint64 _newGasExcess
28          )
29              external
30              virtual
31              onlyOwner
32          {
33              if (_newConfig.gasTargetPerL1Block == 0) revert L2_INVALID_CONFIG();
34              if (_newConfig.basefeeAdjustmentQuotient == 0) revert L2_INVALID_CONFIG();
35      
36              customConfig = _newConfig;
37              gasExcess = _newGasExcess;
38      
39              emit ConfigAndExcessChanged(_newConfig, _newGasExcess);
40          }


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/TaikoL2EIP1559Configurable.sol#L25:40

```solidity
File: contracts/automata-attestation/AutomataDcapV3Attestation.sol


65          function setMrSigner(bytes32 _mrSigner, bool _trusted) external onlyOwner {
66              _trustedUserMrSigner[_mrSigner] = _trusted;
67          }


69          function setMrEnclave(bytes32 _mrEnclave, bool _trusted) external onlyOwner {
70              _trustedUserMrEnclave[_mrEnclave] = _trusted;
71          }


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/AutomataDcapV3Attestation.sol#L69:71

```solidity
File: contracts/common/AddressManager.sol


38          function setAddress(
39              uint64 _chainId,
40              bytes32 _name,
41              address _newAddress
42          )
43              external
44              virtual
45              onlyOwner
46          {
47              address oldAddress = __addresses[_chainId][_name];
48              if (_newAddress == oldAddress) revert AM_INVALID_PARAMS();
49              __addresses[_chainId][_name] = _newAddress;
50              emit AddressSet(_chainId, _name, _newAddress, oldAddress);
51          }


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/common/AddressManager.sol#L38:51

```solidity
File: contracts/tokenvault/BridgedERC20.sol


80          function setSnapshoter(address _snapshooter) external onlyOwner {
81              snapshooter = _snapshooter;
82          }


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC20.sol#L80:82

```solidity
File: contracts/tokenvault/ERC20Vault.sol


148         function changeBridgedToken(
149             CanonicalERC20 calldata _ctoken,
150             address _btokenNew
151         )
152             external
153             nonReentrant
154             whenNotPaused
155             onlyOwner
156             returns (address btokenOld_)
157         {
158             if (_btokenNew == address(0) || bridgedToCanonical[_btokenNew].addr != address(0)) {
159                 revert VAULT_INVALID_NEW_BTOKEN();
160             }
161     
162             if (btokenBlacklist[_btokenNew]) revert VAULT_BTOKEN_BLACKLISTED();
163     
164             if (IBridgedERC20(_btokenNew).owner() != owner()) {
165                 revert VAULT_NOT_SAME_OWNER();
166             }
167     
168             btokenOld_ = canonicalToBridged[_ctoken.chainId][_ctoken.addr];
169     
170             if (btokenOld_ != address(0)) {
171                 CanonicalERC20 memory ctoken = bridgedToCanonical[btokenOld_];
172     
173                 // The ctoken must match the saved one.
174                 if (
175                     ctoken.decimals != _ctoken.decimals
176                         || keccak256(bytes(ctoken.symbol)) != keccak256(bytes(_ctoken.symbol))
177                         || keccak256(bytes(ctoken.name)) != keccak256(bytes(_ctoken.name))
178                 ) revert VAULT_CTOKEN_MISMATCH();
179     
180                 delete bridgedToCanonical[_btokenNew];
181                 btokenBlacklist[btokenOld_] = true;
182     
183                 // Start the migration
184                 IBridgedERC20(btokenOld_).changeMigrationStatus(_btokenNew, false);
185                 IBridgedERC20(_btokenNew).changeMigrationStatus(btokenOld_, true);
186             }
187     
188             bridgedToCanonical[_btokenNew] = _ctoken;
189             canonicalToBridged[_ctoken.chainId][_ctoken.addr] = _btokenNew;
190     
191             emit BridgedTokenChanged({
192                 srcChainId: _ctoken.chainId,
193                 ctoken: _ctoken.addr,
194                 btokenOld: btokenOld_,
195                 btokenNew: _btokenNew,
196                 ctokenSymbol: _ctoken.symbol,
197                 ctokenName: _ctoken.name,
198                 ctokenDecimal: _ctoken.decimals
199             });
200         }


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC20Vault.sol#L148:200

</details>

## NC064 - Consider splitting long calculations:

The longer a string of operations is, the harder it is to understand it. Consider splitting the full calculation into more steps, with more descriptive temporary variable names, and add extensive comments.


<details>
<summary>Click to show 5 findings</summary>

```solidity
File: contracts/L1/libs/LibProving.sol


192                 bool returnLivenessBond = blk.livenessBond > 0 && _proof.data.length == 32
193                     && bytes32(_proof.data) == RETURN_LIVENESS_BOND;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProving.sol#L192:193

```solidity
File: contracts/automata-attestation/lib/QuoteV3Auth/V3Parser.sol


106             uint32 totalQuoteSize = 48 // header
107                 + 384 // local QE report
108                 + 64 // ecdsa256BitSignature
109                 + 64 // ecdsaAttestationKey
110                 + 384 // QE report
111                 + 64 // qeReportSignature
112                 + 2 // sizeof(v3Quote.v3AuthData.qeAuthData.parsedDataSize)
113                 + v3Quote.v3AuthData.qeAuthData.parsedDataSize + 2 // sizeof(v3Quote.v3AuthData.certification.certType)
114                 + 4 // sizeof(v3Quote.v3AuthData.certification.certDataSize)
115                 + v3Quote.v3AuthData.certification.certDataSize;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/QuoteV3Auth/V3Parser.sol#L106:115

```solidity
File: contracts/automata-attestation/utils/BytesUtils.sol


93                          mask = ~(2 ** (8 * (32 - shortest + idx)) - 1);


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/BytesUtils.sol#L93:93

```solidity
File: contracts/automata-attestation/utils/X509DateUtils.sol


25              mnths = (uint8(x509Time[offset + 2]) - 48) * 10 + uint8(x509Time[offset + 3]) - 48;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/X509DateUtils.sol#L25:25

```solidity
File: contracts/thirdparty/solmate/LibFixedPointMath.sol


39                  int256 k = ((x << 96) / 54_916_777_467_707_473_351_141_471_128 + 2 ** 95) >> 96;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/solmate/LibFixedPointMath.sol#L39:39

</details>

## NC065 - High cyclomatic complexity:

Consider breaking down these blocks into more manageable units, by splitting things into utility functions, by reducing nesting, and by using early returns.


<details>
<summary>Click to show 14 findings</summary>

```solidity
File: contracts/L1/libs/LibProposing.sol


68          function proposeBlock(
69              TaikoData.State storage _state,
70              TaikoData.Config memory _config,
71              IAddressResolver _resolver,
72              bytes calldata _data,
73              bytes calldata _txList
74          )
75              internal
76              returns (TaikoData.BlockMetadata memory meta_, TaikoData.EthDeposit[] memory deposits_)
77          {
78              TaikoData.BlockParams memory params = abi.decode(_data, (TaikoData.BlockParams));
79      
80              // We need a prover that will submit proofs after the block has been submitted
81              if (params.assignedProver == address(0)) {
82                  revert L1_INVALID_PROVER();
83              }
84      
85              if (params.coinbase == address(0)) {
86                  params.coinbase = msg.sender;
87              }
88      
89              // Taiko, as a Based Rollup, enables permissionless block proposals.
90              // However, if the "proposer" address is set to a non-zero value, we
91              // ensure that only that specific address has the authority to propose
92              // blocks.
93              TaikoData.SlotB memory b = _state.slotB;
94              if (!_isProposerPermitted(b, _resolver)) revert L1_UNAUTHORIZED();
95      
96              // It's essential to ensure that the ring buffer for proposed blocks
97              // still has space for at least one more block.
98              if (b.numBlocks >= b.lastVerifiedBlockId + _config.blockMaxProposals + 1) {
99                  revert L1_TOO_MANY_BLOCKS();
100             }
101     
102             bytes32 parentMetaHash =
103                 _state.blocks[(b.numBlocks - 1) % _config.blockRingBufferSize].metaHash;
104     
105             // Check if parent block has the right meta hash
106             // This is to allow the proposer to make sure the block builds on the expected latest chain
107             // state
108             if (params.parentMetaHash != 0 && parentMetaHash != params.parentMetaHash) {
109                 revert L1_UNEXPECTED_PARENT();
110             }
111     
112             // Each transaction must handle a specific quantity of L1-to-L2
113             // Ether deposits.
114             deposits_ = LibDepositing.processDeposits(_state, _config, params.coinbase);
115     
116             // Initialize metadata to compute a metaHash, which forms a part of
117             // the block data to be stored on-chain for future integrity checks.
118             // If we choose to persist all data fields in the metadata, it will
119             // require additional storage slots.
120             unchecked {
121                 meta_ = TaikoData.BlockMetadata({
122                     l1Hash: blockhash(block.number - 1),
123                     difficulty: 0, // to be initialized below
124                     blobHash: 0, // to be initialized below
125                     extraData: params.extraData,
126                     depositsHash: keccak256(abi.encode(deposits_)),
127                     coinbase: params.coinbase,
128                     id: b.numBlocks,
129                     gasLimit: _config.blockMaxGasLimit,
130                     timestamp: uint64(block.timestamp),
131                     l1Height: uint64(block.number - 1),
132                     txListByteOffset: 0, // to be initialized below
133                     txListByteSize: 0, // to be initialized below
134                     minTier: 0, // to be initialized below
135                     blobUsed: _txList.length == 0,
136                     parentMetaHash: parentMetaHash
137                 });
138             }
139     
140             // Update certain meta fields
141             if (meta_.blobUsed) {
142                 if (!_config.blobAllowedForDA) revert L1_BLOB_FOR_DA_DISABLED();
143     
144                 if (params.blobHash != 0) {
145                     if (!_config.blobReuseEnabled) revert L1_BLOB_REUSE_DISABLED();
146     
147                     // We try to reuse an old blob
148                     if (!isBlobReusable(_state, _config, params.blobHash)) {
149                         revert L1_BLOB_NOT_REUSABLE();
150                     }
151                     meta_.blobHash = params.blobHash;
152                 } else {
153                     // Always use the first blob in this transaction. If the
154                     // proposeBlock functions are called more than once in the same
155                     // L1 transaction, these multiple L2 blocks will share the same
156                     // blob.
157                     meta_.blobHash = blobhash(0);
158     
159                     if (meta_.blobHash == 0) revert L1_BLOB_NOT_FOUND();
160     
161                     // Depends on the blob data price, it may not make sense to
162                     // cache the blob which costs 20,000 (sstore) + 631 (event)
163                     // extra gas.
164                     if (_config.blobReuseEnabled && params.cacheBlobForReuse) {
165                         _state.reusableBlobs[meta_.blobHash] = block.timestamp;
166                         emit BlobCached(meta_.blobHash);
167                     }
168                 }
169     
170                 // Check that the txList data range is within the max size of a blob
171                 if (uint256(params.txListByteOffset) + params.txListByteSize > MAX_BYTES_PER_BLOB) {
172                     revert L1_TXLIST_OFFSET();
173                 }
174     
175                 meta_.txListByteOffset = params.txListByteOffset;
176                 meta_.txListByteSize = params.txListByteSize;
177             } else {
178                 // The proposer must be an Externally Owned Account (EOA) for
179                 // calldata usage. This ensures that the transaction is not an
180                 // internal one, making calldata retrieval more straightforward for
181                 // Taiko node software.
182                 if (!LibAddress.isSenderEOA()) revert L1_PROPOSER_NOT_EOA();
183     
184                 // The txList is the full byte array without any offset
185                 if (params.txListByteOffset != 0) {
186                     revert L1_INVALID_PARAM();
187                 }
188     
189                 meta_.blobHash = keccak256(_txList);
190                 meta_.txListByteOffset = 0;
191                 meta_.txListByteSize = uint24(_txList.length);
192             }
193     
194             // Check that the tx length is non-zero and within the supported range
195             if (meta_.txListByteSize == 0 || meta_.txListByteSize > _config.blockMaxTxListBytes) {
196                 revert L1_TXLIST_SIZE();
197             }
198     
199             // Following the Merge, the L1 mixHash incorporates the
200             // prevrandao value from the beacon chain. Given the possibility
201             // of multiple Taiko blocks being proposed within a single
202             // Ethereum block, we choose to introduce a salt to this random
203             // number as the L2 mixHash.
204             meta_.difficulty = keccak256(abi.encodePacked(block.prevrandao, b.numBlocks, block.number));
205     
206             // Use the difficulty as a random number
207             meta_.minTier = ITierProvider(_resolver.resolve("tier_provider", false)).getMinTier(
208                 uint256(meta_.difficulty)
209             );
210     
211             // Create the block that will be stored onchain
212             TaikoData.Block memory blk = TaikoData.Block({
213                 metaHash: keccak256(abi.encode(meta_)),
214                 // Safeguard the liveness bond to ensure its preservation,
215                 // particularly in scenarios where it might be altered after the
216                 // block's proposal but before it has been proven or verified.
217                 livenessBond: _config.livenessBond,
218                 blockId: b.numBlocks,
219                 proposedAt: meta_.timestamp,
220                 proposedIn: uint64(block.number),
221                 // For a new block, the next transition ID is always 1, not 0.
222                 nextTransitionId: 1,
223                 // For unverified block, its verifiedTransitionId is always 0.
224                 verifiedTransitionId: 0,
225                 assignedProver: params.assignedProver
226             });
227     
228             // Store the block in the ring buffer
229             _state.blocks[b.numBlocks % _config.blockRingBufferSize] = blk;
230     
231             // Increment the counter (cursor) by 1.
232             unchecked {
233                 ++_state.slotB.numBlocks;
234             }
235     
236             {
237                 IERC20 tko = IERC20(_resolver.resolve("taiko_token", false));
238                 uint256 tkoBalance = tko.balanceOf(address(this));
239     
240                 // Run all hooks.
241                 // Note that address(this).balance has been updated with msg.value,
242                 // prior to any code in this function has been executed.
243                 address prevHook;
244                 for (uint256 i; i < params.hookCalls.length; ++i) {
245                     if (uint160(prevHook) >= uint160(params.hookCalls[i].hook)) {
246                         revert L1_INVALID_HOOK();
247                     }
248     
249                     // When a hook is called, all ether in this contract will be send to the hook.
250                     // If the ether sent to the hook is not used entirely, the hook shall send the Ether
251                     // back to this contract for the next hook to use.
252                     // Proposers shall choose use extra hooks wisely.
253                     IHook(params.hookCalls[i].hook).onBlockProposed{ value: address(this).balance }(
254                         blk, meta_, params.hookCalls[i].data
255                     );
256     
257                     prevHook = params.hookCalls[i].hook;
258                 }
259                 // Refund Ether
260                 if (address(this).balance != 0) {
261                     msg.sender.sendEther(address(this).balance);
262                 }
263     
264                 // Check that after hooks, the Taiko Token balance of this contract
265                 // have increased by the same amount as _config.livenessBond (to prevent)
266                 // multiple draining payments by a malicious proposer nesting the same
267                 // hook.
268                 if (tko.balanceOf(address(this)) != tkoBalance + _config.livenessBond) {
269                     revert L1_LIVENESS_BOND_NOT_RECEIVED();
270                 }
271             }
272     
273             emit BlockProposed({
274                 blockId: blk.blockId,
275                 assignedProver: blk.assignedProver,
276                 livenessBond: _config.livenessBond,
277                 meta: meta_,
278                 depositsProcessed: deposits_
279             });
280         }


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProposing.sol#L68:280

```solidity
File: contracts/L1/libs/LibProving.sol


91          function proveBlock(
92              TaikoData.State storage _state,
93              TaikoData.Config memory _config,
94              IAddressResolver _resolver,
95              TaikoData.BlockMetadata memory _meta,
96              TaikoData.Transition memory _tran,
97              TaikoData.TierProof memory _proof
98          )
99              internal
100             returns (uint8 maxBlocksToVerify_)
101         {
102             // Make sure parentHash is not zero
103             // To contest an existing transition, simply use any non-zero value as
104             // the blockHash and stateRoot.
105             if (_tran.parentHash == 0 || _tran.blockHash == 0 || _tran.stateRoot == 0) {
106                 revert L1_INVALID_TRANSITION();
107             }
108     
109             // Check that the block has been proposed but has not yet been verified.
110             TaikoData.SlotB memory b = _state.slotB;
111             if (_meta.id <= b.lastVerifiedBlockId || _meta.id >= b.numBlocks) {
112                 revert L1_INVALID_BLOCK_ID();
113             }
114     
115             uint64 slot = _meta.id % _config.blockRingBufferSize;
116             TaikoData.Block storage blk = _state.blocks[slot];
117     
118             // Check the integrity of the block data. It's worth noting that in
119             // theory, this check may be skipped, but it's included for added
120             // caution.
121             if (blk.blockId != _meta.id || blk.metaHash != keccak256(abi.encode(_meta))) {
122                 revert L1_BLOCK_MISMATCH();
123             }
124     
125             // Each transition is uniquely identified by the parentHash, with the
126             // blockHash and stateRoot open for later updates as higher-tier proofs
127             // become available. In cases where a transition with the specified
128             // parentHash does not exist, the transition ID (tid) will be set to 0.
129             (uint32 tid, TaikoData.TransitionState storage ts) =
130                 _createTransition(_state, blk, _tran, slot);
131     
132             // The new proof must meet or exceed the minimum tier required by the
133             // block or the previous proof; it cannot be on a lower tier.
134             if (_proof.tier == 0 || _proof.tier < _meta.minTier || _proof.tier < ts.tier) {
135                 revert L1_INVALID_TIER();
136             }
137     
138             // Retrieve the tier configurations. If the tier is not supported, the
139             // subsequent action will result in a revert.
140             ITierProvider.Tier memory tier =
141                 ITierProvider(_resolver.resolve("tier_provider", false)).getTier(_proof.tier);
142     
143             // Check if this prover is allowed to submit a proof for this block
144             _checkProverPermission(_state, blk, ts, tid, tier);
145     
146             // We must verify the proof, and any failure in proof verification will
147             // result in a revert.
148             //
149             // It's crucial to emphasize that the proof can be assessed in two
150             // potential modes: "proving mode" and "contesting mode." However, the
151             // precise verification logic is defined within each tier's IVerifier
152             // contract implementation. We simply specify to the verifier contract
153             // which mode it should utilize - if the new tier is higher than the
154             // previous tier, we employ the proving mode; otherwise, we employ the
155             // contesting mode (the new tier cannot be lower than the previous tier,
156             // this has been checked above).
157             //
158             // It's obvious that proof verification is entirely decoupled from
159             // Taiko's core protocol.
160             {
161                 address verifier = _resolver.resolve(tier.verifierName, true);
162     
163                 if (verifier != address(0)) {
164                     bool isContesting = _proof.tier == ts.tier && tier.contestBond != 0;
165     
166                     IVerifier.Context memory ctx = IVerifier.Context({
167                         metaHash: blk.metaHash,
168                         blobHash: _meta.blobHash,
169                         // Separate msgSender to allow the prover to be any address in the future.
170                         prover: msg.sender,
171                         msgSender: msg.sender,
172                         blockId: blk.blockId,
173                         isContesting: isContesting,
174                         blobUsed: _meta.blobUsed
175                     });
176     
177                     IVerifier(verifier).verifyProof(ctx, _tran, _proof);
178                 } else if (tier.verifierName != TIER_OP) {
179                     // The verifier can be address-zero, signifying that there are no
180                     // proof checks for the tier. In practice, this only applies to
181                     // optimistic proofs.
182                     revert L1_MISSING_VERIFIER();
183                 }
184             }
185     
186             bool isTopTier = tier.contestBond == 0;
187             IERC20 tko = IERC20(_resolver.resolve("taiko_token", false));
188     
189             if (isTopTier) {
190                 // A special return value from the top tier prover can signal this
191                 // contract to return all liveness bond.
192                 bool returnLivenessBond = blk.livenessBond > 0 && _proof.data.length == 32
193                     && bytes32(_proof.data) == RETURN_LIVENESS_BOND;
194     
195                 if (returnLivenessBond) {
196                     tko.transfer(blk.assignedProver, blk.livenessBond);
197                     blk.livenessBond = 0;
198                 }
199             }
200     
201             bool sameTransition = _tran.blockHash == ts.blockHash && _tran.stateRoot == ts.stateRoot;
202     
203             if (_proof.tier > ts.tier) {
204                 // Handles the case when an incoming tier is higher than the current transition's tier.
205                 // Reverts when the incoming proof tries to prove the same transition
206                 // (L1_ALREADY_PROVED).
207                 _overrideWithHigherProof(ts, _tran, _proof, tier, tko, sameTransition);
208     
209                 emit TransitionProved({
210                     blockId: blk.blockId,
211                     tran: _tran,
212                     prover: msg.sender,
213                     validityBond: tier.validityBond,
214                     tier: _proof.tier
215                 });
216             } else {
217                 // New transition and old transition on the same tier - and if this transaction tries to
218                 // prove the same, it reverts
219                 if (sameTransition) revert L1_ALREADY_PROVED();
220     
221                 if (isTopTier) {
222                     // The top tier prover re-proves.
223                     assert(tier.validityBond == 0);
224                     assert(ts.validityBond == 0 && ts.contestBond == 0 && ts.contester == address(0));
225     
226                     ts.prover = msg.sender;
227                     ts.blockHash = _tran.blockHash;
228                     ts.stateRoot = _tran.stateRoot;
229     
230                     emit TransitionProved({
231                         blockId: blk.blockId,
232                         tran: _tran,
233                         prover: msg.sender,
234                         validityBond: 0,
235                         tier: _proof.tier
236                     });
237                 } else {
238                     // Contesting but not on the highest tier
239                     if (ts.contester != address(0)) revert L1_ALREADY_CONTESTED();
240     
241                     // Burn the contest bond from the prover.
242                     tko.transferFrom(msg.sender, address(this), tier.contestBond);
243     
244                     // We retain the contest bond within the transition, just in
245                     // case this configuration is altered to a different value
246                     // before the contest is resolved.
247                     //
248                     // It's worth noting that the previous value of ts.contestBond
249                     // doesn't have any significance.
250                     ts.contestBond = tier.contestBond;
251                     ts.contester = msg.sender;
252                     ts.contestations += 1;
253     
254                     emit TransitionContested({
255                         blockId: blk.blockId,
256                         tran: _tran,
257                         contester: msg.sender,
258                         contestBond: tier.contestBond,
259                         tier: _proof.tier
260                     });
261                 }
262             }
263     
264             ts.timestamp = uint64(block.timestamp);
265             return tier.maxBlocksToVerifyPerProof;
266         }


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProving.sol#L91:266

```solidity
File: contracts/L1/libs/LibVerifying.sol


85          function verifyBlocks(
86              TaikoData.State storage _state,
87              TaikoData.Config memory _config,
88              IAddressResolver _resolver,
89              uint64 _maxBlocksToVerify
90          )
91              internal
92          {
93              if (_maxBlocksToVerify == 0) {
94                  return;
95              }
96      
97              // Retrieve the latest verified block and the associated transition used
98              // for its verification.
99              TaikoData.SlotB memory b = _state.slotB;
100             uint64 blockId = b.lastVerifiedBlockId;
101     
102             uint64 slot = blockId % _config.blockRingBufferSize;
103     
104             TaikoData.Block storage blk = _state.blocks[slot];
105             if (blk.blockId != blockId) revert L1_BLOCK_MISMATCH();
106     
107             uint32 tid = blk.verifiedTransitionId;
108     
109             // The following scenario should never occur but is included as a
110             // precaution.
111             if (tid == 0) revert L1_TRANSITION_ID_ZERO();
112     
113             // The `blockHash` variable represents the most recently trusted
114             // blockHash on L2.
115             bytes32 blockHash = _state.transitions[slot][tid].blockHash;
116             bytes32 stateRoot;
117             uint64 numBlocksVerified;
118             address tierProvider;
119     
120             // Unchecked is safe:
121             // - assignment is within ranges
122             // - blockId and numBlocksVerified values incremented will still be OK in the
123             // next 584K years if we verifying one block per every second
124             unchecked {
125                 ++blockId;
126     
127                 while (blockId < b.numBlocks && numBlocksVerified < _maxBlocksToVerify) {
128                     slot = blockId % _config.blockRingBufferSize;
129     
130                     blk = _state.blocks[slot];
131                     if (blk.blockId != blockId) revert L1_BLOCK_MISMATCH();
132     
133                     tid = LibUtils.getTransitionId(_state, blk, slot, blockHash);
134                     // When `tid` is 0, it indicates that there is no proven
135                     // transition with its parentHash equal to the blockHash of the
136                     // most recently verified block.
137                     if (tid == 0) break;
138     
139                     // A transition with the correct `parentHash` has been located.
140                     TaikoData.TransitionState storage ts = _state.transitions[slot][tid];
141     
142                     // It's not possible to verify this block if either the
143                     // transition is contested and awaiting higher-tier proof or if
144                     // the transition is still within its cooldown period.
145                     if (ts.contester != address(0)) {
146                         break;
147                     } else {
148                         if (tierProvider == address(0)) {
149                             tierProvider = _resolver.resolve("tier_provider", false);
150                         }
151                         if (
152                             uint256(ITierProvider(tierProvider).getTier(ts.tier).cooldownWindow) * 60
153                                 + uint256(ts.timestamp).max(_state.slotB.lastUnpausedAt) > block.timestamp
154                         ) {
155                             // If cooldownWindow is 0, the block can theoretically
156                             // be proved and verified within the same L1 block.
157                             break;
158                         }
159                     }
160     
161                     // Mark this block as verified
162                     blk.verifiedTransitionId = tid;
163     
164                     // Update variables
165                     blockHash = ts.blockHash;
166                     stateRoot = ts.stateRoot;
167     
168                     // We consistently return the liveness bond and the validity
169                     // bond to the actual prover of the transition utilized for
170                     // block verification. If the actual prover happens to be the
171                     // block's assigned prover, he will receive both deposits,
172                     // ultimately earning the proving fee paid during block
173                     // proposal. In contrast, if the actual prover is different from
174                     // the block's assigned prover, the liveness bond serves as a
175                     // reward to the actual prover, while the assigned prover
176                     // forfeits his liveness bond due to failure to fulfill their
177                     // commitment.
178                     uint256 bondToReturn = uint256(ts.validityBond) + blk.livenessBond;
179     
180                     // Nevertheless, it's possible for the actual prover to be the
181                     // same individual or entity as the block's assigned prover.
182                     // Consequently, we have chosen to grant the actual prover only
183                     // half of the liveness bond as a reward.
184                     if (ts.prover != blk.assignedProver) {
185                         bondToReturn -= blk.livenessBond >> 1;
186                     }
187     
188                     IERC20 tko = IERC20(_resolver.resolve("taiko_token", false));
189                     tko.transfer(ts.prover, bondToReturn);
190     
191                     // Note: We exclusively address the bonds linked to the
192                     // transition used for verification. While there may exist
193                     // other transitions for this block, we disregard them entirely.
194                     // The bonds for these other transitions are burned either when
195                     // the transitions are generated or proven. In such cases, both
196                     // the provers and contesters of those transitions forfeit their bonds.
197     
198                     emit BlockVerified({
199                         blockId: blockId,
200                         assignedProver: blk.assignedProver,
201                         prover: ts.prover,
202                         blockHash: blockHash,
203                         stateRoot: stateRoot,
204                         tier: ts.tier,
205                         contestations: ts.contestations
206                     });
207     
208                     ++blockId;
209                     ++numBlocksVerified;
210                 }
211     
212                 if (numBlocksVerified > 0) {
213                     uint64 lastVerifiedBlockId = b.lastVerifiedBlockId + numBlocksVerified;
214     
215                     // Update protocol level state variables
216                     _state.slotB.lastVerifiedBlockId = lastVerifiedBlockId;
217     
218                     // sync chain data
219                     _syncChainData(_config, _resolver, lastVerifiedBlockId, stateRoot);
220                 }
221             }
222         }


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibVerifying.sol#L85:222

```solidity
File: contracts/automata-attestation/AutomataDcapV3Attestation.sol


364         function _verifyParsedQuote(V3Struct.ParsedV3QuoteStruct memory v3quote)
365             internal
366             view
367             returns (bool, bytes memory)
368         {
369             bytes memory retData = abi.encodePacked(INVALID_EXIT_CODE);
370     
371             // // Step 1: Parse the quote input = 152k gas
372             (
373                 bool successful,
374                 ,
375                 ,
376                 bytes memory signedQuoteData,
377                 V3Struct.ECDSAQuoteV3AuthData memory authDataV3
378             ) = V3Parser.validateParsedInput(v3quote);
379             if (!successful) {
380                 return (false, retData);
381             }
382     
383             // Step 2: Verify application enclave report MRENCLAVE and MRSIGNER
384             {
385                 if (_checkLocalEnclaveReport) {
386                     // 4k gas
387                     bool mrEnclaveIsTrusted =
388                         _trustedUserMrEnclave[v3quote.localEnclaveReport.mrEnclave];
389                     bool mrSignerIsTrusted = _trustedUserMrSigner[v3quote.localEnclaveReport.mrSigner];
390     
391                     if (!mrEnclaveIsTrusted || !mrSignerIsTrusted) {
392                         return (false, retData);
393                     }
394                 }
395             }
396     
397             // Step 3: Verify enclave identity = 43k gas
398             EnclaveIdStruct.EnclaveIdStatus qeTcbStatus;
399             {
400                 bool verifiedEnclaveIdSuccessfully;
401                 (verifiedEnclaveIdSuccessfully, qeTcbStatus) =
402                     _verifyQEReportWithIdentity(v3quote.v3AuthData.pckSignedQeReport);
403                 if (!verifiedEnclaveIdSuccessfully) {
404                     return (false, retData);
405                 }
406                 if (
407                     !verifiedEnclaveIdSuccessfully
408                         || qeTcbStatus == EnclaveIdStruct.EnclaveIdStatus.SGX_ENCLAVE_REPORT_ISVSVN_REVOKED
409                 ) {
410                     return (false, retData);
411                 }
412             }
413     
414             // Step 4: Parse Quote CertChain
415             IPEMCertChainLib.ECSha256Certificate[] memory parsedQuoteCerts;
416             TCBInfoStruct.TCBInfo memory fetchedTcbInfo;
417             {
418                 // 536k gas
419                 parsedQuoteCerts = new IPEMCertChainLib.ECSha256Certificate[](3);
420                 for (uint256 i; i < 3; ++i) {
421                     bool isPckCert = i == 0; // additional parsing for PCKCert
422                     bool certDecodedSuccessfully;
423                     // todo! move decodeCert offchain
424                     (certDecodedSuccessfully, parsedQuoteCerts[i]) = pemCertLib.decodeCert(
425                         authDataV3.certification.decodedCertDataArray[i], isPckCert
426                     );
427                     if (!certDecodedSuccessfully) {
428                         return (false, retData);
429                     }
430                 }
431             }
432     
433             // Step 5: basic PCK and TCB check = 381k gas
434             {
435                 string memory parsedFmspc = parsedQuoteCerts[0].pck.sgxExtension.fmspc;
436                 fetchedTcbInfo = tcbInfo[parsedFmspc];
437                 bool tcbConfigured = LibString.eq(parsedFmspc, fetchedTcbInfo.fmspc);
438                 if (!tcbConfigured) {
439                     return (false, retData);
440                 }
441     
442                 IPEMCertChainLib.ECSha256Certificate memory pckCert = parsedQuoteCerts[0];
443                 bool pceidMatched = LibString.eq(pckCert.pck.sgxExtension.pceid, fetchedTcbInfo.pceid);
444                 if (!pceidMatched) {
445                     return (false, retData);
446                 }
447             }
448     
449             // Step 6: Verify TCB Level
450             TCBInfoStruct.TCBStatus tcbStatus;
451             {
452                 // 4k gas
453                 bool tcbVerified;
454                 (tcbVerified, tcbStatus) = _checkTcbLevels(parsedQuoteCerts[0].pck, fetchedTcbInfo);
455                 if (!tcbVerified) {
456                     return (false, retData);
457                 }
458             }
459     
460             // Step 7: Verify cert chain for PCK
461             {
462                 // 660k gas (rootCA pubkey is trusted)
463                 bool pckCertChainVerified = _verifyCertChain(parsedQuoteCerts);
464                 if (!pckCertChainVerified) {
465                     return (false, retData);
466                 }
467             }
468     
469             // Step 8: Verify the local attestation sig and qe report sig = 670k gas
470             {
471                 bool enclaveReportSigsVerified = _enclaveReportSigVerification(
472                     parsedQuoteCerts[0].pubKey,
473                     signedQuoteData,
474                     authDataV3,
475                     v3quote.v3AuthData.pckSignedQeReport
476                 );
477                 if (!enclaveReportSigsVerified) {
478                     return (false, retData);
479                 }
480             }
481     
482             retData = abi.encodePacked(sha256(abi.encode(v3quote)), tcbStatus);
483     
484             return (_attestationTcbIsValid(tcbStatus), retData);
485         }


248         function _verifyCertChain(IPEMCertChainLib.ECSha256Certificate[] memory certs)
249             private
250             view
251             returns (bool)
252         {
253             uint256 n = certs.length;
254             bool certRevoked;
255             bool certNotExpired;
256             bool verified;
257             bool certChainCanBeTrusted;
258     
259             for (uint256 i; i < n; ++i) {
260                 IPEMCertChainLib.ECSha256Certificate memory issuer;
261                 if (i == n - 1) {
262                     // rootCA
263                     issuer = certs[i];
264                 } else {
265                     issuer = certs[i + 1];
266                     if (i == n - 2) {
267                         // this cert is expected to be signed by the root
268                         certRevoked = _serialNumIsRevoked[uint256(IPEMCertChainLib.CRL.ROOT)][certs[i]
269                             .serialNumber];
270                     } else if (certs[i].isPck) {
271                         certRevoked = _serialNumIsRevoked[uint256(IPEMCertChainLib.CRL.PCK)][certs[i]
272                             .serialNumber];
273                     }
274                     if (certRevoked) {
275                         break;
276                     }
277                 }
278     
279                 certNotExpired =
280                     block.timestamp > certs[i].notBefore && block.timestamp < certs[i].notAfter;
281                 if (!certNotExpired) {
282                     break;
283                 }
284     
285                 verified = sigVerifyLib.verifyES256Signature(
286                     certs[i].tbsCertificate, certs[i].signature, issuer.pubKey
287                 );
288                 if (!verified) {
289                     break;
290                 }
291     
292                 bytes32 issuerPubKeyHash = keccak256(issuer.pubKey);
293     
294                 if (issuerPubKeyHash == ROOTCA_PUBKEY_HASH) {
295                     certChainCanBeTrusted = true;
296                     break;
297                 }
298             }
299     
300             return !certRevoked && certNotExpired && verified && certChainCanBeTrusted;
301         }


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/AutomataDcapV3Attestation.sol#L248:301

```solidity
File: contracts/automata-attestation/lib/PEMCertChainLib.sol


74          function decodeCert(
75              bytes memory der,
76              bool isPckCert
77          )
78              external
79              pure
80              returns (bool success, ECSha256Certificate memory cert)
81          {
82              uint256 root = der.root();
83      
84              // Entering tbsCertificate sequence
85              uint256 tbsParentPtr = der.firstChildOf(root);
86      
87              // Begin iterating through the descendants of tbsCertificate
88              uint256 tbsPtr = der.firstChildOf(tbsParentPtr);
89      
90              // The Serial Number is located one element below Version
91      
92              // The issuer commonName value is contained in the Issuer sequence
93              // which is 3 elements below the first element of the tbsCertificate sequence
94      
95              // The Validity sequence is located 4 elements below the first element of the tbsCertificate
96              // sequence
97      
98              // The subject commanName value is contained in the Subject sequence
99              // which is 5 elements below the first element of the tbsCertificate sequence
100     
101             // The PublicKey is located in the second element of subjectPublicKeyInfo sequence
102             // which is 6 elements below the first element of the tbsCertificate sequence
103     
104             tbsPtr = der.nextSiblingOf(tbsPtr);
105     
106             {
107                 bytes memory serialNumBytes = der.bytesAt(tbsPtr);
108                 cert.serialNumber = serialNumBytes;
109             }
110     
111             tbsPtr = der.nextSiblingOf(tbsPtr);
112             tbsPtr = der.nextSiblingOf(tbsPtr);
113     
114             if (isPckCert) {
115                 uint256 issuerPtr = der.firstChildOf(tbsPtr);
116                 issuerPtr = der.firstChildOf(issuerPtr);
117                 issuerPtr = der.firstChildOf(issuerPtr);
118                 issuerPtr = der.nextSiblingOf(issuerPtr);
119                 cert.pck.issuerName = string(der.bytesAt(issuerPtr));
120                 bool issuerNameIsValid = LibString.eq(cert.pck.issuerName, PLATFORM_ISSUER_NAME)
121                     || LibString.eq(cert.pck.issuerName, PROCESSOR_ISSUER_NAME);
122                 if (!issuerNameIsValid) {
123                     return (false, cert);
124                 }
125             }
126     
127             tbsPtr = der.nextSiblingOf(tbsPtr);
128     
129             {
130                 uint256 notBeforePtr = der.firstChildOf(tbsPtr);
131                 uint256 notAfterPtr = der.nextSiblingOf(notBeforePtr);
132                 bytes1 notBeforeTag = der[notBeforePtr.ixs()];
133                 bytes1 notAfterTag = der[notAfterPtr.ixs()];
134                 if (
135                     (notBeforeTag != 0x17 && notBeforeTag == 0x18)
136                         || (notAfterTag != 0x17 && notAfterTag != 0x18)
137                 ) {
138                     return (false, cert);
139                 }
140                 cert.notBefore = X509DateUtils.toTimestamp(der.bytesAt(notBeforePtr));
141                 cert.notAfter = X509DateUtils.toTimestamp(der.bytesAt(notAfterPtr));
142             }
143     
144             tbsPtr = der.nextSiblingOf(tbsPtr);
145     
146             if (isPckCert) {
147                 uint256 subjectPtr = der.firstChildOf(tbsPtr);
148                 subjectPtr = der.firstChildOf(subjectPtr);
149                 subjectPtr = der.firstChildOf(subjectPtr);
150                 subjectPtr = der.nextSiblingOf(subjectPtr);
151                 cert.pck.commonName = string(der.bytesAt(subjectPtr));
152                 if (!LibString.eq(cert.pck.commonName, PCK_COMMON_NAME)) {
153                     return (false, cert);
154                 }
155             }
156     
157             tbsPtr = der.nextSiblingOf(tbsPtr);
158     
159             {
160                 // Entering subjectPublicKeyInfo sequence
161                 uint256 subjectPublicKeyInfoPtr = der.firstChildOf(tbsPtr);
162                 subjectPublicKeyInfoPtr = der.nextSiblingOf(subjectPublicKeyInfoPtr);
163     
164                 // The Signature sequence is located two sibling elements below the tbsCertificate
165                 // element
166                 uint256 sigPtr = der.nextSiblingOf(tbsParentPtr);
167                 sigPtr = der.nextSiblingOf(sigPtr);
168     
169                 // Skip three bytes to the right
170                 // the three bytes in question: 0x034700 or 0x034800 or 0x034900
171                 sigPtr = NodePtr.getPtr(sigPtr.ixs() + 3, sigPtr.ixf() + 3, sigPtr.ixl());
172     
173                 sigPtr = der.firstChildOf(sigPtr);
174                 bytes memory sigX = _trimBytes(der.bytesAt(sigPtr), 32);
175     
176                 sigPtr = der.nextSiblingOf(sigPtr);
177                 bytes memory sigY = _trimBytes(der.bytesAt(sigPtr), 32);
178     
179                 cert.tbsCertificate = der.allBytesAt(tbsParentPtr);
180                 cert.pubKey = _trimBytes(der.bytesAt(subjectPublicKeyInfoPtr), 64);
181                 cert.signature = abi.encodePacked(sigX, sigY);
182             }
183     
184             if (isPckCert) {
185                 // entering Extension sequence
186                 tbsPtr = der.nextSiblingOf(tbsPtr);
187     
188                 // check for the extension tag
189                 if (der[tbsPtr.ixs()] != 0xA3) {
190                     return (false, cert);
191                 }
192     
193                 tbsPtr = der.firstChildOf(tbsPtr);
194                 tbsPtr = der.firstChildOf(tbsPtr);
195     
196                 bool sgxExtnTraversedSuccessfully;
197                 uint256 pcesvn;
198                 uint256[] memory cpuSvns;
199                 bytes memory fmspcBytes;
200                 bytes memory pceidBytes;
201                 (sgxExtnTraversedSuccessfully, pcesvn, cpuSvns, fmspcBytes, pceidBytes) =
202                     _findPckTcbInfo(der, tbsPtr, tbsParentPtr);
203                 if (!sgxExtnTraversedSuccessfully) {
204                     return (false, cert);
205                 }
206                 cert.pck.sgxExtension.pcesvn = pcesvn;
207                 cert.pck.sgxExtension.sgxTcbCompSvnArr = cpuSvns;
208                 cert.pck.sgxExtension.pceid = LibString.toHexStringNoPrefix(pceidBytes);
209                 cert.pck.sgxExtension.fmspc = LibString.toHexStringNoPrefix(fmspcBytes);
210                 cert.isPck = true;
211             }
212     
213             success = true;
214         }


269         function _findPckTcbInfo(
270             bytes memory der,
271             uint256 tbsPtr,
272             uint256 tbsParentPtr
273         )
274             private
275             pure
276             returns (
277                 bool success,
278                 uint256 pcesvn,
279                 uint256[] memory cpusvns,
280                 bytes memory fmspcBytes,
281                 bytes memory pceidBytes
282             )
283         {
284             // iterate through the elements in the Extension sequence
285             // until we locate the SGX Extension OID
286             while (tbsPtr != 0) {
287                 uint256 internalPtr = der.firstChildOf(tbsPtr);
288                 if (der[internalPtr.ixs()] != 0x06) {
289                     return (false, pcesvn, cpusvns, fmspcBytes, pceidBytes);
290                 }
291     
292                 if (BytesUtils.compareBytes(der.bytesAt(internalPtr), SGX_EXTENSION_OID)) {
293                     // 1.2.840.113741.1.13.1
294                     internalPtr = der.nextSiblingOf(internalPtr);
295                     uint256 extnValueParentPtr = der.rootOfOctetStringAt(internalPtr);
296                     uint256 extnValuePtr = der.firstChildOf(extnValueParentPtr);
297     
298                     // Copy flags to memory to avoid stack too deep
299                     PCKTCBFlags memory flags;
300     
301                     while (!(flags.fmspcFound && flags.pceidFound && flags.tcbFound)) {
302                         uint256 extnValueOidPtr = der.firstChildOf(extnValuePtr);
303                         if (der[extnValueOidPtr.ixs()] != 0x06) {
304                             return (false, pcesvn, cpusvns, fmspcBytes, pceidBytes);
305                         }
306                         if (BytesUtils.compareBytes(der.bytesAt(extnValueOidPtr), TCB_OID)) {
307                             // 1.2.840.113741.1.13.1.2
308                             (flags.tcbFound, pcesvn, cpusvns) = _findTcb(der, extnValueOidPtr);
309                         }
310                         if (BytesUtils.compareBytes(der.bytesAt(extnValueOidPtr), PCEID_OID)) {
311                             // 1.2.840.113741.1.13.1.3
312                             uint256 pceidPtr = der.nextSiblingOf(extnValueOidPtr);
313                             pceidBytes = der.bytesAt(pceidPtr);
314                             flags.pceidFound = true;
315                         }
316                         if (BytesUtils.compareBytes(der.bytesAt(extnValueOidPtr), FMSPC_OID)) {
317                             // 1.2.840.113741.1.13.1.4
318                             uint256 fmspcPtr = der.nextSiblingOf(extnValueOidPtr);
319                             fmspcBytes = der.bytesAt(fmspcPtr);
320                             flags.fmspcFound = true;
321                         }
322     
323                         if (extnValuePtr.ixl() < extnValueParentPtr.ixl()) {
324                             extnValuePtr = der.nextSiblingOf(extnValuePtr);
325                         } else {
326                             break;
327                         }
328                     }
329                     success = flags.fmspcFound && flags.pceidFound && flags.tcbFound;
330                     break;
331                 }
332     
333                 if (tbsPtr.ixl() < tbsParentPtr.ixl()) {
334                     tbsPtr = der.nextSiblingOf(tbsPtr);
335                 } else {
336                     tbsPtr = 0; // exit
337                 }
338             }
339         }


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/PEMCertChainLib.sol#L269:339

```solidity
File: contracts/automata-attestation/utils/BytesUtils.sol


320         function base32HexDecodeWord(
321             bytes memory self,
322             uint256 off,
323             uint256 len
324         )
325             internal
326             pure
327             returns (bytes32)
328         {
329             require(len <= 52, "unexpected len");
330     
331             uint256 ret = 0;
332             uint8 decoded;
333             for (uint256 i; i < len; ++i) {
334                 bytes1 char = self[off + i];
335                 require(char >= 0x30 && char <= 0x7A, "invalid char");
336                 decoded = uint8(BASE32_HEX_TABLE[uint256(uint8(char)) - 0x30]);
337                 require(decoded <= 0x20, "invalid decoded");
338                 if (i == len - 1) {
339                     break;
340                 }
341                 ret = (ret << 5) | decoded;
342             }
343     
344             uint256 bitlen = len * 5;
345             if (len % 8 == 0) {
346                 // Multiple of 8 characters, no padding
347                 ret = (ret << 5) | decoded;
348             } else if (len % 8 == 2) {
349                 // Two extra characters - 1 byte
350                 ret = (ret << 3) | (decoded >> 2);
351                 bitlen -= 2;
352             } else if (len % 8 == 4) {
353                 // Four extra characters - 2 bytes
354                 ret = (ret << 1) | (decoded >> 4);
355                 bitlen -= 4;
356             } else if (len % 8 == 5) {
357                 // Five extra characters - 3 bytes
358                 ret = (ret << 4) | (decoded >> 1);
359                 bitlen -= 1;
360             } else if (len % 8 == 7) {
361                 // Seven extra characters - 4 bytes
362                 ret = (ret << 2) | (decoded >> 3);
363                 bitlen -= 3;
364             } else {
365                 revert("unexpected len");
366             }
367     
368             return bytes32(ret << (256 - bitlen));
369         }


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/BytesUtils.sol#L320:369

```solidity
File: contracts/automata-attestation/utils/RsaVerify.sol


212         function pkcs1Sha1(
213             bytes20 _sha1,
214             bytes memory _s,
215             bytes memory _e,
216             bytes memory _m
217         )
218             internal
219             view
220             returns (bool)
221         {
222             uint8[15] memory sha1Prefix = [
223                 0x30,
224                 0x21,
225                 0x30,
226                 0x09,
227                 0x06,
228                 0x05,
229                 0x2b,
230                 0x0e,
231                 0x03,
232                 0x02,
233                 0x1a,
234                 0x05,
235                 0x00,
236                 0x04,
237                 0x14
238             ];
239     
240             // decipher
241             bytes memory input =
242                 bytes.concat(bytes32(_s.length), bytes32(_e.length), bytes32(_m.length), _s, _e, _m);
243             uint256 inputlen = input.length;
244     
245             uint256 decipherlen = _m.length;
246             bytes memory decipher = new bytes(decipherlen);
247             assembly {
248                 pop(
249                     staticcall(
250                         sub(gas(), 2000),
251                         5,
252                         add(input, 0x20),
253                         inputlen,
254                         add(decipher, 0x20),
255                         decipherlen
256                     )
257                 )
258             }
259     
260             // Check that is well encoded:
261             // 0x00 || 0x01 || PS || 0x00 || DigestInfo
262             // PS is padding filled with 0xff
263             // DigestInfo ::= SEQUENCE {
264             //    digestAlgorithm AlgorithmIdentifier,
265             //    digest OCTET STRING
266             // }
267     
268             uint256 paddingLen = decipherlen - 3 - sha1Prefix.length - 20;
269     
270             if (decipher[0] != 0 || decipher[1] != 0x01) {
271                 return false;
272             }
273             for (uint256 i = 2; i < 2 + paddingLen; ++i) {
274                 if (decipher[i] != 0xff) {
275                     return false;
276                 }
277             }
278             if (decipher[2 + paddingLen] != 0) {
279                 return false;
280             }
281     
282             // check digest algorithm
283             for (uint256 i; i < sha1Prefix.length; ++i) {
284                 if (decipher[3 + paddingLen + i] != bytes1(sha1Prefix[i])) {
285                     return false;
286                 }
287             }
288     
289             // check digest
290             for (uint256 i; i < _sha1.length; ++i) {
291                 if (decipher[3 + paddingLen + sha1Prefix.length + i] != _sha1[i]) {
292                     return false;
293                 }
294             }
295     
296             return true;
297         }


43          function pkcs1Sha256(
44              bytes32 _sha256,
45              bytes memory _s,
46              bytes memory _e,
47              bytes memory _m
48          )
49              internal
50              view
51              returns (bool)
52          {
53              uint8[17] memory sha256ExplicitNullParam = [
54                  0x30,
55                  0x31,
56                  0x30,
57                  0x0d,
58                  0x06,
59                  0x09,
60                  0x60,
61                  0x86,
62                  0x48,
63                  0x01,
64                  0x65,
65                  0x03,
66                  0x04,
67                  0x02,
68                  0x01,
69                  0x05,
70                  0x00
71              ];
72      
73              uint8[15] memory sha256ImplicitNullParam = [
74                  0x30,
75                  0x2f,
76                  0x30,
77                  0x0b,
78                  0x06,
79                  0x09,
80                  0x60,
81                  0x86,
82                  0x48,
83                  0x01,
84                  0x65,
85                  0x03,
86                  0x04,
87                  0x02,
88                  0x01
89              ];
90      
91              // decipher
92      
93              bytes memory input =
94                  bytes.concat(bytes32(_s.length), bytes32(_e.length), bytes32(_m.length), _s, _e, _m);
95              uint256 inputlen = input.length;
96      
97              uint256 decipherlen = _m.length;
98              bytes memory decipher = new bytes(decipherlen);
99              assembly {
100                 pop(
101                     staticcall(
102                         sub(gas(), 2000),
103                         5,
104                         add(input, 0x20),
105                         inputlen,
106                         add(decipher, 0x20),
107                         decipherlen
108                     )
109                 )
110             }
111     
112             // Check that is well encoded:
113             //
114             // 0x00 || 0x01 || PS || 0x00 || DigestInfo
115             // PS is padding filled with 0xff
116             // DigestInfo ::= SEQUENCE {
117             //    digestAlgorithm AlgorithmIdentifier,
118             //      [optional algorithm parameters]
119             //    digest OCTET STRING
120             // }
121     
122             bool hasNullParam;
123             uint256 digestAlgoWithParamLen;
124     
125             if (uint8(decipher[decipherlen - 50]) == 0x31) {
126                 hasNullParam = true;
127                 digestAlgoWithParamLen = sha256ExplicitNullParam.length;
128             } else if (uint8(decipher[decipherlen - 48]) == 0x2f) {
129                 hasNullParam = false;
130                 digestAlgoWithParamLen = sha256ImplicitNullParam.length;
131             } else {
132                 return false;
133             }
134     
135             uint256 paddingLen = decipherlen - 5 - digestAlgoWithParamLen - 32;
136     
137             if (decipher[0] != 0 || decipher[1] != 0x01) {
138                 return false;
139             }
140             for (uint256 i = 2; i < 2 + paddingLen; ++i) {
141                 if (decipher[i] != 0xff) {
142                     return false;
143                 }
144             }
145             if (decipher[2 + paddingLen] != 0) {
146                 return false;
147             }
148     
149             // check digest algorithm
150     
151             if (digestAlgoWithParamLen == sha256ExplicitNullParam.length) {
152                 for (uint256 i; i < digestAlgoWithParamLen; ++i) {
153                     if (decipher[3 + paddingLen + i] != bytes1(sha256ExplicitNullParam[i])) {
154                         return false;
155                     }
156                 }
157             } else {
158                 for (uint256 i; i < digestAlgoWithParamLen; ++i) {
159                     if (decipher[3 + paddingLen + i] != bytes1(sha256ImplicitNullParam[i])) {
160                         return false;
161                     }
162                 }
163             }
164     
165             // check digest
166     
167             if (
168                 decipher[3 + paddingLen + digestAlgoWithParamLen] != 0x04
169                     || decipher[4 + paddingLen + digestAlgoWithParamLen] != 0x20
170             ) {
171                 return false;
172             }
173     
174             for (uint256 i; i < _sha256.length; ++i) {
175                 if (decipher[5 + paddingLen + digestAlgoWithParamLen + i] != _sha256[i]) {
176                     return false;
177                 }
178             }
179     
180             return true;
181         }


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/RsaVerify.sol#L43:181

```solidity
File: contracts/bridge/Bridge.sol


155         function recallMessage(
156             Message calldata _message,
157             bytes calldata _proof
158         )
159             external
160             nonReentrant
161             whenNotPaused
162             sameChain(_message.srcChainId)
163         {
164             bytes32 msgHash = hashMessage(_message);
165     
166             if (messageStatus[msgHash] != Status.NEW) revert B_STATUS_MISMATCH();
167     
168             uint64 receivedAt = proofReceipt[msgHash].receivedAt;
169             bool isMessageProven = receivedAt != 0;
170     
171             if (!isMessageProven) {
172                 address signalService = resolve("signal_service", false);
173     
174                 if (!ISignalService(signalService).isSignalSent(address(this), msgHash)) {
175                     revert B_MESSAGE_NOT_SENT();
176                 }
177     
178                 bytes32 failureSignal = signalForFailedMessage(msgHash);
179                 if (!_proveSignalReceived(signalService, failureSignal, _message.destChainId, _proof)) {
180                     revert B_NOT_FAILED();
181                 }
182     
183                 receivedAt = uint64(block.timestamp);
184                 proofReceipt[msgHash].receivedAt = receivedAt;
185             }
186     
187             (uint256 invocationDelay,) = getInvocationDelays();
188     
189             if (block.timestamp >= invocationDelay + receivedAt) {
190                 delete proofReceipt[msgHash];
191                 messageStatus[msgHash] = Status.RECALLED;
192     
193                 // Execute the recall logic based on the contract's support for the
194                 // IRecallableSender interface
195                 if (_message.from.supportsInterface(type(IRecallableSender).interfaceId)) {
196                     _storeContext(msgHash, address(this), _message.srcChainId);
197     
198                     // Perform recall
199                     IRecallableSender(_message.from).onMessageRecalled{ value: _message.value }(
200                         _message, msgHash
201                     );
202     
203                     // Must reset the context after the message call
204                     _resetContext();
205                 } else {
206                     _message.srcOwner.sendEther(_message.value);
207                 }
208                 emit MessageRecalled(msgHash);
209             } else if (!isMessageProven) {
210                 emit MessageReceived(msgHash, _message, true);
211             } else {
212                 revert B_INVOCATION_TOO_EARLY();
213             }
214         }


217         function processMessage(
218             Message calldata _message,
219             bytes calldata _proof
220         )
221             external
222             nonReentrant
223             whenNotPaused
224             sameChain(_message.destChainId)
225         {
226             bytes32 msgHash = hashMessage(_message);
227             if (messageStatus[msgHash] != Status.NEW) revert B_STATUS_MISMATCH();
228     
229             address signalService = resolve("signal_service", false);
230             uint64 receivedAt = proofReceipt[msgHash].receivedAt;
231             bool isMessageProven = receivedAt != 0;
232     
233             (uint256 invocationDelay, uint256 invocationExtraDelay) = getInvocationDelays();
234     
235             if (!isMessageProven) {
236                 if (!_proveSignalReceived(signalService, msgHash, _message.srcChainId, _proof)) {
237                     revert B_NOT_RECEIVED();
238                 }
239     
240                 receivedAt = uint64(block.timestamp);
241     
242                 if (invocationDelay != 0) {
243                     proofReceipt[msgHash] = ProofReceipt({
244                         receivedAt: receivedAt,
245                         preferredExecutor: _message.gasLimit == 0 ? _message.destOwner : msg.sender
246                     });
247                 }
248             }
249     
250             if (invocationDelay != 0 && msg.sender != proofReceipt[msgHash].preferredExecutor) {
251                 // If msg.sender is not the one that proved the message, then there
252                 // is an extra delay.
253                 unchecked {
254                     invocationDelay += invocationExtraDelay;
255                 }
256             }
257     
258             if (block.timestamp >= invocationDelay + receivedAt) {
259                 // If the gas limit is set to zero, only the owner can process the message.
260                 if (_message.gasLimit == 0 && msg.sender != _message.destOwner) {
261                     revert B_PERMISSION_DENIED();
262                 }
263     
264                 delete proofReceipt[msgHash];
265     
266                 uint256 refundAmount;
267     
268                 // Process message differently based on the target address
269                 if (
270                     _message.to == address(0) || _message.to == address(this)
271                         || _message.to == signalService || addressBanned[_message.to]
272                 ) {
273                     // Handle special addresses that don't require actual invocation but
274                     // mark message as DONE
275                     refundAmount = _message.value;
276                     _updateMessageStatus(msgHash, Status.DONE);
277                 } else {
278                     // Use the specified message gas limit if called by the owner, else
279                     // use remaining gas
280                     uint256 gasLimit = msg.sender == _message.destOwner ? gasleft() : _message.gasLimit;
281     
282                     if (_invokeMessageCall(_message, msgHash, gasLimit)) {
283                         _updateMessageStatus(msgHash, Status.DONE);
284                     } else {
285                         _updateMessageStatus(msgHash, Status.RETRIABLE);
286                     }
287                 }
288     
289                 // Determine the refund recipient
290                 address refundTo =
291                     _message.refundTo == address(0) ? _message.destOwner : _message.refundTo;
292     
293                 // Refund the processing fee
294                 if (msg.sender == refundTo) {
295                     refundTo.sendEther(_message.fee + refundAmount);
296                 } else {
297                     // If sender is another address, reward it and refund the rest
298                     msg.sender.sendEther(_message.fee);
299                     refundTo.sendEther(refundAmount);
300                 }
301                 emit MessageExecuted(msgHash);
302             } else if (!isMessageProven) {
303                 emit MessageReceived(msgHash, _message, false);
304             } else {
305                 revert B_INVOCATION_TOO_EARLY();
306             }
307         }


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/Bridge.sol#L217:307

```solidity
File: contracts/signal/SignalService.sol


83          function proveSignalReceived(
84              uint64 _chainId,
85              address _app,
86              bytes32 _signal,
87              bytes calldata _proof
88          )
89              public
90              virtual
91              validSender(_app)
92              nonZeroValue(_signal)
93          {
94              HopProof[] memory hopProofs = abi.decode(_proof, (HopProof[]));
95              if (hopProofs.length == 0) revert SS_EMPTY_PROOF();
96      
97              uint64 chainId = _chainId;
98              address app = _app;
99              bytes32 signal = _signal;
100             bytes32 value = _signal;
101             address signalService = resolve(chainId, "signal_service", false);
102     
103             HopProof memory hop;
104             for (uint256 i; i < hopProofs.length; ++i) {
105                 hop = hopProofs[i];
106     
107                 bytes32 signalRoot = _verifyHopProof(chainId, app, signal, value, hop, signalService);
108                 bool isLastHop = i == hopProofs.length - 1;
109     
110                 if (isLastHop) {
111                     if (hop.chainId != block.chainid) revert SS_INVALID_LAST_HOP_CHAINID();
112                     signalService = address(this);
113                 } else {
114                     if (hop.chainId == 0 || hop.chainId == block.chainid) {
115                         revert SS_INVALID_MID_HOP_CHAINID();
116                     }
117                     signalService = resolve(hop.chainId, "signal_service", false);
118                 }
119     
120                 bool isFullProof = hop.accountProof.length > 0;
121     
122                 _cacheChainData(hop, chainId, hop.blockId, signalRoot, isFullProof, isLastHop);
123     
124                 bytes32 kind = isFullProof ? LibSignals.STATE_ROOT : LibSignals.SIGNAL_ROOT;
125                 signal = signalForChainData(chainId, kind, hop.blockId);
126                 value = hop.rootHash;
127                 chainId = hop.chainId;
128                 app = signalService;
129             }
130     
131             if (value == 0 || value != _loadSignalValue(address(this), signal)) {
132                 revert SS_SIGNAL_NOT_FOUND();
133             }
134         }


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/signal/SignalService.sol#L83:134

```solidity
File: contracts/thirdparty/optimism/trie/MerkleTrie.sol


68          function get(
69              bytes memory _key,
70              bytes[] memory _proof,
71              bytes32 _root
72          )
73              internal
74              pure
75              returns (bytes memory value_)
76          {
77              require(_key.length > 0, "MerkleTrie: empty key");
78      
79              TrieNode[] memory proof = _parseProof(_proof);
80              bytes memory key = Bytes.toNibbles(_key);
81              bytes memory currentNodeID = abi.encodePacked(_root);
82              uint256 currentKeyIndex = 0;
83      
84              // Proof is top-down, so we start at the first element (root).
85              for (uint256 i = 0; i < proof.length; i++) {
86                  TrieNode memory currentNode = proof[i];
87      
88                  // Key index should never exceed total key length or we'll be out of bounds.
89                  require(currentKeyIndex <= key.length, "MerkleTrie: key index exceeds total key length");
90      
91                  if (currentKeyIndex == 0) {
92                      // First proof element is always the root node.
93                      require(
94                          Bytes.equal(abi.encodePacked(keccak256(currentNode.encoded)), currentNodeID),
95                          "MerkleTrie: invalid root hash"
96                      );
97                  } else if (currentNode.encoded.length >= 32) {
98                      // Nodes 32 bytes or larger are hashed inside branch nodes.
99                      require(
100                         Bytes.equal(abi.encodePacked(keccak256(currentNode.encoded)), currentNodeID),
101                         "MerkleTrie: invalid large internal hash"
102                     );
103                 } else {
104                     // Nodes smaller than 32 bytes aren't hashed.
105                     require(
106                         Bytes.equal(currentNode.encoded, currentNodeID),
107                         "MerkleTrie: invalid internal node hash"
108                     );
109                 }
110     
111                 if (currentNode.decoded.length == BRANCH_NODE_LENGTH) {
112                     if (currentKeyIndex == key.length) {
113                         // Value is the last element of the decoded list (for branch nodes). There's
114                         // some ambiguity in the Merkle trie specification because bytes(0) is a
115                         // valid value to place into the trie, but for branch nodes bytes(0) can exist
116                         // even when the value wasn't explicitly placed there. Geth treats a value of
117                         // bytes(0) as "key does not exist" and so we do the same.
118                         value_ = RLPReader.readBytes(currentNode.decoded[TREE_RADIX]);
119                         require(
120                             value_.length > 0,
121                             "MerkleTrie: value length must be greater than zero (branch)"
122                         );
123     
124                         // Extra proof elements are not allowed.
125                         require(
126                             i == proof.length - 1,
127                             "MerkleTrie: value node must be last node in proof (branch)"
128                         );
129     
130                         return value_;
131                     } else {
132                         // We're not at the end of the key yet.
133                         // Figure out what the next node ID should be and continue.
134                         uint8 branchKey = uint8(key[currentKeyIndex]);
135                         RLPReader.RLPItem memory nextNode = currentNode.decoded[branchKey];
136                         currentNodeID = _getNodeID(nextNode);
137                         currentKeyIndex += 1;
138                     }
139                 } else if (currentNode.decoded.length == LEAF_OR_EXTENSION_NODE_LENGTH) {
140                     bytes memory path = _getNodePath(currentNode);
141                     uint8 prefix = uint8(path[0]);
142                     uint8 offset = 2 - (prefix % 2);
143                     bytes memory pathRemainder = Bytes.slice(path, offset);
144                     bytes memory keyRemainder = Bytes.slice(key, currentKeyIndex);
145                     uint256 sharedNibbleLength = _getSharedNibbleLength(pathRemainder, keyRemainder);
146     
147                     // Whether this is a leaf node or an extension node, the path remainder MUST be a
148                     // prefix of the key remainder (or be equal to the key remainder) or the proof is
149                     // considered invalid.
150                     require(
151                         pathRemainder.length == sharedNibbleLength,
152                         "MerkleTrie: path remainder must share all nibbles with key"
153                     );
154     
155                     if (prefix == PREFIX_LEAF_EVEN || prefix == PREFIX_LEAF_ODD) {
156                         // Prefix of 2 or 3 means this is a leaf node. For the leaf node to be valid,
157                         // the key remainder must be exactly equal to the path remainder. We already
158                         // did the necessary byte comparison, so it's more efficient here to check that
159                         // the key remainder length equals the shared nibble length, which implies
160                         // equality with the path remainder (since we already did the same check with
161                         // the path remainder and the shared nibble length).
162                         require(
163                             keyRemainder.length == sharedNibbleLength,
164                             "MerkleTrie: key remainder must be identical to path remainder"
165                         );
166     
167                         // Our Merkle Trie is designed specifically for the purposes of the Ethereum
168                         // state trie. Empty values are not allowed in the state trie, so we can safely
169                         // say that if the value is empty, the key should not exist and the proof is
170                         // invalid.
171                         value_ = RLPReader.readBytes(currentNode.decoded[1]);
172                         require(
173                             value_.length > 0,
174                             "MerkleTrie: value length must be greater than zero (leaf)"
175                         );
176     
177                         // Extra proof elements are not allowed.
178                         require(
179                             i == proof.length - 1,
180                             "MerkleTrie: value node must be last node in proof (leaf)"
181                         );
182     
183                         return value_;
184                     } else if (prefix == PREFIX_EXTENSION_EVEN || prefix == PREFIX_EXTENSION_ODD) {
185                         // Prefix of 0 or 1 means this is an extension node. We move onto the next node
186                         // in the proof and increment the key index by the length of the path remainder
187                         // which is equal to the shared nibble length.
188                         currentNodeID = _getNodeID(currentNode.decoded[1]);
189                         currentKeyIndex += sharedNibbleLength;
190                     } else {
191                         revert("MerkleTrie: received a node with an unknown prefix");
192                     }
193                 } else {
194                     revert("MerkleTrie: received an unparseable node");
195                 }
196             }
197     
198             revert("MerkleTrie: ran out of proof elements");
199         }


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/trie/MerkleTrie.sol#L68:199

</details>

## NC066 - Use of override is unnecessary:

Starting with Solidity version 0.8.8, using the override keyword when the function solely overrides an interface function, and the function doesn't exist in multiple base contracts, is unnecessary.


<details>
<summary>Click to show 63 findings</summary>

```solidity
File: contracts/L1/TaikoL1.sol


    function unpause() public override {
        super.unpause(); // permission checked inside
        state.slotB.lastUnpausedAt = uint64(block.timestamp);
    }

    function getConfig() public view virtual override returns (TaikoData.Config memory) {
        // All hard-coded configurations:
        // - treasury: the actual TaikoL2 address.
        // - anchorGasLimit: 250_000 (based on internal devnet, its ~220_000
        // after 256 L2 blocks)
        return TaikoData.Config({
            chainId: 167_008,
            // Assume the block time is 3s, the protocol will allow ~1 month of
            // new blocks without any verification.
            blockMaxProposals: 864_000,
            blockRingBufferSize: 864_100,
            // Can be overridden by the tier config.
            maxBlocksToVerifyPerProposal: 10,
            blockMaxGasLimit: 15_000_000,
            // Each go-ethereum transaction has a size limit of 128KB,
            // and right now txList is still saved in calldata, so we set it
            // to 120KB.
            blockMaxTxListBytes: 120_000,
            blobExpiry: 24 hours,
            blobAllowedForDA: false,
            blobReuseEnabled: false,
            livenessBond: 250e18, // 250 Taiko token
            // ETH deposit related.
            ethDepositRingBufferSize: 1024,
            ethDepositMinCountPerBlock: 8,
            ethDepositMaxCountPerBlock: 32,
            ethDepositMinAmount: 1 ether,
            ethDepositMaxAmount: 10_000 ether,
            ethDepositGas: 21_000,
            ethDepositMaxFee: 1 ether / 10,
            blockSyncThreshold: 16
        });
    }

    function _authorizePause(address)
        internal
        view
        virtual
        override
        onlyFromOwnerOrNamed("chain_pauser")
    { }

```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/TaikoL1.sol#L220:226

```solidity
File: contracts/L2/TaikoL2EIP1559Configurable.sol


    function getConfig() public view override returns (Config memory) {
        return customConfig;
    }

```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/TaikoL2EIP1559Configurable.sol#L43:45

```solidity
File: contracts/bridge/Bridge.sol


    function _authorizePause(address)
        internal
        view
        virtual
        override
        onlyFromOwnerOrNamed("bridge_pauser")
    { }

    function sendMessage(Message calldata _message)
        external
        payable
        override
        nonReentrant
        whenNotPaused
        returns (bytes32 msgHash_, Message memory message_)
    {
        // Ensure the message owner is not null.
        if (_message.srcOwner == address(0) || _message.destOwner == address(0)) {
            revert B_INVALID_USER();
        }

        // Check if the destination chain is enabled.
        (bool destChainEnabled,) = isDestChainEnabled(_message.destChainId);

        // Verify destination chain and to address.
        if (!destChainEnabled) revert B_INVALID_CHAINID();
        if (_message.destChainId == block.chainid) {
            revert B_INVALID_CHAINID();
        }

        // Ensure the sent value matches the expected amount.
        uint256 expectedAmount = _message.value + _message.fee;
        if (expectedAmount != msg.value) revert B_INVALID_VALUE();

        message_ = _message;

        // Configure message details and send signal to indicate message sending.
        message_.id = nextMessageId++;
        message_.from = msg.sender;
        message_.srcChainId = uint64(block.chainid);

        msgHash_ = hashMessage(message_);

        ISignalService(resolve("signal_service", false)).sendSignal(msgHash_);
        emit MessageSent(msgHash_, message_);
    }

```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/Bridge.sol#L115:152

```solidity
File: contracts/common/AddressManager.sol


    function _authorizePause(address) internal pure override {
        revert AM_UNSUPPORTED();
    }

    function getAddress(uint64 _chainId, bytes32 _name) public view override returns (address) {
        return __addresses[_chainId][_name];
    }

```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/common/AddressManager.sol#L54:56

```solidity
File: contracts/signal/SignalService.sol


    function _authorizePause(address) internal pure override {
        revert SS_UNSUPPORTED();
    }

```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/signal/SignalService.sol#L231:233

```solidity
File: contracts/L1/TaikoToken.sol


    function transfer(address _to, uint256 _amount) public override returns (bool) {
        if (_to == address(this)) revert TKO_INVALID_ADDR();
        return super.transfer(_to, _amount);
    }

    function transferFrom(
        address _from,
        address _to,
        uint256 _amount
    )
        public
        override
        returns (bool)
    {
        if (_to == address(this)) revert TKO_INVALID_ADDR();
        return super.transferFrom(_from, _to, _amount);
    }

    function _beforeTokenTransfer(
        address _from,
        address _to,
        uint256 _amount
    )
        internal
        override(ERC20Upgradeable, ERC20SnapshotUpgradeable)
    {
        super._beforeTokenTransfer(_from, _to, _amount);
    }

    function _afterTokenTransfer(
        address _from,
        address _to,
        uint256 _amount
    )
        internal
        override(ERC20Upgradeable, ERC20VotesUpgradeable)
    {
        super._afterTokenTransfer(_from, _to, _amount);
    }

    function _mint(
        address _to,
        uint256 _amount
    )
        internal
        override(ERC20Upgradeable, ERC20VotesUpgradeable)
    {
        super._mint(_to, _amount);
    }

    function _burn(
        address _from,
        uint256 _amount
    )
        internal
        override(ERC20Upgradeable, ERC20VotesUpgradeable)
    {
        super._burn(_from, _amount);
    }

```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/TaikoToken.sol#L115:123

```solidity
File: contracts/tokenvault/BridgedERC1155.sol


    function _beforeTokenTransfer(
        address, /*_operator*/
        address, /*_from*/
        address _to,
        uint256[] memory, /*_ids*/
        uint256[] memory, /*_amounts*/
        bytes memory /*_data*/
    )
        internal
        virtual
        override
    {
        if (_to == address(this)) revert BTOKEN_CANNOT_RECEIVE();
        if (paused()) revert INVALID_PAUSE_STATUS();
    }

```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC1155.sol#L125:139

```solidity
File: contracts/tokenvault/BridgedERC20.sol


    function _beforeTokenTransfer(
        address _from,
        address _to,
        uint256 _amount
    )
        internal
        override(ERC20Upgradeable, ERC20SnapshotUpgradeable)
    {
        if (_to == address(this)) revert BTOKEN_CANNOT_RECEIVE();
        if (paused()) revert INVALID_PAUSE_STATUS();
        super._beforeTokenTransfer(_from, _to, _amount);
    }

    function _afterTokenTransfer(
        address _from,
        address _to,
        uint256 _amount
    )
        internal
        override(ERC20Upgradeable, ERC20VotesUpgradeable)
    {
        super._afterTokenTransfer(_from, _to, _amount);
    }

    function _mint(
        address _to,
        uint256 _amount
    )
        internal
        override(ERC20Upgradeable, ERC20VotesUpgradeable)
    {
        super._mint(_to, _amount);
    }

    function _burn(
        address _from,
        uint256 _amount
    )
        internal
        override(ERC20Upgradeable, ERC20VotesUpgradeable)
    {
        super._burn(_from, _amount);
    }

    function name()
        public
        view
        override(ERC20Upgradeable, IERC20MetadataUpgradeable)
        returns (string memory)
    {
        return LibBridgedToken.buildName(super.name(), srcChainId);
    }

    function symbol()
        public
        view
        override(ERC20Upgradeable, IERC20MetadataUpgradeable)
        returns (string memory)
    {
        return LibBridgedToken.buildSymbol(super.symbol());
    }

    function decimals()
        public
        view
        override(ERC20Upgradeable, IERC20MetadataUpgradeable)
        returns (uint8)
    {
        return __srcDecimals;
    }

    function _mintToken(address _account, uint256 _amount) internal override {
        _mint(_account, _amount);
    }

    function _burnToken(address _from, uint256 _amount) internal override {
        _burn(_from, _amount);
    }

```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC20.sol#L133:135

```solidity
File: contracts/tokenvault/BridgedERC721.sol


    function _beforeTokenTransfer(
        address, /*_from*/
        address _to,
        uint256, /*_firstTokenId*/
        uint256 /*_batchSize*/
    )
        internal
        virtual
        override
    {
        if (_to == address(this)) revert BTOKEN_CANNOT_RECEIVE();
        if (paused()) revert INVALID_PAUSE_STATUS();
    }

    function name() public view override(ERC721Upgradeable) returns (string memory) {
        return LibBridgedToken.buildName(super.name(), srcChainId);
    }

    function symbol() public view override(ERC721Upgradeable) returns (string memory) {
        return LibBridgedToken.buildSymbol(super.symbol());
    }

    function tokenURI(uint256 _tokenId) public view virtual override returns (string memory) {
        return string(
            abi.encodePacked(
                LibBridgedToken.buildURI(srcToken, srcChainId), Strings.toString(_tokenId)
            )
        );
    }

```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC721.sol#L107:113

```solidity
File: contracts/L1/gov/TaikoGovernor.sol


    function propose(
        address[] memory _targets,
        uint256[] memory _values,
        bytes[] memory _calldatas,
        string memory _description
    )
        public
        override(IGovernorUpgradeable, GovernorUpgradeable, GovernorCompatibilityBravoUpgradeable)
        returns (uint256)
    {
        return super.propose(_targets, _values, _calldatas, _description);
    }

    function propose(
        address[] memory _targets,
        uint256[] memory _values,
        string[] memory _signatures,
        bytes[] memory _calldatas,
        string memory _description
    )
        public
        virtual
        override(GovernorCompatibilityBravoUpgradeable)
        returns (uint256)
    {
        if (_signatures.length != _calldatas.length) revert TG_INVALID_SIGNATURES_LENGTH();

        return GovernorCompatibilityBravoUpgradeable.propose(
            _targets, _values, _signatures, _calldatas, _description
        );
    }

    function supportsInterface(bytes4 _interfaceId)
        public
        view
        override(GovernorUpgradeable, GovernorTimelockControlUpgradeable, IERC165Upgradeable)
        returns (bool)
    {
        return super.supportsInterface(_interfaceId);
    }

    function state(uint256 _proposalId)
        public
        view
        override(IGovernorUpgradeable, GovernorUpgradeable, GovernorTimelockControlUpgradeable)
        returns (ProposalState)
    {
        return super.state(_proposalId);
    }

    function votingDelay() public pure override returns (uint256) {
        return 7200; // 1 day
    }

    function votingPeriod() public pure override returns (uint256) {
        return 50_400; // 1 week
    }

    function proposalThreshold() public pure override returns (uint256) {
        return 1_000_000_000 ether / 10_000; // 0.01% of Taiko Token
    }

    function _execute(
        uint256 _proposalId,
        address[] memory _targets,
        uint256[] memory _values,
        bytes[] memory _calldatas,
        bytes32 _descriptionHash
    )
        internal
        override(GovernorUpgradeable, GovernorTimelockControlUpgradeable)
    {
        super._execute(_proposalId, _targets, _values, _calldatas, _descriptionHash);
    }

    function _cancel(
        address[] memory _targets,
        uint256[] memory _values,
        bytes[] memory _calldatas,
        bytes32 _descriptionHash
    )
        internal
        override(GovernorUpgradeable, GovernorTimelockControlUpgradeable)
        returns (uint256)
    {
        return super._cancel(_targets, _values, _calldatas, _descriptionHash);
    }

    function _executor()
        internal
        view
        override(GovernorUpgradeable, GovernorTimelockControlUpgradeable)
        returns (address)
    {
        return super._executor();
    }

```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/gov/TaikoGovernor.sol#L153:160

```solidity
File: contracts/tokenvault/BaseVault.sol


    function supportsInterface(bytes4 _interfaceId) public view virtual override returns (bool) {
        return _interfaceId == type(IRecallableSender).interfaceId;
    }

```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BaseVault.sol#L39:41

```solidity
File: contracts/tokenvault/ERC1155Vault.sol


    function supportsInterface(bytes4 interfaceId)
        public
        view
        virtual
        override(BaseVault, ERC1155ReceiverUpgradeable)
        returns (bool)
    {
        return interfaceId == type(ERC1155ReceiverUpgradeable).interfaceId
            || BaseVault.supportsInterface(interfaceId);
    }

    function name() public pure override returns (bytes32) {
        return "erc1155_vault";
    }

    function onMessageRecalled(
        IBridge.Message calldata message,
        bytes32 msgHash
    )
        external
        payable
        override
        nonReentrant
        whenNotPaused
    {
        // `onlyFromBridge` checked in checkRecallMessageContext
        checkRecallMessageContext();

        (bytes memory data) = abi.decode(message.data[4:], (bytes));
        (CanonicalNFT memory ctoken,,, uint256[] memory tokenIds, uint256[] memory amounts) =
            abi.decode(data, (CanonicalNFT, address, address, uint256[], uint256[]));

        // Transfer the ETH and tokens back to the owner
        address token = _transferTokens(ctoken, message.srcOwner, tokenIds, amounts);
        message.srcOwner.sendEther(message.value);

        // Emit TokenReleased event
        emit TokenReleased({
            msgHash: msgHash,
            from: message.srcOwner,
            ctoken: ctoken.addr,
            token: token,
            tokenIds: tokenIds,
            amounts: amounts
        });
    }

```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC1155Vault.sol#L127:157

```solidity
File: contracts/L1/gov/TaikoTimelockController.sol


    function getMinDelay() public view override returns (uint256) {
        return hasRole(TIMELOCK_ADMIN_ROLE, msg.sender) ? 0 : super.getMinDelay();
    }

```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/gov/TaikoTimelockController.sol#L24:26

```solidity
File: contracts/L1/tiers/DevnetTierProvider.sol


    function getTier(uint16 _tierId) public pure override returns (ITierProvider.Tier memory) {
        if (_tierId == LibTiers.TIER_OPTIMISTIC) {
            return ITierProvider.Tier({
                verifierName: "tier_optimistic",
                validityBond: 250 ether, // TKO
                contestBond: 500 ether, // TKO
                cooldownWindow: 1440, //24 hours
                provingWindow: 120, // 2 hours
                maxBlocksToVerifyPerProof: 16
            });
        }

        if (_tierId == LibTiers.TIER_GUARDIAN) {
            return ITierProvider.Tier({
                verifierName: "tier_guardian",
                validityBond: 0, // must be 0 for top tier
                contestBond: 0, // must be 0 for top tier
                cooldownWindow: 60, //1 hours
                provingWindow: 2880, // 48 hours
                maxBlocksToVerifyPerProof: 16
            });
        }

        revert TIER_NOT_FOUND();
    }

    function getTierIds() public pure override returns (uint16[] memory tiers_) {
        tiers_ = new uint16[](2);
        tiers_[0] = LibTiers.TIER_OPTIMISTIC;
        tiers_[1] = LibTiers.TIER_GUARDIAN;
    }

    function getMinTier(uint256) public pure override returns (uint16) {
        return LibTiers.TIER_OPTIMISTIC;
    }

```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/tiers/DevnetTierProvider.sol#L54:56

```solidity
File: contracts/L1/tiers/MainnetTierProvider.sol


    function getTier(uint16 _tierId) public pure override returns (ITierProvider.Tier memory) {
        if (_tierId == LibTiers.TIER_SGX) {
            return ITierProvider.Tier({
                verifierName: "tier_sgx",
                validityBond: 250 ether, // TKO
                contestBond: 500 ether, // TKO
                cooldownWindow: 1440, //24 hours
                provingWindow: 60, // 1 hours
                maxBlocksToVerifyPerProof: 8
            });
        }

        if (_tierId == LibTiers.TIER_SGX_ZKVM) {
            return ITierProvider.Tier({
                verifierName: "tier_sgx_zkvm",
                validityBond: 500 ether, // TKO
                contestBond: 1000 ether, // TKO
                cooldownWindow: 1440, //24 hours
                provingWindow: 240, // 4 hours
                maxBlocksToVerifyPerProof: 4
            });
        }

        if (_tierId == LibTiers.TIER_GUARDIAN) {
            return ITierProvider.Tier({
                verifierName: "tier_guardian",
                validityBond: 0, // must be 0 for top tier
                contestBond: 0, // must be 0 for top tier
                cooldownWindow: 60, //1 hours
                provingWindow: 2880, // 48 hours
                maxBlocksToVerifyPerProof: 16
            });
        }

        revert TIER_NOT_FOUND();
    }

    function getTierIds() public pure override returns (uint16[] memory tiers_) {
        tiers_ = new uint16[](3);
        tiers_[0] = LibTiers.TIER_SGX;
        tiers_[1] = LibTiers.TIER_SGX_ZKVM;
        tiers_[2] = LibTiers.TIER_GUARDIAN;
    }

    function getMinTier(uint256 _rand) public pure override returns (uint16) {
        // 0.1% require SGX + ZKVM; all others require SGX
        if (_rand % 1000 == 0) return LibTiers.TIER_SGX_ZKVM;
        else return LibTiers.TIER_SGX;
    }

```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/tiers/MainnetTierProvider.sol#L66:70

```solidity
File: contracts/L1/tiers/TestnetTierProvider.sol


    function getTier(uint16 _tierId) public pure override returns (ITierProvider.Tier memory) {
        if (_tierId == LibTiers.TIER_OPTIMISTIC) {
            return ITierProvider.Tier({
                verifierName: "tier_optimistic",
                validityBond: 250 ether, // TKO
                contestBond: 500 ether, // TKO
                cooldownWindow: 1440, //24 hours
                provingWindow: 30, // 0.5 hours
                maxBlocksToVerifyPerProof: 12
            });
        }

        if (_tierId == LibTiers.TIER_SGX) {
            return ITierProvider.Tier({
                verifierName: "tier_sgx",
                validityBond: 500 ether, // TKO
                contestBond: 1000 ether, // TKO
                cooldownWindow: 1440, //24 hours
                provingWindow: 60, // 1 hours
                maxBlocksToVerifyPerProof: 8
            });
        }

        if (_tierId == LibTiers.TIER_GUARDIAN) {
            return ITierProvider.Tier({
                verifierName: "tier_guardian",
                validityBond: 0, // must be 0 for top tier
                contestBond: 0, // must be 0 for top tier
                cooldownWindow: 60, //1 hours
                provingWindow: 2880, // 48 hours
                maxBlocksToVerifyPerProof: 16
            });
        }

        revert TIER_NOT_FOUND();
    }

    function getTierIds() public pure override returns (uint16[] memory tiers_) {
        tiers_ = new uint16[](3);
        tiers_[0] = LibTiers.TIER_OPTIMISTIC;
        tiers_[1] = LibTiers.TIER_SGX;
        tiers_[2] = LibTiers.TIER_GUARDIAN;
    }

    function getMinTier(uint256 _rand) public pure override returns (uint16) {
        // 10% will be selected to require SGX proofs.
        if (_rand % 10 == 0) return LibTiers.TIER_SGX;
        // Other blocks are optimistic, without validity proofs.
        return LibTiers.TIER_OPTIMISTIC;
    }

```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/tiers/TestnetTierProvider.sol#L66:71

```solidity
File: contracts/automata-attestation/AutomataDcapV3Attestation.sol


    function verifyAttestation(bytes calldata data) external view override returns (bool) {
        (bool success,) = _verify(data);
        return success;
    }

    function verifyParsedQuote(V3Struct.ParsedV3QuoteStruct calldata v3quote)
        external
        view
        override
        returns (bool, bytes memory)
    {
        return _verifyParsedQuote(v3quote);
    }

```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/AutomataDcapV3Attestation.sol#L355:362

```solidity
File: contracts/common/EssentialContract.sol


    function _authorizeUpgrade(address) internal virtual override onlyOwner { }

```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/common/EssentialContract.sol#L114:114

```solidity
File: contracts/tokenvault/ERC20Vault.sol


    function name() public pure override returns (bytes32) {
        return "erc20_vault";
    }

    function onMessageRecalled(
        IBridge.Message calldata _message,
        bytes32 _msgHash
    )
        external
        payable
        override
        nonReentrant
        whenNotPaused
    {
        // `onlyFromBridge` checked in checkRecallMessageContext
        checkRecallMessageContext();

        (bytes memory data) = abi.decode(_message.data[4:], (bytes));
        (CanonicalERC20 memory ctoken,,, uint256 amount) =
            abi.decode(data, (CanonicalERC20, address, address, uint256));

        // Transfer the ETH and tokens back to the owner
        address token = _transferTokens(ctoken, _message.srcOwner, amount);
        _message.srcOwner.sendEther(_message.value);

        emit TokenReleased({
            msgHash: _msgHash,
            from: _message.srcOwner,
            ctoken: ctoken.addr,
            token: token,
            amount: amount
        });
    }

```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC20Vault.sol#L285:313

```solidity
File: contracts/tokenvault/ERC721Vault.sol


    function name() public pure override returns (bytes32) {
        return "erc721_vault";
    }

    function onMessageRecalled(
        IBridge.Message calldata _message,
        bytes32 _msgHash
    )
        external
        payable
        override
        nonReentrant
        whenNotPaused
    {
        // `onlyFromBridge` checked in checkRecallMessageContext
        checkRecallMessageContext();

        (bytes memory data) = abi.decode(_message.data[4:], (bytes));
        (CanonicalNFT memory ctoken,,, uint256[] memory tokenIds) =
            abi.decode(data, (CanonicalNFT, address, address, uint256[]));

        // Transfer the ETH and tokens back to the owner
        address token = _transferTokens(ctoken, _message.srcOwner, tokenIds);
        _message.srcOwner.sendEther(_message.value);

        emit TokenReleased({
            msgHash: _msgHash,
            from: _message.srcOwner,
            ctoken: ctoken.addr,
            token: token,
            tokenIds: tokenIds,
            amounts: new uint256[](tokenIds.length)
        });
    }

```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC721Vault.sol#L110:139

```solidity
File: contracts/tokenvault/adapters/USDCAdapter.sol


    function _mintToken(address _account, uint256 _amount) internal override {
        usdc.mint(_account, _amount);
    }

    function _burnToken(address _from, uint256 _amount) internal override {
        usdc.transferFrom(_from, address(this), _amount);
        usdc.burn(_amount);
    }

```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/adapters/USDCAdapter.sol#L47:50

```solidity
File: contracts/tokenvault/BridgedERC20Base.sol


    function owner() public view override(IBridgedERC20, OwnableUpgradeable) returns (address) {
        return super.owner();
    }

```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC20Base.sol#L93:95

</details>

## NC067 - Unused import:

The identifier is imported but never used within the file


```solidity
File: contracts/automata-attestation/AutomataDcapV3Attestation.sol


4       import { V3Struct } from "./lib/QuoteV3Auth/V3Struct.sol";


13      import { Base64 } from "solady/src/utils/Base64.sol";


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/AutomataDcapV3Attestation.sol#L13:13

```solidity
File: contracts/automata-attestation/interfaces/IAttestation.sol


4       import { V3Struct } from "../lib/QuoteV3Auth/V3Struct.sol";


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/interfaces/IAttestation.sol#L4:4

## NC068 - Use `string.concat()` on strings instead of `abi.encodePacked()` for clearer semantic meaning:

Starting with version 0.8.12, Solidity has the `string.concat()` function, which allows one to concatenate a list of strings, without extra padding. Using this function rather than `abi.encodePacked()` makes the intended operation more clear, leading to less reviewer confusion.


<details>
<summary>Click to show 8 findings</summary>

```solidity
File: contracts/automata-attestation/AutomataDcapV3Attestation.sol


163             bytes memory retData = abi.encodePacked(INVALID_EXIT_CODE);


369             bytes memory retData = abi.encodePacked(INVALID_EXIT_CODE);


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/AutomataDcapV3Attestation.sol#L369:369

```solidity
File: contracts/libs/LibTrieProof.sol


48                      SecureMerkleTrie.get(abi.encodePacked(_addr), _accountProof, _rootHash);


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/libs/LibTrieProof.sol#L48:48

```solidity
File: contracts/thirdparty/optimism/rlp/RLPWriter.sol


56              bytes memory b = abi.encodePacked(_x);


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/rlp/RLPWriter.sol#L56:56

```solidity
File: contracts/thirdparty/optimism/trie/MerkleTrie.sol


81              bytes memory currentNodeID = abi.encodePacked(_root);


94                          Bytes.equal(abi.encodePacked(keccak256(currentNode.encoded)), currentNodeID),


100                         Bytes.equal(abi.encodePacked(keccak256(currentNode.encoded)), currentNodeID),


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/trie/MerkleTrie.sol#L100:100

```solidity
File: contracts/thirdparty/optimism/trie/SecureMerkleTrie.sol


55              hash_ = abi.encodePacked(keccak256(_key));


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/trie/SecureMerkleTrie.sol#L55:55

</details>

## NC069 - Unsafe conversion from unsigned to signed values:

Solidity follows [two's complement](https://en.wikipedia.org/wiki/Two%27s_complement) rules for its integers, meaning that the most significant bit for signed integers is used to denote the sign, and converting between the two requires inverting all of the bits and adding one. Because of this, casting an unsigned integer to a signed one may result in a change of the sign and or magnitude of the value. For example, `int8(type(uint8).max)` is not equal to `type(int8).max`, but is equal to `-1`. `type(uint8).max` in binary is `11111111`, which if cast to a signed value, means the first binary `1` indicates a negative value, and the binary `1`s, invert to all zeroes, and when one is added, it becomes one, but negative, and therefore the decimal value of binary `11111111` is `-1`.


```solidity
File: contracts/L2/Lib1559Math.sol


45              return uint256(LibFixedPointMath.exp(int256(input)));


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/Lib1559Math.sol#L45:45

```solidity
File: contracts/automata-attestation/utils/BytesUtils.sol


104             return int256(len) - int256(otherlen);


97                          return int256(diff);


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/BytesUtils.sol#L97:97

## NC070 - Put all system-wide constants in one file:

Putting all the system-wide constants in a single file improves code readability, makes it easier to understand the basic configuration and limitations of the system, and makes maintenance easier.


<details>
<summary>Click to show 23 findings</summary>

```solidity
File: contracts/L1/hooks/AssignmentHook.sol


38          uint256 public constant MAX_GAS_PAYING_PROVER = 50_000;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/hooks/AssignmentHook.sol#L38:38

```solidity
File: contracts/L1/libs/LibProposing.sol


21          uint256 public constant MAX_BYTES_PER_BLOB = 4096 * 32;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProposing.sol#L21:21

```solidity
File: contracts/L1/libs/LibProving.sol


20          bytes32 public constant RETURN_LIVENESS_BOND = keccak256("RETURN_LIVENESS_BOND");


23          bytes32 public constant TIER_OP = bytes32("tier_optimistic");


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProving.sol#L23:23

```solidity
File: contracts/L1/provers/Guardians.sol


11          uint256 public constant MIN_NUM_GUARDIANS = 5;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/provers/Guardians.sol#L11:11

```solidity
File: contracts/L1/tiers/ITierProvider.sol


39          uint16 public constant TIER_OPTIMISTIC = 100;


42          uint16 public constant TIER_SGX = 200;


45          uint16 public constant TIER_SGX_ZKVM = 300;


48          uint16 public constant TIER_GUARDIAN = 1000;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/tiers/ITierProvider.sol#L48:48

```solidity
File: contracts/L2/TaikoL2.sol


32          address public constant GOLDEN_TOUCH_ADDRESS = 0x0000777735367b36bC9B61C50022d9D0700dB4Ec;


35          uint8 public constant BLOCK_SYNC_THRESHOLD = 5;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/TaikoL2.sol#L35:35

```solidity
File: contracts/libs/Lib4844.sol


10          address public constant POINT_EVALUATION_PRECOMPILE_ADDRESS = address(0x0A);


13          uint32 public constant FIELD_ELEMENTS_PER_BLOB = 4096;


16          uint256 public constant BLS_MODULUS =
17              52_435_875_175_126_190_479_447_740_508_185_965_837_690_552_500_527_637_822_603_658_699_938_581_184_513;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/libs/Lib4844.sol#L16:17

```solidity
File: contracts/signal/LibSignals.sol


8           bytes32 public constant STATE_ROOT = keccak256("STATE_ROOT");


11          bytes32 public constant SIGNAL_ROOT = keccak256("SIGNAL_ROOT");


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/signal/LibSignals.sol#L11:11

```solidity
File: contracts/thirdparty/solmate/LibFixedPointMath.sol


7           uint128 public constant MAX_EXP_INPUT = 135_305_999_368_893_231_588;


8           uint256 public constant SCALING_FACTOR = 1e18; // For fixed point representation factor


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/solmate/LibFixedPointMath.sol#L8:8

```solidity
File: contracts/tokenvault/BaseNFTVault.sol


47          bytes4 public constant ERC1155_INTERFACE_ID = 0xd9b67a26;


50          bytes4 public constant ERC721_INTERFACE_ID = 0x80ac58cd;


53          uint256 public constant MAX_TOKEN_PER_TXN = 10;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BaseNFTVault.sol#L53:53

```solidity
File: contracts/verifiers/SgxVerifier.sol


30          uint64 public constant INSTANCE_EXPIRY = 180 days;


34          uint64 public constant INSTANCE_VALIDITY_DELAY = 1 days;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/verifiers/SgxVerifier.sol#L34:34

</details>

## NC071 - Add inline comments for unnamed variables:

`function foo(address x, address)` -> `function foo(address x, address /* y */)`


<details>
<summary>Click to show 10 findings</summary>

```solidity
File: contracts/L1/TaikoL1.sol


220         function _authorizePause(address)
221             internal
222             view
223             virtual
224             override
225             onlyFromOwnerOrNamed("chain_pauser")
226         { }


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/TaikoL1.sol#L220:226

```solidity
File: contracts/L1/tiers/DevnetTierProvider.sol


54          function getMinTier(uint256) public pure override returns (uint16) {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/tiers/DevnetTierProvider.sol#L54:54

```solidity
File: contracts/bridge/Bridge.sol


461         function _authorizePause(address)
462             internal
463             view
464             virtual
465             override
466             onlyFromOwnerOrNamed("bridge_pauser")
467         { }


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/Bridge.sol#L461:467

```solidity
File: contracts/common/AddressManager.sol


58          function _authorizePause(address) internal pure override {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/common/AddressManager.sol#L58:58

```solidity
File: contracts/signal/SignalService.sol


231         function _authorizePause(address) internal pure override {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/signal/SignalService.sol#L231:231

```solidity
File: contracts/tokenvault/BridgedERC1155.sol


125         function _beforeTokenTransfer(
126             address, /*_operator*/
127             address, /*_from*/
128             address _to,
129             uint256[] memory, /*_ids*/
130             uint256[] memory, /*_amounts*/
131             bytes memory /*_data*/
132         )
133             internal
134             virtual
135             override
136         {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC1155.sol#L125:136

```solidity
File: contracts/tokenvault/BridgedERC721.sol


115         function _beforeTokenTransfer(
116             address, /*_from*/
117             address _to,
118             uint256, /*_firstTokenId*/
119             uint256 /*_batchSize*/
120         )
121             internal
122             virtual
123             override
124         {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC721.sol#L115:124

```solidity
File: contracts/tokenvault/ERC1155Vault.sol


175         function onERC1155Received(
176             address,
177             address,
178             uint256,
179             uint256,
180             bytes calldata
181         )
182             external
183             pure
184             returns (bytes4)
185         {


160         function onERC1155BatchReceived(
161             address,
162             address,
163             uint256[] calldata,
164             uint256[] calldata,
165             bytes calldata
166         )
167             external
168             pure
169             returns (bytes4)
170         {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC1155Vault.sol#L160:170

```solidity
File: contracts/tokenvault/ERC721Vault.sol


142         function onERC721Received(
143             address,
144             address,
145             uint256,
146             bytes calldata
147         )
148             external
149             pure
150             returns (bytes4)
151         {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC721Vault.sol#L142:151

</details>

## NC072 - Consider adding emergency-stop functionality:

Adding a way to quickly halt protocol functionality in an emergency, rather than having to pause individual contracts one-by-one, will make in-progress hack mitigation faster and much less stressful.


<details>
<summary>Click to show 9 findings</summary>

```solidity
File: contracts/L1/TaikoToken.sol


15      contract TaikoToken is EssentialContract, ERC20SnapshotUpgradeable, ERC20VotesUpgradeable {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/TaikoToken.sol#L15:15

```solidity
File: contracts/L2/TaikoL2EIP1559Configurable.sol


9       contract TaikoL2EIP1559Configurable is TaikoL2 {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/TaikoL2EIP1559Configurable.sol#L9:9

```solidity
File: contracts/automata-attestation/AutomataDcapV3Attestation.sol


22      contract AutomataDcapV3Attestation is IAttestation {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/AutomataDcapV3Attestation.sol#L22:22

```solidity
File: contracts/common/AddressManager.sol


10      contract AddressManager is EssentialContract, IAddressManager {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/common/AddressManager.sol#L10:10

```solidity
File: contracts/signal/SignalService.sol


14      contract SignalService is EssentialContract, ISignalService {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/signal/SignalService.sol#L14:14

```solidity
File: contracts/team/TimelockTokenPool.sol


25      contract TimelockTokenPool is EssentialContract {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/TimelockTokenPool.sol#L25:25

```solidity
File: contracts/tokenvault/BridgedERC20.sol


15      contract BridgedERC20 is


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC20.sol#L15:15

```solidity
File: contracts/tokenvault/ERC20Vault.sol


18      contract ERC20Vault is BaseVault {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC20Vault.sol#L18:18

```solidity
File: contracts/verifiers/SgxVerifier.sol


19      contract SgxVerifier is EssentialContract, IVerifier {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/verifiers/SgxVerifier.sol#L19:19

</details>

## NC073 - Named imports of parent contracts are missing:




<details>
<summary>Click to show 46 findings</summary>

```solidity
File: contracts/L1/TaikoL1.sol


22      contract TaikoL1 is EssentialContract, ITaikoL1, TaikoEvents, TaikoErrors {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/TaikoL1.sol#L22:22

```solidity
File: contracts/L1/TaikoToken.sol


15      contract TaikoToken is EssentialContract, ERC20SnapshotUpgradeable, ERC20VotesUpgradeable {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/TaikoToken.sol#L15:15

```solidity
File: contracts/L1/gov/TaikoGovernor.sol


17          EssentialContract,


20          GovernorVotesQuorumFractionUpgradeable,


19          GovernorVotesUpgradeable,


21          GovernorTimelockControlUpgradeable


18          GovernorCompatibilityBravoUpgradeable,


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/gov/TaikoGovernor.sol#L18:18

```solidity
File: contracts/L1/gov/TaikoTimelockController.sol


9       contract TaikoTimelockController is EssentialContract, TimelockControllerUpgradeable {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/gov/TaikoTimelockController.sol#L9:9

```solidity
File: contracts/L1/hooks/AssignmentHook.sol


14      contract AssignmentHook is EssentialContract, IHook {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/hooks/AssignmentHook.sol#L14:14

```solidity
File: contracts/L1/provers/GuardianProver.sol


10      contract GuardianProver is Guardians {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/provers/GuardianProver.sol#L10:10

```solidity
File: contracts/L1/provers/Guardians.sol


9       abstract contract Guardians is EssentialContract {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/provers/Guardians.sol#L9:9

```solidity
File: contracts/L1/tiers/DevnetTierProvider.sol


10      contract DevnetTierProvider is EssentialContract, ITierProvider {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/tiers/DevnetTierProvider.sol#L10:10

```solidity
File: contracts/L1/tiers/MainnetTierProvider.sol


10      contract MainnetTierProvider is EssentialContract, ITierProvider {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/tiers/MainnetTierProvider.sol#L10:10

```solidity
File: contracts/L1/tiers/TestnetTierProvider.sol


10      contract TestnetTierProvider is EssentialContract, ITierProvider {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/tiers/TestnetTierProvider.sol#L10:10

```solidity
File: contracts/L2/CrossChainOwned.sol


14      abstract contract CrossChainOwned is EssentialContract, IMessageInvocable {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/CrossChainOwned.sol#L14:14

```solidity
File: contracts/L2/TaikoL2.sol


21      contract TaikoL2 is CrossChainOwned {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/TaikoL2.sol#L21:21

```solidity
File: contracts/L2/TaikoL2EIP1559Configurable.sol


9       contract TaikoL2EIP1559Configurable is TaikoL2 {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/TaikoL2EIP1559Configurable.sol#L9:9

```solidity
File: contracts/automata-attestation/utils/SigVerifyLib.sol


15      contract SigVerifyLib is ISigVerifyLib {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/SigVerifyLib.sol#L15:15

```solidity
File: contracts/bridge/Bridge.sol


16      contract Bridge is EssentialContract, IBridge {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/Bridge.sol#L16:16

```solidity
File: contracts/common/AddressManager.sol


10      contract AddressManager is EssentialContract, IAddressManager {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/common/AddressManager.sol#L10:10

```solidity
File: contracts/common/AddressResolver.sol


11      abstract contract AddressResolver is IAddressResolver, Initializable {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/common/AddressResolver.sol#L11:11

```solidity
File: contracts/common/EssentialContract.sol


10      abstract contract EssentialContract is UUPSUpgradeable, Ownable2StepUpgradeable, AddressResolver {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/common/EssentialContract.sol#L10:10

```solidity
File: contracts/signal/SignalService.sol


14      contract SignalService is EssentialContract, ISignalService {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/signal/SignalService.sol#L14:14

```solidity
File: contracts/team/TimelockTokenPool.sol


25      contract TimelockTokenPool is EssentialContract {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/TimelockTokenPool.sol#L25:25

```solidity
File: contracts/team/airdrop/ERC20Airdrop.sol


11      contract ERC20Airdrop is MerkleClaimable {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/airdrop/ERC20Airdrop.sol#L11:11

```solidity
File: contracts/team/airdrop/ERC20Airdrop2.sol


12      contract ERC20Airdrop2 is MerkleClaimable {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/airdrop/ERC20Airdrop2.sol#L12:12

```solidity
File: contracts/team/airdrop/ERC721Airdrop.sol


9       contract ERC721Airdrop is MerkleClaimable {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/airdrop/ERC721Airdrop.sol#L9:9

```solidity
File: contracts/team/airdrop/MerkleClaimable.sol


10      abstract contract MerkleClaimable is EssentialContract {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/airdrop/MerkleClaimable.sol#L10:10

```solidity
File: contracts/tokenvault/BaseNFTVault.sol


9       abstract contract BaseNFTVault is BaseVault {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BaseNFTVault.sol#L9:9

```solidity
File: contracts/tokenvault/BaseVault.sol


14          IRecallableSender,


16          IERC165Upgradeable


15          IMessageInvocable,


13          EssentialContract,


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BaseVault.sol#L13:13

```solidity
File: contracts/tokenvault/BridgedERC1155.sol


14      contract BridgedERC1155 is EssentialContract, IERC1155MetadataURIUpgradeable, ERC1155Upgradeable {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC1155.sol#L14:14

```solidity
File: contracts/tokenvault/BridgedERC20.sol


18          ERC20SnapshotUpgradeable,


17          IERC20MetadataUpgradeable,


16          BridgedERC20Base,


19          ERC20VotesUpgradeable


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC20.sol#L19:19

```solidity
File: contracts/tokenvault/BridgedERC20Base.sol


9       abstract contract BridgedERC20Base is EssentialContract, IBridgedERC20 {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC20Base.sol#L9:9

```solidity
File: contracts/tokenvault/BridgedERC721.sol


12      contract BridgedERC721 is EssentialContract, ERC721Upgradeable {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC721.sol#L12:12

```solidity
File: contracts/tokenvault/ERC1155Vault.sol


29      contract ERC1155Vault is BaseNFTVault, ERC1155ReceiverUpgradeable {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC1155Vault.sol#L29:29

```solidity
File: contracts/tokenvault/ERC20Vault.sol


18      contract ERC20Vault is BaseVault {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC20Vault.sol#L18:18

```solidity
File: contracts/tokenvault/ERC721Vault.sol


16      contract ERC721Vault is BaseNFTVault, IERC721Receiver {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC721Vault.sol#L16:16

```solidity
File: contracts/tokenvault/adapters/USDCAdapter.sol


28      contract USDCAdapter is BridgedERC20Base {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/adapters/USDCAdapter.sol#L28:28

```solidity
File: contracts/verifiers/GuardianVerifier.sol


10      contract GuardianVerifier is EssentialContract, IVerifier {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/verifiers/GuardianVerifier.sol#L10:10

```solidity
File: contracts/verifiers/SgxVerifier.sol


19      contract SgxVerifier is EssentialContract, IVerifier {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/verifiers/SgxVerifier.sol#L19:19

</details>

## NC074 - Contract doesn't handle all NFT types:

There are two primary standards for NFTs - [ERC-721](https://eips.ethereum.org/EIPS/eip-721) and [ERC-1155](https://eips.ethereum.org/EIPS/eip-1155). Supporting one but not the other excludes half of the available market.


```solidity
File: contracts/tokenvault/ERC1155Vault.sol


29      contract ERC1155Vault is BaseNFTVault, ERC1155ReceiverUpgradeable {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC1155Vault.sol#L29:29

```solidity
File: contracts/tokenvault/ERC721Vault.sol


16      contract ERC721Vault is BaseNFTVault, IERC721Receiver {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC721Vault.sol#L16:16

## NC075 - Use `bytes.concat()` on bytes instead of `abi.encodePacked()` for clearer semantic meaning:

Starting with version 0.8.4, Solidity has the `bytes.concat()` function, which allows one to concatenate a list of bytes/strings, without extra padding. Using this function rather than `abi.encodePacked()` makes the intended operation more clear, leading to less reviewer confusion.


<details>
<summary>Click to show 4 findings</summary>

```solidity
File: contracts/automata-attestation/lib/PEMCertChainLib.sol


181                 cert.signature = abi.encodePacked(sigX, sigY);


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/PEMCertChainLib.sol#L181:181

```solidity
File: contracts/signal/SignalService.sol


203             return keccak256(abi.encodePacked("SIGNAL", _chainId, _app, _signal));


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/signal/SignalService.sol#L203:203

```solidity
File: contracts/thirdparty/optimism/rlp/RLPWriter.sol


17                  out_ = abi.encodePacked(_writeLength(_in.length, 128), _in);


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/rlp/RLPWriter.sol#L17:17

```solidity
File: contracts/thirdparty/optimism/trie/MerkleTrie.sol


81              bytes memory currentNodeID = abi.encodePacked(_root);


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/trie/MerkleTrie.sol#L81:81

</details>

## NC076 - Style guide: State and local variables should be named using lowerCamelCase:

The Solidity style guide says to use mixedCase for local and state variable names. Note that while OpenZeppelin may not follow this advice, it still is the recommended way of naming variables.


<details>
<summary>Click to show 43 findings</summary>

```solidity
File: contracts/L1/TaikoL1.sol


26          uint256[50] private __gap;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/TaikoL1.sol#L26:26

```solidity
File: contracts/L1/TaikoToken.sol


16          uint256[50] private __gap;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/TaikoToken.sol#L16:16

```solidity
File: contracts/L1/gov/TaikoGovernor.sol


23          uint256[50] private __gap;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/gov/TaikoGovernor.sol#L23:23

```solidity
File: contracts/L1/gov/TaikoTimelockController.sol


10          uint256[50] private __gap;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/gov/TaikoTimelockController.sol#L10:10

```solidity
File: contracts/L1/hooks/AssignmentHook.sol


40          uint256[50] private __gap;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/hooks/AssignmentHook.sol#L40:40

```solidity
File: contracts/L1/provers/GuardianProver.sol


11          uint256[50] private __gap;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/provers/GuardianProver.sol#L11:11

```solidity
File: contracts/L1/provers/Guardians.sol


32          uint256[46] private __gap;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/provers/Guardians.sol#L32:32

```solidity
File: contracts/L1/tiers/DevnetTierProvider.sol


11          uint256[50] private __gap;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/tiers/DevnetTierProvider.sol#L11:11

```solidity
File: contracts/L1/tiers/MainnetTierProvider.sol


11          uint256[50] private __gap;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/tiers/MainnetTierProvider.sol#L11:11

```solidity
File: contracts/L1/tiers/TestnetTierProvider.sol


11          uint256[50] private __gap;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/tiers/TestnetTierProvider.sol#L11:11

```solidity
File: contracts/L2/CrossChainOwned.sol


21          uint256[49] private __gap;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/CrossChainOwned.sol#L21:21

```solidity
File: contracts/L2/TaikoL2.sol


52          uint256[47] private __gap;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/TaikoL2.sol#L52:52

```solidity
File: contracts/L2/TaikoL2EIP1559Configurable.sol


13          uint256[49] private __gap;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/TaikoL2EIP1559Configurable.sol#L13:13

```solidity
File: contracts/automata-attestation/utils/SigVerifyLib.sol


18          address private ES256VERIFIER;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/SigVerifyLib.sol#L18:18

```solidity
File: contracts/bridge/Bridge.sol


38          Context private __ctx;


48          uint256[43] private __gap;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/Bridge.sol#L48:48

```solidity
File: contracts/common/AddressManager.sol


12          mapping(uint256 chainId => mapping(bytes32 name => address addr)) private __addresses;


14          uint256[49] private __gap;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/common/AddressManager.sol#L14:14

```solidity
File: contracts/common/AddressResolver.sol


14          uint256[49] private __gap;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/common/AddressResolver.sol#L14:14

```solidity
File: contracts/common/EssentialContract.sol


21          uint8 private __reentry;


23          uint8 private __paused;


25          uint256[49] private __gap;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/common/EssentialContract.sol#L25:25

```solidity
File: contracts/signal/SignalService.sol


23          uint256[48] private __gap;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/signal/SignalService.sol#L23:23

```solidity
File: contracts/team/TimelockTokenPool.sol


82          uint128[44] private __gap;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/TimelockTokenPool.sol#L82:82

```solidity
File: contracts/team/airdrop/ERC20Airdrop.sol


18          uint256[48] private __gap;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/airdrop/ERC20Airdrop.sol#L18:18

```solidity
File: contracts/team/airdrop/ERC20Airdrop2.sol


30          uint256[45] private __gap;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/airdrop/ERC20Airdrop2.sol#L30:30

```solidity
File: contracts/team/airdrop/ERC721Airdrop.sol


16          uint256[48] private __gap;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/airdrop/ERC721Airdrop.sol#L16:16

```solidity
File: contracts/team/airdrop/MerkleClaimable.sol


23          uint256[47] private __gap;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/airdrop/MerkleClaimable.sol#L23:23

```solidity
File: contracts/tokenvault/BaseNFTVault.sol


61          uint256[48] private __gap;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BaseNFTVault.sol#L61:61

```solidity
File: contracts/tokenvault/BaseVault.sol


18          uint256[50] private __gap;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BaseVault.sol#L18:18

```solidity
File: contracts/tokenvault/BridgedERC1155.sol


22          string private __symbol;


25          string private __name;


27          uint256[46] private __gap;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC1155.sol#L27:27

```solidity
File: contracts/tokenvault/BridgedERC20.sol


24          uint8 private __srcDecimals;


32          uint256[47] private __gap;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC20.sol#L32:32

```solidity
File: contracts/tokenvault/BridgedERC20Base.sol


16          uint256[49] private __gap;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC20Base.sol#L16:16

```solidity
File: contracts/tokenvault/BridgedERC721.sol


19          uint256[48] private __gap;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC721.sol#L19:19

```solidity
File: contracts/tokenvault/ERC1155Vault.sol


32          uint256[50] private __gap;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC1155Vault.sol#L32:32

```solidity
File: contracts/tokenvault/ERC20Vault.sol


54          uint256[47] private __gap;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC20Vault.sol#L54:54

```solidity
File: contracts/tokenvault/ERC721Vault.sol


19          uint256[50] private __gap;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC721Vault.sol#L19:19

```solidity
File: contracts/tokenvault/adapters/USDCAdapter.sol


32          uint256[49] private __gap;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/adapters/USDCAdapter.sol#L32:32

```solidity
File: contracts/verifiers/GuardianVerifier.sol


11          uint256[50] private __gap;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/verifiers/GuardianVerifier.sol#L11:11

```solidity
File: contracts/verifiers/SgxVerifier.sol


57          uint256[47] private __gap;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/verifiers/SgxVerifier.sol#L57:57

</details>

## NC077 - Unusual loop variable:

The normal name for loop variables is i, and when there is a nested loop, to use j. Not following this convention may lead to some reviewer confusion.


```solidity
File: contracts/automata-attestation/utils/BytesUtils.sol


80              for (uint256 idx = 0; idx < shortest; idx += 32) {
81                  uint256 a;
82                  uint256 b;
83                  assembly {
84                      a := mload(selfptr)
85                      b := mload(otherptr)
86                  }
87                  if (a != b) {
88                      // Mask out irrelevant bytes and check again
89                      uint256 mask;
90                      if (shortest > 32) {
91                          mask = type(uint256).max; // aka 0xffffff....
92                      } else {
93                          mask = ~(2 ** (8 * (32 - shortest + idx)) - 1);
94                      }
95                      uint256 diff = (a & mask) - (b & mask);
96                      if (diff != 0) {
97                          return int256(diff);
98                      }
99                  }
100                 selfptr += 32;
101                 otherptr += 32;
102             }


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/BytesUtils.sol#L80:102

## NC078 - Visibility should be set explicitly rather than defaulting to internal:

Visibility of state variables should be set explicitly rather than defaulting to internal.


```solidity
File: contracts/automata-attestation/lib/PEMCertChainLib.sol


32          uint256 constant SGX_TCB_CPUSVN_SIZE = 16;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/PEMCertChainLib.sol#L32:32

```solidity
File: contracts/automata-attestation/utils/BytesUtils.sol


310         bytes constant BASE32_HEX_TABLE =
311             hex"00010203040506070809FFFFFFFFFFFFFF0A0B0C0D0E0F101112131415161718191A1B1C1D1E1FFFFFFFFFFFFFFFFFFFFF0A0B0C0D0E0F101112131415161718191A1B1C1D1E1F";


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/BytesUtils.sol#L310:311

```solidity
File: contracts/thirdparty/nomad-xyz/ExcessivelySafeCall.sol


6           uint256 constant LOW_28_MASK =
7               0x00000000ffffffffffffffffffffffffffffffffffffffffffffffffffffffff;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/nomad-xyz/ExcessivelySafeCall.sol#L6:7

## NC079 - Event declarations should have NatSpec @param annotations:

Documents a parameter just like in Doxygen (must be followed by parameter name)


```solidity
File: contracts/L1/libs/LibDepositing.sol


19          event EthDeposited(TaikoData.EthDeposit deposit);


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibDepositing.sol#L19:19

## NC080 - Event declarations should have NatSpec @dev annotations:

Explain to a developer any extra details


<details>
<summary>Click to show 45 findings</summary>

```solidity
File: contracts/L1/hooks/AssignmentHook.sol


46          event BlockAssigned(


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/hooks/AssignmentHook.sol#L46:46

```solidity
File: contracts/L1/libs/LibProposing.sol


31          event BlockProposed(


41          event BlobCached(bytes32 blobHash);


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProposing.sol#L41:41

```solidity
File: contracts/L1/libs/LibProving.sol


32          event TransitionProved(


46          event TransitionContested(


56          event ProvingPaused(bool paused);


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProving.sol#L56:56

```solidity
File: contracts/L1/libs/LibVerifying.sol


28          event BlockVerified(


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibVerifying.sol#L28:28

```solidity
File: contracts/L1/provers/GuardianProver.sol


18          event GuardianApproval(


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/provers/GuardianProver.sol#L18:18

```solidity
File: contracts/L1/provers/Guardians.sol


37          event GuardiansUpdated(uint32 version, address[] guardians);


43          event Approved(uint256 indexed operationId, uint256 approvalBits, bool proofSubmitted);


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/provers/Guardians.sol#L43:43

```solidity
File: contracts/L2/CrossChainOwned.sol


26          event TransactionExecuted(uint64 indexed txId, bytes4 indexed selector);


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/CrossChainOwned.sol#L26:26

```solidity
File: contracts/L2/TaikoL2.sol


57          event Anchored(bytes32 parentHash, uint64 gasExcess);


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/TaikoL2.sol#L57:57

```solidity
File: contracts/L2/TaikoL2EIP1559Configurable.sol


18          event ConfigAndExcessChanged(Config config, uint64 gasExcess);


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/TaikoL2EIP1559Configurable.sol#L18:18

```solidity
File: contracts/bridge/IBridge.sol


69          event MessageSent(bytes32 indexed msgHash, Message message);


75          event MessageReceived(bytes32 indexed msgHash, Message message, bool isRecall);


79          event MessageRecalled(bytes32 indexed msgHash);


83          event MessageExecuted(bytes32 indexed msgHash);


87          event MessageRetried(bytes32 indexed msgHash);


92          event MessageStatusChanged(bytes32 indexed msgHash, Status status);


97          event MessageSuspended(bytes32 msgHash, bool suspended);


102         event AddressBanned(address indexed addr, bool banned);


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/IBridge.sol#L102:102

```solidity
File: contracts/common/AddressManager.sol


21          event AddressSet(


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/common/AddressManager.sol#L21:21

```solidity
File: contracts/common/EssentialContract.sol


29          event Paused(address account);


33          event Unpaused(address account);


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/common/EssentialContract.sol#L33:33

```solidity
File: contracts/signal/ISignalService.sol


36          event ChainDataSynced(


49          event SignalSent(address app, bytes32 signal, bytes32 slot, bytes32 value);


54          event Authorized(address indexed addr, bool authrized);


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/signal/ISignalService.sol#L54:54

```solidity
File: contracts/team/TimelockTokenPool.sol


87          event Granted(address indexed recipient, Grant grant);


92          event Voided(address indexed recipient, uint128 amount);


99          event Withdrawn(address indexed recipient, address to, uint128 amount, uint128 cost);


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/TimelockTokenPool.sol#L99:99

```solidity
File: contracts/team/airdrop/ERC20Airdrop2.sol


35          event Withdrawn(address user, uint256 amount);


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/airdrop/ERC20Airdrop2.sol#L35:35

```solidity
File: contracts/team/airdrop/MerkleClaimable.sol


27          event Claimed(bytes32 hash);


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/airdrop/MerkleClaimable.sol#L27:27

```solidity
File: contracts/tokenvault/BaseNFTVault.sol


69          event BridgedTokenDeployed(


86          event TokenSent(


104         event TokenReleased(


122         event TokenReceived(


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BaseNFTVault.sol#L122:122

```solidity
File: contracts/tokenvault/BridgedERC20Base.sol


21          event MigrationStatusChanged(address addr, bool inbound);


27          event MigratedTo(address indexed fromToken, address indexed account, uint256 amount);


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC20Base.sol#L27:27

```solidity
File: contracts/tokenvault/ERC20Vault.sol


63          event BridgedTokenDeployed(


80          event BridgedTokenChanged(


98          event TokenSent(


114         event TokenReleased(


126         event TokenReceived(


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC20Vault.sol#L126:126

```solidity
File: contracts/verifiers/SgxVerifier.sol


65          event InstanceAdded(


72          event InstanceDeleted(uint256 indexed id, address indexed instance);


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/verifiers/SgxVerifier.sol#L72:72

</details>

## NC081 - Function definitions should have NatSpec @dev annotations:

Explain to a developer any extra details


<details>
<summary>Click to show 338 findings</summary>

```solidity
File: contracts/L1/ITaikoL1.sol


14          function proposeBlock(


27          function proveBlock(uint64 _blockId, bytes calldata _input) external;


31          function verifyBlocks(uint64 _maxBlocksToVerify) external;


35          function getConfig() external view returns (TaikoData.Config memory);


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/ITaikoL1.sol#L35:35

```solidity
File: contracts/L1/TaikoL1.sol


42          function init(


55          function proposeBlock(


75          function proveBlock(


100         function verifyBlocks(uint64 _maxBlocksToVerify)


111         function pauseProving(bool _pause) external {


119         function depositEtherToL2(address _recipient) external payable nonReentrant whenNotPaused {


124         function unpause() public override {


132         function canDepositEthToL2(uint256 _amount) public view returns (bool) {


137         function isBlobReusable(bytes32 _blobHash) public view returns (bool) {


145         function getBlock(uint64 _blockId)


162         function getTransition(


176         function getStateVariables()


186         function getConfig() public view virtual override returns (TaikoData.Config memory) {


220         function _authorizePause(address)


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/TaikoL1.sol#L220:220

```solidity
File: contracts/L1/TaikoToken.sol


25          function init(


47          function burn(address _from, uint256 _amount) public onlyOwner {


52          function snapshot() public onlyFromOwnerOrNamed("snapshooter") {


60          function transfer(address _to, uint256 _amount) public override returns (bool) {


70          function transferFrom(


83          function _beforeTokenTransfer(


94          function _afterTokenTransfer(


105         function _mint(


115         function _burn(


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/TaikoToken.sol#L115:115

```solidity
File: contracts/L1/gov/TaikoGovernor.sol


31          function init(


111         function votingDelay() public pure override returns (uint256) {


117         function votingPeriod() public pure override returns (uint256) {


123         function proposalThreshold() public pure override returns (uint256) {


127         function _execute(


140         function _cancel(


153         function _executor()


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/gov/TaikoGovernor.sol#L153:153

```solidity
File: contracts/L1/gov/TaikoTimelockController.sol


15          function init(address _owner, uint256 _minDelay) external initializer {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/gov/TaikoTimelockController.sol#L15:15

```solidity
File: contracts/L1/hooks/AssignmentHook.sol


57          function init(address _owner, address _addressManager) external initializer {


62          function onBlockProposed(


137         function hashAssignment(


164         function _getProverFee(


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/hooks/AssignmentHook.sol#L164:164

```solidity
File: contracts/L1/hooks/IHook.sol


13          function onBlockProposed(


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/hooks/IHook.sol#L13:13

```solidity
File: contracts/L1/libs/LibProposing.sol


287         function isBlobReusable(


299         function _isProposerPermitted(


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProposing.sol#L299:299

```solidity
File: contracts/L1/libs/LibProving.sol


73          function pauseProving(TaikoData.State storage _state, bool _pause) external {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProving.sol#L73:73

```solidity
File: contracts/L1/libs/LibVerifying.sol


47          function init(


224         function _syncChainData(


245         function _isConfigValid(TaikoData.Config memory _config) private view returns (bool) {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibVerifying.sol#L245:245

```solidity
File: contracts/L1/provers/GuardianProver.sol


25          function init(address _owner, address _addressManager) external initializer {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/provers/GuardianProver.sol#L25:25

```solidity
File: contracts/L1/provers/Guardians.sol


53          function setGuardians(


101         function isApproved(bytes32 _hash) public view returns (bool) {


107         function numGuardians() public view returns (uint256) {


111         function approve(uint256 _operationId, bytes32 _hash) internal returns (bool approved_) {


124         function deleteApproval(bytes32 _hash) internal {


128         function isApproved(uint256 _approvalBits) internal view returns (bool) {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/provers/Guardians.sol#L128:128

```solidity
File: contracts/L1/tiers/DevnetTierProvider.sol


15          function init(address _owner) external initializer {


20          function getTier(uint16 _tierId) public pure override returns (ITierProvider.Tier memory) {


47          function getTierIds() public pure override returns (uint16[] memory tiers_) {


54          function getMinTier(uint256) public pure override returns (uint16) {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/tiers/DevnetTierProvider.sol#L54:54

```solidity
File: contracts/L1/tiers/MainnetTierProvider.sol


15          function init(address _owner) external initializer {


20          function getTier(uint16 _tierId) public pure override returns (ITierProvider.Tier memory) {


58          function getTierIds() public pure override returns (uint16[] memory tiers_) {


66          function getMinTier(uint256 _rand) public pure override returns (uint16) {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/tiers/MainnetTierProvider.sol#L66:66

```solidity
File: contracts/L1/tiers/TestnetTierProvider.sol


15          function init(address _owner) external initializer {


20          function getTier(uint16 _tierId) public pure override returns (ITierProvider.Tier memory) {


58          function getTierIds() public pure override returns (uint16[] memory tiers_) {


66          function getMinTier(uint256 _rand) public pure override returns (uint16) {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/tiers/TestnetTierProvider.sol#L66:66

```solidity
File: contracts/L2/CrossChainOwned.sol


60          function __CrossChainOwned_init(


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/CrossChainOwned.sol#L60:60

```solidity
File: contracts/L2/TaikoL2.sol


71          function init(


107         function anchor(


163         function withdraw(


185         function getBasefee(


200         function getBlockHash(uint64 _blockId) public view returns (bytes32) {


208         function getConfig() public view virtual returns (Config memory config_) {


219         function skipFeeCheck() public pure virtual returns (bool) {


223         function _calcPublicInputHash(uint256 _blockId)


252         function _calc1559BaseFee(


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/TaikoL2.sol#L252:252

```solidity
File: contracts/L2/TaikoL2EIP1559Configurable.sol


25          function setConfigAndExcess(


43          function getConfig() public view override returns (Config memory) {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/TaikoL2EIP1559Configurable.sol#L43:43

```solidity
File: contracts/automata-attestation/AutomataDcapV3Attestation.sol


54          constructor(address sigVerifyLibAddr, address pemCertLibAddr) {


65          function setMrSigner(bytes32 _mrSigner, bool _trusted) external onlyOwner {


69          function setMrEnclave(bytes32 _mrEnclave, bool _trusted) external onlyOwner {


73          function addRevokedCertSerialNum(


88          function removeRevokedCertSerialNum(


103         function configureTcbInfoJson(


114         function configureQeIdentityJson(EnclaveIdStruct.EnclaveId calldata qeIdentityInput)


122         function toggleLocalReportCheck() external onlyOwner {


126         function _attestationTcbIsValid(TCBInfoStruct.TCBStatus status)


138         function verifyAttestation(bytes calldata data) external view override returns (bool) {


175         function _verifyQEReportWithIdentity(V3Struct.EnclaveReport memory quoteEnclaveReport)


206         function _checkTcbLevels(


229         function _isCpuSvnHigherOrGreater(


248         function _verifyCertChain(IPEMCertChainLib.ECSha256Certificate[] memory certs)


303         function _enclaveReportSigVerification(


364         function _verifyParsedQuote(V3Struct.ParsedV3QuoteStruct memory v3quote)


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/AutomataDcapV3Attestation.sol#L364:364

```solidity
File: contracts/automata-attestation/interfaces/IAttestation.sol


9           function verifyAttestation(bytes calldata data) external returns (bool);


10          function verifyParsedQuote(V3Struct.ParsedV3QuoteStruct calldata v3quote)


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/interfaces/IAttestation.sol#L10:10

```solidity
File: contracts/automata-attestation/interfaces/ISigVerifyLib.sol


38          function verifyAttStmtSignature(


48          function verifyCertificateSignature(


58          function verifyRS256Signature(


67          function verifyRS1Signature(


76          function verifyES256Signature(


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/interfaces/ISigVerifyLib.sol#L76:76

```solidity
File: contracts/automata-attestation/lib/PEMCertChainLib.sol


40          function splitCertificateChain(


74          function decodeCert(


216         function _removeHeadersAndFooters(string memory pemData)


252         function _trimBytes(


269         function _findPckTcbInfo(


341         function _findTcb(


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/PEMCertChainLib.sol#L341:341

```solidity
File: contracts/automata-attestation/lib/QuoteV3Auth/V3Parser.sol


21          function parseInput(


62          function validateParsedInput(V3Struct.ParsedV3QuoteStruct memory v3Quote)


133         function parseEnclaveReport(bytes memory rawEnclaveReport)


152         function littleEndianDecode(bytes memory encoded) private pure returns (uint256 decoded) {


165         function parseAndVerifyHeader(bytes memory rawHeader)


203         function parseAuthDataAndVerifyCertType(


244         function packQEReport(V3Struct.EnclaveReport memory enclaveReport)


267         function parseCerificationChainBytes(


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/QuoteV3Auth/V3Parser.sol#L267:267

```solidity
File: contracts/automata-attestation/lib/interfaces/IPEMCertChainLib.sol


36          function splitCertificateChain(


44          function decodeCert(


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/interfaces/IPEMCertChainLib.sol#L44:44

```solidity
File: contracts/automata-attestation/utils/Asn1Decode.sol


14          function ixs(uint256 self) internal pure returns (uint256) {


19          function ixf(uint256 self) internal pure returns (uint256) {


24          function ixl(uint256 self) internal pure returns (uint256) {


29          function getPtr(uint256 _ixs, uint256 _ixf, uint256 _ixl) internal pure returns (uint256) {


165         function keccakOfBytesAt(bytes memory der, uint256 ptr) internal pure returns (bytes32) {


169         function keccakOfAllBytesAt(bytes memory der, uint256 ptr) internal pure returns (bytes32) {


187         function _readNodeLength(bytes memory der, uint256 ix) private pure returns (uint256) {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/Asn1Decode.sol#L187:187

```solidity
File: contracts/automata-attestation/utils/BytesUtils.sol


272         function memcpy(uint256 dest, uint256 src, uint256 len) private pure {


371         function compareBytes(bytes memory a, bytes memory b) internal pure returns (bool) {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/BytesUtils.sol#L371:371

```solidity
File: contracts/automata-attestation/utils/SHA1.sol


11          function sha1(bytes memory data) internal pure returns (bytes20 ret) {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/SHA1.sol#L11:11

```solidity
File: contracts/automata-attestation/utils/SigVerifyLib.sol


20          constructor(address es256Verifier) {


24          function verifyAttStmtSignature(


54          function verifyCertificateSignature(


79          function verifyRS256Signature(


96          function verifyRS1Signature(


113         function verifyES256Signature(


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/SigVerifyLib.sol#L113:113

```solidity
File: contracts/automata-attestation/utils/X509DateUtils.sol


8           function toTimestamp(bytes memory x509Time) internal pure returns (uint256) {


34          function toUnixTimestamp(


71          function isLeapYear(uint16 year) internal pure returns (bool) {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/X509DateUtils.sol#L71:71

```solidity
File: contracts/bridge/Bridge.sol


70          receive() external payable { }


75          function init(address _owner, address _addressManager) external initializer {


82          function suspendMessages(


101         function banAddress(


115         function sendMessage(Message calldata _message)


155         function recallMessage(


217         function processMessage(


310         function retryMessage(


340         function isMessageSent(Message calldata _message) public view returns (bool) {


352         function proveMessageFailed(


374         function proveMessageReceived(


392         function isDestChainEnabled(uint64 _chainId)


403         function context() public view returns (Context memory ctx_) {


449         function hashMessage(Message memory _message) public pure returns (bytes32) {


456         function signalForFailedMessage(bytes32 _msgHash) public pure returns (bytes32) {


461         function _authorizePause(address)


529         function _resetContext() private {


541         function _storeContext(bytes32 _msgHash, address _from, uint64 _srcChainId) private {


555         function _loadContext() private view returns (Context memory) {


577         function _proveSignalReceived(


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/Bridge.sol#L577:577

```solidity
File: contracts/bridge/IBridge.sol


109         function sendMessage(Message calldata _message)


145         function context() external view returns (Context memory ctx_);


150         function isMessageSent(Message calldata _message) external view returns (bool);


155         function hashMessage(Message memory _message) external pure returns (bytes32);


164         function onMessageRecalled(


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/IBridge.sol#L164:164

```solidity
File: contracts/common/AddressManager.sol


30          function init(address _owner) external initializer {


38          function setAddress(


54          function getAddress(uint64 _chainId, bytes32 _name) public view override returns (address) {


58          function _authorizePause(address) internal pure override {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/common/AddressManager.sol#L58:58

```solidity
File: contracts/common/AddressResolver.sol


30          function resolve(


43          function resolve(


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/common/AddressResolver.sol#L43:43

```solidity
File: contracts/common/EssentialContract.sol


64          constructor() {


69          function pause() public virtual whenNotPaused {


78          function unpause() public virtual whenPaused {


88          function paused() public view returns (bool) {


95          function __Essential_init(


109         function __Essential_init(address _owner) internal virtual {


114         function _authorizeUpgrade(address) internal virtual override onlyOwner { }


116         function _authorizePause(address) internal virtual onlyOwner { }


119         function _storeReentryLock(uint8 _reentry) internal virtual {


130         function _loadReentryLock() internal view virtual returns (uint8 reentry_) {


140         function _inNonReentrant() internal view returns (bool) {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/common/EssentialContract.sol#L140:140

```solidity
File: contracts/common/IAddressResolver.sol


19          function resolve(


34          function resolve(


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/common/IAddressResolver.sol#L34:34

```solidity
File: contracts/libs/Lib4844.sol


30          function evaluatePoint(


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/libs/Lib4844.sol#L30:30

```solidity
File: contracts/libs/LibAddress.sol


46          function supportsInterface(


61          function isValidSignature(


77          function isSenderEOA() internal view returns (bool) {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/libs/LibAddress.sol#L77:77

```solidity
File: contracts/libs/LibTrieProof.sol


34          function verifyMerkleProof(


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/libs/LibTrieProof.sol#L34:34

```solidity
File: contracts/signal/ISignalService.sol


59          function sendSignal(bytes32 _signal) external returns (bytes32 slot_);


68          function syncChainData(


84          function proveSignalReceived(


96          function isSignalSent(address _app, bytes32 _signal) external view returns (bool);


105         function isChainDataSynced(


122         function getSyncedChainData(


137         function signalForChainData(


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/signal/ISignalService.sol#L137:137

```solidity
File: contracts/signal/SignalService.sol


48          function init(address _owner, address _addressManager) external initializer {


63          function sendSignal(bytes32 _signal) external returns (bytes32) {


68          function syncChainData(


137         function isChainDataSynced(


153         function isSignalSent(address _app, bytes32 _signal) public view returns (bool) {


158         function getSyncedChainData(


177         function signalForChainData(


194         function getSignalSlot(


206         function _verifyHopProof(


231         function _authorizePause(address) internal pure override {


235         function _syncChainData(


253         function _sendSignal(


271         function _cacheChainData(


298         function _loadSignalValue(


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/signal/SignalService.sol#L298:298

```solidity
File: contracts/team/TimelockTokenPool.sol


111         function init(


135         function grant(address _recipient, Grant memory _grant) external onlyOwner {


150         function void(address _recipient) external onlyOwner {


161         function withdraw() external {


168         function withdraw(address _to, bytes memory _sig) external {


176         function getMyGrantSummary(address _recipient)


204         function getMyGrant(address _recipient) public view returns (Grant memory) {


208         function _withdraw(address _recipient, address _to) private {


225         function _voidGrant(Grant storage _grant) private returns (uint128 amountVoided) {


235         function _getAmountOwned(Grant memory _grant) private view returns (uint128) {


239         function _getAmountUnlocked(Grant memory _grant) private view returns (uint128) {


245         function _calcAmount(


267         function _validateGrant(Grant memory _grant) private pure {


273         function _validateCliff(uint64 _start, uint64 _cliff, uint32 _period) private pure {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/TimelockTokenPool.sol#L273:273

```solidity
File: contracts/team/airdrop/ERC20Airdrop.sol


27          function init(


50          function claimAndDelegate(


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/airdrop/ERC20Airdrop.sol#L50:50

```solidity
File: contracts/team/airdrop/ERC20Airdrop2.sol


54          function init(


78          function claim(address user, uint256 amount, bytes32[] calldata proof) external nonReentrant {


88          function withdraw(address user) external ongoingWithdrawals {


104         function getBalance(address user)


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/airdrop/ERC20Airdrop2.sol#L104:104

```solidity
File: contracts/team/airdrop/ERC721Airdrop.sol


25          function init(


47          function claim(


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/airdrop/ERC721Airdrop.sol#L47:47

```solidity
File: contracts/team/airdrop/MerkleClaimable.sol


45          function setConfig(


56          function __MerkleClaimable_init(


67          function _verifyClaim(bytes memory data, bytes32[] calldata proof) internal ongoingClaim {


77          function _verifyMerkleProof(


90          function _setConfig(uint64 _claimStart, uint64 _claimEnd, bytes32 _merkleRoot) private {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/airdrop/MerkleClaimable.sol#L90:90

```solidity
File: contracts/thirdparty/optimism/Bytes.sol


15          function slice(


91          function slice(bytes memory _bytes, uint256 _start) internal pure returns (bytes memory) {


102         function toNibbles(bytes memory _bytes) internal pure returns (bytes memory) {


149         function equal(bytes memory _bytes, bytes memory _other) internal pure returns (bool) {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/Bytes.sol#L149:149

```solidity
File: contracts/thirdparty/optimism/rlp/RLPReader.sol


35          function toRLPItem(bytes memory _in) internal pure returns (RLPItem memory out_) {


53          function readList(RLPItem memory _in) internal pure returns (RLPItem[] memory out_) {


102         function readList(bytes memory _in) internal pure returns (RLPItem[] memory out_) {


109         function readBytes(RLPItem memory _in) internal pure returns (bytes memory out_) {


128         function readBytes(bytes memory _in) internal pure returns (bytes memory out_) {


135         function readRawBytes(RLPItem memory _in) internal pure returns (bytes memory out_) {


144         function _decodeLength(RLPItem memory _in)


277         function _copy(


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/rlp/RLPReader.sol#L277:277

```solidity
File: contracts/thirdparty/optimism/rlp/RLPWriter.sol


13          function writeBytes(bytes memory _in) internal pure returns (bytes memory out_) {


24          function writeUint(uint256 _in) internal pure returns (bytes memory out_) {


32          function _writeLength(uint256 _len, uint256 _offset) private pure returns (bytes memory out_) {


55          function _toBinary(uint256 _x) private pure returns (bytes memory out_) {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/rlp/RLPWriter.sol#L55:55

```solidity
File: contracts/thirdparty/optimism/trie/MerkleTrie.sol


50          function verifyInclusionProof(


68          function get(


205         function _parseProof(bytes[] memory _proof) private pure returns (TrieNode[] memory proof_) {


220         function _getNodeID(RLPReader.RLPItem memory _node) private pure returns (bytes memory id_) {


227         function _getNodePath(TrieNode memory _node) private pure returns (bytes memory nibbles_) {


235         function _getSharedNibbleLength(


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/trie/MerkleTrie.sol#L235:235

```solidity
File: contracts/thirdparty/optimism/trie/SecureMerkleTrie.sol


19          function verifyInclusionProof(


38          function get(


54          function _getSecureKey(bytes memory _key) private pure returns (bytes memory hash_) {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/trie/SecureMerkleTrie.sol#L54:54

```solidity
File: contracts/thirdparty/solmate/LibFixedPointMath.sol


13          function exp(int256 x) internal pure returns (int256 r) {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/solmate/LibFixedPointMath.sol#L13:13

```solidity
File: contracts/tokenvault/BaseVault.sol


32          function init(address _owner, address _addressManager) external initializer {


39          function supportsInterface(bytes4 _interfaceId) public view virtual override returns (bool) {


45          function name() public pure virtual returns (bytes32);


47          function checkProcessMessageContext()


58          function checkRecallMessageContext()


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BaseVault.sol#L58:58

```solidity
File: contracts/tokenvault/BridgedERC1155.sol


38          function init(


115         function name() public view returns (string memory) {


121         function symbol() public view returns (string memory) {


125         function _beforeTokenTransfer(


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC1155.sol#L125:125

```solidity
File: contracts/tokenvault/BridgedERC20.sol


52          function init(


80          function setSnapshoter(address _snapshooter) external onlyOwner {


85          function snapshot() external onlyOwnerOrSnapshooter {


91          function name()


102         function symbol()


113         function decimals()


125         function canonical() public view returns (address, uint256) {


129         function _mintToken(address _account, uint256 _amount) internal override {


133         function _burnToken(address _from, uint256 _amount) internal override {


152         function _afterTokenTransfer(


163         function _mint(


173         function _burn(


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC20.sol#L173:173

```solidity
File: contracts/tokenvault/BridgedERC20Base.sol


36          function changeMigrationStatus(


57          function mint(address _account, uint256 _amount) public nonReentrant whenNotPaused {


75          function burn(address _account, uint256 _amount) public nonReentrant whenNotPaused {


93          function owner() public view override(IBridgedERC20, OwnableUpgradeable) returns (address) {


97          function _mintToken(address _account, uint256 _amount) internal virtual;


99          function _burnToken(address _from, uint256 _amount) internal virtual;


101         function _isMigratingOut() internal view returns (bool) {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC20Base.sol#L101:101

```solidity
File: contracts/tokenvault/BridgedERC721.sol


31          function init(


87          function name() public view override(ERC721Upgradeable) returns (string memory) {


93          function symbol() public view override(ERC721Upgradeable) returns (string memory) {


100         function source() public view returns (address, uint256) {


107         function tokenURI(uint256 _tokenId) public view virtual override returns (string memory) {


115         function _beforeTokenTransfer(


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC721.sol#L115:115

```solidity
File: contracts/tokenvault/ERC1155Vault.sol


18          function name() external view returns (string memory);


21          function symbol() external view returns (string memory);


39          function sendToken(BridgeTransferOp memory _op)


93          function onMessageInvocation(bytes calldata data) external payable nonReentrant whenNotPaused {


127         function onMessageRecalled(


160         function onERC1155BatchReceived(


175         function onERC1155Received(


204         function name() public pure override returns (bytes32) {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC1155Vault.sol#L204:204

```solidity
File: contracts/tokenvault/ERC20Vault.sol


148         function changeBridgedToken(


207         function sendToken(BridgeTransferOp calldata _op)


253         function onMessageInvocation(bytes calldata _data)


285         function onMessageRecalled(


316         function name() public pure override returns (bytes32) {


320         function _transferTokens(


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC20Vault.sol#L320:320

```solidity
File: contracts/tokenvault/ERC721Vault.sol


26          function sendToken(BridgeTransferOp memory _op)


77          function onMessageInvocation(bytes calldata _data)


110         function onMessageRecalled(


142         function onERC721Received(


156         function name() public pure override returns (bytes32) {


160         function _transferTokens(


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC721Vault.sol#L160:160

```solidity
File: contracts/tokenvault/IBridgedERC20.sol


14          function mint(address _account, uint256 _amount) external;


19          function burn(address _from, uint256 _amount) external;


24          function changeMigrationStatus(address _addr, bool _inbound) external;


28          function owner() external view returns (address);


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/IBridgedERC20.sol#L28:28

```solidity
File: contracts/tokenvault/LibBridgedToken.sol


11          function validateInputs(


28          function buildName(


39          function buildSymbol(string memory _symbol) internal pure returns (string memory) {


43          function buildURI(


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/LibBridgedToken.sol#L43:43

```solidity
File: contracts/tokenvault/adapters/USDCAdapter.sol


11          function burn(uint256 _amount) external;


16          function mint(address _to, uint256 _amount) external;


23          function transferFrom(address from, address _to, uint256 _amount) external returns (bool);


38          function init(address _owner, address _addressManager, IUSDC _usdc) external initializer {


43          function _mintToken(address _account, uint256 _amount) internal override {


47          function _burnToken(address _from, uint256 _amount) internal override {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/adapters/USDCAdapter.sol#L47:47

```solidity
File: contracts/verifiers/GuardianVerifier.sol


18          function init(address _owner, address _addressManager) external initializer {


23          function verifyProof(


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/verifiers/GuardianVerifier.sol#L23:23

```solidity
File: contracts/verifiers/IVerifier.sol


24          function verifyProof(


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/verifiers/IVerifier.sol#L24:24

```solidity
File: contracts/verifiers/SgxVerifier.sol


83          function init(address _owner, address _addressManager) external initializer {


90          function addInstances(address[] calldata _instances)


100         function deleteInstances(uint256[] calldata _ids)


118         function registerInstance(V3Struct.ParsedV3QuoteStruct calldata _attestation)


139         function verifyProof(


171         function getSignedHash(


195         function _addInstances(


226         function _replaceInstance(uint256 id, address oldInstance, address newInstance) private {


233         function _isInstanceValid(uint256 id, address instance) private view returns (bool) {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/verifiers/SgxVerifier.sol#L233:233

</details>

## NC082 - Function definitions should have NatSpec @notice annotations:

Explain to an end user what this does


<details>
<summary>Click to show 252 findings</summary>

```solidity
File: contracts/L1/TaikoL1.sol


34          receive() external payable {


55          function proposeBlock(


75          function proveBlock(


100         function verifyBlocks(uint64 _maxBlocksToVerify)


124         function unpause() public override {


186         function getConfig() public view virtual override returns (TaikoData.Config memory) {


220         function _authorizePause(address)


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/TaikoL1.sol#L220:220

```solidity
File: contracts/L1/TaikoToken.sol


83          function _beforeTokenTransfer(


94          function _afterTokenTransfer(


105         function _mint(


115         function _burn(


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/TaikoToken.sol#L115:115

```solidity
File: contracts/L1/gov/TaikoGovernor.sol


48          function propose(


89          function supportsInterface(bytes4 _interfaceId)


99          function state(uint256 _proposalId)


127         function _execute(


140         function _cancel(


153         function _executor()


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/gov/TaikoGovernor.sol#L153:153

```solidity
File: contracts/L1/gov/TaikoTimelockController.sol


24          function getMinDelay() public view override returns (uint256) {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/gov/TaikoTimelockController.sol#L24:24

```solidity
File: contracts/L1/hooks/AssignmentHook.sol


62          function onBlockProposed(


164         function _getProverFee(


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/hooks/AssignmentHook.sol#L164:164

```solidity
File: contracts/L1/libs/LibDepositing.sol


29          function depositEtherToL2(


67          function processDeposits(


122         function canDepositEthToL2(


149         function _encodeEthDeposit(address _addr, uint256 _amount) private pure returns (uint256) {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibDepositing.sol#L149:149

```solidity
File: contracts/L1/libs/LibProposing.sol


68          function proposeBlock(


299         function _isProposerPermitted(


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProposing.sol#L299:299

```solidity
File: contracts/L1/libs/LibProving.sol


91          function proveBlock(


269         function _createTransition(


350         function _overrideWithHigherProof(


401         function _checkProverPermission(


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProving.sol#L401:401

```solidity
File: contracts/L1/libs/LibUtils.sol


52          function getBlock(


70          function getTransitionId(


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibUtils.sol#L70:70

```solidity
File: contracts/L1/libs/LibVerifying.sol


85          function verifyBlocks(


224         function _syncChainData(


245         function _isConfigValid(TaikoData.Config memory _config) private view returns (bool) {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibVerifying.sol#L245:245

```solidity
File: contracts/L1/provers/GuardianProver.sol


35          function approve(


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/provers/GuardianProver.sol#L35:35

```solidity
File: contracts/L1/provers/Guardians.sol


111         function approve(uint256 _operationId, bytes32 _hash) internal returns (bool approved_) {


124         function deleteApproval(bytes32 _hash) internal {


128         function isApproved(uint256 _approvalBits) internal view returns (bool) {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/provers/Guardians.sol#L128:128

```solidity
File: contracts/L1/tiers/DevnetTierProvider.sol


20          function getTier(uint16 _tierId) public pure override returns (ITierProvider.Tier memory) {


47          function getTierIds() public pure override returns (uint16[] memory tiers_) {


54          function getMinTier(uint256) public pure override returns (uint16) {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/tiers/DevnetTierProvider.sol#L54:54

```solidity
File: contracts/L1/tiers/ITierProvider.sol


22          function getTier(uint16 tierId) external view returns (Tier memory);


28          function getTierIds() external view returns (uint16[] memory);


33          function getMinTier(uint256 rand) external view returns (uint16);


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/tiers/ITierProvider.sol#L33:33

```solidity
File: contracts/L1/tiers/MainnetTierProvider.sol


20          function getTier(uint16 _tierId) public pure override returns (ITierProvider.Tier memory) {


58          function getTierIds() public pure override returns (uint16[] memory tiers_) {


66          function getMinTier(uint256 _rand) public pure override returns (uint16) {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/tiers/MainnetTierProvider.sol#L66:66

```solidity
File: contracts/L1/tiers/TestnetTierProvider.sol


20          function getTier(uint16 _tierId) public pure override returns (ITierProvider.Tier memory) {


58          function getTierIds() public pure override returns (uint16[] memory tiers_) {


66          function getMinTier(uint256 _rand) public pure override returns (uint16) {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/tiers/TestnetTierProvider.sol#L66:66

```solidity
File: contracts/L2/CrossChainOwned.sol


36          function onMessageInvocation(bytes calldata _data)


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/CrossChainOwned.sol#L36:36

```solidity
File: contracts/L2/Lib1559Math.sol


16          function basefee(


33          function _ethQty(


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/Lib1559Math.sol#L33:33

```solidity
File: contracts/L2/TaikoL2.sol


223         function _calcPublicInputHash(uint256 _blockId)


252         function _calc1559BaseFee(


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/TaikoL2.sol#L252:252

```solidity
File: contracts/L2/TaikoL2EIP1559Configurable.sol


43          function getConfig() public view override returns (Config memory) {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/TaikoL2EIP1559Configurable.sol#L43:43

```solidity
File: contracts/automata-attestation/AutomataDcapV3Attestation.sol


54          constructor(address sigVerifyLibAddr, address pemCertLibAddr) {


65          function setMrSigner(bytes32 _mrSigner, bool _trusted) external onlyOwner {


69          function setMrEnclave(bytes32 _mrEnclave, bool _trusted) external onlyOwner {


73          function addRevokedCertSerialNum(


88          function removeRevokedCertSerialNum(


103         function configureTcbInfoJson(


114         function configureQeIdentityJson(EnclaveIdStruct.EnclaveId calldata qeIdentityInput)


122         function toggleLocalReportCheck() external onlyOwner {


126         function _attestationTcbIsValid(TCBInfoStruct.TCBStatus status)


138         function verifyAttestation(bytes calldata data) external view override returns (bool) {


162         function _verify(bytes calldata quote) private view returns (bool, bytes memory) {


175         function _verifyQEReportWithIdentity(V3Struct.EnclaveReport memory quoteEnclaveReport)


206         function _checkTcbLevels(


229         function _isCpuSvnHigherOrGreater(


248         function _verifyCertChain(IPEMCertChainLib.ECSha256Certificate[] memory certs)


303         function _enclaveReportSigVerification(


355         function verifyParsedQuote(V3Struct.ParsedV3QuoteStruct calldata v3quote)


364         function _verifyParsedQuote(V3Struct.ParsedV3QuoteStruct memory v3quote)


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/AutomataDcapV3Attestation.sol#L364:364

```solidity
File: contracts/automata-attestation/interfaces/IAttestation.sol


9           function verifyAttestation(bytes calldata data) external returns (bool);


10          function verifyParsedQuote(V3Struct.ParsedV3QuoteStruct calldata v3quote)


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/interfaces/IAttestation.sol#L10:10

```solidity
File: contracts/automata-attestation/interfaces/ISigVerifyLib.sol


38          function verifyAttStmtSignature(


48          function verifyCertificateSignature(


58          function verifyRS256Signature(


67          function verifyRS1Signature(


76          function verifyES256Signature(


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/interfaces/ISigVerifyLib.sol#L76:76

```solidity
File: contracts/automata-attestation/lib/PEMCertChainLib.sol


40          function splitCertificateChain(


74          function decodeCert(


216         function _removeHeadersAndFooters(string memory pemData)


252         function _trimBytes(


269         function _findPckTcbInfo(


341         function _findTcb(


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/PEMCertChainLib.sol#L341:341

```solidity
File: contracts/automata-attestation/lib/QuoteV3Auth/V3Parser.sol


21          function parseInput(


62          function validateParsedInput(V3Struct.ParsedV3QuoteStruct memory v3Quote)


133         function parseEnclaveReport(bytes memory rawEnclaveReport)


152         function littleEndianDecode(bytes memory encoded) private pure returns (uint256 decoded) {


165         function parseAndVerifyHeader(bytes memory rawHeader)


203         function parseAuthDataAndVerifyCertType(


244         function packQEReport(V3Struct.EnclaveReport memory enclaveReport)


267         function parseCerificationChainBytes(


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/QuoteV3Auth/V3Parser.sol#L267:267

```solidity
File: contracts/automata-attestation/lib/interfaces/IPEMCertChainLib.sol


36          function splitCertificateChain(


44          function decodeCert(


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/interfaces/IPEMCertChainLib.sol#L44:44

```solidity
File: contracts/automata-attestation/utils/Asn1Decode.sol


14          function ixs(uint256 self) internal pure returns (uint256) {


19          function ixf(uint256 self) internal pure returns (uint256) {


24          function ixl(uint256 self) internal pure returns (uint256) {


29          function getPtr(uint256 _ixs, uint256 _ixf, uint256 _ixl) internal pure returns (uint256) {


47          function root(bytes memory der) internal pure returns (uint256) {


56          function rootOfBitStringAt(bytes memory der, uint256 ptr) internal pure returns (uint256) {


66          function rootOfOctetStringAt(bytes memory der, uint256 ptr) internal pure returns (uint256) {


77          function nextSiblingOf(bytes memory der, uint256 ptr) internal pure returns (uint256) {


87          function firstChildOf(bytes memory der, uint256 ptr) internal pure returns (uint256) {


98          function isChildOf(uint256 i, uint256 j) internal pure returns (bool) {


111         function bytesAt(bytes memory der, uint256 ptr) internal pure returns (bytes memory) {


121         function allBytesAt(bytes memory der, uint256 ptr) internal pure returns (bytes memory) {


131         function bytes32At(bytes memory der, uint256 ptr) internal pure returns (bytes32) {


141         function uintAt(bytes memory der, uint256 ptr) internal pure returns (uint256) {


154         function uintBytesAt(bytes memory der, uint256 ptr) internal pure returns (bytes memory) {


165         function keccakOfBytesAt(bytes memory der, uint256 ptr) internal pure returns (bytes32) {


169         function keccakOfAllBytesAt(bytes memory der, uint256 ptr) internal pure returns (bytes32) {


179         function bitstringAt(bytes memory der, uint256 ptr) internal pure returns (bytes memory) {


187         function _readNodeLength(bytes memory der, uint256 ix) private pure returns (uint256) {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/Asn1Decode.sol#L187:187

```solidity
File: contracts/automata-attestation/utils/BytesUtils.sol


16          function keccak(


39          function compare(bytes memory self, bytes memory other) internal pure returns (int256) {


56          function compare(


116         function equals(


138         function equals(


160         function equals(


178         function equals(bytes memory self, bytes memory other) internal pure returns (bool) {


188         function readUint8(bytes memory self, uint256 idx) internal pure returns (uint8 ret) {


198         function readUint16(bytes memory self, uint256 idx) internal pure returns (uint16 ret) {


211         function readUint32(bytes memory self, uint256 idx) internal pure returns (uint32 ret) {


224         function readBytes32(bytes memory self, uint256 idx) internal pure returns (bytes32 ret) {


237         function readBytes20(bytes memory self, uint256 idx) internal pure returns (bytes20 ret) {


255         function readBytesN(


272         function memcpy(uint256 dest, uint256 src, uint256 len) private pure {


284         function substring(


320         function base32HexDecodeWord(


371         function compareBytes(bytes memory a, bytes memory b) internal pure returns (bool) {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/BytesUtils.sol#L371:371

```solidity
File: contracts/automata-attestation/utils/RsaVerify.sol


43          function pkcs1Sha256(


191         function pkcs1Sha256Raw(


212         function pkcs1Sha1(


307         function pkcs1Sha1Raw(


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/RsaVerify.sol#L307:307

```solidity
File: contracts/automata-attestation/utils/SHA1.sol


11          function sha1(bytes memory data) internal pure returns (bytes20 ret) {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/SHA1.sol#L11:11

```solidity
File: contracts/automata-attestation/utils/SigVerifyLib.sol


20          constructor(address es256Verifier) {


24          function verifyAttStmtSignature(


54          function verifyCertificateSignature(


79          function verifyRS256Signature(


96          function verifyRS1Signature(


113         function verifyES256Signature(


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/SigVerifyLib.sol#L113:113

```solidity
File: contracts/automata-attestation/utils/X509DateUtils.sol


8           function toTimestamp(bytes memory x509Time) internal pure returns (uint256) {


34          function toUnixTimestamp(


71          function isLeapYear(uint16 year) internal pure returns (bool) {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/X509DateUtils.sol#L71:71

```solidity
File: contracts/bridge/Bridge.sol


115         function sendMessage(Message calldata _message)


155         function recallMessage(


217         function processMessage(


310         function retryMessage(


340         function isMessageSent(Message calldata _message) public view returns (bool) {


449         function hashMessage(Message memory _message) public pure returns (bytes32) {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/Bridge.sol#L449:449

```solidity
File: contracts/common/AddressManager.sol


54          function getAddress(uint64 _chainId, bytes32 _name) public view override returns (address) {


58          function _authorizePause(address) internal pure override {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/common/AddressManager.sol#L58:58

```solidity
File: contracts/common/AddressResolver.sol


30          function resolve(


43          function resolve(


58          function __AddressResolver_init(address _addressManager) internal virtual onlyInitializing {


72          function _resolve(


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/common/AddressResolver.sol#L72:72

```solidity
File: contracts/common/EssentialContract.sol


64          constructor() {


109         function __Essential_init(address _owner) internal virtual {


114         function _authorizeUpgrade(address) internal virtual override onlyOwner { }


116         function _authorizePause(address) internal virtual onlyOwner { }


119         function _storeReentryLock(uint8 _reentry) internal virtual {


130         function _loadReentryLock() internal view virtual returns (uint8 reentry_) {


140         function _inNonReentrant() internal view returns (bool) {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/common/EssentialContract.sol#L140:140

```solidity
File: contracts/libs/LibAddress.sol


22          function sendEther(address _to, uint256 _amount, uint256 _gasLimit) internal {


42          function sendEther(address _to, uint256 _amount) internal {


46          function supportsInterface(


61          function isValidSignature(


77          function isSenderEOA() internal view returns (bool) {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/libs/LibAddress.sol#L77:77

```solidity
File: contracts/libs/LibMath.sol


12          function min(uint256 _a, uint256 _b) internal pure returns (uint256) {


20          function max(uint256 _a, uint256 _b) internal pure returns (uint256) {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/libs/LibMath.sol#L20:20

```solidity
File: contracts/signal/SignalService.sol


56          function authorize(address _addr, bool _authorize) external onlyOwner {


63          function sendSignal(bytes32 _signal) external returns (bytes32) {


68          function syncChainData(


83          function proveSignalReceived(


137         function isChainDataSynced(


153         function isSignalSent(address _app, bytes32 _signal) public view returns (bool) {


158         function getSyncedChainData(


177         function signalForChainData(


206         function _verifyHopProof(


231         function _authorizePause(address) internal pure override {


235         function _syncChainData(


253         function _sendSignal(


271         function _cacheChainData(


298         function _loadSignalValue(


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/signal/SignalService.sol#L298:298

```solidity
File: contracts/team/TimelockTokenPool.sol


208         function _withdraw(address _recipient, address _to) private {


225         function _voidGrant(Grant storage _grant) private returns (uint128 amountVoided) {


235         function _getAmountOwned(Grant memory _grant) private view returns (uint128) {


239         function _getAmountUnlocked(Grant memory _grant) private view returns (uint128) {


245         function _calcAmount(


267         function _validateGrant(Grant memory _grant) private pure {


273         function _validateCliff(uint64 _start, uint64 _cliff, uint32 _period) private pure {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/TimelockTokenPool.sol#L273:273

```solidity
File: contracts/team/airdrop/MerkleClaimable.sol


56          function __MerkleClaimable_init(


67          function _verifyClaim(bytes memory data, bytes32[] calldata proof) internal ongoingClaim {


77          function _verifyMerkleProof(


90          function _setConfig(uint64 _claimStart, uint64 _claimEnd, bytes32 _merkleRoot) private {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/airdrop/MerkleClaimable.sol#L90:90

```solidity
File: contracts/thirdparty/solmate/LibFixedPointMath.sol


13          function exp(int256 x) internal pure returns (int256 r) {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/solmate/LibFixedPointMath.sol#L13:13

```solidity
File: contracts/tokenvault/BaseVault.sol


47          function checkProcessMessageContext()


58          function checkRecallMessageContext()


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BaseVault.sol#L58:58

```solidity
File: contracts/tokenvault/BridgedERC1155.sol


66          function mint(


83          function mintBatch(


100         function burn(


125         function _beforeTokenTransfer(


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC1155.sol#L125:125

```solidity
File: contracts/tokenvault/BridgedERC20.sol


129         function _mintToken(address _account, uint256 _amount) internal override {


133         function _burnToken(address _from, uint256 _amount) internal override {


139         function _beforeTokenTransfer(


152         function _afterTokenTransfer(


163         function _mint(


173         function _burn(


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC20.sol#L173:173

```solidity
File: contracts/tokenvault/BridgedERC20Base.sol


97          function _mintToken(address _account, uint256 _amount) internal virtual;


99          function _burnToken(address _from, uint256 _amount) internal virtual;


101         function _isMigratingOut() internal view returns (bool) {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC20Base.sol#L101:101

```solidity
File: contracts/tokenvault/BridgedERC721.sol


54          function mint(


69          function burn(


115         function _beforeTokenTransfer(


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC721.sol#L115:115

```solidity
File: contracts/tokenvault/ERC1155Vault.sol


93          function onMessageInvocation(bytes calldata data) external payable nonReentrant whenNotPaused {


127         function onMessageRecalled(


192         function supportsInterface(bytes4 interfaceId)


204         function name() public pure override returns (bytes32) {


214         function _transferTokens(


240         function _handleMessage(


288         function _getOrDeployBridgedToken(CanonicalNFT memory _ctoken)


303         function _deployBridgedToken(CanonicalNFT memory _ctoken) private returns (address btoken_) {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC1155Vault.sol#L303:303

```solidity
File: contracts/tokenvault/ERC20Vault.sol


253         function onMessageInvocation(bytes calldata _data)


285         function onMessageRecalled(


316         function name() public pure override returns (bytes32) {


320         function _transferTokens(


348         function _handleMessage(


391         function _getOrDeployBridgedToken(CanonicalERC20 memory ctoken)


407         function _deployBridgedToken(CanonicalERC20 memory ctoken) private returns (address btoken) {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC20Vault.sol#L407:407

```solidity
File: contracts/tokenvault/ERC721Vault.sol


77          function onMessageInvocation(bytes calldata _data)


110         function onMessageRecalled(


142         function onERC721Received(


156         function name() public pure override returns (bytes32) {


160         function _transferTokens(


187         function _handleMessage(


224         function _getOrDeployBridgedToken(CanonicalNFT memory _ctoken)


240         function _deployBridgedToken(CanonicalNFT memory _ctoken) private returns (address btoken_) {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC721Vault.sol#L240:240

```solidity
File: contracts/tokenvault/LibBridgedToken.sol


11          function validateInputs(


28          function buildName(


39          function buildSymbol(string memory _symbol) internal pure returns (string memory) {


43          function buildURI(


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/LibBridgedToken.sol#L43:43

```solidity
File: contracts/tokenvault/adapters/USDCAdapter.sol


43          function _mintToken(address _account, uint256 _amount) internal override {


47          function _burnToken(address _from, uint256 _amount) internal override {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/adapters/USDCAdapter.sol#L47:47

```solidity
File: contracts/verifiers/GuardianVerifier.sol


23          function verifyProof(


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/verifiers/GuardianVerifier.sol#L23:23

```solidity
File: contracts/verifiers/SgxVerifier.sol


139         function verifyProof(


195         function _addInstances(


226         function _replaceInstance(uint256 id, address oldInstance, address newInstance) private {


233         function _isInstanceValid(uint256 id, address instance) private view returns (bool) {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/verifiers/SgxVerifier.sol#L233:233

</details>

## NC083 - Interface declarations should have NatSpec @author annotations:

The name of the author


<details>
<summary>Click to show 16 findings</summary>

```solidity
File: contracts/L1/ITaikoL1.sol


8       interface ITaikoL1 {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/ITaikoL1.sol#L8:8

```solidity
File: contracts/L1/hooks/IHook.sol


8       interface IHook {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/hooks/IHook.sol#L8:8

```solidity
File: contracts/L1/tiers/ITierProvider.sol


7       interface ITierProvider {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/tiers/ITierProvider.sol#L7:7

```solidity
File: contracts/automata-attestation/interfaces/IAttestation.sol


8       interface IAttestation {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/interfaces/IAttestation.sol#L8:8

```solidity
File: contracts/automata-attestation/interfaces/ISigVerifyLib.sol


6       interface ISigVerifyLib {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/interfaces/ISigVerifyLib.sol#L6:6

```solidity
File: contracts/automata-attestation/lib/interfaces/IPEMCertChainLib.sol


6       interface IPEMCertChainLib {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/interfaces/IPEMCertChainLib.sol#L6:6

```solidity
File: contracts/bridge/IBridge.sol


8       interface IBridge {


160     interface IRecallableSender {


174     interface IMessageInvocable {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/IBridge.sol#L174:174

```solidity
File: contracts/common/IAddressManager.sol


7       interface IAddressManager {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/common/IAddressManager.sol#L7:7

```solidity
File: contracts/common/IAddressResolver.sol


13      interface IAddressResolver {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/common/IAddressResolver.sol#L13:13

```solidity
File: contracts/signal/ISignalService.sol


12      interface ISignalService {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/signal/ISignalService.sol#L12:12

```solidity
File: contracts/tokenvault/ERC1155Vault.sol


16      interface IERC1155NameAndSymbol {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC1155Vault.sol#L16:16

```solidity
File: contracts/tokenvault/IBridgedERC20.sol


10      interface IBridgedERC20 {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/IBridgedERC20.sol#L10:10

```solidity
File: contracts/tokenvault/adapters/USDCAdapter.sol


8       interface IUSDC {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/adapters/USDCAdapter.sol#L8:8

```solidity
File: contracts/verifiers/IVerifier.sol


9       interface IVerifier {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/verifiers/IVerifier.sol#L9:9

</details>

## NC084 - Interface declarations should have NatSpec @notice annotations:

Explain to an end user what this does


<details>
<summary>Click to show 6 findings</summary>

```solidity
File: contracts/L1/ITaikoL1.sol


8       interface ITaikoL1 {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/ITaikoL1.sol#L8:8

```solidity
File: contracts/L1/hooks/IHook.sol


8       interface IHook {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/hooks/IHook.sol#L8:8

```solidity
File: contracts/automata-attestation/interfaces/IAttestation.sol


8       interface IAttestation {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/interfaces/IAttestation.sol#L8:8

```solidity
File: contracts/automata-attestation/interfaces/ISigVerifyLib.sol


6       interface ISigVerifyLib {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/interfaces/ISigVerifyLib.sol#L6:6

```solidity
File: contracts/automata-attestation/lib/interfaces/IPEMCertChainLib.sol


6       interface IPEMCertChainLib {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/interfaces/IPEMCertChainLib.sol#L6:6

```solidity
File: contracts/tokenvault/adapters/USDCAdapter.sol


8       interface IUSDC {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/adapters/USDCAdapter.sol#L8:8

</details>

## NC085 - Interface declarations should have NatSpec @dev annotations:

Explain to a developer any extra details


<details>
<summary>Click to show 13 findings</summary>

```solidity
File: contracts/L1/ITaikoL1.sol


8       interface ITaikoL1 {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/ITaikoL1.sol#L8:8

```solidity
File: contracts/L1/hooks/IHook.sol


8       interface IHook {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/hooks/IHook.sol#L8:8

```solidity
File: contracts/L1/tiers/ITierProvider.sol


7       interface ITierProvider {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/tiers/ITierProvider.sol#L7:7

```solidity
File: contracts/automata-attestation/interfaces/IAttestation.sol


8       interface IAttestation {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/interfaces/IAttestation.sol#L8:8

```solidity
File: contracts/automata-attestation/interfaces/ISigVerifyLib.sol


6       interface ISigVerifyLib {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/interfaces/ISigVerifyLib.sol#L6:6

```solidity
File: contracts/automata-attestation/lib/interfaces/IPEMCertChainLib.sol


6       interface IPEMCertChainLib {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/interfaces/IPEMCertChainLib.sol#L6:6

```solidity
File: contracts/bridge/IBridge.sol


160     interface IRecallableSender {


174     interface IMessageInvocable {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/IBridge.sol#L174:174

```solidity
File: contracts/common/IAddressManager.sol


7       interface IAddressManager {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/common/IAddressManager.sol#L7:7

```solidity
File: contracts/signal/ISignalService.sol


12      interface ISignalService {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/signal/ISignalService.sol#L12:12

```solidity
File: contracts/tokenvault/ERC1155Vault.sol


16      interface IERC1155NameAndSymbol {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC1155Vault.sol#L16:16

```solidity
File: contracts/tokenvault/adapters/USDCAdapter.sol


8       interface IUSDC {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/adapters/USDCAdapter.sol#L8:8

```solidity
File: contracts/verifiers/IVerifier.sol


9       interface IVerifier {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/verifiers/IVerifier.sol#L9:9

</details>

## NC086 - Abstract contract declarations should have NatSpec @author annotations:

The name of the author


<details>
<summary>Click to show 10 findings</summary>

```solidity
File: contracts/L1/TaikoErrors.sol


11      abstract contract TaikoErrors {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/TaikoErrors.sol#L11:11

```solidity
File: contracts/L1/TaikoEvents.sol


13      abstract contract TaikoEvents {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/TaikoEvents.sol#L13:13

```solidity
File: contracts/L1/provers/Guardians.sol


9       abstract contract Guardians is EssentialContract {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/provers/Guardians.sol#L9:9

```solidity
File: contracts/L2/CrossChainOwned.sol


14      abstract contract CrossChainOwned is EssentialContract, IMessageInvocable {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/CrossChainOwned.sol#L14:14

```solidity
File: contracts/common/AddressResolver.sol


11      abstract contract AddressResolver is IAddressResolver, Initializable {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/common/AddressResolver.sol#L11:11

```solidity
File: contracts/common/EssentialContract.sol


10      abstract contract EssentialContract is UUPSUpgradeable, Ownable2StepUpgradeable, AddressResolver {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/common/EssentialContract.sol#L10:10

```solidity
File: contracts/team/airdrop/MerkleClaimable.sol


10      abstract contract MerkleClaimable is EssentialContract {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/airdrop/MerkleClaimable.sol#L10:10

```solidity
File: contracts/tokenvault/BaseNFTVault.sol


9       abstract contract BaseNFTVault is BaseVault {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BaseNFTVault.sol#L9:9

```solidity
File: contracts/tokenvault/BaseVault.sol


12      abstract contract BaseVault is


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BaseVault.sol#L12:12

```solidity
File: contracts/tokenvault/BridgedERC20Base.sol


9       abstract contract BridgedERC20Base is EssentialContract, IBridgedERC20 {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC20Base.sol#L9:9

</details>

## NC087 - Abstract contract declarations should have NatSpec @notice annotations:

Explain to an end user what this does


```solidity
File: contracts/common/EssentialContract.sol


10      abstract contract EssentialContract is UUPSUpgradeable, Ownable2StepUpgradeable, AddressResolver {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/common/EssentialContract.sol#L10:10

```solidity
File: contracts/tokenvault/BridgedERC20Base.sol


9       abstract contract BridgedERC20Base is EssentialContract, IBridgedERC20 {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC20Base.sol#L9:9

## NC088 - Abstract contract declarations should have Natspec @dev annotations:

Explain to a developer any extra details


<details>
<summary>Click to show 7 findings</summary>

```solidity
File: contracts/L1/provers/Guardians.sol


9       abstract contract Guardians is EssentialContract {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/provers/Guardians.sol#L9:9

```solidity
File: contracts/common/AddressResolver.sol


11      abstract contract AddressResolver is IAddressResolver, Initializable {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/common/AddressResolver.sol#L11:11

```solidity
File: contracts/common/EssentialContract.sol


10      abstract contract EssentialContract is UUPSUpgradeable, Ownable2StepUpgradeable, AddressResolver {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/common/EssentialContract.sol#L10:10

```solidity
File: contracts/team/airdrop/MerkleClaimable.sol


10      abstract contract MerkleClaimable is EssentialContract {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/airdrop/MerkleClaimable.sol#L10:10

```solidity
File: contracts/tokenvault/BaseNFTVault.sol


9       abstract contract BaseNFTVault is BaseVault {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BaseNFTVault.sol#L9:9

```solidity
File: contracts/tokenvault/BaseVault.sol


12      abstract contract BaseVault is


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BaseVault.sol#L12:12

```solidity
File: contracts/tokenvault/BridgedERC20Base.sol


9       abstract contract BridgedERC20Base is EssentialContract, IBridgedERC20 {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC20Base.sol#L9:9

</details>

## NC089 - Library declarations should have Natspec @title annotations:

A title that should describe the contract/interface


```solidity
File: contracts/L1/tiers/ITierProvider.sol


37      library LibTiers {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/tiers/ITierProvider.sol#L37:37

```solidity
File: contracts/thirdparty/nomad-xyz/ExcessivelySafeCall.sol


5       library ExcessivelySafeCall {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/nomad-xyz/ExcessivelySafeCall.sol#L5:5

```solidity
File: contracts/thirdparty/solmate/LibFixedPointMath.sol


6       library LibFixedPointMath {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/solmate/LibFixedPointMath.sol#L6:6

## NC090 - Library declarations should have Natspec @author annotations:

The name of the author


<details>
<summary>Click to show 30 findings</summary>

```solidity
File: contracts/L1/TaikoData.sol


8       library TaikoData {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/TaikoData.sol#L8:8

```solidity
File: contracts/L1/libs/LibDepositing.sol


12      library LibDepositing {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibDepositing.sol#L12:12

```solidity
File: contracts/L1/libs/LibProposing.sol


15      library LibProposing {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProposing.sol#L15:15

```solidity
File: contracts/L1/libs/LibProving.sol


16      library LibProving {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProving.sol#L16:16

```solidity
File: contracts/L1/libs/LibUtils.sol


9       library LibUtils {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibUtils.sol#L9:9

```solidity
File: contracts/L1/libs/LibVerifying.sol


16      library LibVerifying {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibVerifying.sol#L16:16

```solidity
File: contracts/L1/tiers/ITierProvider.sol


37      library LibTiers {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/tiers/ITierProvider.sol#L37:37

```solidity
File: contracts/L2/Lib1559Math.sol


10      library Lib1559Math {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/Lib1559Math.sol#L10:10

```solidity
File: contracts/automata-attestation/lib/EnclaveIdStruct.sol


6       library EnclaveIdStruct {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/EnclaveIdStruct.sol#L6:6

```solidity
File: contracts/automata-attestation/lib/QuoteV3Auth/V3Parser.sol


11      library V3Parser {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/QuoteV3Auth/V3Parser.sol#L11:11

```solidity
File: contracts/automata-attestation/lib/QuoteV3Auth/V3Struct.sol


6       library V3Struct {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/QuoteV3Auth/V3Struct.sol#L6:6

```solidity
File: contracts/automata-attestation/lib/TCBInfoStruct.sol


6       library TCBInfoStruct {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/TCBInfoStruct.sol#L6:6

```solidity
File: contracts/automata-attestation/utils/Asn1Decode.sol


12      library NodePtr {


38      library Asn1Decode {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/Asn1Decode.sol#L38:38

```solidity
File: contracts/automata-attestation/utils/BytesUtils.sol


8       library BytesUtils {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/BytesUtils.sol#L8:8

```solidity
File: contracts/automata-attestation/utils/RsaVerify.sol


34      library RsaVerify {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/RsaVerify.sol#L34:34

```solidity
File: contracts/automata-attestation/utils/SHA1.sol


10      library SHA1 {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/SHA1.sol#L10:10

```solidity
File: contracts/automata-attestation/utils/X509DateUtils.sol


7       library X509DateUtils {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/X509DateUtils.sol#L7:7

```solidity
File: contracts/libs/Lib4844.sol


8       library Lib4844 {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/libs/Lib4844.sol#L8:8

```solidity
File: contracts/libs/LibAddress.sol


13      library LibAddress {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/libs/LibAddress.sol#L13:13

```solidity
File: contracts/libs/LibMath.sol


7       library LibMath {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/libs/LibMath.sol#L7:7

```solidity
File: contracts/libs/LibTrieProof.sol


15      library LibTrieProof {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/libs/LibTrieProof.sol#L15:15

```solidity
File: contracts/signal/LibSignals.sol


6       library LibSignals {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/signal/LibSignals.sol#L6:6

```solidity
File: contracts/thirdparty/nomad-xyz/ExcessivelySafeCall.sol


5       library ExcessivelySafeCall {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/nomad-xyz/ExcessivelySafeCall.sol#L5:5

```solidity
File: contracts/thirdparty/optimism/Bytes.sol


6       library Bytes {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/Bytes.sol#L6:6

```solidity
File: contracts/thirdparty/optimism/rlp/RLPReader.sol


9       library RLPReader {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/rlp/RLPReader.sol#L9:9

```solidity
File: contracts/thirdparty/optimism/trie/MerkleTrie.sol


11      library MerkleTrie {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/trie/MerkleTrie.sol#L11:11

```solidity
File: contracts/thirdparty/optimism/trie/SecureMerkleTrie.sol


9       library SecureMerkleTrie {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/trie/SecureMerkleTrie.sol#L9:9

```solidity
File: contracts/thirdparty/solmate/LibFixedPointMath.sol


6       library LibFixedPointMath {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/solmate/LibFixedPointMath.sol#L6:6

```solidity
File: contracts/tokenvault/LibBridgedToken.sol


8       library LibBridgedToken {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/LibBridgedToken.sol#L8:8

</details>

## NC091 - Library declarations should have Natspec @notice annotations:

Explain to an end user what this does


<details>
<summary>Click to show 19 findings</summary>

```solidity
File: contracts/L1/tiers/ITierProvider.sol


37      library LibTiers {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/tiers/ITierProvider.sol#L37:37

```solidity
File: contracts/automata-attestation/lib/EnclaveIdStruct.sol


6       library EnclaveIdStruct {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/EnclaveIdStruct.sol#L6:6

```solidity
File: contracts/automata-attestation/lib/QuoteV3Auth/V3Parser.sol


11      library V3Parser {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/QuoteV3Auth/V3Parser.sol#L11:11

```solidity
File: contracts/automata-attestation/lib/QuoteV3Auth/V3Struct.sol


6       library V3Struct {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/QuoteV3Auth/V3Struct.sol#L6:6

```solidity
File: contracts/automata-attestation/lib/TCBInfoStruct.sol


6       library TCBInfoStruct {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/TCBInfoStruct.sol#L6:6

```solidity
File: contracts/automata-attestation/utils/Asn1Decode.sol


12      library NodePtr {


38      library Asn1Decode {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/Asn1Decode.sol#L38:38

```solidity
File: contracts/automata-attestation/utils/BytesUtils.sol


8       library BytesUtils {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/BytesUtils.sol#L8:8

```solidity
File: contracts/automata-attestation/utils/RsaVerify.sol


34      library RsaVerify {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/RsaVerify.sol#L34:34

```solidity
File: contracts/automata-attestation/utils/SHA1.sol


10      library SHA1 {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/SHA1.sol#L10:10

```solidity
File: contracts/automata-attestation/utils/X509DateUtils.sol


7       library X509DateUtils {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/X509DateUtils.sol#L7:7

```solidity
File: contracts/libs/LibAddress.sol


13      library LibAddress {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/libs/LibAddress.sol#L13:13

```solidity
File: contracts/libs/LibMath.sol


7       library LibMath {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/libs/LibMath.sol#L7:7

```solidity
File: contracts/libs/LibTrieProof.sol


15      library LibTrieProof {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/libs/LibTrieProof.sol#L15:15

```solidity
File: contracts/signal/LibSignals.sol


6       library LibSignals {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/signal/LibSignals.sol#L6:6

```solidity
File: contracts/thirdparty/nomad-xyz/ExcessivelySafeCall.sol


5       library ExcessivelySafeCall {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/nomad-xyz/ExcessivelySafeCall.sol#L5:5

```solidity
File: contracts/thirdparty/optimism/rlp/RLPWriter.sol


9       library RLPWriter {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/rlp/RLPWriter.sol#L9:9

```solidity
File: contracts/thirdparty/solmate/LibFixedPointMath.sol


6       library LibFixedPointMath {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/solmate/LibFixedPointMath.sol#L6:6

```solidity
File: contracts/tokenvault/LibBridgedToken.sol


8       library LibBridgedToken {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/LibBridgedToken.sol#L8:8

</details>

## NC092 - Library declarations should have Natspec @dev annotations:

Explain to a developer any extra details


<details>
<summary>Click to show 26 findings</summary>

```solidity
File: contracts/L1/TaikoData.sol


8       library TaikoData {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/TaikoData.sol#L8:8

```solidity
File: contracts/L1/libs/LibDepositing.sol


12      library LibDepositing {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibDepositing.sol#L12:12

```solidity
File: contracts/L1/libs/LibProposing.sol


15      library LibProposing {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProposing.sol#L15:15

```solidity
File: contracts/L1/libs/LibProving.sol


16      library LibProving {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProving.sol#L16:16

```solidity
File: contracts/L1/libs/LibUtils.sol


9       library LibUtils {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibUtils.sol#L9:9

```solidity
File: contracts/L1/libs/LibVerifying.sol


16      library LibVerifying {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibVerifying.sol#L16:16

```solidity
File: contracts/automata-attestation/lib/EnclaveIdStruct.sol


6       library EnclaveIdStruct {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/EnclaveIdStruct.sol#L6:6

```solidity
File: contracts/automata-attestation/lib/QuoteV3Auth/V3Parser.sol


11      library V3Parser {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/QuoteV3Auth/V3Parser.sol#L11:11

```solidity
File: contracts/automata-attestation/lib/QuoteV3Auth/V3Struct.sol


6       library V3Struct {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/QuoteV3Auth/V3Struct.sol#L6:6

```solidity
File: contracts/automata-attestation/lib/TCBInfoStruct.sol


6       library TCBInfoStruct {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/TCBInfoStruct.sol#L6:6

```solidity
File: contracts/automata-attestation/utils/Asn1Decode.sol


12      library NodePtr {


38      library Asn1Decode {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/Asn1Decode.sol#L38:38

```solidity
File: contracts/automata-attestation/utils/BytesUtils.sol


8       library BytesUtils {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/BytesUtils.sol#L8:8

```solidity
File: contracts/automata-attestation/utils/RsaVerify.sol


34      library RsaVerify {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/RsaVerify.sol#L34:34

```solidity
File: contracts/automata-attestation/utils/SHA1.sol


10      library SHA1 {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/SHA1.sol#L10:10

```solidity
File: contracts/automata-attestation/utils/X509DateUtils.sol


7       library X509DateUtils {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/X509DateUtils.sol#L7:7

```solidity
File: contracts/libs/LibTrieProof.sol


15      library LibTrieProof {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/libs/LibTrieProof.sol#L15:15

```solidity
File: contracts/signal/LibSignals.sol


6       library LibSignals {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/signal/LibSignals.sol#L6:6

```solidity
File: contracts/thirdparty/nomad-xyz/ExcessivelySafeCall.sol


5       library ExcessivelySafeCall {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/nomad-xyz/ExcessivelySafeCall.sol#L5:5

```solidity
File: contracts/thirdparty/optimism/Bytes.sol


6       library Bytes {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/Bytes.sol#L6:6

```solidity
File: contracts/thirdparty/optimism/rlp/RLPReader.sol


9       library RLPReader {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/rlp/RLPReader.sol#L9:9

```solidity
File: contracts/thirdparty/optimism/rlp/RLPWriter.sol


9       library RLPWriter {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/rlp/RLPWriter.sol#L9:9

```solidity
File: contracts/thirdparty/optimism/trie/MerkleTrie.sol


11      library MerkleTrie {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/trie/MerkleTrie.sol#L11:11

```solidity
File: contracts/thirdparty/optimism/trie/SecureMerkleTrie.sol


9       library SecureMerkleTrie {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/trie/SecureMerkleTrie.sol#L9:9

```solidity
File: contracts/thirdparty/solmate/LibFixedPointMath.sol


6       library LibFixedPointMath {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/solmate/LibFixedPointMath.sol#L6:6

```solidity
File: contracts/tokenvault/LibBridgedToken.sol


8       library LibBridgedToken {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/LibBridgedToken.sol#L8:8

</details>

## NC093 - Modifier definitions should have Natspec @notice annotations:

Explain to an end user what this does


<details>
<summary>Click to show 15 findings</summary>

```solidity
File: contracts/L1/TaikoL1.sol


28          modifier whenProvingNotPaused() {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/TaikoL1.sol#L28:28

```solidity
File: contracts/automata-attestation/AutomataDcapV3Attestation.sol


60          modifier onlyOwner() {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/AutomataDcapV3Attestation.sol#L60:60

```solidity
File: contracts/bridge/Bridge.sol


64          modifier sameChain(uint64 _chainId) {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/Bridge.sol#L64:64

```solidity
File: contracts/common/AddressResolver.sol


24          modifier onlyFromNamed(bytes32 _name) {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/common/AddressResolver.sol#L24:24

```solidity
File: contracts/common/EssentialContract.sol


41          modifier onlyFromOwnerOrNamed(bytes32 _name) {


46          modifier nonReentrant() {


53          modifier whenPaused() {


58          modifier whenNotPaused() {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/common/EssentialContract.sol#L58:58

```solidity
File: contracts/signal/SignalService.sol


35          modifier validSender(address _app) {


40          modifier nonZeroValue(bytes32 _input) {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/signal/SignalService.sol#L40:40

```solidity
File: contracts/team/airdrop/ERC20Airdrop2.sol


39          modifier ongoingWithdrawals() {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/airdrop/ERC20Airdrop2.sol#L39:39

```solidity
File: contracts/team/airdrop/MerkleClaimable.sol


33          modifier ongoingClaim() {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/airdrop/MerkleClaimable.sol#L33:33

```solidity
File: contracts/tokenvault/BaseNFTVault.sol


140         modifier withValidOperation(BridgeTransferOp memory _op) {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BaseNFTVault.sol#L140:140

```solidity
File: contracts/tokenvault/BaseVault.sol


22          modifier onlyFromBridge() {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BaseVault.sol#L22:22

```solidity
File: contracts/tokenvault/BridgedERC20.sol


37          modifier onlyOwnerOrSnapshooter() {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC20.sol#L37:37

</details>

## NC094 - Modifier definitions should have Natspec @dev annotations:

Explain to a developer any extra details


<details>
<summary>Click to show 13 findings</summary>

```solidity
File: contracts/L1/TaikoL1.sol


28          modifier whenProvingNotPaused() {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/TaikoL1.sol#L28:28

```solidity
File: contracts/automata-attestation/AutomataDcapV3Attestation.sol


60          modifier onlyOwner() {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/AutomataDcapV3Attestation.sol#L60:60

```solidity
File: contracts/bridge/Bridge.sol


64          modifier sameChain(uint64 _chainId) {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/Bridge.sol#L64:64

```solidity
File: contracts/common/EssentialContract.sol


46          modifier nonReentrant() {


53          modifier whenPaused() {


58          modifier whenNotPaused() {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/common/EssentialContract.sol#L58:58

```solidity
File: contracts/signal/SignalService.sol


35          modifier validSender(address _app) {


40          modifier nonZeroValue(bytes32 _input) {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/signal/SignalService.sol#L40:40

```solidity
File: contracts/team/airdrop/ERC20Airdrop2.sol


39          modifier ongoingWithdrawals() {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/airdrop/ERC20Airdrop2.sol#L39:39

```solidity
File: contracts/team/airdrop/MerkleClaimable.sol


33          modifier ongoingClaim() {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/airdrop/MerkleClaimable.sol#L33:33

```solidity
File: contracts/tokenvault/BaseNFTVault.sol


140         modifier withValidOperation(BridgeTransferOp memory _op) {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BaseNFTVault.sol#L140:140

```solidity
File: contracts/tokenvault/BaseVault.sol


22          modifier onlyFromBridge() {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BaseVault.sol#L22:22

```solidity
File: contracts/tokenvault/BridgedERC20.sol


37          modifier onlyOwnerOrSnapshooter() {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC20.sol#L37:37

</details>

## NC095 - Contract definitions should have Natspec @author annotations:

The name of the author


<details>
<summary>Click to show 30 findings</summary>

```solidity
File: contracts/L1/TaikoL1.sol


22      contract TaikoL1 is EssentialContract, ITaikoL1, TaikoEvents, TaikoErrors {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/TaikoL1.sol#L22:22

```solidity
File: contracts/L1/TaikoToken.sol


15      contract TaikoToken is EssentialContract, ERC20SnapshotUpgradeable, ERC20VotesUpgradeable {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/TaikoToken.sol#L15:15

```solidity
File: contracts/L1/gov/TaikoGovernor.sol


16      contract TaikoGovernor is


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/gov/TaikoGovernor.sol#L16:16

```solidity
File: contracts/L1/gov/TaikoTimelockController.sol


9       contract TaikoTimelockController is EssentialContract, TimelockControllerUpgradeable {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/gov/TaikoTimelockController.sol#L9:9

```solidity
File: contracts/L1/hooks/AssignmentHook.sol


14      contract AssignmentHook is EssentialContract, IHook {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/hooks/AssignmentHook.sol#L14:14

```solidity
File: contracts/L1/provers/GuardianProver.sol


10      contract GuardianProver is Guardians {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/provers/GuardianProver.sol#L10:10

```solidity
File: contracts/L1/tiers/DevnetTierProvider.sol


10      contract DevnetTierProvider is EssentialContract, ITierProvider {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/tiers/DevnetTierProvider.sol#L10:10

```solidity
File: contracts/L1/tiers/MainnetTierProvider.sol


10      contract MainnetTierProvider is EssentialContract, ITierProvider {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/tiers/MainnetTierProvider.sol#L10:10

```solidity
File: contracts/L1/tiers/TestnetTierProvider.sol


10      contract TestnetTierProvider is EssentialContract, ITierProvider {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/tiers/TestnetTierProvider.sol#L10:10

```solidity
File: contracts/L2/TaikoL2.sol


21      contract TaikoL2 is CrossChainOwned {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/TaikoL2.sol#L21:21

```solidity
File: contracts/L2/TaikoL2EIP1559Configurable.sol


9       contract TaikoL2EIP1559Configurable is TaikoL2 {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/TaikoL2EIP1559Configurable.sol#L9:9

```solidity
File: contracts/automata-attestation/AutomataDcapV3Attestation.sol


22      contract AutomataDcapV3Attestation is IAttestation {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/AutomataDcapV3Attestation.sol#L22:22

```solidity
File: contracts/automata-attestation/lib/PEMCertChainLib.sol


12      contract PEMCertChainLib is IPEMCertChainLib {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/PEMCertChainLib.sol#L12:12

```solidity
File: contracts/automata-attestation/utils/SigVerifyLib.sol


15      contract SigVerifyLib is ISigVerifyLib {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/SigVerifyLib.sol#L15:15

```solidity
File: contracts/bridge/Bridge.sol


16      contract Bridge is EssentialContract, IBridge {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/Bridge.sol#L16:16

```solidity
File: contracts/common/AddressManager.sol


10      contract AddressManager is EssentialContract, IAddressManager {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/common/AddressManager.sol#L10:10

```solidity
File: contracts/signal/SignalService.sol


14      contract SignalService is EssentialContract, ISignalService {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/signal/SignalService.sol#L14:14

```solidity
File: contracts/team/TimelockTokenPool.sol


25      contract TimelockTokenPool is EssentialContract {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/TimelockTokenPool.sol#L25:25

```solidity
File: contracts/team/airdrop/ERC20Airdrop.sol


11      contract ERC20Airdrop is MerkleClaimable {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/airdrop/ERC20Airdrop.sol#L11:11

```solidity
File: contracts/team/airdrop/ERC20Airdrop2.sol


12      contract ERC20Airdrop2 is MerkleClaimable {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/airdrop/ERC20Airdrop2.sol#L12:12

```solidity
File: contracts/team/airdrop/ERC721Airdrop.sol


9       contract ERC721Airdrop is MerkleClaimable {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/airdrop/ERC721Airdrop.sol#L9:9

```solidity
File: contracts/tokenvault/BridgedERC1155.sol


14      contract BridgedERC1155 is EssentialContract, IERC1155MetadataURIUpgradeable, ERC1155Upgradeable {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC1155.sol#L14:14

```solidity
File: contracts/tokenvault/BridgedERC20.sol


15      contract BridgedERC20 is


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC20.sol#L15:15

```solidity
File: contracts/tokenvault/BridgedERC721.sol


12      contract BridgedERC721 is EssentialContract, ERC721Upgradeable {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC721.sol#L12:12

```solidity
File: contracts/tokenvault/ERC1155Vault.sol


29      contract ERC1155Vault is BaseNFTVault, ERC1155ReceiverUpgradeable {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC1155Vault.sol#L29:29

```solidity
File: contracts/tokenvault/ERC20Vault.sol


18      contract ERC20Vault is BaseVault {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC20Vault.sol#L18:18

```solidity
File: contracts/tokenvault/ERC721Vault.sol


16      contract ERC721Vault is BaseNFTVault, IERC721Receiver {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC721Vault.sol#L16:16

```solidity
File: contracts/tokenvault/adapters/USDCAdapter.sol


28      contract USDCAdapter is BridgedERC20Base {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/adapters/USDCAdapter.sol#L28:28

```solidity
File: contracts/verifiers/GuardianVerifier.sol


10      contract GuardianVerifier is EssentialContract, IVerifier {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/verifiers/GuardianVerifier.sol#L10:10

```solidity
File: contracts/verifiers/SgxVerifier.sol


19      contract SgxVerifier is EssentialContract, IVerifier {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/verifiers/SgxVerifier.sol#L19:19

</details>

## NC096 - Contract definitions should have Natspec @notice annotations:

Explain to an end user what this does


<details>
<summary>Click to show 12 findings</summary>

```solidity
File: contracts/L1/gov/TaikoGovernor.sol


16      contract TaikoGovernor is


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/gov/TaikoGovernor.sol#L16:16

```solidity
File: contracts/L1/gov/TaikoTimelockController.sol


9       contract TaikoTimelockController is EssentialContract, TimelockControllerUpgradeable {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/gov/TaikoTimelockController.sol#L9:9

```solidity
File: contracts/L1/provers/GuardianProver.sol


10      contract GuardianProver is Guardians {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/provers/GuardianProver.sol#L10:10

```solidity
File: contracts/L1/tiers/DevnetTierProvider.sol


10      contract DevnetTierProvider is EssentialContract, ITierProvider {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/tiers/DevnetTierProvider.sol#L10:10

```solidity
File: contracts/L1/tiers/MainnetTierProvider.sol


10      contract MainnetTierProvider is EssentialContract, ITierProvider {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/tiers/MainnetTierProvider.sol#L10:10

```solidity
File: contracts/L1/tiers/TestnetTierProvider.sol


10      contract TestnetTierProvider is EssentialContract, ITierProvider {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/tiers/TestnetTierProvider.sol#L10:10

```solidity
File: contracts/automata-attestation/AutomataDcapV3Attestation.sol


22      contract AutomataDcapV3Attestation is IAttestation {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/AutomataDcapV3Attestation.sol#L22:22

```solidity
File: contracts/automata-attestation/lib/PEMCertChainLib.sol


12      contract PEMCertChainLib is IPEMCertChainLib {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/PEMCertChainLib.sol#L12:12

```solidity
File: contracts/automata-attestation/utils/SigVerifyLib.sol


15      contract SigVerifyLib is ISigVerifyLib {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/SigVerifyLib.sol#L15:15

```solidity
File: contracts/team/airdrop/ERC721Airdrop.sol


9       contract ERC721Airdrop is MerkleClaimable {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/airdrop/ERC721Airdrop.sol#L9:9

```solidity
File: contracts/tokenvault/adapters/USDCAdapter.sol


28      contract USDCAdapter is BridgedERC20Base {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/adapters/USDCAdapter.sol#L28:28

```solidity
File: contracts/verifiers/GuardianVerifier.sol


10      contract GuardianVerifier is EssentialContract, IVerifier {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/verifiers/GuardianVerifier.sol#L10:10

</details>

## NC097 - Contract definitions should have Natspec @dev annotations:

Explain to a developer any extra details


<details>
<summary>Click to show 19 findings</summary>

```solidity
File: contracts/L1/gov/TaikoGovernor.sol


16      contract TaikoGovernor is


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/gov/TaikoGovernor.sol#L16:16

```solidity
File: contracts/L1/gov/TaikoTimelockController.sol


9       contract TaikoTimelockController is EssentialContract, TimelockControllerUpgradeable {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/gov/TaikoTimelockController.sol#L9:9

```solidity
File: contracts/L1/hooks/AssignmentHook.sol


14      contract AssignmentHook is EssentialContract, IHook {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/hooks/AssignmentHook.sol#L14:14

```solidity
File: contracts/L1/provers/GuardianProver.sol


10      contract GuardianProver is Guardians {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/provers/GuardianProver.sol#L10:10

```solidity
File: contracts/L2/TaikoL2.sol


21      contract TaikoL2 is CrossChainOwned {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/TaikoL2.sol#L21:21

```solidity
File: contracts/L2/TaikoL2EIP1559Configurable.sol


9       contract TaikoL2EIP1559Configurable is TaikoL2 {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/TaikoL2EIP1559Configurable.sol#L9:9

```solidity
File: contracts/automata-attestation/AutomataDcapV3Attestation.sol


22      contract AutomataDcapV3Attestation is IAttestation {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/AutomataDcapV3Attestation.sol#L22:22

```solidity
File: contracts/automata-attestation/lib/PEMCertChainLib.sol


12      contract PEMCertChainLib is IPEMCertChainLib {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/PEMCertChainLib.sol#L12:12

```solidity
File: contracts/automata-attestation/utils/SigVerifyLib.sol


15      contract SigVerifyLib is ISigVerifyLib {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/SigVerifyLib.sol#L15:15

```solidity
File: contracts/common/AddressManager.sol


10      contract AddressManager is EssentialContract, IAddressManager {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/common/AddressManager.sol#L10:10

```solidity
File: contracts/team/TimelockTokenPool.sol


25      contract TimelockTokenPool is EssentialContract {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/TimelockTokenPool.sol#L25:25

```solidity
File: contracts/team/airdrop/ERC20Airdrop.sol


11      contract ERC20Airdrop is MerkleClaimable {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/airdrop/ERC20Airdrop.sol#L11:11

```solidity
File: contracts/team/airdrop/ERC20Airdrop2.sol


12      contract ERC20Airdrop2 is MerkleClaimable {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/airdrop/ERC20Airdrop2.sol#L12:12

```solidity
File: contracts/team/airdrop/ERC721Airdrop.sol


9       contract ERC721Airdrop is MerkleClaimable {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/airdrop/ERC721Airdrop.sol#L9:9

```solidity
File: contracts/tokenvault/BridgedERC1155.sol


14      contract BridgedERC1155 is EssentialContract, IERC1155MetadataURIUpgradeable, ERC1155Upgradeable {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC1155.sol#L14:14

```solidity
File: contracts/tokenvault/BridgedERC20.sol


15      contract BridgedERC20 is


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC20.sol#L15:15

```solidity
File: contracts/tokenvault/BridgedERC721.sol


12      contract BridgedERC721 is EssentialContract, ERC721Upgradeable {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC721.sol#L12:12

```solidity
File: contracts/tokenvault/adapters/USDCAdapter.sol


28      contract USDCAdapter is BridgedERC20Base {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/adapters/USDCAdapter.sol#L28:28

```solidity
File: contracts/verifiers/GuardianVerifier.sol


10      contract GuardianVerifier is EssentialContract, IVerifier {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/verifiers/GuardianVerifier.sol#L10:10

</details>

## NC098 - Event definitions should have Natspec @notice annotations:

Explain to an end user what this does


<details>
<summary>Click to show 7 findings</summary>

```solidity
File: contracts/L1/TaikoEvents.sol


21          event BlockProposed(


37          event BlockVerified(


53          event TransitionProved(


67          event TransitionContested(


77          event BlobCached(bytes32 blobHash);


81          event ProvingPaused(bool paused);


86          event EthDeposited(TaikoData.EthDeposit deposit);


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/TaikoEvents.sol#L86:86

</details>

## NC099 - State variable declarations should have Natspec @notice annotations:

Explain to an end user what this does


<details>
<summary>Click to show 90 findings</summary>

```solidity
File: contracts/L1/TaikoL1.sol


26          uint256[50] private __gap;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/TaikoL1.sol#L26:26

```solidity
File: contracts/L1/TaikoToken.sol


16          uint256[50] private __gap;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/TaikoToken.sol#L16:16

```solidity
File: contracts/L1/gov/TaikoGovernor.sol


23          uint256[50] private __gap;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/gov/TaikoGovernor.sol#L23:23

```solidity
File: contracts/L1/gov/TaikoTimelockController.sol


10          uint256[50] private __gap;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/gov/TaikoTimelockController.sol#L10:10

```solidity
File: contracts/L1/hooks/AssignmentHook.sol


40          uint256[50] private __gap;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/hooks/AssignmentHook.sol#L40:40

```solidity
File: contracts/L1/provers/GuardianProver.sol


11          uint256[50] private __gap;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/provers/GuardianProver.sol#L11:11

```solidity
File: contracts/L1/provers/Guardians.sol


32          uint256[46] private __gap;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/provers/Guardians.sol#L32:32

```solidity
File: contracts/L1/tiers/DevnetTierProvider.sol


11          uint256[50] private __gap;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/tiers/DevnetTierProvider.sol#L11:11

```solidity
File: contracts/L1/tiers/MainnetTierProvider.sol


11          uint256[50] private __gap;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/tiers/MainnetTierProvider.sol#L11:11

```solidity
File: contracts/L1/tiers/TestnetTierProvider.sol


11          uint256[50] private __gap;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/tiers/TestnetTierProvider.sol#L11:11

```solidity
File: contracts/L2/CrossChainOwned.sol


21          uint256[49] private __gap;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/CrossChainOwned.sol#L21:21

```solidity
File: contracts/L2/TaikoL2.sol


52          uint256[47] private __gap;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/TaikoL2.sol#L52:52

```solidity
File: contracts/L2/TaikoL2EIP1559Configurable.sol


13          uint256[49] private __gap;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/TaikoL2EIP1559Configurable.sol#L13:13

```solidity
File: contracts/automata-attestation/AutomataDcapV3Attestation.sol


25          ISigVerifyLib public immutable sigVerifyLib;


26          IPEMCertChainLib public immutable pemCertLib;


29          uint256 internal constant CPUSVN_LENGTH = 16;


33          bytes32 internal constant ROOTCA_PUBKEY_HASH =


36          uint8 internal constant INVALID_EXIT_CODE = 255;


38          bool private _checkLocalEnclaveReport;


39          mapping(bytes32 enclave => bool trusted) private _trustedUserMrEnclave;


40          mapping(bytes32 signer => bool trusted) private _trustedUserMrSigner;


47          mapping(uint256 idx => mapping(bytes serialNum => bool revoked)) private _serialNumIsRevoked;


49          mapping(string fmspc => TCBInfoStruct.TCBInfo tcbInfo) public tcbInfo;


50          EnclaveIdStruct.EnclaveId public qeIdentity;


52          address public owner;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/AutomataDcapV3Attestation.sol#L52:52

```solidity
File: contracts/automata-attestation/lib/PEMCertChainLib.sol


17          string internal constant HEADER = "-----BEGIN CERTIFICATE-----";


18          string internal constant FOOTER = "-----END CERTIFICATE-----";


19          uint256 internal constant HEADER_LENGTH = 27;


20          uint256 internal constant FOOTER_LENGTH = 25;


22          string internal constant PCK_COMMON_NAME = "Intel SGX PCK Certificate";


23          string internal constant PLATFORM_ISSUER_NAME = "Intel SGX PCK Platform CA";


24          string internal constant PROCESSOR_ISSUER_NAME = "Intel SGX PCK Processor CA";


25          bytes internal constant SGX_EXTENSION_OID = hex"2A864886F84D010D01";


26          bytes internal constant TCB_OID = hex"2A864886F84D010D0102";


27          bytes internal constant PCESVN_OID = hex"2A864886F84D010D010211";


28          bytes internal constant PCEID_OID = hex"2A864886F84D010D0103";


29          bytes internal constant FMSPC_OID = hex"2A864886F84D010D0104";


32          uint256 constant SGX_TCB_CPUSVN_SIZE = 16;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/PEMCertChainLib.sol#L32:32

```solidity
File: contracts/automata-attestation/lib/QuoteV3Auth/V3Parser.sol


14          uint256 internal constant MINIMUM_QUOTE_LENGTH = 1020;


15          bytes2 internal constant SUPPORTED_QUOTE_VERSION = 0x0300;


16          bytes2 internal constant SUPPORTED_ATTESTATION_KEY_TYPE = 0x0200;


18          bytes4 internal constant SUPPORTED_TEE_TYPE = 0;


19          bytes16 internal constant VALID_QE_VENDOR_ID = 0x939a7233f79c4ca9940a0db3957f0607;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/QuoteV3Auth/V3Parser.sol#L19:19

```solidity
File: contracts/automata-attestation/utils/BytesUtils.sol


310         bytes constant BASE32_HEX_TABLE =


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/BytesUtils.sol#L310:310

```solidity
File: contracts/automata-attestation/utils/SigVerifyLib.sol


18          address private ES256VERIFIER;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/SigVerifyLib.sol#L18:18

```solidity
File: contracts/bridge/Bridge.sol


23          bytes32 private constant _CTX_SLOT =


27          uint256 internal constant PLACEHOLDER = type(uint256).max;


38          Context private __ctx;


48          uint256[43] private __gap;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/Bridge.sol#L48:48

```solidity
File: contracts/common/AddressManager.sol


12          mapping(uint256 chainId => mapping(bytes32 name => address addr)) private __addresses;


14          uint256[49] private __gap;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/common/AddressManager.sol#L14:14

```solidity
File: contracts/common/AddressResolver.sol


14          uint256[49] private __gap;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/common/AddressResolver.sol#L14:14

```solidity
File: contracts/common/EssentialContract.sol


11          uint8 private constant _FALSE = 1;


13          uint8 private constant _TRUE = 2;


17          bytes32 private constant _REENTRY_SLOT =


21          uint8 private __reentry;


23          uint8 private __paused;


25          uint256[49] private __gap;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/common/EssentialContract.sol#L25:25

```solidity
File: contracts/libs/LibAddress.sol


14          bytes4 private constant _EIP1271_MAGICVALUE = 0x1626ba7e;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/libs/LibAddress.sol#L14:14

```solidity
File: contracts/libs/LibTrieProof.sol


18          uint256 private constant _ACCOUNT_FIELD_INDEX_STORAGE_HASH = 2;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/libs/LibTrieProof.sol#L18:18

```solidity
File: contracts/signal/SignalService.sol


23          uint256[48] private __gap;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/signal/SignalService.sol#L23:23

```solidity
File: contracts/team/TimelockTokenPool.sol


82          uint128[44] private __gap;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/TimelockTokenPool.sol#L82:82

```solidity
File: contracts/team/airdrop/ERC20Airdrop.sol


18          uint256[48] private __gap;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/airdrop/ERC20Airdrop.sol#L18:18

```solidity
File: contracts/team/airdrop/ERC20Airdrop2.sol


30          uint256[45] private __gap;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/airdrop/ERC20Airdrop2.sol#L30:30

```solidity
File: contracts/team/airdrop/ERC721Airdrop.sol


16          uint256[48] private __gap;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/airdrop/ERC721Airdrop.sol#L16:16

```solidity
File: contracts/team/airdrop/MerkleClaimable.sol


23          uint256[47] private __gap;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/airdrop/MerkleClaimable.sol#L23:23

```solidity
File: contracts/thirdparty/nomad-xyz/ExcessivelySafeCall.sol


6           uint256 constant LOW_28_MASK =


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/nomad-xyz/ExcessivelySafeCall.sol#L6:6

```solidity
File: contracts/thirdparty/solmate/LibFixedPointMath.sol


7           uint128 public constant MAX_EXP_INPUT = 135_305_999_368_893_231_588;


8           uint256 public constant SCALING_FACTOR = 1e18; // For fixed point representation factor


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/solmate/LibFixedPointMath.sol#L8:8

```solidity
File: contracts/tokenvault/BaseNFTVault.sol


61          uint256[48] private __gap;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BaseNFTVault.sol#L61:61

```solidity
File: contracts/tokenvault/BaseVault.sol


18          uint256[50] private __gap;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BaseVault.sol#L18:18

```solidity
File: contracts/tokenvault/BridgedERC1155.sol


22          string private __symbol;


25          string private __name;


27          uint256[46] private __gap;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC1155.sol#L27:27

```solidity
File: contracts/tokenvault/BridgedERC20.sol


22          address public srcToken;


24          uint8 private __srcDecimals;


27          uint256 public srcChainId;


30          address public snapshooter;


32          uint256[47] private __gap;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC20.sol#L32:32

```solidity
File: contracts/tokenvault/BridgedERC20Base.sol


16          uint256[49] private __gap;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC20Base.sol#L16:16

```solidity
File: contracts/tokenvault/BridgedERC721.sol


19          uint256[48] private __gap;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC721.sol#L19:19

```solidity
File: contracts/tokenvault/ERC1155Vault.sol


32          uint256[50] private __gap;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC1155Vault.sol#L32:32

```solidity
File: contracts/tokenvault/ERC20Vault.sol


54          uint256[47] private __gap;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC20Vault.sol#L54:54

```solidity
File: contracts/tokenvault/ERC721Vault.sol


19          uint256[50] private __gap;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC721Vault.sol#L19:19

```solidity
File: contracts/tokenvault/adapters/USDCAdapter.sol


32          uint256[49] private __gap;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/adapters/USDCAdapter.sol#L32:32

```solidity
File: contracts/verifiers/GuardianVerifier.sol


11          uint256[50] private __gap;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/verifiers/GuardianVerifier.sol#L11:11

```solidity
File: contracts/verifiers/SgxVerifier.sol


39          uint256 public nextInstanceId;


47          mapping(uint256 instanceId => Instance instance) public instances;


55          mapping(address instanceAddress => bool alreadyAttested) public addressRegistered;


57          uint256[47] private __gap;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/verifiers/SgxVerifier.sol#L57:57

</details>

## NC100 - State variable declarations should have Natspec @dev annotations:

Explain to a developer any extra details


<details>
<summary>Click to show 144 findings</summary>

```solidity
File: contracts/L1/TaikoL1.sol


24          TaikoData.State public state;


26          uint256[50] private __gap;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/TaikoL1.sol#L26:26

```solidity
File: contracts/L1/TaikoToken.sol


16          uint256[50] private __gap;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/TaikoToken.sol#L16:16

```solidity
File: contracts/L1/gov/TaikoGovernor.sol


23          uint256[50] private __gap;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/gov/TaikoGovernor.sol#L23:23

```solidity
File: contracts/L1/gov/TaikoTimelockController.sol


10          uint256[50] private __gap;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/gov/TaikoTimelockController.sol#L10:10

```solidity
File: contracts/L1/hooks/AssignmentHook.sol


40          uint256[50] private __gap;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/hooks/AssignmentHook.sol#L40:40

```solidity
File: contracts/L1/libs/LibProving.sol


20          bytes32 public constant RETURN_LIVENESS_BOND = keccak256("RETURN_LIVENESS_BOND");


23          bytes32 public constant TIER_OP = bytes32("tier_optimistic");


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProving.sol#L23:23

```solidity
File: contracts/L1/provers/GuardianProver.sol


11          uint256[50] private __gap;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/provers/GuardianProver.sol#L11:11

```solidity
File: contracts/L1/provers/Guardians.sol


11          uint256 public constant MIN_NUM_GUARDIANS = 5;


19          mapping(uint32 version => mapping(bytes32 hash => uint256 approvalBits)) internal _approvals;


30          uint32 public minGuardians;


32          uint256[46] private __gap;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/provers/Guardians.sol#L32:32

```solidity
File: contracts/L1/tiers/DevnetTierProvider.sol


11          uint256[50] private __gap;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/tiers/DevnetTierProvider.sol#L11:11

```solidity
File: contracts/L1/tiers/ITierProvider.sol


39          uint16 public constant TIER_OPTIMISTIC = 100;


42          uint16 public constant TIER_SGX = 200;


45          uint16 public constant TIER_SGX_ZKVM = 300;


48          uint16 public constant TIER_GUARDIAN = 1000;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/tiers/ITierProvider.sol#L48:48

```solidity
File: contracts/L1/tiers/MainnetTierProvider.sol


11          uint256[50] private __gap;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/tiers/MainnetTierProvider.sol#L11:11

```solidity
File: contracts/L1/tiers/TestnetTierProvider.sol


11          uint256[50] private __gap;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/tiers/TestnetTierProvider.sol#L11:11

```solidity
File: contracts/L2/CrossChainOwned.sol


16          uint64 public ownerChainId;


19          uint64 public nextTxId;


21          uint256[49] private __gap;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/CrossChainOwned.sol#L21:21

```solidity
File: contracts/L2/TaikoL2.sol


32          address public constant GOLDEN_TOUCH_ADDRESS = 0x0000777735367b36bC9B61C50022d9D0700dB4Ec;


35          uint8 public constant BLOCK_SYNC_THRESHOLD = 5;


39          mapping(uint256 blockId => bytes32 blockHash) public l2Hashes;


50          uint64 public lastSyncedBlock;


52          uint256[47] private __gap;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/TaikoL2.sol#L52:52

```solidity
File: contracts/L2/TaikoL2EIP1559Configurable.sol


11          Config public customConfig;


13          uint256[49] private __gap;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/TaikoL2EIP1559Configurable.sol#L13:13

```solidity
File: contracts/automata-attestation/AutomataDcapV3Attestation.sol


25          ISigVerifyLib public immutable sigVerifyLib;


26          IPEMCertChainLib public immutable pemCertLib;


29          uint256 internal constant CPUSVN_LENGTH = 16;


33          bytes32 internal constant ROOTCA_PUBKEY_HASH =


36          uint8 internal constant INVALID_EXIT_CODE = 255;


38          bool private _checkLocalEnclaveReport;


39          mapping(bytes32 enclave => bool trusted) private _trustedUserMrEnclave;


40          mapping(bytes32 signer => bool trusted) private _trustedUserMrSigner;


47          mapping(uint256 idx => mapping(bytes serialNum => bool revoked)) private _serialNumIsRevoked;


49          mapping(string fmspc => TCBInfoStruct.TCBInfo tcbInfo) public tcbInfo;


50          EnclaveIdStruct.EnclaveId public qeIdentity;


52          address public owner;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/AutomataDcapV3Attestation.sol#L52:52

```solidity
File: contracts/automata-attestation/lib/PEMCertChainLib.sol


17          string internal constant HEADER = "-----BEGIN CERTIFICATE-----";


18          string internal constant FOOTER = "-----END CERTIFICATE-----";


19          uint256 internal constant HEADER_LENGTH = 27;


20          uint256 internal constant FOOTER_LENGTH = 25;


22          string internal constant PCK_COMMON_NAME = "Intel SGX PCK Certificate";


23          string internal constant PLATFORM_ISSUER_NAME = "Intel SGX PCK Platform CA";


24          string internal constant PROCESSOR_ISSUER_NAME = "Intel SGX PCK Processor CA";


25          bytes internal constant SGX_EXTENSION_OID = hex"2A864886F84D010D01";


26          bytes internal constant TCB_OID = hex"2A864886F84D010D0102";


27          bytes internal constant PCESVN_OID = hex"2A864886F84D010D010211";


28          bytes internal constant PCEID_OID = hex"2A864886F84D010D0103";


29          bytes internal constant FMSPC_OID = hex"2A864886F84D010D0104";


32          uint256 constant SGX_TCB_CPUSVN_SIZE = 16;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/PEMCertChainLib.sol#L32:32

```solidity
File: contracts/automata-attestation/lib/QuoteV3Auth/V3Parser.sol


14          uint256 internal constant MINIMUM_QUOTE_LENGTH = 1020;


15          bytes2 internal constant SUPPORTED_QUOTE_VERSION = 0x0300;


16          bytes2 internal constant SUPPORTED_ATTESTATION_KEY_TYPE = 0x0200;


18          bytes4 internal constant SUPPORTED_TEE_TYPE = 0;


19          bytes16 internal constant VALID_QE_VENDOR_ID = 0x939a7233f79c4ca9940a0db3957f0607;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/QuoteV3Auth/V3Parser.sol#L19:19

```solidity
File: contracts/automata-attestation/utils/BytesUtils.sol


310         bytes constant BASE32_HEX_TABLE =


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/BytesUtils.sol#L310:310

```solidity
File: contracts/automata-attestation/utils/SigVerifyLib.sol


18          address private ES256VERIFIER;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/SigVerifyLib.sol#L18:18

```solidity
File: contracts/bridge/Bridge.sol


48          uint256[43] private __gap;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/Bridge.sol#L48:48

```solidity
File: contracts/common/AddressManager.sol


14          uint256[49] private __gap;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/common/AddressManager.sol#L14:14

```solidity
File: contracts/common/AddressResolver.sol


13          address public addressManager;


14          uint256[49] private __gap;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/common/AddressResolver.sol#L14:14

```solidity
File: contracts/common/EssentialContract.sol


11          uint8 private constant _FALSE = 1;


13          uint8 private constant _TRUE = 2;


23          uint8 private __paused;


25          uint256[49] private __gap;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/common/EssentialContract.sol#L25:25

```solidity
File: contracts/libs/Lib4844.sol


10          address public constant POINT_EVALUATION_PRECOMPILE_ADDRESS = address(0x0A);


13          uint32 public constant FIELD_ELEMENTS_PER_BLOB = 4096;


16          uint256 public constant BLS_MODULUS =


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/libs/Lib4844.sol#L16:16

```solidity
File: contracts/libs/LibAddress.sol


14          bytes4 private constant _EIP1271_MAGICVALUE = 0x1626ba7e;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/libs/LibAddress.sol#L14:14

```solidity
File: contracts/libs/LibTrieProof.sol


18          uint256 private constant _ACCOUNT_FIELD_INDEX_STORAGE_HASH = 2;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/libs/LibTrieProof.sol#L18:18

```solidity
File: contracts/signal/LibSignals.sol


8           bytes32 public constant STATE_ROOT = keccak256("STATE_ROOT");


11          bytes32 public constant SIGNAL_ROOT = keccak256("SIGNAL_ROOT");


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/signal/LibSignals.sol#L11:11

```solidity
File: contracts/signal/SignalService.sol


23          uint256[48] private __gap;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/signal/SignalService.sol#L23:23

```solidity
File: contracts/team/TimelockTokenPool.sol


59          address public taikoToken;


62          address public costToken;


65          address public sharedVault;


68          uint128 public totalAmountGranted;


71          uint128 public totalAmountVoided;


74          uint128 public totalAmountWithdrawn;


77          uint128 public totalCostPaid;


80          mapping(address recipient => Recipient receipt) public recipients;


82          uint128[44] private __gap;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/TimelockTokenPool.sol#L82:82

```solidity
File: contracts/team/airdrop/ERC20Airdrop.sol


13          address public token;


16          address public vault;


18          uint256[48] private __gap;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/airdrop/ERC20Airdrop.sol#L18:18

```solidity
File: contracts/team/airdrop/ERC20Airdrop2.sol


16          address public token;


19          address public vault;


22          mapping(address addr => uint256 amountClaimed) public claimedAmount;


25          mapping(address addr => uint256 amountWithdrawn) public withdrawnAmount;


28          uint64 public withdrawalWindow;


30          uint256[45] private __gap;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/airdrop/ERC20Airdrop2.sol#L30:30

```solidity
File: contracts/team/airdrop/ERC721Airdrop.sol


11          address public token;


14          address public vault;


16          uint256[48] private __gap;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/airdrop/ERC721Airdrop.sol#L16:16

```solidity
File: contracts/team/airdrop/MerkleClaimable.sol


12          mapping(bytes32 hash => bool claimed) public isClaimed;


15          bytes32 public merkleRoot;


18          uint64 public claimStart;


21          uint64 public claimEnd;


23          uint256[47] private __gap;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/airdrop/MerkleClaimable.sol#L23:23

```solidity
File: contracts/thirdparty/nomad-xyz/ExcessivelySafeCall.sol


6           uint256 constant LOW_28_MASK =


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/nomad-xyz/ExcessivelySafeCall.sol#L6:6

```solidity
File: contracts/thirdparty/optimism/rlp/RLPReader.sol


30          uint256 internal constant MAX_LIST_LENGTH = 32;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/rlp/RLPReader.sol#L30:30

```solidity
File: contracts/thirdparty/optimism/trie/MerkleTrie.sol


21          uint256 internal constant TREE_RADIX = 16;


24          uint256 internal constant BRANCH_NODE_LENGTH = TREE_RADIX + 1;


27          uint256 internal constant LEAF_OR_EXTENSION_NODE_LENGTH = 2;


30          uint8 internal constant PREFIX_EXTENSION_EVEN = 0;


33          uint8 internal constant PREFIX_EXTENSION_ODD = 1;


36          uint8 internal constant PREFIX_LEAF_EVEN = 2;


39          uint8 internal constant PREFIX_LEAF_ODD = 3;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/trie/MerkleTrie.sol#L39:39

```solidity
File: contracts/thirdparty/solmate/LibFixedPointMath.sol


7           uint128 public constant MAX_EXP_INPUT = 135_305_999_368_893_231_588;


8           uint256 public constant SCALING_FACTOR = 1e18; // For fixed point representation factor


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/solmate/LibFixedPointMath.sol#L8:8

```solidity
File: contracts/tokenvault/BaseNFTVault.sol


47          bytes4 public constant ERC1155_INTERFACE_ID = 0xd9b67a26;


50          bytes4 public constant ERC721_INTERFACE_ID = 0x80ac58cd;


53          uint256 public constant MAX_TOKEN_PER_TXN = 10;


56          mapping(address btoken => CanonicalNFT canonical) public bridgedToCanonical;


59          mapping(uint256 chainId => mapping(address ctoken => address btoken)) public canonicalToBridged;


61          uint256[48] private __gap;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BaseNFTVault.sol#L61:61

```solidity
File: contracts/tokenvault/BaseVault.sol


18          uint256[50] private __gap;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BaseVault.sol#L18:18

```solidity
File: contracts/tokenvault/BridgedERC1155.sol


16          address public srcToken;


19          uint256 public srcChainId;


27          uint256[46] private __gap;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC1155.sol#L27:27

```solidity
File: contracts/tokenvault/BridgedERC20.sol


24          uint8 private __srcDecimals;


32          uint256[47] private __gap;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC20.sol#L32:32

```solidity
File: contracts/tokenvault/BridgedERC20Base.sol


11          address public migratingAddress;


14          bool public migratingInbound;


16          uint256[49] private __gap;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC20Base.sol#L16:16

```solidity
File: contracts/tokenvault/BridgedERC721.sol


14          address public srcToken;


17          uint256 public srcChainId;


19          uint256[48] private __gap;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC721.sol#L19:19

```solidity
File: contracts/tokenvault/ERC1155Vault.sol


32          uint256[50] private __gap;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC1155Vault.sol#L32:32

```solidity
File: contracts/tokenvault/ERC20Vault.sol


45          mapping(address btoken => CanonicalERC20 canonical) public bridgedToCanonical;


49          mapping(uint256 chainId => mapping(address ctoken => address btoken)) public canonicalToBridged;


52          mapping(address btoken => bool blacklisted) public btokenBlacklist;


54          uint256[47] private __gap;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC20Vault.sol#L54:54

```solidity
File: contracts/tokenvault/ERC721Vault.sol


19          uint256[50] private __gap;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC721Vault.sol#L19:19

```solidity
File: contracts/tokenvault/adapters/USDCAdapter.sol


32          uint256[49] private __gap;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/adapters/USDCAdapter.sol#L32:32

```solidity
File: contracts/verifiers/GuardianVerifier.sol


11          uint256[50] private __gap;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/verifiers/GuardianVerifier.sol#L11:11

```solidity
File: contracts/verifiers/SgxVerifier.sol


30          uint64 public constant INSTANCE_EXPIRY = 180 days;


34          uint64 public constant INSTANCE_VALIDITY_DELAY = 1 days;


57          uint256[47] private __gap;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/verifiers/SgxVerifier.sol#L57:57

</details>

## NC101 - Functions should have Natspec @return annotations:

Documents the return variables of a contract’s function


<details>
<summary>Click to show 131 findings</summary>

```solidity
File: contracts/L1/TaikoL1.sol


55          function proposeBlock(


137         function isBlobReusable(bytes32 _blobHash) public view returns (bool) {


186         function getConfig() public view virtual override returns (TaikoData.Config memory) {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/TaikoL1.sol#L186:186

```solidity
File: contracts/L1/gov/TaikoGovernor.sol


48          function propose(


69          function propose(


89          function supportsInterface(bytes4 _interfaceId)


99          function state(uint256 _proposalId)


140         function _cancel(


153         function _executor()


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/gov/TaikoGovernor.sol#L153:153

```solidity
File: contracts/L1/hooks/AssignmentHook.sol


164         function _getProverFee(


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/hooks/AssignmentHook.sol#L164:164

```solidity
File: contracts/L1/libs/LibDepositing.sol


67          function processDeposits(


122         function canDepositEthToL2(


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibDepositing.sol#L122:122

```solidity
File: contracts/L1/libs/LibProposing.sol


299         function _isProposerPermitted(


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProposing.sol#L299:299

```solidity
File: contracts/L1/libs/LibProving.sol


91          function proveBlock(


269         function _createTransition(


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProving.sol#L269:269

```solidity
File: contracts/L1/libs/LibUtils.sol


52          function getBlock(


70          function getTransitionId(


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibUtils.sol#L70:70

```solidity
File: contracts/L1/libs/LibVerifying.sol


245         function _isConfigValid(TaikoData.Config memory _config) private view returns (bool) {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibVerifying.sol#L245:245

```solidity
File: contracts/L1/provers/Guardians.sol


111         function approve(uint256 _operationId, bytes32 _hash) internal returns (bool approved_) {


128         function isApproved(uint256 _approvalBits) internal view returns (bool) {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/provers/Guardians.sol#L128:128

```solidity
File: contracts/L1/tiers/DevnetTierProvider.sol


20          function getTier(uint16 _tierId) public pure override returns (ITierProvider.Tier memory) {


47          function getTierIds() public pure override returns (uint16[] memory tiers_) {


54          function getMinTier(uint256) public pure override returns (uint16) {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/tiers/DevnetTierProvider.sol#L54:54

```solidity
File: contracts/L1/tiers/MainnetTierProvider.sol


20          function getTier(uint16 _tierId) public pure override returns (ITierProvider.Tier memory) {


58          function getTierIds() public pure override returns (uint16[] memory tiers_) {


66          function getMinTier(uint256 _rand) public pure override returns (uint16) {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/tiers/MainnetTierProvider.sol#L66:66

```solidity
File: contracts/L1/tiers/TestnetTierProvider.sol


20          function getTier(uint16 _tierId) public pure override returns (ITierProvider.Tier memory) {


58          function getTierIds() public pure override returns (uint16[] memory tiers_) {


66          function getMinTier(uint256 _rand) public pure override returns (uint16) {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/tiers/TestnetTierProvider.sol#L66:66

```solidity
File: contracts/L2/Lib1559Math.sol


16          function basefee(


33          function _ethQty(


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/Lib1559Math.sol#L33:33

```solidity
File: contracts/L2/TaikoL2.sol


223         function _calcPublicInputHash(uint256 _blockId)


252         function _calc1559BaseFee(


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/TaikoL2.sol#L252:252

```solidity
File: contracts/L2/TaikoL2EIP1559Configurable.sol


43          function getConfig() public view override returns (Config memory) {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/TaikoL2EIP1559Configurable.sol#L43:43

```solidity
File: contracts/automata-attestation/AutomataDcapV3Attestation.sol


126         function _attestationTcbIsValid(TCBInfoStruct.TCBStatus status)


138         function verifyAttestation(bytes calldata data) external view override returns (bool) {


162         function _verify(bytes calldata quote) private view returns (bool, bytes memory) {


175         function _verifyQEReportWithIdentity(V3Struct.EnclaveReport memory quoteEnclaveReport)


206         function _checkTcbLevels(


229         function _isCpuSvnHigherOrGreater(


248         function _verifyCertChain(IPEMCertChainLib.ECSha256Certificate[] memory certs)


303         function _enclaveReportSigVerification(


355         function verifyParsedQuote(V3Struct.ParsedV3QuoteStruct calldata v3quote)


364         function _verifyParsedQuote(V3Struct.ParsedV3QuoteStruct memory v3quote)


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/AutomataDcapV3Attestation.sol#L364:364

```solidity
File: contracts/automata-attestation/interfaces/IAttestation.sol


9           function verifyAttestation(bytes calldata data) external returns (bool);


10          function verifyParsedQuote(V3Struct.ParsedV3QuoteStruct calldata v3quote)


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/interfaces/IAttestation.sol#L10:10

```solidity
File: contracts/automata-attestation/interfaces/ISigVerifyLib.sol


38          function verifyAttStmtSignature(


48          function verifyCertificateSignature(


58          function verifyRS256Signature(


67          function verifyRS1Signature(


76          function verifyES256Signature(


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/interfaces/ISigVerifyLib.sol#L76:76

```solidity
File: contracts/automata-attestation/lib/PEMCertChainLib.sol


40          function splitCertificateChain(


74          function decodeCert(


216         function _removeHeadersAndFooters(string memory pemData)


252         function _trimBytes(


269         function _findPckTcbInfo(


341         function _findTcb(


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/PEMCertChainLib.sol#L341:341

```solidity
File: contracts/automata-attestation/lib/QuoteV3Auth/V3Parser.sol


21          function parseInput(


62          function validateParsedInput(V3Struct.ParsedV3QuoteStruct memory v3Quote)


133         function parseEnclaveReport(bytes memory rawEnclaveReport)


152         function littleEndianDecode(bytes memory encoded) private pure returns (uint256 decoded) {


165         function parseAndVerifyHeader(bytes memory rawHeader)


203         function parseAuthDataAndVerifyCertType(


267         function parseCerificationChainBytes(


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/QuoteV3Auth/V3Parser.sol#L267:267

```solidity
File: contracts/automata-attestation/lib/interfaces/IPEMCertChainLib.sol


36          function splitCertificateChain(


44          function decodeCert(


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/interfaces/IPEMCertChainLib.sol#L44:44

```solidity
File: contracts/automata-attestation/utils/Asn1Decode.sol


14          function ixs(uint256 self) internal pure returns (uint256) {


19          function ixf(uint256 self) internal pure returns (uint256) {


24          function ixl(uint256 self) internal pure returns (uint256) {


29          function getPtr(uint256 _ixs, uint256 _ixf, uint256 _ixl) internal pure returns (uint256) {


165         function keccakOfBytesAt(bytes memory der, uint256 ptr) internal pure returns (bytes32) {


169         function keccakOfAllBytesAt(bytes memory der, uint256 ptr) internal pure returns (bytes32) {


187         function _readNodeLength(bytes memory der, uint256 ix) private pure returns (uint256) {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/Asn1Decode.sol#L187:187

```solidity
File: contracts/automata-attestation/utils/BytesUtils.sol


284         function substring(


371         function compareBytes(bytes memory a, bytes memory b) internal pure returns (bool) {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/BytesUtils.sol#L371:371

```solidity
File: contracts/automata-attestation/utils/SHA1.sol


11          function sha1(bytes memory data) internal pure returns (bytes20 ret) {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/SHA1.sol#L11:11

```solidity
File: contracts/automata-attestation/utils/SigVerifyLib.sol


24          function verifyAttStmtSignature(


54          function verifyCertificateSignature(


79          function verifyRS256Signature(


96          function verifyRS1Signature(


113         function verifyES256Signature(


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/SigVerifyLib.sol#L113:113

```solidity
File: contracts/automata-attestation/utils/X509DateUtils.sol


8           function toTimestamp(bytes memory x509Time) internal pure returns (uint256) {


34          function toUnixTimestamp(


71          function isLeapYear(uint16 year) internal pure returns (bool) {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/X509DateUtils.sol#L71:71

```solidity
File: contracts/bridge/Bridge.sol


115         function sendMessage(Message calldata _message)


340         function isMessageSent(Message calldata _message) public view returns (bool) {


403         function context() public view returns (Context memory ctx_) {


449         function hashMessage(Message memory _message) public pure returns (bytes32) {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/Bridge.sol#L449:449

```solidity
File: contracts/common/AddressManager.sol


54          function getAddress(uint64 _chainId, bytes32 _name) public view override returns (address) {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/common/AddressManager.sol#L54:54

```solidity
File: contracts/common/AddressResolver.sol


30          function resolve(


43          function resolve(


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/common/AddressResolver.sol#L43:43

```solidity
File: contracts/common/EssentialContract.sol


130         function _loadReentryLock() internal view virtual returns (uint8 reentry_) {


140         function _inNonReentrant() internal view returns (bool) {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/common/EssentialContract.sol#L140:140

```solidity
File: contracts/libs/LibAddress.sol


46          function supportsInterface(


61          function isValidSignature(


77          function isSenderEOA() internal view returns (bool) {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/libs/LibAddress.sol#L77:77

```solidity
File: contracts/signal/SignalService.sol


63          function sendSignal(bytes32 _signal) external returns (bytes32) {


68          function syncChainData(


137         function isChainDataSynced(


153         function isSignalSent(address _app, bytes32 _signal) public view returns (bool) {


158         function getSyncedChainData(


177         function signalForChainData(


206         function _verifyHopProof(


235         function _syncChainData(


253         function _sendSignal(


298         function _loadSignalValue(


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/signal/SignalService.sol#L298:298

```solidity
File: contracts/team/TimelockTokenPool.sol


176         function getMyGrantSummary(address _recipient)


225         function _voidGrant(Grant storage _grant) private returns (uint128 amountVoided) {


235         function _getAmountOwned(Grant memory _grant) private view returns (uint128) {


239         function _getAmountUnlocked(Grant memory _grant) private view returns (uint128) {


245         function _calcAmount(


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/TimelockTokenPool.sol#L245:245

```solidity
File: contracts/team/airdrop/MerkleClaimable.sol


77          function _verifyMerkleProof(


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/airdrop/MerkleClaimable.sol#L77:77

```solidity
File: contracts/thirdparty/solmate/LibFixedPointMath.sol


13          function exp(int256 x) internal pure returns (int256 r) {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/solmate/LibFixedPointMath.sol#L13:13

```solidity
File: contracts/tokenvault/BaseVault.sol


47          function checkProcessMessageContext()


58          function checkRecallMessageContext()


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BaseVault.sol#L58:58

```solidity
File: contracts/tokenvault/BridgedERC20Base.sol


101         function _isMigratingOut() internal view returns (bool) {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC20Base.sol#L101:101

```solidity
File: contracts/tokenvault/ERC1155Vault.sol


18          function name() external view returns (string memory);


21          function symbol() external view returns (string memory);


160         function onERC1155BatchReceived(


175         function onERC1155Received(


204         function name() public pure override returns (bytes32) {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC1155Vault.sol#L204:204

```solidity
File: contracts/tokenvault/ERC20Vault.sol


316         function name() public pure override returns (bytes32) {


320         function _transferTokens(


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC20Vault.sol#L320:320

```solidity
File: contracts/tokenvault/ERC721Vault.sol


142         function onERC721Received(


156         function name() public pure override returns (bytes32) {


160         function _transferTokens(


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC721Vault.sol#L160:160

```solidity
File: contracts/tokenvault/LibBridgedToken.sol


28          function buildName(


39          function buildSymbol(string memory _symbol) internal pure returns (string memory) {


43          function buildURI(


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/LibBridgedToken.sol#L43:43

```solidity
File: contracts/verifiers/SgxVerifier.sol


195         function _addInstances(


233         function _isInstanceValid(uint256 id, address instance) private view returns (bool) {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/verifiers/SgxVerifier.sol#L233:233

</details>

## NC102 - Functions should have Natspec @param annotations:

Documents a parameter just like in Doxygen (must be followed by parameter name)


<details>
<summary>Click to show 210 findings</summary>

```solidity
File: contracts/L1/TaikoL1.sol


34          receive() external payable {


55          function proposeBlock(


75          function proveBlock(


100         function verifyBlocks(uint64 _maxBlocksToVerify)


124         function unpause() public override {


137         function isBlobReusable(bytes32 _blobHash) public view returns (bool) {


176         function getStateVariables()


186         function getConfig() public view virtual override returns (TaikoData.Config memory) {


220         function _authorizePause(address)


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/TaikoL1.sol#L220:220

```solidity
File: contracts/L1/TaikoToken.sol


52          function snapshot() public onlyFromOwnerOrNamed("snapshooter") {


83          function _beforeTokenTransfer(


94          function _afterTokenTransfer(


105         function _mint(


115         function _burn(


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/TaikoToken.sol#L115:115

```solidity
File: contracts/L1/gov/TaikoGovernor.sol


48          function propose(


69          function propose(


89          function supportsInterface(bytes4 _interfaceId)


99          function state(uint256 _proposalId)


111         function votingDelay() public pure override returns (uint256) {


117         function votingPeriod() public pure override returns (uint256) {


123         function proposalThreshold() public pure override returns (uint256) {


127         function _execute(


140         function _cancel(


153         function _executor()


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/gov/TaikoGovernor.sol#L153:153

```solidity
File: contracts/L1/gov/TaikoTimelockController.sol


24          function getMinDelay() public view override returns (uint256) {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/gov/TaikoTimelockController.sol#L24:24

```solidity
File: contracts/L1/hooks/AssignmentHook.sol


62          function onBlockProposed(


164         function _getProverFee(


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/hooks/AssignmentHook.sol#L164:164

```solidity
File: contracts/L1/libs/LibDepositing.sol


67          function processDeposits(


122         function canDepositEthToL2(


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibDepositing.sol#L122:122

```solidity
File: contracts/L1/libs/LibProposing.sol


299         function _isProposerPermitted(


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProposing.sol#L299:299

```solidity
File: contracts/L1/libs/LibProving.sol


269         function _createTransition(


350         function _overrideWithHigherProof(


401         function _checkProverPermission(


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProving.sol#L401:401

```solidity
File: contracts/L1/libs/LibUtils.sol


70          function getTransitionId(


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibUtils.sol#L70:70

```solidity
File: contracts/L1/libs/LibVerifying.sol


85          function verifyBlocks(


224         function _syncChainData(


245         function _isConfigValid(TaikoData.Config memory _config) private view returns (bool) {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibVerifying.sol#L245:245

```solidity
File: contracts/L1/provers/Guardians.sol


107         function numGuardians() public view returns (uint256) {


111         function approve(uint256 _operationId, bytes32 _hash) internal returns (bool approved_) {


124         function deleteApproval(bytes32 _hash) internal {


128         function isApproved(uint256 _approvalBits) internal view returns (bool) {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/provers/Guardians.sol#L128:128

```solidity
File: contracts/L1/tiers/DevnetTierProvider.sol


20          function getTier(uint16 _tierId) public pure override returns (ITierProvider.Tier memory) {


47          function getTierIds() public pure override returns (uint16[] memory tiers_) {


54          function getMinTier(uint256) public pure override returns (uint16) {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/tiers/DevnetTierProvider.sol#L54:54

```solidity
File: contracts/L1/tiers/MainnetTierProvider.sol


20          function getTier(uint16 _tierId) public pure override returns (ITierProvider.Tier memory) {


58          function getTierIds() public pure override returns (uint16[] memory tiers_) {


66          function getMinTier(uint256 _rand) public pure override returns (uint16) {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/tiers/MainnetTierProvider.sol#L66:66

```solidity
File: contracts/L1/tiers/TestnetTierProvider.sol


20          function getTier(uint16 _tierId) public pure override returns (ITierProvider.Tier memory) {


58          function getTierIds() public pure override returns (uint16[] memory tiers_) {


66          function getMinTier(uint256 _rand) public pure override returns (uint16) {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/tiers/TestnetTierProvider.sol#L66:66

```solidity
File: contracts/L2/CrossChainOwned.sol


36          function onMessageInvocation(bytes calldata _data)


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/CrossChainOwned.sol#L36:36

```solidity
File: contracts/L2/Lib1559Math.sol


33          function _ethQty(


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/Lib1559Math.sol#L33:33

```solidity
File: contracts/L2/TaikoL2.sol


208         function getConfig() public view virtual returns (Config memory config_) {


219         function skipFeeCheck() public pure virtual returns (bool) {


223         function _calcPublicInputHash(uint256 _blockId)


252         function _calc1559BaseFee(


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/TaikoL2.sol#L252:252

```solidity
File: contracts/L2/TaikoL2EIP1559Configurable.sol


43          function getConfig() public view override returns (Config memory) {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/TaikoL2EIP1559Configurable.sol#L43:43

```solidity
File: contracts/automata-attestation/AutomataDcapV3Attestation.sol


54          constructor(address sigVerifyLibAddr, address pemCertLibAddr) {


65          function setMrSigner(bytes32 _mrSigner, bool _trusted) external onlyOwner {


69          function setMrEnclave(bytes32 _mrEnclave, bool _trusted) external onlyOwner {


73          function addRevokedCertSerialNum(


88          function removeRevokedCertSerialNum(


103         function configureTcbInfoJson(


114         function configureQeIdentityJson(EnclaveIdStruct.EnclaveId calldata qeIdentityInput)


122         function toggleLocalReportCheck() external onlyOwner {


126         function _attestationTcbIsValid(TCBInfoStruct.TCBStatus status)


138         function verifyAttestation(bytes calldata data) external view override returns (bool) {


162         function _verify(bytes calldata quote) private view returns (bool, bytes memory) {


175         function _verifyQEReportWithIdentity(V3Struct.EnclaveReport memory quoteEnclaveReport)


206         function _checkTcbLevels(


229         function _isCpuSvnHigherOrGreater(


248         function _verifyCertChain(IPEMCertChainLib.ECSha256Certificate[] memory certs)


303         function _enclaveReportSigVerification(


355         function verifyParsedQuote(V3Struct.ParsedV3QuoteStruct calldata v3quote)


364         function _verifyParsedQuote(V3Struct.ParsedV3QuoteStruct memory v3quote)


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/AutomataDcapV3Attestation.sol#L364:364

```solidity
File: contracts/automata-attestation/lib/PEMCertChainLib.sol


40          function splitCertificateChain(


74          function decodeCert(


216         function _removeHeadersAndFooters(string memory pemData)


252         function _trimBytes(


269         function _findPckTcbInfo(


341         function _findTcb(


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/PEMCertChainLib.sol#L341:341

```solidity
File: contracts/automata-attestation/lib/QuoteV3Auth/V3Parser.sol


21          function parseInput(


62          function validateParsedInput(V3Struct.ParsedV3QuoteStruct memory v3Quote)


133         function parseEnclaveReport(bytes memory rawEnclaveReport)


152         function littleEndianDecode(bytes memory encoded) private pure returns (uint256 decoded) {


165         function parseAndVerifyHeader(bytes memory rawHeader)


203         function parseAuthDataAndVerifyCertType(


267         function parseCerificationChainBytes(


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/QuoteV3Auth/V3Parser.sol#L267:267

```solidity
File: contracts/automata-attestation/utils/Asn1Decode.sol


14          function ixs(uint256 self) internal pure returns (uint256) {


19          function ixf(uint256 self) internal pure returns (uint256) {


24          function ixl(uint256 self) internal pure returns (uint256) {


29          function getPtr(uint256 _ixs, uint256 _ixf, uint256 _ixl) internal pure returns (uint256) {


165         function keccakOfBytesAt(bytes memory der, uint256 ptr) internal pure returns (bytes32) {


169         function keccakOfAllBytesAt(bytes memory der, uint256 ptr) internal pure returns (bytes32) {


187         function _readNodeLength(bytes memory der, uint256 ix) private pure returns (uint256) {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/Asn1Decode.sol#L187:187

```solidity
File: contracts/automata-attestation/utils/BytesUtils.sol


272         function memcpy(uint256 dest, uint256 src, uint256 len) private pure {


371         function compareBytes(bytes memory a, bytes memory b) internal pure returns (bool) {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/BytesUtils.sol#L371:371

```solidity
File: contracts/automata-attestation/utils/SHA1.sol


11          function sha1(bytes memory data) internal pure returns (bytes20 ret) {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/SHA1.sol#L11:11

```solidity
File: contracts/automata-attestation/utils/SigVerifyLib.sol


20          constructor(address es256Verifier) {


24          function verifyAttStmtSignature(


54          function verifyCertificateSignature(


79          function verifyRS256Signature(


96          function verifyRS1Signature(


113         function verifyES256Signature(


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/SigVerifyLib.sol#L113:113

```solidity
File: contracts/automata-attestation/utils/X509DateUtils.sol


8           function toTimestamp(bytes memory x509Time) internal pure returns (uint256) {


34          function toUnixTimestamp(


71          function isLeapYear(uint16 year) internal pure returns (bool) {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/X509DateUtils.sol#L71:71

```solidity
File: contracts/bridge/Bridge.sol


70          receive() external payable { }


115         function sendMessage(Message calldata _message)


155         function recallMessage(


217         function processMessage(


310         function retryMessage(


340         function isMessageSent(Message calldata _message) public view returns (bool) {


403         function context() public view returns (Context memory ctx_) {


417         function getInvocationDelays()


449         function hashMessage(Message memory _message) public pure returns (bytes32) {


461         function _authorizePause(address)


529         function _resetContext() private {


555         function _loadContext() private view returns (Context memory) {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/Bridge.sol#L555:555

```solidity
File: contracts/common/AddressManager.sol


54          function getAddress(uint64 _chainId, bytes32 _name) public view override returns (address) {


58          function _authorizePause(address) internal pure override {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/common/AddressManager.sol#L58:58

```solidity
File: contracts/common/AddressResolver.sol


30          function resolve(


43          function resolve(


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/common/AddressResolver.sol#L43:43

```solidity
File: contracts/common/EssentialContract.sol


64          constructor() {


69          function pause() public virtual whenNotPaused {


78          function unpause() public virtual whenPaused {


88          function paused() public view returns (bool) {


109         function __Essential_init(address _owner) internal virtual {


114         function _authorizeUpgrade(address) internal virtual override onlyOwner { }


116         function _authorizePause(address) internal virtual onlyOwner { }


119         function _storeReentryLock(uint8 _reentry) internal virtual {


130         function _loadReentryLock() internal view virtual returns (uint8 reentry_) {


140         function _inNonReentrant() internal view returns (bool) {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/common/EssentialContract.sol#L140:140

```solidity
File: contracts/libs/LibAddress.sol


46          function supportsInterface(


61          function isValidSignature(


77          function isSenderEOA() internal view returns (bool) {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/libs/LibAddress.sol#L77:77

```solidity
File: contracts/signal/SignalService.sol


63          function sendSignal(bytes32 _signal) external returns (bytes32) {


68          function syncChainData(


83          function proveSignalReceived(


137         function isChainDataSynced(


153         function isSignalSent(address _app, bytes32 _signal) public view returns (bool) {


158         function getSyncedChainData(


177         function signalForChainData(


206         function _verifyHopProof(


231         function _authorizePause(address) internal pure override {


235         function _syncChainData(


253         function _sendSignal(


271         function _cacheChainData(


298         function _loadSignalValue(


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/signal/SignalService.sol#L298:298

```solidity
File: contracts/team/TimelockTokenPool.sol


161         function withdraw() external {


176         function getMyGrantSummary(address _recipient)


208         function _withdraw(address _recipient, address _to) private {


225         function _voidGrant(Grant storage _grant) private returns (uint128 amountVoided) {


235         function _getAmountOwned(Grant memory _grant) private view returns (uint128) {


239         function _getAmountUnlocked(Grant memory _grant) private view returns (uint128) {


245         function _calcAmount(


267         function _validateGrant(Grant memory _grant) private pure {


273         function _validateCliff(uint64 _start, uint64 _cliff, uint32 _period) private pure {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/TimelockTokenPool.sol#L273:273

```solidity
File: contracts/team/airdrop/MerkleClaimable.sol


56          function __MerkleClaimable_init(


67          function _verifyClaim(bytes memory data, bytes32[] calldata proof) internal ongoingClaim {


77          function _verifyMerkleProof(


90          function _setConfig(uint64 _claimStart, uint64 _claimEnd, bytes32 _merkleRoot) private {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/airdrop/MerkleClaimable.sol#L90:90

```solidity
File: contracts/thirdparty/solmate/LibFixedPointMath.sol


13          function exp(int256 x) internal pure returns (int256 r) {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/solmate/LibFixedPointMath.sol#L13:13

```solidity
File: contracts/tokenvault/BaseVault.sol


47          function checkProcessMessageContext()


58          function checkRecallMessageContext()


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BaseVault.sol#L58:58

```solidity
File: contracts/tokenvault/BridgedERC1155.sol


115         function name() public view returns (string memory) {


121         function symbol() public view returns (string memory) {


125         function _beforeTokenTransfer(


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC1155.sol#L125:125

```solidity
File: contracts/tokenvault/BridgedERC20.sol


85          function snapshot() external onlyOwnerOrSnapshooter {


91          function name()


102         function symbol()


113         function decimals()


125         function canonical() public view returns (address, uint256) {


129         function _mintToken(address _account, uint256 _amount) internal override {


133         function _burnToken(address _from, uint256 _amount) internal override {


139         function _beforeTokenTransfer(


152         function _afterTokenTransfer(


163         function _mint(


173         function _burn(


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC20.sol#L173:173

```solidity
File: contracts/tokenvault/BridgedERC20Base.sol


93          function owner() public view override(IBridgedERC20, OwnableUpgradeable) returns (address) {


101         function _isMigratingOut() internal view returns (bool) {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC20Base.sol#L101:101

```solidity
File: contracts/tokenvault/BridgedERC721.sol


87          function name() public view override(ERC721Upgradeable) returns (string memory) {


93          function symbol() public view override(ERC721Upgradeable) returns (string memory) {


100         function source() public view returns (address, uint256) {


115         function _beforeTokenTransfer(


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC721.sol#L115:115

```solidity
File: contracts/tokenvault/ERC1155Vault.sol


93          function onMessageInvocation(bytes calldata data) external payable nonReentrant whenNotPaused {


127         function onMessageRecalled(


160         function onERC1155BatchReceived(


175         function onERC1155Received(


204         function name() public pure override returns (bytes32) {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC1155Vault.sol#L204:204

```solidity
File: contracts/tokenvault/ERC20Vault.sol


253         function onMessageInvocation(bytes calldata _data)


285         function onMessageRecalled(


316         function name() public pure override returns (bytes32) {


320         function _transferTokens(


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC20Vault.sol#L320:320

```solidity
File: contracts/tokenvault/ERC721Vault.sol


77          function onMessageInvocation(bytes calldata _data)


110         function onMessageRecalled(


142         function onERC721Received(


156         function name() public pure override returns (bytes32) {


160         function _transferTokens(


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC721Vault.sol#L160:160

```solidity
File: contracts/tokenvault/LibBridgedToken.sol


11          function validateInputs(


28          function buildName(


39          function buildSymbol(string memory _symbol) internal pure returns (string memory) {


43          function buildURI(


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/LibBridgedToken.sol#L43:43

```solidity
File: contracts/tokenvault/adapters/USDCAdapter.sol


43          function _mintToken(address _account, uint256 _amount) internal override {


47          function _burnToken(address _from, uint256 _amount) internal override {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/adapters/USDCAdapter.sol#L47:47

```solidity
File: contracts/verifiers/GuardianVerifier.sol


23          function verifyProof(


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/verifiers/GuardianVerifier.sol#L23:23

```solidity
File: contracts/verifiers/SgxVerifier.sol


139         function verifyProof(


195         function _addInstances(


226         function _replaceInstance(uint256 id, address oldInstance, address newInstance) private {


233         function _isInstanceValid(uint256 id, address instance) private view returns (bool) {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/verifiers/SgxVerifier.sol#L233:233

</details>

## NC103 - Missing events in sensitive functions:

Sensitive setter functions in smart contracts often alter critical state variables. Without events emitted in these functions, external observers or dApps cannot easily track or react to these state changes. Missing events can obscure contract activity, hampering transparency and making integration more challenging. To resolve this, incorporate appropriate event emissions within these functions. Events offer an efficient way to log crucial changes, aiding in real-time tracking and post-transaction verification..


```solidity
File: contracts/automata-attestation/AutomataDcapV3Attestation.sol


65          function setMrSigner(bytes32 _mrSigner, bool _trusted) external onlyOwner {
66              _trustedUserMrSigner[_mrSigner] = _trusted;
67          }


69          function setMrEnclave(bytes32 _mrEnclave, bool _trusted) external onlyOwner {
70              _trustedUserMrEnclave[_mrEnclave] = _trusted;
71          }


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/AutomataDcapV3Attestation.sol#L69:71

```solidity
File: contracts/tokenvault/BridgedERC20.sol


80          function setSnapshoter(address _snapshooter) external onlyOwner {
81              snapshooter = _snapshooter;
82          }


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC20.sol#L80:82

## NC104 - If statement control structures do not comply with best practices:

If statements which include a single line do not need to have curly brackets, however according to the Solidiity style guide the line of code executed upon the if statement condition being met should still be on the next line, not on the same line as the if statement declaration.


<details>
<summary>Click to show 135 findings</summary>

```solidity
File: contracts/L1/TaikoL1.sol


29              if (state.slotB.provingPaused) revert L1_PROVING_PAUSED();


35              if (!_inNonReentrant()) revert L1_RECEIVE_DISABLED();


90              if (_blockId != meta.id) revert L1_INVALID_BLOCK_ID();


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/TaikoL1.sol#L90:90

```solidity
File: contracts/L1/TaikoToken.sol


61              if (_to == address(this)) revert TKO_INVALID_ADDR();


79              if (_to == address(this)) revert TKO_INVALID_ADDR();


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/TaikoToken.sol#L79:79

```solidity
File: contracts/L1/gov/TaikoGovernor.sol


81              if (_signatures.length != _calldatas.length) revert TG_INVALID_SIGNATURES_LENGTH();


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/gov/TaikoGovernor.sol#L81:81

```solidity
File: contracts/L1/hooks/AssignmentHook.sol


173                 if (_tierFees[i].tier == _tierId) return _tierFees[i].fee;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/hooks/AssignmentHook.sol#L173:173

```solidity
File: contracts/L1/libs/LibDepositing.sol


150             if (_amount > type(uint96).max) revert L1_INVALID_ETH_DEPOSIT();


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibDepositing.sol#L150:150

```solidity
File: contracts/L1/libs/LibProposing.sol


94              if (!_isProposerPermitted(b, _resolver)) revert L1_UNAUTHORIZED();


142                 if (!_config.blobAllowedForDA) revert L1_BLOB_FOR_DA_DISABLED();


145                     if (!_config.blobReuseEnabled) revert L1_BLOB_REUSE_DISABLED();


159                     if (meta_.blobHash == 0) revert L1_BLOB_NOT_FOUND();


182                 if (!LibAddress.isSenderEOA()) revert L1_PROPOSER_NOT_EOA();


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProposing.sol#L182:182

```solidity
File: contracts/L1/libs/LibProving.sol


74              if (_state.slotB.provingPaused == _pause) revert L1_INVALID_PAUSE_STATUS();


219                 if (sameTransition) revert L1_ALREADY_PROVED();


239                     if (ts.contester != address(0)) revert L1_ALREADY_CONTESTED();


374                 if (_sameTransition) revert L1_ALREADY_PROVED();


412             if (_tier.contestBond == 0) return;


420                 if (!isAssignedPover) revert L1_NOT_ASSIGNED_PROVER();


424                 if (isAssignedPover) revert L1_ASSIGNED_PROVER_NOT_ALLOWED();


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProving.sol#L424:424

```solidity
File: contracts/L1/libs/LibUtils.sol


40              if (blk.blockId != _blockId) revert L1_BLOCK_MISMATCH();


43              if (tid == 0) revert L1_TRANSITION_NOT_FOUND();


86              if (tid_ >= _blk.nextTransitionId) revert L1_UNEXPECTED_TRANSITION_ID();


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibUtils.sol#L86:86

```solidity
File: contracts/L1/libs/LibVerifying.sol


54              if (!_isConfigValid(_config)) revert L1_INVALID_CONFIG();


105             if (blk.blockId != blockId) revert L1_BLOCK_MISMATCH();


111             if (tid == 0) revert L1_TRANSITION_ID_ZERO();


131                     if (blk.blockId != blockId) revert L1_BLOCK_MISMATCH();


137                     if (tid == 0) break;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibVerifying.sol#L137:137

```solidity
File: contracts/L1/provers/GuardianProver.sol


45              if (_proof.tier != LibTiers.TIER_GUARDIAN) revert INVALID_PROOF();


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/provers/GuardianProver.sol#L45:45

```solidity
File: contracts/L1/provers/Guardians.sol


82                  if (guardian == address(0)) revert INVALID_GUARDIAN();


84                  if (guardianIds[guardian] != 0) revert INVALID_GUARDIAN_SET();


113             if (id == 0) revert INVALID_GUARDIAN();


134                     if (bits & 1 == 1) ++count;


135                     if (count == minGuardians) return true;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/provers/Guardians.sol#L135:135

```solidity
File: contracts/L1/tiers/TestnetTierProvider.sol


68              if (_rand % 10 == 0) return LibTiers.TIER_SGX;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/tiers/TestnetTierProvider.sol#L68:68

```solidity
File: contracts/L2/CrossChainOwned.sol


43              if (txId != nextTxId) revert XCO_INVALID_TX_ID();


51              if (!success) revert XCO_TX_REVERTED();


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/CrossChainOwned.sol#L51:51

```solidity
File: contracts/L2/TaikoL2.sol


123             if (msg.sender != GOLDEN_TOUCH_ADDRESS) revert L2_INVALID_SENDER();


172             if (_to == address(0)) revert L2_INVALID_PARAM();


201             if (_blockId >= block.number) return 0;


202             if (_blockId + 256 >= block.number) return blockhash(_blockId);


296             if (basefee_ == 0) basefee_ = 1;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/TaikoL2.sol#L296:296

```solidity
File: contracts/L2/TaikoL2EIP1559Configurable.sol


33              if (_newConfig.gasTargetPerL1Block == 0) revert L2_INVALID_CONFIG();


34              if (_newConfig.basefeeAdjustmentQuotient == 0) revert L2_INVALID_CONFIG();


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/TaikoL2EIP1559Configurable.sol#L34:34

```solidity
File: contracts/automata-attestation/utils/X509DateUtils.sol


57              if (isLeapYear(year)) monthDays[1] = 29;


72              if (year % 4 != 0) return false;


73              if (year % 100 != 0) return true;


74              if (year % 400 != 0) return false;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/X509DateUtils.sol#L74:74

```solidity
File: contracts/bridge/Bridge.sol


65              if (_chainId != block.chainid) revert B_INVALID_CHAINID();


109             if (addressBanned[_addr] == _ban) revert B_INVALID_STATUS();


132             if (!destChainEnabled) revert B_INVALID_CHAINID();


139             if (expectedAmount != msg.value) revert B_INVALID_VALUE();


166             if (messageStatus[msgHash] != Status.NEW) revert B_STATUS_MISMATCH();


227             if (messageStatus[msgHash] != Status.NEW) revert B_STATUS_MISMATCH();


322                 if (msg.sender != _message.destOwner) revert B_PERMISSION_DENIED();


341             if (_message.srcChainId != block.chainid) return false;


360             if (_message.srcChainId != block.chainid) return false;


382             if (_message.destChainId != block.chainid) return false;


485             if (_gasLimit == 0) revert B_INVALID_GAS_LIMIT();


516             if (messageStatus[_msgHash] == _status) return;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/Bridge.sol#L516:516

```solidity
File: contracts/common/AddressManager.sol


48              if (_newAddress == oldAddress) revert AM_INVALID_PARAMS();


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/common/AddressManager.sol#L48:48

```solidity
File: contracts/common/AddressResolver.sol


25              if (msg.sender != resolve(_name, true)) revert RESOLVER_DENIED();


81              if (addressManager == address(0)) revert RESOLVER_INVALID_MANAGER();


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/common/AddressResolver.sol#L81:81

```solidity
File: contracts/common/EssentialContract.sol


42              if (msg.sender != owner() && msg.sender != resolve(_name, true)) revert RESOLVER_DENIED();


47              if (_loadReentryLock() == _TRUE) revert REENTRANT_CALL();


54              if (!paused()) revert INVALID_PAUSE_STATUS();


59              if (paused()) revert INVALID_PAUSE_STATUS();


105             if (_addressManager == address(0)) revert ZERO_ADDR_MANAGER();


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/common/EssentialContract.sol#L105:105

```solidity
File: contracts/libs/Lib4844.sol


40              if (_x >= BLS_MODULUS) revert POINT_X_TOO_LARGE();


41              if (_y >= BLS_MODULUS) revert POINT_Y_TOO_LARGE();


47              if (!ok) revert EVAL_FAILED_1();


49              if (ret.length != 64) revert EVAL_FAILED_2();


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/libs/Lib4844.sol#L49:49

```solidity
File: contracts/libs/LibAddress.sol


24              if (_to == address(0)) revert ETH_TRANSFER_FAILED();


36              if (!success) revert ETH_TRANSFER_FAILED();


54              if (!Address.isContract(_addr)) return false;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/libs/LibAddress.sol#L54:54

```solidity
File: contracts/libs/LibTrieProof.sol


50                  if (rlpAccount.length == 0) revert LTP_INVALID_ACCOUNT_PROOF();


64              if (!verified) revert LTP_INVALID_INCLUSION_PROOF();


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/libs/LibTrieProof.sol#L64:64

```solidity
File: contracts/signal/SignalService.sol


36              if (_app == address(0)) revert SS_INVALID_SENDER();


41              if (_input == 0) revert SS_INVALID_VALUE();


57              if (isAuthorized[_addr] == _authorize) revert SS_INVALID_STATE();


77              if (!isAuthorized[msg.sender]) revert SS_UNAUTHORIZED();


95              if (hopProofs.length == 0) revert SS_EMPTY_PROOF();


111                     if (hop.chainId != block.chainid) revert SS_INVALID_LAST_HOP_CHAINID();


172                 if (chainData_ == 0) revert SS_SIGNAL_NOT_FOUND();


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/signal/SignalService.sol#L172:172

```solidity
File: contracts/team/TimelockTokenPool.sol


121             if (_taikoToken == address(0)) revert INVALID_PARAM();


124             if (_costToken == address(0)) revert INVALID_PARAM();


127             if (_sharedVault == address(0)) revert INVALID_PARAM();


136             if (_recipient == address(0)) revert INVALID_PARAM();


137             if (recipients[_recipient].grant.amount != 0) revert ALREADY_GRANTED();


154             if (amountVoided == 0) revert NOTHING_TO_VOID();


169             if (_to == address(0)) revert INVALID_PARAM();


255             if (_amount == 0) return 0;


256             if (_start == 0) return _amount;


257             if (block.timestamp <= _start) return 0;


259             if (_period == 0) return _amount;


260             if (block.timestamp >= _start + _period) return _amount;


262             if (block.timestamp <= _cliff) return 0;


268             if (_grant.amount == 0) revert INVALID_GRANT();


275                 if (_cliff > 0) revert INVALID_GRANT();


277                 if (_cliff > 0 && _cliff <= _start) revert INVALID_GRANT();


278                 if (_cliff >= _start + _period) revert INVALID_GRANT();


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/TimelockTokenPool.sol#L278:278

```solidity
File: contracts/team/airdrop/ERC20Airdrop2.sol


111             if (balance == 0) return (0, 0);


114             if (block.timestamp < claimEnd) return (balance, 0);


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/airdrop/ERC20Airdrop2.sol#L114:114

```solidity
File: contracts/team/airdrop/MerkleClaimable.sol


70              if (isClaimed[hash]) revert CLAIMED_ALREADY();


71              if (!_verifyMerkleProof(proof, merkleRoot, hash)) revert INVALID_PROOF();


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/airdrop/MerkleClaimable.sol#L71:71

```solidity
File: contracts/thirdparty/solmate/LibFixedPointMath.sol


26                  if (x >= 135_305_999_368_893_231_589) revert Overflow();


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/solmate/LibFixedPointMath.sol#L26:26

```solidity
File: contracts/tokenvault/BaseNFTVault.sol


149             if (_op.token == address(0)) revert VAULT_INVALID_TOKEN();


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BaseNFTVault.sol#L149:149

```solidity
File: contracts/tokenvault/BaseVault.sol


55              if (ctx_.from != selfOnSourceChain) revert VAULT_PERMISSION_DENIED();


65              if (ctx_.from != msg.sender) revert VAULT_PERMISSION_DENIED();


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BaseVault.sol#L65:65

```solidity
File: contracts/tokenvault/BridgedERC1155.sol


137             if (_to == address(this)) revert BTOKEN_CANNOT_RECEIVE();


138             if (paused()) revert INVALID_PAUSE_STATUS();


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC1155.sol#L138:138

```solidity
File: contracts/tokenvault/BridgedERC20.sol


147             if (_to == address(this)) revert BTOKEN_CANNOT_RECEIVE();


148             if (paused()) revert INVALID_PAUSE_STATUS();


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC20.sol#L148:148

```solidity
File: contracts/tokenvault/BridgedERC20Base.sol


59              if (_isMigratingOut()) revert BB_MINT_DISALLOWED();


78                  if (msg.sender != _account) revert BB_PERMISSION_DENIED();


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC20Base.sol#L78:78

```solidity
File: contracts/tokenvault/BridgedERC721.sol


125             if (_to == address(this)) revert BTOKEN_CANNOT_RECEIVE();


126             if (paused()) revert INVALID_PAUSE_STATUS();


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC721.sol#L126:126

```solidity
File: contracts/tokenvault/ERC1155Vault.sol


48                  if (_op.amounts[i] == 0) revert VAULT_INVALID_AMOUNT();


108             if (to == address(0) || to == address(this)) revert VAULT_INVALID_TO();


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC1155Vault.sol#L108:108

```solidity
File: contracts/tokenvault/ERC20Vault.sol


162             if (btokenBlacklist[_btokenNew]) revert VAULT_BTOKEN_BLACKLISTED();


214             if (_op.amount == 0) revert VAULT_INVALID_AMOUNT();


215             if (_op.token == address(0)) revert VAULT_INVALID_TOKEN();


216             if (btokenBlacklist[_op.token]) revert VAULT_BTOKEN_BLACKLISTED();


267             if (to == address(0) || to == address(this)) revert VAULT_INVALID_TO();


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC20Vault.sol#L267:267

```solidity
File: contracts/tokenvault/ERC721Vault.sol


35                  if (_op.amounts[i] != 0) revert VAULT_INVALID_AMOUNT();


91              if (to == address(0) || to == address(this)) revert VAULT_INVALID_TO();


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC721Vault.sol#L91:91

```solidity
File: contracts/verifiers/SgxVerifier.sol


107                 if (instances[idx].addr == address(0)) revert SGX_INVALID_INSTANCE();


130             if (!verified) revert SGX_INVALID_ATTESTATION();


148             if (_ctx.isContesting) return;


152             if (_proof.data.length != 89) revert SGX_INVALID_PROOF();


161             if (!_isInstanceValid(id, oldInstance)) revert SGX_INVALID_INSTANCE();


211                 if (addressRegistered[_instances[i]]) revert SGX_ALREADY_ATTESTED();


215                 if (_instances[i] == address(0)) revert SGX_INVALID_INSTANCE();


234             if (instance == address(0)) return false;


235             if (instance != instances[id].addr) return false;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/verifiers/SgxVerifier.sol#L235:235

</details>

## NC105 - A event should be emitted if a non immutable state variable is set in a constructor:




```solidity
File: contracts/automata-attestation/AutomataDcapV3Attestation.sol


54          constructor(address sigVerifyLibAddr, address pemCertLibAddr) {
55              sigVerifyLib = ISigVerifyLib(sigVerifyLibAddr);
56              pemCertLib = PEMCertChainLib(pemCertLibAddr);
57              owner = msg.sender;
58          }


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/AutomataDcapV3Attestation.sol#L54:58

```solidity
File: contracts/automata-attestation/utils/SigVerifyLib.sol


20          constructor(address es256Verifier) {
21              ES256VERIFIER = es256Verifier;
22          }


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/SigVerifyLib.sol#L20:22

## NC106 - Unused file:

The file is never imported by any other source file. If the file is needed for tests, it should be moved to a test directory


```solidity
File: contracts/libs/Lib4844.sol


/// @auditbase `Good/contracts/libs/Lib4844.sol` not used in any contracts


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/libs/Lib4844.sol#L1:1

## NC107 - Public state arrays should have a getter to return all elements:

In Solidity, public state variables automatically generate a getter function. For non-array types, this is straightforward: it simply returns the value. However, for arrays, the automatically generated getter only allows retrieval of an element at a specific index, not the entire array. This is mainly to prevent unintentional high gas costs, as returning the entire array can be expensive if it's large. If developers want to retrieve the whole array, they must explicitly define a function, as auto-generation could inadvertently expose contracts to gas-related vulnerabilities or lead to unwanted behavior for larger arrays.


```solidity
File: contracts/L1/provers/Guardians.sol


23          address[] public guardians;


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/provers/Guardians.sol#L23:23

## NC108 - It is best practice to use linear inheritance:

In Solidity, complex inheritance structures can obfuscate code understanding, introducing potential security risks. Multiple inheritance, especially with overlapping function names or state variables, can cause unintentional overrides or ambiguous behavior. Resolution: Strive for linear and simple inheritance chains. Avoid diamond or circular inheritance patterns. Clearly document the purpose and relationships of base contracts, ensuring that overrides are intentional. Tools like Remix or Hardhat can visualize inheritance chains, assisting in verification. Keeping inheritance streamlined aids in better code readability, reduces potential errors, and ensures smoother audits and upgrades.


<details>
<summary>Click to show 18 findings</summary>

```solidity
File: contracts/L1/TaikoL1.sol


22      contract TaikoL1 is EssentialContract, ITaikoL1, TaikoEvents, TaikoErrors {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/TaikoL1.sol#L22:22

```solidity
File: contracts/L1/TaikoToken.sol


15      contract TaikoToken is EssentialContract, ERC20SnapshotUpgradeable, ERC20VotesUpgradeable {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/TaikoToken.sol#L15:15

```solidity
File: contracts/L1/gov/TaikoGovernor.sol


16      contract TaikoGovernor is
17          EssentialContract,
18          GovernorCompatibilityBravoUpgradeable,
19          GovernorVotesUpgradeable,
20          GovernorVotesQuorumFractionUpgradeable,
21          GovernorTimelockControlUpgradeable


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/gov/TaikoGovernor.sol#L16:21

```solidity
File: contracts/L1/gov/TaikoTimelockController.sol


9       contract TaikoTimelockController is EssentialContract, TimelockControllerUpgradeable {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/gov/TaikoTimelockController.sol#L9:9

```solidity
File: contracts/L1/hooks/AssignmentHook.sol


14      contract AssignmentHook is EssentialContract, IHook {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/hooks/AssignmentHook.sol#L14:14

```solidity
File: contracts/L1/tiers/DevnetTierProvider.sol


10      contract DevnetTierProvider is EssentialContract, ITierProvider {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/tiers/DevnetTierProvider.sol#L10:10

```solidity
File: contracts/L1/tiers/MainnetTierProvider.sol


10      contract MainnetTierProvider is EssentialContract, ITierProvider {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/tiers/MainnetTierProvider.sol#L10:10

```solidity
File: contracts/L1/tiers/TestnetTierProvider.sol


10      contract TestnetTierProvider is EssentialContract, ITierProvider {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/tiers/TestnetTierProvider.sol#L10:10

```solidity
File: contracts/bridge/Bridge.sol


16      contract Bridge is EssentialContract, IBridge {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/Bridge.sol#L16:16

```solidity
File: contracts/common/AddressManager.sol


10      contract AddressManager is EssentialContract, IAddressManager {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/common/AddressManager.sol#L10:10

```solidity
File: contracts/signal/SignalService.sol


14      contract SignalService is EssentialContract, ISignalService {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/signal/SignalService.sol#L14:14

```solidity
File: contracts/tokenvault/BridgedERC1155.sol


14      contract BridgedERC1155 is EssentialContract, IERC1155MetadataURIUpgradeable, ERC1155Upgradeable {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC1155.sol#L14:14

```solidity
File: contracts/tokenvault/BridgedERC20.sol


15      contract BridgedERC20 is
16          BridgedERC20Base,
17          IERC20MetadataUpgradeable,
18          ERC20SnapshotUpgradeable,
19          ERC20VotesUpgradeable


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC20.sol#L15:19

```solidity
File: contracts/tokenvault/BridgedERC721.sol


12      contract BridgedERC721 is EssentialContract, ERC721Upgradeable {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC721.sol#L12:12

```solidity
File: contracts/tokenvault/ERC1155Vault.sol


29      contract ERC1155Vault is BaseNFTVault, ERC1155ReceiverUpgradeable {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC1155Vault.sol#L29:29

```solidity
File: contracts/tokenvault/ERC721Vault.sol


16      contract ERC721Vault is BaseNFTVault, IERC721Receiver {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC721Vault.sol#L16:16

```solidity
File: contracts/verifiers/GuardianVerifier.sol


10      contract GuardianVerifier is EssentialContract, IVerifier {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/verifiers/GuardianVerifier.sol#L10:10

```solidity
File: contracts/verifiers/SgxVerifier.sol


19      contract SgxVerifier is EssentialContract, IVerifier {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/verifiers/SgxVerifier.sol#L19:19

</details>

## NC109 - Consider only defining one library/interface/contract per sol file:

Combining multiple libraries, interfaces, or contracts in a single  file can lead to clutter, reduced readability, and versioning issues. **Resolution**: Adopt the best practice of defining only one library, interface, or contract per Solidity file. This modular approach enhances clarity, simplifies unit testing, and streamlines code review. Furthermore, segregating components makes version management easier, as updates to one component won't necessitate changes to a file housing multiple unrelated components. Structured file management can further assist in avoiding naming collisions and ensure smoother integration into larger systems or DApps.


<details>
<summary>Click to show 5 findings</summary>

```solidity
File: contracts/L1/tiers/ITierProvider.sol


7       interface ITierProvider {
8           struct Tier {
9               bytes32 verifierName;
10              uint96 validityBond;
11              uint96 contestBond;
12              uint24 cooldownWindow; // in minutes
13              uint16 provingWindow; // in minutes
14              uint8 maxBlocksToVerifyPerProof;
15          }
16      
17          error TIER_NOT_FOUND();
18      
19          /// @dev Retrieves the configuration for a specified tier.
20          /// @param tierId ID of the tier.
21          /// @return Tier struct containing the tier's parameters.
22          function getTier(uint16 tierId) external view returns (Tier memory);
23      
24          /// @dev Retrieves the IDs of all supported tiers.
25          /// Note that the core protocol requires the number of tiers to be smaller
26          /// than 256. In reality, this number should be much smaller.
27          /// @return The ids of the tiers.
28          function getTierIds() external view returns (uint16[] memory);
29      
30          /// @dev Determines the minimal tier for a block based on a random input.
31          /// @param rand (Semi) random number.
32          /// @return The tier id.
33          function getMinTier(uint256 rand) external view returns (uint16);
34      }
35      
36      /// @dev Tier ID cannot be zero!
37      library LibTiers {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/tiers/ITierProvider.sol#L7:37

```solidity
File: contracts/automata-attestation/utils/Asn1Decode.sol


12      library NodePtr {
13          // Unpack first byte index
14          function ixs(uint256 self) internal pure returns (uint256) {
15              return uint80(self);
16          }
17          // Unpack first content byte index
18      
19          function ixf(uint256 self) internal pure returns (uint256) {
20              return uint80(self >> 80);
21          }
22          // Unpack last content byte index
23      
24          function ixl(uint256 self) internal pure returns (uint256) {
25              return uint80(self >> 160);
26          }
27          // Pack 3 uint80s into a uint256
28      
29          function getPtr(uint256 _ixs, uint256 _ixf, uint256 _ixl) internal pure returns (uint256) {
30              _ixs |= _ixf << 80;
31              _ixs |= _ixl << 160;
32              return _ixs;
33          }
34      }
35      
36      /// @title Asn1Decode
37      /// @custom:security-contact security@taiko.xyz
38      library Asn1Decode {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/Asn1Decode.sol#L12:38

```solidity
File: contracts/bridge/IBridge.sol


8       interface IBridge {
9           enum Status {
10              NEW,
11              RETRIABLE,
12              DONE,
13              FAILED,
14              RECALLED
15          }
16      
17          struct Message {
18              // Message ID whose value is automatically assigned.
19              uint128 id;
20              // The address, EOA or contract, that interacts with this bridge.
21              // The value is automatically assigned.
22              address from;
23              // Source chain ID whose value is automatically assigned.
24              uint64 srcChainId;
25              // Destination chain ID where the `to` address lives.
26              uint64 destChainId;
27              // The owner of the message on the source chain.
28              address srcOwner;
29              // The owner of the message on the destination chain.
30              address destOwner;
31              // The destination address on the destination chain.
32              address to;
33              // Alternate address to send any refund on the destination chain.
34              // If blank, defaults to destOwner.
35              address refundTo;
36              // value to invoke on the destination chain.
37              uint256 value;
38              // Processing fee for the relayer. Zero if owner will process themself.
39              uint256 fee;
40              // gasLimit to invoke on the destination chain.
41              uint256 gasLimit;
42              // callData to invoke on the destination chain.
43              bytes data;
44              // Optional memo.
45              string memo;
46          }
47      
48          // Note that this struct shall take only 1 slot to minimize gas cost
49          struct ProofReceipt {
50              // The time a message is marked as received on the destination chain
51              uint64 receivedAt;
52              // The address that can execute the message after the invocation delay without an extra
53              // delay.
54              // For a failed message, preferredExecutor's value doesn't matter as only the owner can
55              // invoke the message.
56              address preferredExecutor;
57          }
58      
59          // Struct representing the context of a bridge operation.
60          struct Context {
61              bytes32 msgHash; // Message hash.
62              address from; // Sender's address.
63              uint64 srcChainId; // Source chain ID.
64          }
65      
66          /// @notice Emitted when a message is sent.
67          /// @param msgHash The hash of the message.
68          /// @param message The message.
69          event MessageSent(bytes32 indexed msgHash, Message message);
70      
71          /// @notice Emitted when a message is received.
72          /// @param msgHash The hash of the message.
73          /// @param message The message.
74          /// @param isRecall True if the message is a recall.
75          event MessageReceived(bytes32 indexed msgHash, Message message, bool isRecall);
76      
77          /// @notice Emitted when a message is recalled.
78          /// @param msgHash The hash of the message.
79          event MessageRecalled(bytes32 indexed msgHash);
80      
81          /// @notice Emitted when a message is executed.
82          /// @param msgHash The hash of the message.
83          event MessageExecuted(bytes32 indexed msgHash);
84      
85          /// @notice Emitted when a message is retried.
86          /// @param msgHash The hash of the message.
87          event MessageRetried(bytes32 indexed msgHash);
88      
89          /// @notice Emitted when the status of a message changes.
90          /// @param msgHash The hash of the message.
91          /// @param status The new status of the message.
92          event MessageStatusChanged(bytes32 indexed msgHash, Status status);
93      
94          /// @notice Emitted when a message is suspended or unsuspended.
95          /// @param msgHash The hash of the message.
96          /// @param suspended True if the message is suspended.
97          event MessageSuspended(bytes32 msgHash, bool suspended);
98      
99          /// @notice Emitted when an address is banned or unbanned.
100         /// @param addr The address to ban or unban.
101         /// @param banned True if the address is banned.
102         event AddressBanned(address indexed addr, bool banned);
103     
104         /// @notice Sends a message to the destination chain and takes custody
105         /// of Ether required in this contract. All extra Ether will be refunded.
106         /// @param _message The message to be sent.
107         /// @return msgHash_ The hash of the sent message.
108         /// @return message_ The updated message sent.
109         function sendMessage(Message calldata _message)
110             external
111             payable
112             returns (bytes32 msgHash_, Message memory message_);
113     
114         /// @notice Recalls a failed message on its source chain, releasing
115         /// associated assets.
116         /// @dev This function checks if the message failed on the source chain and
117         /// releases associated Ether or tokens.
118         /// @param _message The message whose associated Ether should be released.
119         /// @param _proof The merkle inclusion proof.
120         function recallMessage(Message calldata _message, bytes calldata _proof) external;
121     
122         /// @notice Processes a bridge message on the destination chain. This
123         /// function is callable by any address, including the `message.destOwner`.
124         /// @dev The process begins by hashing the message and checking the message
125         /// status in the bridge  If the status is "NEW", the message is invoked. The
126         /// status is updated accordingly, and processing fees are refunded as
127         /// needed.
128         /// @param _message The message to be processed.
129         /// @param _proof The merkle inclusion proof.
130         function processMessage(Message calldata _message, bytes calldata _proof) external;
131     
132         /// @notice Retries to invoke the messageCall after releasing associated
133         /// Ether and tokens.
134         /// @dev This function can be called by any address, including the
135         /// `message.destOwner`.
136         /// It attempts to invoke the messageCall and updates the message status
137         /// accordingly.
138         /// @param _message The message to retry.
139         /// @param _isLastAttempt Specifies if this is the last attempt to retry the
140         /// message.
141         function retryMessage(Message calldata _message, bool _isLastAttempt) external;
142     
143         /// @notice Returns the bridge state context.
144         /// @return ctx_ The context of the current bridge operation.
145         function context() external view returns (Context memory ctx_);
146     
147         /// @notice Checks if the message was sent.
148         /// @param _message The message.
149         /// @return true if the message was sent.
150         function isMessageSent(Message calldata _message) external view returns (bool);
151     
152         /// @notice Hash the message
153         /// @param _message The message struct variable to be hashed.
154         /// @return The message's hash.
155         function hashMessage(Message memory _message) external pure returns (bytes32);
156     }
157     
158     /// @title IRecallableSender
159     /// @notice An interface that all recallable message senders shall implement.
160     interface IRecallableSender {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/IBridge.sol#L8:160

```solidity
File: contracts/tokenvault/ERC1155Vault.sol


16      interface IERC1155NameAndSymbol {
17          /// @notice Returns the name of the token.
18          function name() external view returns (string memory);
19      
20          /// @notice Returns the symbol of the token.
21          function symbol() external view returns (string memory);
22      }
23      
24      /// @title ERC1155Vault
25      /// @dev Labeled in AddressResolver as "erc1155_vault"
26      /// @notice This vault holds all ERC1155 tokens that users have deposited.
27      /// It also manages the mapping between canonical tokens and their bridged
28      /// tokens.
29      contract ERC1155Vault is BaseNFTVault, ERC1155ReceiverUpgradeable {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC1155Vault.sol#L16:29

```solidity
File: contracts/tokenvault/adapters/USDCAdapter.sol


8       interface IUSDC {
9           /// @notice Burns a specific amount of tokens.
10          /// @param _amount The amount of token to be burned.
11          function burn(uint256 _amount) external;
12      
13          /// @notice Mints a specific amount of new tokens to an address.
14          /// @param _to The address that will receive the minted tokens.
15          /// @param _amount The amount of tokens to mint.
16          function mint(address _to, uint256 _amount) external;
17      
18          /// @notice Transfers tokens from one address to another.
19          /// @param from The address which you want to send tokens from.
20          /// @param _to The address which you want to transfer to.
21          /// @param _amount The amount of tokens to be transferred.
22          /// @return true if the transfer was successful, otherwise false.
23          function transferFrom(address from, address _to, uint256 _amount) external returns (bool);
24      }
25      
26      /// @title USDCAdapter
27      /// @custom:security-contact security@taiko.xyz
28      contract USDCAdapter is BridgedERC20Base {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/adapters/USDCAdapter.sol#L8:28

</details>

## NC110 - Use a struct to encapsulate multiple function parameters:

Using a struct to encapsulate multiple parameters in Solidity functions can significantly enhance code readability and maintainability. Instead of passing a long list of arguments, which can be error-prone and hard to manage, a struct allows grouping related data into a single, coherent entity. This approach simplifies function signatures and makes the code more organized. It also enhances code clarity, as developers can easily understand the relationship between the parameters. Moreover, it aids in future code modifications and expansions, as adding or modifying a parameter only requires changes in the struct definition, rather than in every function that uses these parameters.


<details>
<summary>Click to show 23 findings</summary>

```solidity
File: contracts/L1/gov/TaikoGovernor.sol


69          function propose(
70              address[] memory _targets,
71              uint256[] memory _values,
72              string[] memory _signatures,
73              bytes[] memory _calldatas,
74              string memory _description
75          )
76              public
77              virtual
78              override(GovernorCompatibilityBravoUpgradeable)
79              returns (uint256)
80          {


127         function _execute(
128             uint256 _proposalId,
129             address[] memory _targets,
130             uint256[] memory _values,
131             bytes[] memory _calldatas,
132             bytes32 _descriptionHash
133         )
134             internal
135             override(GovernorUpgradeable, GovernorTimelockControlUpgradeable)
136         {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/gov/TaikoGovernor.sol#L127:136

```solidity
File: contracts/L1/libs/LibProposing.sol


68          function proposeBlock(
69              TaikoData.State storage _state,
70              TaikoData.Config memory _config,
71              IAddressResolver _resolver,
72              bytes calldata _data,
73              bytes calldata _txList
74          )
75              internal
76              returns (TaikoData.BlockMetadata memory meta_, TaikoData.EthDeposit[] memory deposits_)
77          {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProposing.sol#L68:77

```solidity
File: contracts/L1/libs/LibProving.sol


91          function proveBlock(
92              TaikoData.State storage _state,
93              TaikoData.Config memory _config,
94              IAddressResolver _resolver,
95              TaikoData.BlockMetadata memory _meta,
96              TaikoData.Transition memory _tran,
97              TaikoData.TierProof memory _proof
98          )
99              internal
100             returns (uint8 maxBlocksToVerify_)
101         {


350         function _overrideWithHigherProof(
351             TaikoData.TransitionState storage _ts,
352             TaikoData.Transition memory _tran,
353             TaikoData.TierProof memory _proof,
354             ITierProvider.Tier memory _tier,
355             IERC20 _tko,
356             bool _sameTransition
357         )
358             private
359         {


401         function _checkProverPermission(
402             TaikoData.State storage _state,
403             TaikoData.Block storage _blk,
404             TaikoData.TransitionState storage _ts,
405             uint32 _tid,
406             ITierProvider.Tier memory _tier
407         )
408             private
409             view
410         {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProving.sol#L401:410

```solidity
File: contracts/automata-attestation/utils/BytesUtils.sol


56          function compare(
57              bytes memory self,
58              uint256 offset,
59              uint256 len,
60              bytes memory other,
61              uint256 otheroffset,
62              uint256 otherlen
63          )
64              internal
65              pure
66              returns (int256)
67          {


116         function equals(
117             bytes memory self,
118             uint256 offset,
119             bytes memory other,
120             uint256 otherOffset,
121             uint256 len
122         )
123             internal
124             pure
125             returns (bool)
126         {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/BytesUtils.sol#L116:126

```solidity
File: contracts/automata-attestation/utils/X509DateUtils.sol


34          function toUnixTimestamp(
35              uint16 year,
36              uint8 month,
37              uint8 day,
38              uint8 hour,
39              uint8 minute,
40              uint8 second
41          )
42              internal
43              pure
44              returns (uint256)
45          {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/X509DateUtils.sol#L34:45

```solidity
File: contracts/libs/Lib4844.sol


30          function evaluatePoint(
31              bytes32 _blobHash,
32              uint256 _x,
33              uint256 _y,
34              bytes1[48] memory _commitment,
35              bytes1[48] memory _pointProof
36          )
37              internal
38              view
39          {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/libs/Lib4844.sol#L30:39

```solidity
File: contracts/libs/LibTrieProof.sol


34          function verifyMerkleProof(
35              bytes32 _rootHash,
36              address _addr,
37              bytes32 _slot,
38              bytes32 _value,
39              bytes[] memory _accountProof,
40              bytes[] memory _storageProof
41          )
42              internal
43              pure
44              returns (bytes32 storageRoot_)
45          {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/libs/LibTrieProof.sol#L34:45

```solidity
File: contracts/signal/SignalService.sol


206         function _verifyHopProof(
207             uint64 _chainId,
208             address _app,
209             bytes32 _signal,
210             bytes32 _value,
211             HopProof memory _hop,
212             address _signalService
213         )
214             internal
215             virtual
216             validSender(_app)
217             nonZeroValue(_signal)
218             nonZeroValue(_value)
219             returns (bytes32)
220         {


271         function _cacheChainData(
272             HopProof memory _hop,
273             uint64 _chainId,
274             uint64 _blockId,
275             bytes32 _signalRoot,
276             bool _isFullProof,
277             bool _isLastHop
278         )
279             private
280         {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/signal/SignalService.sol#L271:280

```solidity
File: contracts/team/airdrop/ERC20Airdrop.sol


27          function init(
28              address _owner,
29              uint64 _claimStart,
30              uint64 _claimEnd,
31              bytes32 _merkleRoot,
32              address _token,
33              address _vault
34          )
35              external
36              initializer
37          {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/airdrop/ERC20Airdrop.sol#L27:37

```solidity
File: contracts/team/airdrop/ERC20Airdrop2.sol


54          function init(
55              address _owner,
56              uint64 _claimStart,
57              uint64 _claimEnd,
58              bytes32 _merkleRoot,
59              address _token,
60              address _vault,
61              uint64 _withdrawalWindow
62          )
63              external
64              initializer
65          {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/airdrop/ERC20Airdrop2.sol#L54:65

```solidity
File: contracts/team/airdrop/ERC721Airdrop.sol


25          function init(
26              address _owner,
27              uint64 _claimStart,
28              uint64 _claimEnd,
29              bytes32 _merkleRoot,
30              address _token,
31              address _vault
32          )
33              external
34              initializer
35          {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/airdrop/ERC721Airdrop.sol#L25:35

```solidity
File: contracts/thirdparty/nomad-xyz/ExcessivelySafeCall.sol


25          function excessivelySafeCall(
26              address _target,
27              uint256 _gas,
28              uint256 _value,
29              uint16 _maxCopy,
30              bytes memory _calldata
31          )
32              internal
33              returns (bool, bytes memory)
34          {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/nomad-xyz/ExcessivelySafeCall.sol#L25:34

```solidity
File: contracts/tokenvault/BridgedERC1155.sol


38          function init(
39              address _owner,
40              address _addressManager,
41              address _srcToken,
42              uint256 _srcChainId,
43              string memory _symbol,
44              string memory _name
45          )
46              external
47              initializer
48          {


125         function _beforeTokenTransfer(
126             address, /*_operator*/
127             address, /*_from*/
128             address _to,
129             uint256[] memory, /*_ids*/
130             uint256[] memory, /*_amounts*/
131             bytes memory /*_data*/
132         )
133             internal
134             virtual
135             override
136         {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC1155.sol#L125:136

```solidity
File: contracts/tokenvault/BridgedERC20.sol


52          function init(
53              address _owner,
54              address _addressManager,
55              address _srcToken,
56              uint256 _srcChainId,
57              uint8 _decimals,
58              string memory _symbol,
59              string memory _name
60          )
61              external
62              initializer
63          {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC20.sol#L52:63

```solidity
File: contracts/tokenvault/BridgedERC721.sol


31          function init(
32              address _owner,
33              address _addressManager,
34              address _srcToken,
35              uint256 _srcChainId,
36              string memory _symbol,
37              string memory _name
38          )
39              external
40              initializer
41          {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC721.sol#L31:41

```solidity
File: contracts/tokenvault/ERC1155Vault.sol


160         function onERC1155BatchReceived(
161             address,
162             address,
163             uint256[] calldata,
164             uint256[] calldata,
165             bytes calldata
166         )
167             external
168             pure
169             returns (bytes4)
170         {


175         function onERC1155Received(
176             address,
177             address,
178             uint256,
179             uint256,
180             bytes calldata
181         )
182             external
183             pure
184             returns (bytes4)
185         {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC1155Vault.sol#L175:185

</details>

## NC111 - Avoid defining a function in a single line including it's contents:




```solidity
File: contracts/bridge/Bridge.sol


70          receive() external payable { }


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/Bridge.sol#L70:70

```solidity
File: contracts/common/EssentialContract.sol


114         function _authorizeUpgrade(address) internal virtual override onlyOwner { }


116         function _authorizePause(address) internal virtual onlyOwner { }


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/common/EssentialContract.sol#L116:116

## NC112 - Empty bytes check is missing:

When developing smart contracts in Solidity, it's crucial to validate the inputs of your functions. This includes ensuring that the bytes parameters are not empty, especially when they represent crucial data such as addresses, identifiers, or raw data that the contract needs to process.Missing empty bytes checks can lead to unexpected behaviour in your contract.For instance, certain operations might fail, produce incorrect results, or consume unnecessary gas when performed with empty bytes.  Moreover, missing input validation can potentially expose your contract to malicious activity, including exploitation of unhandled edge cases.To mitigate these issues, always validate that bytes parameters are not empty when the logic of your contract requires it.


<details>
<summary>Click to show 88 findings</summary>

```solidity
File: contracts/L1/TaikoL1.sol


55          function proposeBlock(
56              bytes calldata _params,
57              bytes calldata _txList
58          )


75          function proveBlock(
76              uint64 _blockId,
77              bytes calldata _input
78          )


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/TaikoL1.sol#L75:78

```solidity
File: contracts/L1/hooks/AssignmentHook.sol


62          function onBlockProposed(
63              TaikoData.Block memory _blk,
64              TaikoData.BlockMetadata memory _meta,
65              bytes memory _data
66          )


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/hooks/AssignmentHook.sol#L62:66

```solidity
File: contracts/L1/libs/LibProposing.sol


68          function proposeBlock(
69              TaikoData.State storage _state,
70              TaikoData.Config memory _config,
71              IAddressResolver _resolver,
72              bytes calldata _data,
73              bytes calldata _txList
74          )


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProposing.sol#L68:74

```solidity
File: contracts/L2/CrossChainOwned.sol


36          function onMessageInvocation(bytes calldata _data)


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/CrossChainOwned.sol#L36:36

```solidity
File: contracts/automata-attestation/AutomataDcapV3Attestation.sol


138         function verifyAttestation(bytes calldata data) external view override returns (bool) {


162         function _verify(bytes calldata quote) private view returns (bool, bytes memory) {


303         function _enclaveReportSigVerification(
304             bytes memory pckCertPubKey,
305             bytes memory signedQuoteData,
306             V3Struct.ECDSAQuoteV3AuthData memory authDataV3,
307             V3Struct.EnclaveReport memory qeEnclaveReport
308         )


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/AutomataDcapV3Attestation.sol#L303:308

```solidity
File: contracts/automata-attestation/lib/PEMCertChainLib.sol


40          function splitCertificateChain(
41              bytes memory pemChain,
42              uint256 size
43          )


74          function decodeCert(
75              bytes memory der,
76              bool isPckCert
77          )


252         function _trimBytes(
253             bytes memory input,
254             uint256 expectedLength
255         )


269         function _findPckTcbInfo(
270             bytes memory der,
271             uint256 tbsPtr,
272             uint256 tbsParentPtr
273         )


341         function _findTcb(
342             bytes memory der,
343             uint256 oidPtr
344         )


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/PEMCertChainLib.sol#L341:344

```solidity
File: contracts/automata-attestation/lib/QuoteV3Auth/V3Parser.sol


21          function parseInput(
22              bytes memory quote,
23              address pemCertLibAddr
24          )


133         function parseEnclaveReport(bytes memory rawEnclaveReport)


152         function littleEndianDecode(bytes memory encoded) private pure returns (uint256 decoded) {


165         function parseAndVerifyHeader(bytes memory rawHeader)


203         function parseAuthDataAndVerifyCertType(
204             bytes memory rawAuthData,
205             address pemCertLibAddr
206         )


267         function parseCerificationChainBytes(
268             bytes memory certBytes,
269             address pemCertLibAddr
270         )


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/QuoteV3Auth/V3Parser.sol#L267:270

```solidity
File: contracts/automata-attestation/utils/Asn1Decode.sol


47          function root(bytes memory der) internal pure returns (uint256) {


56          function rootOfBitStringAt(bytes memory der, uint256 ptr) internal pure returns (uint256) {


66          function rootOfOctetStringAt(bytes memory der, uint256 ptr) internal pure returns (uint256) {


77          function nextSiblingOf(bytes memory der, uint256 ptr) internal pure returns (uint256) {


87          function firstChildOf(bytes memory der, uint256 ptr) internal pure returns (uint256) {


111         function bytesAt(bytes memory der, uint256 ptr) internal pure returns (bytes memory) {


121         function allBytesAt(bytes memory der, uint256 ptr) internal pure returns (bytes memory) {


131         function bytes32At(bytes memory der, uint256 ptr) internal pure returns (bytes32) {


141         function uintAt(bytes memory der, uint256 ptr) internal pure returns (uint256) {


154         function uintBytesAt(bytes memory der, uint256 ptr) internal pure returns (bytes memory) {


165         function keccakOfBytesAt(bytes memory der, uint256 ptr) internal pure returns (bytes32) {


169         function keccakOfAllBytesAt(bytes memory der, uint256 ptr) internal pure returns (bytes32) {


179         function bitstringAt(bytes memory der, uint256 ptr) internal pure returns (bytes memory) {


187         function _readNodeLength(bytes memory der, uint256 ix) private pure returns (uint256) {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/Asn1Decode.sol#L187:187

```solidity
File: contracts/automata-attestation/utils/BytesUtils.sol


16          function keccak(
17              bytes memory self,
18              uint256 offset,
19              uint256 len
20          )


39          function compare(bytes memory self, bytes memory other) internal pure returns (int256) {


56          function compare(
57              bytes memory self,
58              uint256 offset,
59              uint256 len,
60              bytes memory other,
61              uint256 otheroffset,
62              uint256 otherlen
63          )


116         function equals(
117             bytes memory self,
118             uint256 offset,
119             bytes memory other,
120             uint256 otherOffset,
121             uint256 len
122         )


138         function equals(
139             bytes memory self,
140             uint256 offset,
141             bytes memory other,
142             uint256 otherOffset
143         )


160         function equals(
161             bytes memory self,
162             uint256 offset,
163             bytes memory other
164         )


178         function equals(bytes memory self, bytes memory other) internal pure returns (bool) {


188         function readUint8(bytes memory self, uint256 idx) internal pure returns (uint8 ret) {


198         function readUint16(bytes memory self, uint256 idx) internal pure returns (uint16 ret) {


211         function readUint32(bytes memory self, uint256 idx) internal pure returns (uint32 ret) {


224         function readBytes32(bytes memory self, uint256 idx) internal pure returns (bytes32 ret) {


237         function readBytes20(bytes memory self, uint256 idx) internal pure returns (bytes20 ret) {


255         function readBytesN(
256             bytes memory self,
257             uint256 idx,
258             uint256 len
259         )


284         function substring(
285             bytes memory self,
286             uint256 offset,
287             uint256 len
288         )


320         function base32HexDecodeWord(
321             bytes memory self,
322             uint256 off,
323             uint256 len
324         )


371         function compareBytes(bytes memory a, bytes memory b) internal pure returns (bool) {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/BytesUtils.sol#L371:371

```solidity
File: contracts/automata-attestation/utils/RsaVerify.sol


43          function pkcs1Sha256(
44              bytes32 _sha256,
45              bytes memory _s,
46              bytes memory _e,
47              bytes memory _m
48          )


191         function pkcs1Sha256Raw(
192             bytes memory _data,
193             bytes memory _s,
194             bytes memory _e,
195             bytes memory _m
196         )


212         function pkcs1Sha1(
213             bytes20 _sha1,
214             bytes memory _s,
215             bytes memory _e,
216             bytes memory _m
217         )


307         function pkcs1Sha1Raw(
308             bytes memory _data,
309             bytes memory _s,
310             bytes memory _e,
311             bytes memory _m
312         )


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/RsaVerify.sol#L307:312

```solidity
File: contracts/automata-attestation/utils/SHA1.sol


11          function sha1(bytes memory data) internal pure returns (bytes20 ret) {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/SHA1.sol#L11:11

```solidity
File: contracts/automata-attestation/utils/SigVerifyLib.sol


24          function verifyAttStmtSignature(
25              bytes memory tbs,
26              bytes memory signature,
27              PublicKey memory publicKey,
28              Algorithm alg
29          )


54          function verifyCertificateSignature(
55              bytes memory tbs,
56              bytes memory signature,
57              PublicKey memory publicKey,
58              CertSigAlgorithm alg
59          )


79          function verifyRS256Signature(
80              bytes memory tbs,
81              bytes memory signature,
82              bytes memory publicKey
83          )


96          function verifyRS1Signature(
97              bytes memory tbs,
98              bytes memory signature,
99              bytes memory publicKey
100         )


113         function verifyES256Signature(
114             bytes memory tbs,
115             bytes memory signature,
116             bytes memory publicKey
117         )


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/SigVerifyLib.sol#L113:117

```solidity
File: contracts/automata-attestation/utils/X509DateUtils.sol


8           function toTimestamp(bytes memory x509Time) internal pure returns (uint256) {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/utils/X509DateUtils.sol#L8:8

```solidity
File: contracts/bridge/Bridge.sol


155         function recallMessage(
156             Message calldata _message,
157             bytes calldata _proof
158         )


217         function processMessage(
218             Message calldata _message,
219             bytes calldata _proof
220         )


352         function proveMessageFailed(
353             Message calldata _message,
354             bytes calldata _proof
355         )


374         function proveMessageReceived(
375             Message calldata _message,
376             bytes calldata _proof
377         )


577         function _proveSignalReceived(
578             address _signalService,
579             bytes32 _signal,
580             uint64 _chainId,
581             bytes calldata _proof
582         )


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/Bridge.sol#L577:582

```solidity
File: contracts/libs/LibAddress.sol


61          function isValidSignature(
62              address _addr,
63              bytes32 _hash,
64              bytes memory _sig
65          )


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/libs/LibAddress.sol#L61:65

```solidity
File: contracts/signal/SignalService.sol


83          function proveSignalReceived(
84              uint64 _chainId,
85              address _app,
86              bytes32 _signal,
87              bytes calldata _proof
88          )


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/signal/SignalService.sol#L83:88

```solidity
File: contracts/team/TimelockTokenPool.sol


168         function withdraw(address _to, bytes memory _sig) external {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/TimelockTokenPool.sol#L168:168

```solidity
File: contracts/team/airdrop/ERC20Airdrop.sol


50          function claimAndDelegate(
51              address user,
52              uint256 amount,
53              bytes32[] calldata proof,
54              bytes calldata delegationData
55          )


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/airdrop/ERC20Airdrop.sol#L50:55

```solidity
File: contracts/team/airdrop/MerkleClaimable.sol


67          function _verifyClaim(bytes memory data, bytes32[] calldata proof) internal ongoingClaim {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/airdrop/MerkleClaimable.sol#L67:67

```solidity
File: contracts/thirdparty/nomad-xyz/ExcessivelySafeCall.sol


25          function excessivelySafeCall(
26              address _target,
27              uint256 _gas,
28              uint256 _value,
29              uint16 _maxCopy,
30              bytes memory _calldata
31          )


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/nomad-xyz/ExcessivelySafeCall.sol#L25:31

```solidity
File: contracts/thirdparty/optimism/Bytes.sol


15          function slice(
16              bytes memory _bytes,
17              uint256 _start,
18              uint256 _length
19          )


91          function slice(bytes memory _bytes, uint256 _start) internal pure returns (bytes memory) {


102         function toNibbles(bytes memory _bytes) internal pure returns (bytes memory) {


149         function equal(bytes memory _bytes, bytes memory _other) internal pure returns (bool) {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/Bytes.sol#L149:149

```solidity
File: contracts/thirdparty/optimism/rlp/RLPReader.sol


35          function toRLPItem(bytes memory _in) internal pure returns (RLPItem memory out_) {


102         function readList(bytes memory _in) internal pure returns (RLPItem[] memory out_) {


128         function readBytes(bytes memory _in) internal pure returns (bytes memory out_) {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/rlp/RLPReader.sol#L128:128

```solidity
File: contracts/thirdparty/optimism/rlp/RLPWriter.sol


13          function writeBytes(bytes memory _in) internal pure returns (bytes memory out_) {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/rlp/RLPWriter.sol#L13:13

```solidity
File: contracts/thirdparty/optimism/trie/MerkleTrie.sol


50          function verifyInclusionProof(
51              bytes memory _key,
52              bytes memory _value,
53              bytes[] memory _proof,
54              bytes32 _root
55          )


68          function get(
69              bytes memory _key,
70              bytes[] memory _proof,
71              bytes32 _root
72          )


235         function _getSharedNibbleLength(
236             bytes memory _a,
237             bytes memory _b
238         )


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/trie/MerkleTrie.sol#L235:238

```solidity
File: contracts/thirdparty/optimism/trie/SecureMerkleTrie.sol


19          function verifyInclusionProof(
20              bytes memory _key,
21              bytes memory _value,
22              bytes[] memory _proof,
23              bytes32 _root
24          )


38          function get(
39              bytes memory _key,
40              bytes[] memory _proof,
41              bytes32 _root
42          )


54          function _getSecureKey(bytes memory _key) private pure returns (bytes memory hash_) {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/optimism/trie/SecureMerkleTrie.sol#L54:54

```solidity
File: contracts/tokenvault/ERC1155Vault.sol


93          function onMessageInvocation(bytes calldata data) external payable nonReentrant whenNotPaused {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC1155Vault.sol#L93:93

```solidity
File: contracts/tokenvault/ERC20Vault.sol


253         function onMessageInvocation(bytes calldata _data)


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC20Vault.sol#L253:253

```solidity
File: contracts/tokenvault/ERC721Vault.sol


77          function onMessageInvocation(bytes calldata _data)


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC721Vault.sol#L77:77

</details>

## NC113 - Defining All External/Public Functions in Contract Interfaces:

It is preferable to have all the external and public function in an interface to make using them easier by developers. This helps ensure the whole API is extracted in a interface.


<details>
<summary>Click to show 51 findings</summary>

```solidity
File: contracts/L1/TaikoL1.sol


132         function canDepositEthToL2(uint256 _amount) public view returns (bool) {


137         function isBlobReusable(bytes32 _blobHash) public view returns (bool) {


145         function getBlock(uint64 _blockId)


162         function getTransition(
163             uint64 _blockId,
164             bytes32 _parentHash
165         )


176         function getStateVariables()


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/TaikoL1.sol#L176:176

```solidity
File: contracts/L1/TaikoToken.sol


25          function init(
26              address _owner,
27              string calldata _name,
28              string calldata _symbol,
29              address _recipient
30          )


47          function burn(address _from, uint256 _amount) public onlyOwner {


52          function snapshot() public onlyFromOwnerOrNamed("snapshooter") {


60          function transfer(address _to, uint256 _amount) public override returns (bool) {


70          function transferFrom(
71              address _from,
72              address _to,
73              uint256 _amount
74          )


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/TaikoToken.sol#L70:74

```solidity
File: contracts/L1/gov/TaikoGovernor.sol


69          function propose(
70              address[] memory _targets,
71              uint256[] memory _values,
72              string[] memory _signatures,
73              bytes[] memory _calldatas,
74              string memory _description
75          )


89          function supportsInterface(bytes4 _interfaceId)


99          function state(uint256 _proposalId)


111         function votingDelay() public pure override returns (uint256) {


117         function votingPeriod() public pure override returns (uint256) {


123         function proposalThreshold() public pure override returns (uint256) {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/gov/TaikoGovernor.sol#L123:123

```solidity
File: contracts/L1/gov/TaikoTimelockController.sol


24          function getMinDelay() public view override returns (uint256) {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/gov/TaikoTimelockController.sol#L24:24

```solidity
File: contracts/L1/hooks/AssignmentHook.sol


137         function hashAssignment(
138             ProverAssignment memory _assignment,
139             address _taikoL1Address,
140             bytes32 _blobHash
141         )


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/hooks/AssignmentHook.sol#L137:141

```solidity
File: contracts/L2/TaikoL2.sol


185         function getBasefee(
186             uint64 _l1BlockId,
187             uint32 _parentGasUsed
188         )


200         function getBlockHash(uint64 _blockId) public view returns (bytes32) {


208         function getConfig() public view virtual returns (Config memory config_) {


219         function skipFeeCheck() public pure virtual returns (bool) {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L2/TaikoL2.sol#L219:219

```solidity
File: contracts/automata-attestation/AutomataDcapV3Attestation.sol


103         function configureTcbInfoJson(
104             string calldata fmspc,
105             TCBInfoStruct.TCBInfo calldata tcbInfoInput
106         )


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/AutomataDcapV3Attestation.sol#L103:106

```solidity
File: contracts/bridge/Bridge.sol


352         function proveMessageFailed(
353             Message calldata _message,
354             bytes calldata _proof
355         )


374         function proveMessageReceived(
375             Message calldata _message,
376             bytes calldata _proof
377         )


392         function isDestChainEnabled(uint64 _chainId)


417         function getInvocationDelays()


456         function signalForFailedMessage(bytes32 _msgHash) public pure returns (bytes32) {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/Bridge.sol#L456:456

```solidity
File: contracts/signal/SignalService.sol


194         function getSignalSlot(
195             uint64 _chainId,
196             address _app,
197             bytes32 _signal
198         )


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/signal/SignalService.sol#L194:198

```solidity
File: contracts/team/TimelockTokenPool.sol


176         function getMyGrantSummary(address _recipient)


204         function getMyGrant(address _recipient) public view returns (Grant memory) {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/TimelockTokenPool.sol#L204:204

```solidity
File: contracts/team/airdrop/ERC20Airdrop2.sol


104         function getBalance(address user)


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/airdrop/ERC20Airdrop2.sol#L104:104

```solidity
File: contracts/tokenvault/BridgedERC1155.sol


66          function mint(
67              address _to,
68              uint256 _tokenId,
69              uint256 _amount
70          )


83          function mintBatch(
84              address _to,
85              uint256[] memory _tokenIds,
86              uint256[] memory _amounts
87          )


100         function burn(
101             address _account,
102             uint256 _tokenId,
103             uint256 _amount
104         )


115         function name() public view returns (string memory) {


121         function symbol() public view returns (string memory) {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC1155.sol#L121:121

```solidity
File: contracts/tokenvault/BridgedERC20.sol


91          function name()


102         function symbol()


113         function decimals()


125         function canonical() public view returns (address, uint256) {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC20.sol#L125:125

```solidity
File: contracts/tokenvault/BridgedERC721.sol


54          function mint(
55              address _account,
56              uint256 _tokenId
57          )


69          function burn(
70              address _account,
71              uint256 _tokenId
72          )


87          function name() public view override(ERC721Upgradeable) returns (string memory) {


93          function symbol() public view override(ERC721Upgradeable) returns (string memory) {


100         function source() public view returns (address, uint256) {


107         function tokenURI(uint256 _tokenId) public view virtual override returns (string memory) {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/BridgedERC721.sol#L107:107

```solidity
File: contracts/tokenvault/ERC1155Vault.sol


192         function supportsInterface(bytes4 interfaceId)


204         function name() public pure override returns (bytes32) {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC1155Vault.sol#L204:204

```solidity
File: contracts/tokenvault/ERC721Vault.sol


156         function name() public pure override returns (bytes32) {


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/tokenvault/ERC721Vault.sol#L156:156

```solidity
File: contracts/verifiers/SgxVerifier.sol


171         function getSignedHash(
172             TaikoData.Transition memory _tran,
173             address _newInstance,
174             address _prover,
175             bytes32 _metaHash
176         )


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/verifiers/SgxVerifier.sol#L171:176

</details>

## NC114 - Avoid mutating function parameters:

Function parameters in Solidity are passed by value, meaning they are essentially local copies. Mutating them can lead to confusion and errors because the changes don't persist outside the function. By keeping function parameters immutable, you ensure clarity in code behavior, preventing unintended side-effects. If you need to modify a value based on a parameter, use a local variable inside the function, leaving the original parameter unaltered. By adhering to this practice, you maintain a clear distinction between input data and the internal processing logic, improving code readability and reducing the potential for bugs.


```solidity
File: contracts/automata-attestation/lib/PEMCertChainLib.sol


334                     tbsPtr = der.nextSiblingOf(tbsPtr);


```

https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/automata-attestation/lib/PEMCertChainLib.sol#L334:334


